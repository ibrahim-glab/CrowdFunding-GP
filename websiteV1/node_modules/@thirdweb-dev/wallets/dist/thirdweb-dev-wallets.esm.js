import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-71fe23d8.esm.js';
import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from './classPrivateFieldSet-e25e1cec.esm.js';
import { Core } from '@walletconnect/core';
import { Web3Wallet } from '@walletconnect/web3wallet';
import { utils } from 'ethers';
import EventEmitter from 'eventemitter3';
import { T as TW_WC_PROJECT_ID, W as WC_RELAY_URL, E as EIP155_SIGNING_METHODS } from './wc-f2c5150f.esm.js';
export { E as EIP155_SIGNING_METHODS } from './wc-f2c5150f.esm.js';
import { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils';
export { a as AbstractClientWallet, A as AsyncLocalStorage, D as DEFAULT_DAPP_META, c as createAsyncLocalStorage, i as isWalletAnalyticsEnabled, s as setWalletAnalyticsEnabled } from './base-1919df7d.esm.js';
export { w as walletIds } from './walletIds-3f5c1028.esm.js';
export { W as WagmiConnector } from './WagmiConnector-6011bbb1.esm.js';
export { A as AddChainError, C as ChainNotConfiguredError, P as ProviderRpcError, S as SwitchChainError, U as UserRejectedRequestError } from './errors-b8627438.esm.js';
export { n as normalizeChainId } from './normalizeChainId-abcb61d5.esm.js';
export { C as Connector, W as WagmiAdapter } from './connector-20f7cf73.esm.js';
export { BloctoWallet } from '../evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.esm.js';
export { MetaMaskWallet } from '../evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.esm.js';
export { g as getInjectedXDEFIProvider } from './getInjectedXDEFIProvider-63fe03f0.esm.js';
export { OKXWallet } from '../evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.esm.js';
export { g as getInjectedOKXProvider } from './getInjectedOKXProvider-bef80221.esm.js';
export { CoreWallet } from '../evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.esm.js';
export { g as getInjectedCoreWalletProvider } from './getInjectedCoreWalletProvider-ebe9ab09.esm.js';
export { OneKeyWallet } from '../evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.esm.js';
export { g as getInjectedOneKeyProvider } from './getInjectedOneKeyProvider-b2a7d8e7.esm.js';
export { CryptoDefiWallet } from '../evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.esm.js';
export { g as getInjectedCryptoDefiWalletProvider } from './getInjectedCryptoDefiWalletProvider-6883e68f.esm.js';
export { RabbyWallet } from '../evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.esm.js';
export { g as getInjectedRabbyProvider } from './getInjectedRabbyProvider-71aa751e.esm.js';
export { Coin98Wallet } from '../evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.esm.js';
export { g as getInjectedCoin98Provider } from './getInjectedCoin98Provider-87d2f6e1.esm.js';
export { g as getInjectedMetamaskProvider } from './getInjectedMetamaskProvider-ca1f08ac.esm.js';
export { g as getInjectedPhantomProvider } from './getInjectedPhantomProvider-594ca51b.esm.js';
export { g as getInjectedRainbowProvider } from './getInjectedRainbowProvider-d812bb1f.esm.js';
export { g as getInjectedCoinbaseProvider } from './getInjectedCoinbaseProvider-e62a7926.esm.js';
export { a as assertWindowEthereum } from './assertWindowEthereum-2bcf9787.esm.js';
export { E as EngineSigner, a as EngineWallet } from './engine-a40a2dba.esm.js';
export { PaperWallet } from '../evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.esm.js';
export { CoinbaseWallet } from '../evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.esm.js';
export { EmbeddedWallet } from '../evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.esm.js';
export { EthersWallet } from '../evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.esm.js';
export { FrameWallet } from '../evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.esm.js';
export { InjectedWallet } from '../evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.esm.js';
export { LocalWallet, isValidPrivateKey } from '../evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.esm.js';
export { SignerWallet } from '../evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.esm.js';
export { MagicLink } from '../evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.esm.js';
export { XDEFIWallet } from '../evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.esm.js';
export { PhantomWallet } from '../evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.esm.js';
export { PrivateKeyWallet } from '../evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.esm.js';
export { RainbowWallet } from '../evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.esm.js';
export { SafeWallet } from '../evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.esm.js';
export { SmartWallet, getAllSigners, getAllSmartWallets, getSmartWalletAddress, getUserOpReceipt, isSmartWalletDeployed } from '../evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.esm.js';
export { TrustWallet } from '../evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.esm.js';
export { WalletConnect } from '../evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.esm.js';
export { WalletConnectV1 } from '../evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.esm.js';
export { ZerionWallet } from '../evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.esm.js';
export { TokenBoundSmartWallet } from '../evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.esm.js';
export { A as AUTH_TOKEN_LOCAL_STORAGE_NAME, c as AuthProvider, D as DEVICE_SHARE_LOCAL_STORAGE_NAME, a as DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED, E as EmbeddedWalletSdk, R as RecoveryShareManagement, U as UserWalletStatus, W as WALLET_USER_DETAILS_LOCAL_STORAGE_NAME, b as WALLET_USER_ID_LOCAL_STORAGE_NAME } from './embedded-wallet-967c9d1a.esm.js';
import '@thirdweb-dev/chains';
import '../evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.esm.js';
import './defineProperty-d067c271.esm.js';
import '@thirdweb-dev/sdk';
import './headers-f11f4a2d.esm.js';
import 'buffer';
import '@thirdweb-dev/crypto';
import './constants-bb3cbc65.esm.js';
import '@account-abstraction/contracts';
import '@paperxyz/sdk-common-utilities';
import 'ethers/lib/utils';

const PREFIX = "__TW__";
class LocalStorage {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
  }
}

/**
 * @internal
 */
function createLocalStorage(name) {
  return new LocalStorage(name);
}

// connect dapp support through wcv2 protocol

class WalletConnectHandler extends EventEmitter {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
}

var _core = /*#__PURE__*/new WeakMap();
var _wcWallet = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
var _wcMetadata = /*#__PURE__*/new WeakMap();
var _activeProposal = /*#__PURE__*/new WeakMap();
var _activeRequestEvent = /*#__PURE__*/new WeakMap();
var _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();
var _getSignParamsMessage = /*#__PURE__*/new WeakSet();
class WalletConnectV2Handler extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    /**
     * Gets message from various signing request methods by filtering out
     * a value that is not an address (thus is a message).
     * If it is a hex string, it gets converted to utf8 string
     */
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "Thirdweb Smart Wallet",
        description: "Thirdweb Smart Wallet",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options?.walletConnectReceiver === true ? {} : options?.walletConnectReceiver)
    };
    _classPrivateFieldSet(this, _wcMetadata, defaultWCReceiverConfig.walletConnectWalletMetadata);
    _classPrivateFieldSet(this, _core, new Core({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet, await Web3Wallet.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach(key => {
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        namespace.chains?.map(chain => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet).approveSession({
      id,
      relayProtocol: relays[0]?.protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await this.wallet.signMessage(message || ""); // TODO: handle empty message

        response = formatJsonRpcResult(id, signedMessage);
        break;
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      //   const {
      //     domain,
      //     types,
      //     message: data,
      //   } = getSignTypedDataParamsData(request.params);
      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471
      //   delete types.EIP712Domain;
      //   const signedData = await wallet._signTypedData(domain, types, data);
      //   return formatJsonRpcResult(id, signedData);
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({
          topic,
          response: error
        });
    }
    return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return _classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6000
      }
    };
    return _classPrivateFieldGet(this, _wcWallet)?.disconnectSession(params);
  }
}
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", proposal => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", session => {
    _classPrivateFieldSet(this, _session, undefined);
    _classPrivateFieldSet(this, _activeProposal, undefined);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", async requestEvent => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter(p => !utils.isAddress(p))[0] || ""; // TODO: handle empty message

  if (utils.isHexString(message)) {
    return utils.toUtf8String(message);
  }
  return message;
}

export { LocalStorage, WalletConnectHandler, WalletConnectV2Handler, createLocalStorage };
