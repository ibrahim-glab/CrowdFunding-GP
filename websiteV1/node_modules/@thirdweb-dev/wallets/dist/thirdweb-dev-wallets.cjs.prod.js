'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var classPrivateMethodGet = require('./classPrivateMethodGet-cf746c9e.cjs.prod.js');
var classPrivateFieldSet = require('./classPrivateFieldSet-4a4973f9.cjs.prod.js');
var core = require('@walletconnect/core');
var web3wallet = require('@walletconnect/web3wallet');
var ethers = require('ethers');
var EventEmitter = require('eventemitter3');
var wc = require('./wc-cfed8885.cjs.prod.js');
var jsonrpcUtils = require('@walletconnect/jsonrpc-utils');
var evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase = require('./base-9abdc1da.cjs.prod.js');
var walletIds = require('./walletIds-ec2f8e22.cjs.prod.js');
var WagmiConnector = require('./WagmiConnector-17577fd3.cjs.prod.js');
var errors = require('./errors-2d1f3da1.cjs.prod.js');
var normalizeChainId = require('./normalizeChainId-dc975fa1.cjs.prod.js');
var connector = require('./connector-1b2fa06d.cjs.prod.js');
var evm_wallets_blocto_dist_thirdwebDevWalletsEvmWalletsBlocto = require('../evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.cjs.prod.js');
var evm_wallets_metamask_dist_thirdwebDevWalletsEvmWalletsMetamask = require('../evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.cjs.prod.js');
var getInjectedXDEFIProvider = require('./getInjectedXDEFIProvider-e49b88c7.cjs.prod.js');
var evm_wallets_okx_dist_thirdwebDevWalletsEvmWalletsOkx = require('../evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.cjs.prod.js');
var getInjectedOKXProvider = require('./getInjectedOKXProvider-95f6a54f.cjs.prod.js');
var evm_wallets_coreWallet_dist_thirdwebDevWalletsEvmWalletsCoreWallet = require('../evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.cjs.prod.js');
var getInjectedCoreWalletProvider = require('./getInjectedCoreWalletProvider-cfe1627d.cjs.prod.js');
var evm_wallets_onekey_dist_thirdwebDevWalletsEvmWalletsOnekey = require('../evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.cjs.prod.js');
var getInjectedOneKeyProvider = require('./getInjectedOneKeyProvider-958e095b.cjs.prod.js');
var evm_wallets_cryptoDefiWallet_dist_thirdwebDevWalletsEvmWalletsCryptoDefiWallet = require('../evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.cjs.prod.js');
var getInjectedCryptoDefiWalletProvider = require('./getInjectedCryptoDefiWalletProvider-a5a7a82c.cjs.prod.js');
var evm_wallets_rabby_dist_thirdwebDevWalletsEvmWalletsRabby = require('../evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.cjs.prod.js');
var getInjectedRabbyProvider = require('./getInjectedRabbyProvider-462cdbb4.cjs.prod.js');
var evm_wallets_coin98_dist_thirdwebDevWalletsEvmWalletsCoin98 = require('../evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.cjs.prod.js');
var getInjectedCoin98Provider = require('./getInjectedCoin98Provider-3932611c.cjs.prod.js');
var getInjectedMetamaskProvider = require('./getInjectedMetamaskProvider-c893db64.cjs.prod.js');
var getInjectedPhantomProvider = require('./getInjectedPhantomProvider-b25fa41a.cjs.prod.js');
var getInjectedRainbowProvider = require('./getInjectedRainbowProvider-62df0752.cjs.prod.js');
var getInjectedCoinbaseProvider = require('./getInjectedCoinbaseProvider-da9a48f1.cjs.prod.js');
var assertWindowEthereum = require('./assertWindowEthereum-941010de.cjs.prod.js');
var evm_wallets_engine_dist_thirdwebDevWalletsEvmWalletsEngine = require('./engine-bde6a768.cjs.prod.js');
var evm_wallets_paperWallet_dist_thirdwebDevWalletsEvmWalletsPaperWallet = require('../evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.cjs.prod.js');
var evm_wallets_coinbaseWallet_dist_thirdwebDevWalletsEvmWalletsCoinbaseWallet = require('../evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.cjs.prod.js');
var evm_wallets_embeddedWallet_dist_thirdwebDevWalletsEvmWalletsEmbeddedWallet = require('../evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.cjs.prod.js');
var evm_wallets_ethers_dist_thirdwebDevWalletsEvmWalletsEthers = require('../evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.cjs.prod.js');
var evm_wallets_frame_dist_thirdwebDevWalletsEvmWalletsFrame = require('../evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.cjs.prod.js');
var evm_wallets_injected_dist_thirdwebDevWalletsEvmWalletsInjected = require('../evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.cjs.prod.js');
var evm_wallets_localWallet_dist_thirdwebDevWalletsEvmWalletsLocalWallet = require('../evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.cjs.prod.js');
var evm_wallets_signer_dist_thirdwebDevWalletsEvmWalletsSigner = require('../evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.cjs.prod.js');
var evm_wallets_magic_dist_thirdwebDevWalletsEvmWalletsMagic = require('../evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.cjs.prod.js');
var evm_wallets_xdefi_dist_thirdwebDevWalletsEvmWalletsXdefi = require('../evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.cjs.prod.js');
var evm_wallets_phantom_dist_thirdwebDevWalletsEvmWalletsPhantom = require('../evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.cjs.prod.js');
var evm_wallets_privateKey_dist_thirdwebDevWalletsEvmWalletsPrivateKey = require('../evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.cjs.prod.js');
var evm_wallets_rainbowWallet_dist_thirdwebDevWalletsEvmWalletsRainbowWallet = require('../evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.cjs.prod.js');
var evm_wallets_safe_dist_thirdwebDevWalletsEvmWalletsSafe = require('../evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.cjs.prod.js');
var evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet = require('../evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.cjs.prod.js');
var evm_wallets_trust_dist_thirdwebDevWalletsEvmWalletsTrust = require('../evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.cjs.prod.js');
var evm_wallets_walletConnect_dist_thirdwebDevWalletsEvmWalletsWalletConnect = require('../evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.cjs.prod.js');
var evm_wallets_walletConnectV1_dist_thirdwebDevWalletsEvmWalletsWalletConnectV1 = require('../evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.cjs.prod.js');
var evm_wallets_zerion_dist_thirdwebDevWalletsEvmWalletsZerion = require('../evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.cjs.prod.js');
var evm_wallets_tokenBoundSmartWallet_dist_thirdwebDevWalletsEvmWalletsTokenBoundSmartWallet = require('../evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.cjs.prod.js');
var embeddedWallet = require('./embedded-wallet-9c37cd01.cjs.prod.js');
require('@thirdweb-dev/chains');
require('../evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.cjs.prod.js');
require('./defineProperty-f6178623.cjs.prod.js');
require('@thirdweb-dev/sdk');
require('./headers-68bfc859.cjs.prod.js');
require('buffer');
require('@thirdweb-dev/crypto');
require('./constants-b1bc6343.cjs.prod.js');
require('@account-abstraction/contracts');
require('@paperxyz/sdk-common-utilities');
require('ethers/lib/utils');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var EventEmitter__default = /*#__PURE__*/_interopDefault(EventEmitter);

const PREFIX = "__TW__";
class LocalStorage {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
  }
}

/**
 * @internal
 */
function createLocalStorage(name) {
  return new LocalStorage(name);
}

// connect dapp support through wcv2 protocol

class WalletConnectHandler extends EventEmitter__default["default"] {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
}

var _core = /*#__PURE__*/new WeakMap();
var _wcWallet = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
var _wcMetadata = /*#__PURE__*/new WeakMap();
var _activeProposal = /*#__PURE__*/new WeakMap();
var _activeRequestEvent = /*#__PURE__*/new WeakMap();
var _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();
var _getSignParamsMessage = /*#__PURE__*/new WeakSet();
class WalletConnectV2Handler extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    /**
     * Gets message from various signing request methods by filtering out
     * a value that is not an address (thus is a message).
     * If it is a hex string, it gets converted to utf8 string
     */
    classPrivateMethodGet._classPrivateMethodInitSpec(this, _getSignParamsMessage);
    classPrivateMethodGet._classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "Thirdweb Smart Wallet",
        description: "Thirdweb Smart Wallet",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: wc.TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: wc.WC_RELAY_URL,
      ...(options?.walletConnectReceiver === true ? {} : options?.walletConnectReceiver)
    };
    classPrivateFieldSet._classPrivateFieldSet(this, _wcMetadata, defaultWCReceiverConfig.walletConnectWalletMetadata);
    classPrivateFieldSet._classPrivateFieldSet(this, _core, new core.Core({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    }));
  }
  async init() {
    classPrivateFieldSet._classPrivateFieldSet(this, _wcWallet, await web3wallet.Web3Wallet.init({
      core: classPrivateFieldSet._classPrivateFieldGet(this, _core),
      metadata: classPrivateFieldSet._classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      classPrivateFieldSet._classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    classPrivateMethodGet._classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
  }
  async connectApp(wcUri) {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = classPrivateFieldSet._classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach(key => {
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        namespace.chains?.map(chain => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    classPrivateFieldSet._classPrivateFieldSet(this, _session, await classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).approveSession({
      id,
      relayProtocol: relays[0]?.protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = classPrivateFieldSet._classPrivateFieldGet(this, _activeProposal);
    await classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = classPrivateFieldSet._classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case wc.EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case wc.EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = classPrivateMethodGet._classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await this.wallet.signMessage(message || ""); // TODO: handle empty message

        response = jsonrpcUtils.formatJsonRpcResult(id, signedMessage);
        break;
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      //   const {
      //     domain,
      //     types,
      //     message: data,
      //   } = getSignTypedDataParamsData(request.params);
      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471
      //   delete types.EIP712Domain;
      //   const signedData = await wallet._signTypedData(domain, types, data);
      //   return formatJsonRpcResult(id, signedData);
      case wc.EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = jsonrpcUtils.formatJsonRpcResult(id, transactionHash);
        break;
      case wc.EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = jsonrpcUtils.formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({
          topic,
          response: error
        });
    }
    return classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = classPrivateFieldSet._classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)?.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: classPrivateFieldSet._classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6000
      }
    };
    return classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)?.disconnectSession(params);
  }
}
function _setupWalletConnectEventsListeners2() {
  if (!classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).on("session_proposal", proposal => {
    classPrivateFieldSet._classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).on("session_delete", session => {
    classPrivateFieldSet._classPrivateFieldSet(this, _session, undefined);
    classPrivateFieldSet._classPrivateFieldSet(this, _activeProposal, undefined);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  classPrivateFieldSet._classPrivateFieldGet(this, _wcWallet).on("session_request", async requestEvent => {
    if (!classPrivateFieldSet._classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case wc.EIP155_SIGNING_METHODS.ETH_SIGN:
      case wc.EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        classPrivateFieldSet._classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(ethers.utils.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: classPrivateFieldSet._classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: classPrivateFieldSet._classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case wc.EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case wc.EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        classPrivateFieldSet._classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: classPrivateFieldSet._classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: classPrivateFieldSet._classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter(p => !ethers.utils.isAddress(p))[0] || ""; // TODO: handle empty message

  if (ethers.utils.isHexString(message)) {
    return ethers.utils.toUtf8String(message);
  }
  return message;
}

exports.EIP155_SIGNING_METHODS = wc.EIP155_SIGNING_METHODS;
exports.AbstractClientWallet = evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.AbstractClientWallet;
exports.AsyncLocalStorage = evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.AsyncLocalStorage;
exports.DEFAULT_DAPP_META = evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.DEFAULT_DAPP_META;
exports.createAsyncLocalStorage = evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.createAsyncLocalStorage;
exports.isWalletAnalyticsEnabled = evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.isWalletAnalyticsEnabled;
exports.setWalletAnalyticsEnabled = evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.setWalletAnalyticsEnabled;
exports.walletIds = walletIds.walletIds;
exports.WagmiConnector = WagmiConnector.WagmiConnector;
exports.AddChainError = errors.AddChainError;
exports.ChainNotConfiguredError = errors.ChainNotConfiguredError;
exports.ProviderRpcError = errors.ProviderRpcError;
exports.SwitchChainError = errors.SwitchChainError;
exports.UserRejectedRequestError = errors.UserRejectedRequestError;
exports.normalizeChainId = normalizeChainId.normalizeChainId;
exports.Connector = connector.Connector;
exports.WagmiAdapter = connector.WagmiAdapter;
exports.BloctoWallet = evm_wallets_blocto_dist_thirdwebDevWalletsEvmWalletsBlocto.BloctoWallet;
exports.MetaMaskWallet = evm_wallets_metamask_dist_thirdwebDevWalletsEvmWalletsMetamask.MetaMaskWallet;
exports.getInjectedXDEFIProvider = getInjectedXDEFIProvider.getInjectedXDEFIProvider;
exports.OKXWallet = evm_wallets_okx_dist_thirdwebDevWalletsEvmWalletsOkx.OKXWallet;
exports.getInjectedOKXProvider = getInjectedOKXProvider.getInjectedOKXProvider;
exports.CoreWallet = evm_wallets_coreWallet_dist_thirdwebDevWalletsEvmWalletsCoreWallet.CoreWallet;
exports.getInjectedCoreWalletProvider = getInjectedCoreWalletProvider.getInjectedCoreWalletProvider;
exports.OneKeyWallet = evm_wallets_onekey_dist_thirdwebDevWalletsEvmWalletsOnekey.OneKeyWallet;
exports.getInjectedOneKeyProvider = getInjectedOneKeyProvider.getInjectedOneKeyProvider;
exports.CryptoDefiWallet = evm_wallets_cryptoDefiWallet_dist_thirdwebDevWalletsEvmWalletsCryptoDefiWallet.CryptoDefiWallet;
exports.getInjectedCryptoDefiWalletProvider = getInjectedCryptoDefiWalletProvider.getInjectedCryptoDefiWalletProvider;
exports.RabbyWallet = evm_wallets_rabby_dist_thirdwebDevWalletsEvmWalletsRabby.RabbyWallet;
exports.getInjectedRabbyProvider = getInjectedRabbyProvider.getInjectedRabbyProvider;
exports.Coin98Wallet = evm_wallets_coin98_dist_thirdwebDevWalletsEvmWalletsCoin98.Coin98Wallet;
exports.getInjectedCoin98Provider = getInjectedCoin98Provider.getInjectedCoin98Provider;
exports.getInjectedMetamaskProvider = getInjectedMetamaskProvider.getInjectedMetamaskProvider;
exports.getInjectedPhantomProvider = getInjectedPhantomProvider.getInjectedPhantomProvider;
exports.getInjectedRainbowProvider = getInjectedRainbowProvider.getInjectedRainbowProvider;
exports.getInjectedCoinbaseProvider = getInjectedCoinbaseProvider.getInjectedCoinbaseProvider;
exports.assertWindowEthereum = assertWindowEthereum.assertWindowEthereum;
exports.EngineSigner = evm_wallets_engine_dist_thirdwebDevWalletsEvmWalletsEngine.EngineSigner;
exports.EngineWallet = evm_wallets_engine_dist_thirdwebDevWalletsEvmWalletsEngine.EngineWallet;
exports.PaperWallet = evm_wallets_paperWallet_dist_thirdwebDevWalletsEvmWalletsPaperWallet.PaperWallet;
exports.CoinbaseWallet = evm_wallets_coinbaseWallet_dist_thirdwebDevWalletsEvmWalletsCoinbaseWallet.CoinbaseWallet;
exports.EmbeddedWallet = evm_wallets_embeddedWallet_dist_thirdwebDevWalletsEvmWalletsEmbeddedWallet.EmbeddedWallet;
exports.EthersWallet = evm_wallets_ethers_dist_thirdwebDevWalletsEvmWalletsEthers.EthersWallet;
exports.FrameWallet = evm_wallets_frame_dist_thirdwebDevWalletsEvmWalletsFrame.FrameWallet;
exports.InjectedWallet = evm_wallets_injected_dist_thirdwebDevWalletsEvmWalletsInjected.InjectedWallet;
exports.LocalWallet = evm_wallets_localWallet_dist_thirdwebDevWalletsEvmWalletsLocalWallet.LocalWallet;
exports.isValidPrivateKey = evm_wallets_localWallet_dist_thirdwebDevWalletsEvmWalletsLocalWallet.isValidPrivateKey;
exports.SignerWallet = evm_wallets_signer_dist_thirdwebDevWalletsEvmWalletsSigner.SignerWallet;
exports.MagicLink = evm_wallets_magic_dist_thirdwebDevWalletsEvmWalletsMagic.MagicLink;
exports.XDEFIWallet = evm_wallets_xdefi_dist_thirdwebDevWalletsEvmWalletsXdefi.XDEFIWallet;
exports.PhantomWallet = evm_wallets_phantom_dist_thirdwebDevWalletsEvmWalletsPhantom.PhantomWallet;
exports.PrivateKeyWallet = evm_wallets_privateKey_dist_thirdwebDevWalletsEvmWalletsPrivateKey.PrivateKeyWallet;
exports.RainbowWallet = evm_wallets_rainbowWallet_dist_thirdwebDevWalletsEvmWalletsRainbowWallet.RainbowWallet;
exports.SafeWallet = evm_wallets_safe_dist_thirdwebDevWalletsEvmWalletsSafe.SafeWallet;
exports.SmartWallet = evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet.SmartWallet;
exports.getAllSigners = evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet.getAllSigners;
exports.getAllSmartWallets = evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet.getAllSmartWallets;
exports.getSmartWalletAddress = evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet.getSmartWalletAddress;
exports.getUserOpReceipt = evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet.getUserOpReceipt;
exports.isSmartWalletDeployed = evm_wallets_smartWallet_dist_thirdwebDevWalletsEvmWalletsSmartWallet.isSmartWalletDeployed;
exports.TrustWallet = evm_wallets_trust_dist_thirdwebDevWalletsEvmWalletsTrust.TrustWallet;
exports.WalletConnect = evm_wallets_walletConnect_dist_thirdwebDevWalletsEvmWalletsWalletConnect.WalletConnect;
exports.WalletConnectV1 = evm_wallets_walletConnectV1_dist_thirdwebDevWalletsEvmWalletsWalletConnectV1.WalletConnectV1;
exports.ZerionWallet = evm_wallets_zerion_dist_thirdwebDevWalletsEvmWalletsZerion.ZerionWallet;
exports.TokenBoundSmartWallet = evm_wallets_tokenBoundSmartWallet_dist_thirdwebDevWalletsEvmWalletsTokenBoundSmartWallet.TokenBoundSmartWallet;
exports.AUTH_TOKEN_LOCAL_STORAGE_NAME = embeddedWallet.AUTH_TOKEN_LOCAL_STORAGE_NAME;
exports.AuthProvider = embeddedWallet.AuthProvider;
exports.DEVICE_SHARE_LOCAL_STORAGE_NAME = embeddedWallet.DEVICE_SHARE_LOCAL_STORAGE_NAME;
exports.DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED = embeddedWallet.DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED;
exports.EmbeddedWalletSdk = embeddedWallet.EmbeddedWalletSdk;
exports.RecoveryShareManagement = embeddedWallet.RecoveryShareManagement;
exports.UserWalletStatus = embeddedWallet.UserWalletStatus;
exports.WALLET_USER_DETAILS_LOCAL_STORAGE_NAME = embeddedWallet.WALLET_USER_DETAILS_LOCAL_STORAGE_NAME;
exports.WALLET_USER_ID_LOCAL_STORAGE_NAME = embeddedWallet.WALLET_USER_ID_LOCAL_STORAGE_NAME;
exports.LocalStorage = LocalStorage;
exports.WalletConnectHandler = WalletConnectHandler;
exports.WalletConnectV2Handler = WalletConnectV2Handler;
exports.createLocalStorage = createLocalStorage;
