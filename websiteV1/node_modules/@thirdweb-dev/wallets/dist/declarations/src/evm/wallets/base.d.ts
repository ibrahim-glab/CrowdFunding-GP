import { Chain } from "@thirdweb-dev/chains";
import { AsyncStorage } from "../../core/AsyncStorage";
import type { DAppMetaData } from "../../core/types/dAppMeta";
import { EVMWallet } from "../interfaces";
import { ConnectParams, Connector } from "../interfaces/connector";
import { AbstractWallet } from "./abstract";
/**
 * General options required for creating a wallet instance
 */
export type WalletOptions<TOpts extends Record<string, any> = {}> = {
    /**
     * chains supported by the wallet
     */
    chains?: Chain[];
    /**
     * Unique identifier for the wallet ( name of the wallet )
     */
    walletId?: string;
    /**
     * Storage to use for saving the wallet data
     */
    walletStorage?: AsyncStorage;
    /**
     * Metadata for the dapp. Some wallets use some of this data to display in their UI
     */
    dappMetadata?: DAppMetaData;
    /**
     * thirdweb apiKey client id. This is required to use thirdweb's infrastructure services like RPCs, IPFS Storage etc.
     *
     * You can create an API key for free on [thirdweb Dashboard](https://thirdweb.com/create-api-key)
     */
    clientId?: string;
    /**
     * Specify if analytics should be enabled or disabled for the wallet
     */
    analytics?: "enabled" | "disabled";
} & TOpts;
export type WalletMeta = {
    name: string;
    iconURL: string;
    urls?: {
        android?: string;
        ios?: string;
        chrome?: string;
        firefox?: string;
    };
};
/**
 * The base class for all client-side wallets (web, mobile) in the Wallet SDK. It extends AbstractWallet and adds client side specific logic.
 * A client side wallet delegates the wallet-specific connection logic to a Connector.
 *
 * This wallet is not meant to be used directly, but instead be extended to [build your own wallet](https://portal.thirdweb.com/wallet-sdk/v2/build)
 *
 * @abstractWallet
 */
export declare abstract class AbstractClientWallet<TAdditionalOpts extends Record<string, any> = {}, TConnectParams extends Record<string, any> = {}> extends AbstractWallet {
    #private;
    walletId: string;
    protected walletStorage: AsyncStorage;
    protected chains: Chain[];
    protected dappMetadata: DAppMetaData;
    protected options?: WalletOptions<TAdditionalOpts>;
    /**
     * @internal
     */
    static meta: WalletMeta;
    /**
     * @internal
     */
    getMeta(): WalletMeta;
    /**
     * Creates an returns instance of `AbstractClientWallet`
     *
     * @param walletId - A Unique identifier for the wallet ( name of the wallet )
     * @param options - Options for creating wallet instance
     */
    constructor(walletId: string, options?: WalletOptions<TAdditionalOpts>);
    /**
     * Returns the Wallet Connector used by the wallet
     */
    protected abstract getConnector(): Promise<Connector<TConnectParams>>;
    /**
     * auto-connect the wallet if possible
     * @returns
     */
    autoConnect(connectOptions?: ConnectParams<TConnectParams>): Promise<string>;
    /**
     * Connect wallet
     * @param connectOptions - Options for connecting to the wallet
     * @returns
     */
    connect(connectOptions?: ConnectParams<TConnectParams>): Promise<string>;
    /**
     * @internal
     * Get the options used for connecting to the wallet
     * @returns
     */
    getConnectParams(): ConnectParams<TConnectParams> | undefined;
    /**
     * @internal
     * Get the options used for creating the wallet instance
     */
    getOptions(): WalletOptions<TAdditionalOpts> | undefined;
    /**
     * Get [ethers Signer](https://docs.ethers.org/v5/api/signer/) object of the connected wallet
     */
    getSigner(): Promise<import("ethers").Signer>;
    /**
     * Disconnect the wallet
     */
    disconnect(): Promise<void>;
    /**
     * Switch to different Network/Blockchain in the connected wallet
     * @param chainId - The chainId of the network to switch to
     */
    switchChain(chainId: number): Promise<void>;
    /**
     * Update the chains supported by the wallet. This is useful if wallet was initialized with some chains and this needs to be updated without re-initializing the wallet
     */
    updateChains(chains: Chain[]): Promise<void>;
    /**
     * If the wallet uses another "personal wallet" under the hood, return it
     *
     * This is only useful for wallets like Safe or Smart Wallet uses a "personal wallet" under the hood to sign transactions. This method returns that wallet
     */
    getPersonalWallet(): EVMWallet | undefined;
}
//# sourceMappingURL=base.d.ts.map