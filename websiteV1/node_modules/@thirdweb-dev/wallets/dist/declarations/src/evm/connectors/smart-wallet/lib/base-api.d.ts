import { BigNumber, BigNumberish, providers } from "ethers";
import { UserOperationStruct } from "@account-abstraction/contracts";
import { TransactionDetailsForUserOp } from "./transaction-details";
import { Transaction } from "@thirdweb-dev/sdk";
import { HttpRpcClient } from "./http-rpc-client";
import type { BaseApiParams, PaymasterAPI, UserOpOptions } from "../types";
/**
 * Base class for all Smart Wallet ERC-4337 Clients to implement.
 * Subclass should inherit 5 methods to support a specific wallet contract:
 *
 * - getAccountInitCode - return the value to put into the "initCode" field, if the account is not yet deployed. should create the account instance using a factory contract.
 * - getNonce - return current account's nonce value
 * - encodeExecute - encode the call from entryPoint through our account to the target contract.
 * - signUserOpHash - sign the hash of a UserOp.
 *
 * The user can use the following APIs:
 * - createUnsignedUserOp - given "target" and "calldata", fill userOp to perform that operation from the account.
 * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it
 */
export declare abstract class BaseAccountAPI {
    private senderAddress;
    private isPhantom;
    private readonly entryPointView;
    provider: providers.Provider;
    entryPointAddress: string;
    paymasterAPI: PaymasterAPI;
    accountAddress?: string;
    gasless?: boolean;
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     */
    protected constructor(params: BaseApiParams);
    /**
     * return the value to put into the "initCode" field, if the contract is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    abstract getAccountInitCode(): Promise<string>;
    /**
     * return current account's nonce.
     */
    abstract getNonce(): Promise<BigNumber>;
    /**
     * encode the call from entryPoint through our account to the target contract.
     * @param target - The target contract address
     * @param value - The value to send to the target contract
     * @param data - The calldata to send to the target contract
     */
    abstract prepareExecute(target: string, value: BigNumberish, data: string): Promise<Transaction<any>>;
    /**
     * sign a userOp's hash (userOpHash).
     * @param userOpHash - The hash to sign
     */
    abstract signUserOpHash(userOpHash: string): Promise<string>;
    /**
     * calculate the account address even before it is deployed
     */
    abstract getCounterFactualAddress(): Promise<string>;
    /**
     * check if the contract is already deployed.
     */
    checkAccountPhantom(): Promise<boolean>;
    /**
     * return initCode value to into the UserOp.
     * (either deployment code, or empty hex if contract already deployed)
     */
    getInitCode(): Promise<string>;
    /**
     * return maximum gas used for verification.
     * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
     */
    getVerificationGasLimit(): Promise<BigNumberish>;
    /**
     * return userOpHash for signing.
     * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)
     * @param userOp - userOperation, (signature field ignored)
     */
    getUserOpHash(userOp: UserOperationStruct): Promise<string>;
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    getAccountAddress(): Promise<string>;
    estimateCreationGas(initCode?: string): Promise<BigNumberish>;
    createUnsignedUserOp(httpRpcClient: HttpRpcClient, info: TransactionDetailsForUserOp, options?: UserOpOptions): Promise<UserOperationStruct>;
    /**
     * Sign the filled userOp.
     * @param userOp - The UserOperation to sign (with signature field ignored)
     */
    signUserOp(userOp: UserOperationStruct): Promise<UserOperationStruct>;
    /**
     * get the transaction that has this userOpHash mined, or null if not found
     * @param userOpHash - returned by sendUserOpToBundler (or by getUserOpHash..)
     * @param timeout - stop waiting after this timeout
     * @param interval - time to wait between polls.
     * @returns The transactionHash this userOp was mined, or null if not found.
     */
    getUserOpReceipt(userOpHash: string, timeout?: number, interval?: number): Promise<string | null>;
    private unwrapBundlerError;
}
//# sourceMappingURL=base-api.d.ts.map