import { _ as hasMatchingAbi, bj as AbiSchema, cv as AmountSchema, ax as getCreate2FactoryAddress, aE as computeDeploymentInfo, av as isContractDeployed, az as getInitBytecodeWithSalt, b7 as BigNumberTransformSchema, b5 as BigNumberSchema, b6 as BigNumberishSchema, b9 as AddressOrEnsSchema } from './index-e7118e8b.browser.esm.js';
import { utils, BigNumber } from 'ethers';
import invariant from 'tiny-invariant';
import { GENERATED_ABI } from '@thirdweb-dev/generated-abis';
import { z } from 'zod';
import { C as CommonNFTOutput, a as CommonNFTInput, N as NFTInputOrUriSchema } from './setErc20Allowance-0fd3045e.browser.esm.js';

/**
 * @internal
 * @param contractWrapper - The contract wrapper to check
 * @param abi - The abi to check
 * @returns
 */
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}

function toEther(amount) {
  return utils.formatEther(amount);
}

function toUnits(amount, decimals) {
  return utils.parseUnits(AmountSchema.parse(amount), decimals);
}

function toDisplayValue(amount, decimals) {
  return utils.formatUnits(amount, decimals);
}

/**
 *
 * @internal
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param create2Factory - The create2 factory to use
 */
async function computeNativeTokenAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  }, clientId, secretKey)).transaction.predictedAddress;
}

/**
 * Deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address.
 *
 * @internal
 *
 * @param signer - The signer to use
 * @param bytecode - The bytecode to deploy
 * @param encodedArgs - The encoded constructor args to use
 * @param create2FactoryAddress - The create2 factory address to use
 */
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 7000000;
  // Check if the implementation contract is already deployed
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    const tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}

/**
 * @internal
 */
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return undefined;
}

let ProposalState = /*#__PURE__*/function (ProposalState) {
  ProposalState[ProposalState["Pending"] = 0] = "Pending";
  ProposalState[ProposalState["Active"] = 1] = "Active";
  ProposalState[ProposalState["Canceled"] = 2] = "Canceled";
  ProposalState[ProposalState["Defeated"] = 3] = "Defeated";
  ProposalState[ProposalState["Succeeded"] = 4] = "Succeeded";
  ProposalState[ProposalState["Queued"] = 5] = "Queued";
  ProposalState[ProposalState["Expired"] = 6] = "Expired";
  ProposalState[ProposalState["Executed"] = 7] = "Executed";
  return ProposalState;
}({});

const PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();

/**
 * @internal
 */
const OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional())();

/**
 * @internal
 */
const EditionMetadataOutputSchema = /* @__PURE__ */(() => z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
}))();

/**
 * @internal
 */
const EditionMetadataWithOwnerOutputSchema = /* @__PURE__ */(() => EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
}))();

/**
 * @internal
 */
const EditionMetadataInputSchema = /* @__PURE__ */(() => z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
}))();

/**
 * @internal
 */
const EditionMetadataInputOrUriSchema = /* @__PURE__ */(() => z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
}))();

/**
 * @public
 */

/**
 * @public
 */

/**
 * @internal
 */
const TokenMintInputSchema = /* @__PURE__ */(() => z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
}))();

/**
 * @public
 */

export { EditionMetadataOutputSchema as E, OptionalPropertiesInput as O, ProposalState as P, TokenMintInputSchema as T, toUnits as a, toDisplayValue as b, computeNativeTokenAddress as c, deployContractDeterministicRaw as d, EditionMetadataWithOwnerOutputSchema as e, EditionMetadataInputSchema as f, getCachedAbiForContract as g, EditionMetadataInputOrUriSchema as h, matchesPrebuiltAbi as m, toEther as t };
