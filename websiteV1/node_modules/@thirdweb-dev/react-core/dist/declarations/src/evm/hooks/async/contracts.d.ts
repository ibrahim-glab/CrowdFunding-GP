import { RequiredParam } from "../../../core/query-utils/required-param";
import { ContractAddress } from "../../types";
import { UseMutationResult, UseQueryResult } from "@tanstack/react-query";
import type { ContractEvent, ContractForPrebuiltContractType, ContractType, EventQueryOptions, PrebuiltContractType, SmartContract, SUPPORTED_CHAIN_ID, ThirdwebSDK, ValidContractInstance, BaseContractForAddress, PublishedMetadata } from "@thirdweb-dev/sdk";
import type { CallOverrides, ContractInterface, providers } from "ethers";
import { ContractAddress as GeneratedContractAddress } from "@thirdweb-dev/generated-abis";
declare function fetchContractType(contractAddress: RequiredParam<ContractAddress>, sdk: RequiredParam<ThirdwebSDK>): Promise<"split" | "edition-drop" | "edition" | "marketplace" | "marketplace-v3" | "multiwrap" | "nft-collection" | "nft-drop" | "pack" | "signature-drop" | "token-drop" | "token" | "vote" | "custom" | null>;
/**
 * Hook for determining the type of contract for a contract address.
 *
 * This is useful if you want to determine if a contract is a [prebuilt contract](https://portal.thirdweb.com/pre-built-contracts).
 *
 * @example
 * ```jsx
 * import { useContractType } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { data, isLoading, error } = useContractType(contractAddress);
 * }
 * ```
 *
 * @param contractAddress - The address of the contract
 * @returns Query result containing the type of the contract in the `data` property
 * @metadata
 */
export declare function useContractType(contractAddress: RequiredParam<ContractAddress>): UseQueryResult<"split" | "edition-drop" | "edition" | "marketplace" | "marketplace-v3" | "multiwrap" | "nft-collection" | "nft-drop" | "pack" | "signature-drop" | "token-drop" | "token" | "vote" | "custom" | null, unknown>;
/**
 * @internal
 */
export declare const contractType: {
    cacheKey: (contractAddress: RequiredParam<ContractAddress>, chainId: RequiredParam<SUPPORTED_CHAIN_ID>) => import("@tanstack/react-query").QueryKey;
    useQuery: typeof useContractType;
    fetchQuery: typeof fetchContractType;
};
declare function fetchCompilerMetadata(contractAddress: RequiredParam<ContractAddress>, sdk: RequiredParam<ThirdwebSDK>): Promise<PublishedMetadata> | null;
/**
 * Hook for retrieving information such as the ABI, license, and metadata of a smart contract using it's contract address.
 *
 * @example
 * ```jsx
 * import { useCompilerMetadata } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { data, isLoading, error } = useCompilerMetadata(contractAddress);
 * }
 *
 * export default App;
 * ```
 *
 * @param contractAddress - The address of the deployed contract
 * @returns Query result containing the compiler metadata of the deployed contract in the `data` property
 *
 * @metadata
 */
export declare function useCompilerMetadata(contractAddress: RequiredParam<ContractAddress>): UseQueryResult<PublishedMetadata | null>;
/**
 * @internal
 */
export declare const compilerMetadata: {
    cacheKey: (contractAddress: RequiredParam<ContractAddress>, chainId: RequiredParam<SUPPORTED_CHAIN_ID>) => import("@tanstack/react-query").QueryKey;
    useQuery: typeof useCompilerMetadata;
    fetchQuery: typeof fetchCompilerMetadata;
};
/**
 * @contract
 */
export type UseContractResult<TContract extends ValidContractInstance = SmartContract> = UseQueryResult<TContract | undefined> & {
    contract: TContract | undefined;
};
/**
 * Hook for connecting to a smart contract.
 *
 * Provide your smart contract address as the first parameter. Once connected, the `contract` will be an instance of your smart contract.
 *
 * The ABI of the smart contract is resolved automatically for contracts deployed or imported using the [thirdweb dashboard](https://thirdweb.com/dashboard).
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract(contractAddress);
 * ```
 *
 * @remarks
 *
 * To cache the ABI of the smart contract, use [thirdweb generate](https://portal.thirdweb.com/cli/generate). This is recommended to improve performance and provide type-safety when interacting with your smart contract.
 *
 *
 * @param contractAddress - The address of the deployed contract
 * @returns Query result object that includes the contract once it is resolved
 * @contract
 */
export declare function useContract(contractAddress: RequiredParam<ContractAddress>): UseContractResult<SmartContract>;
/**
 * If your contract is a prebuilt contract, it is strongly recommended you provide the contract's name as the second argument to gain access to improved top-level functions and type inference.
 *
 * Available contract types are:
 * - `"nft-drop"`
 * - `"signature-drop"`
 * - `"edition-drop"`
 * - `"nft-collection"`
 * - `"edition"`
 * - `"multiwrap"`
 * - `"pack"`
 * - `"token-drop"`
 * - `"token"`
 * - `"marketplace"`
 * - `"marketplace-v3"`
 * - `"split"`
 * - `"vote"`
 *
 * When a contract type is provided, the contract object will be typed as the contract's class.
 * For example, if you provide the contract type `"pack"`, the contract object will be returned typed as an instance of the `Pack` class, unlocking all of the top-level functions specific to the pack.
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract(contractAddress, "pack");
 * ```
 *
 * @param contractAddress - The address of the deployed contract
 * @param _contractType - The type of the contract
 * @returns Query result object that includes the contract once it is resolved
 * @public
 */
export declare function useContract<TContractType extends ContractType>(contractAddress: RequiredParam<ContractAddress>, _contractType: TContractType): UseContractResult<TContractType extends PrebuiltContractType ? ContractForPrebuiltContractType<TContractType> : SmartContract>;
/**
 * Optionally, (if you don’t want to use the dashboard import feature),
 * you can provide your smart contract’s ABI to the second parameter of the useContract hook.
 * This is useful when developing on a local node, where it may be faster to use the ABI than to import the contract using the dashboard.
 *
 * The ABI is only necessary if you have not deployed your contract with, or imported your contract to the [thirdweb dashboard](https://thirdweb.com/dashboard).
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract(contractAddress, contractAbi);
 * ```
 *
 * @param contractAddress - The address of the deployed contract
 * @param _abi - The ABI of the contract to use
 * @returns Query result object that includes the contract once it is resolved
 */
export declare function useContract(contractAddress: RequiredParam<ContractAddress>, _abi: ContractInterface): UseContractResult<SmartContract>;
export declare function useContract<TContractAddress extends ContractAddress | GeneratedContractAddress>(contractAddress: RequiredParam<TContractAddress>): UseContractResult<TContractAddress extends GeneratedContractAddress ? SmartContract<BaseContractForAddress<TContractAddress>> : SmartContract>;
/**
 * Get the metadata of given contract
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading } = useContractMetadata(contract);
 * ```
 *
 * @param contract - The `ValidContractInstance` instance of the contract to get the metadata for
 * @returns A Query result object that includes the contract metadata of the deployed contract
 * @twfeature ContractMetadata
 * @metadata
 */
export declare function useContractMetadata<TContract extends ValidContractInstance>(contract: RequiredParam<TContract>): UseQueryResult<RequiredParam<TContract> extends undefined ? undefined : Awaited<ReturnType<TContract["metadata"]["get"]>>, unknown>;
/**
 * Update the metadata of the given contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract("{{contract_address}}");
 *   const {
 *     mutate: updateContractMetadata,
 *     isLoading,
 *     error,
 *   } = useContractMetadataUpdate(contract);
 *
 *   if (error) {
 *     console.error("failed to update contract metadata", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updateContractMetadata({ name: "New name", description: "New description" })}
 *     >
 *       Update contract metadata
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - The `ValidContractInstance` instance of the contract to get the metadata for
 * @returns Mutation object to update the contract metadata
 * @twfeature ContractMetadata
 * @metadata
 */
export declare function useContractMetadataUpdate(contract: RequiredParam<ValidContractInstance>): UseMutationResult<{
    receipt: providers.TransactionReceipt;
    data: () => Promise<any>;
}, unknown, {
    name: string;
    description?: string | undefined;
    image?: any;
    external_link?: string | undefined;
    app_uri?: string | undefined;
}, unknown>;
/**
 * CONTRACT EVENTS
 */
/**
 * Hook for reading events emitted by a smart contract, including new events as they are emitted (optional).
 *
 * By default, it reads all events emitted by the smart contract.
 *
 * @example
 * ```tsx
 * import { useContractEvents, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useContractEvents(contract);
 * }
 * ```
 *
 * @param contract - The contract instance of the contract to listen to events for
 *
 * @param eventName -
 * The name of the event to query for.
 *
 * For example, if your smart contract emits an event called `MyEvent`, you would pass `"MyEvent"` to this parameter.
 *
 * Omit this parameter or provide undefined to query for all events emitted by the smart contract.
 *
 * @param options -
 * An object containing options to filter the events being queried.
 *
 * Available options include
 * - `queryFilter` to refine which events you want to read,
 * - a boolean `subscribe` flag to subscribe to new events as they are emitted.
 *
 * ### Example
 * ```tsx
 * import {
 *   useContractEvents,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useContractEvents(
 *     contract,
 *     "MyEvent",
 *     {
 *       queryFilter: {
 *         filters: {
 *           tokenId: 123, // e.g. Only events where tokenId = 123
 *         },
 *         fromBlock: 0, // Events starting from this block
 *         toBlock: 100, // Events up to this block
 *         order: "asc", // Order of events ("asc" or "desc")
 *       },
 *       subscribe: true, // Subscribe to new events
 *     },
 *   );
 * ```
 *
 * @returns The hook's `data` property, once loaded, contains an array of `ContractEvent` objects
 * @contract
 *
 */
export declare function useContractEvents(contract: RequiredParam<ValidContractInstance>, eventName?: string, options?: {
    queryFilter?: EventQueryOptions;
    subscribe?: boolean;
}): UseQueryResult<ContractEvent<Record<string, any>>[], unknown>;
/**
 * Generic hook for reading any data from a smart contract via it’s function/view/variable name.
 *
 * ```javascript
 * const { contract } = useContract("{{contract_address}}");
 * const { data, isLoading, error } = useContractRead(contract, "functionName", args);
 * ```
 *
 * @example
 * Provide your smart contract instance from `useContract`, a function name and the arguments to pass to the function (if any).
 *
 * For example, to read the value of a view on your smart contract called `getName` you would do the following:
 *
 * ```tsx
 * import { useContractRead, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useContractRead(contract, "getName");
 * }
 * ```
 *
 * @remarks
 * If you have cached the ABI of your smart contract using [thirdweb generate](https://portal.thirdweb.com/cli/generate), the functionName and args parameters are strongly typed according to your smart contract’s ABI.
 *
 * @param contract - The contract instance of the contract to call a function on
 *
 * @param functionName - The name of the function to call in the smart contract. This can be any function, view, variable, etc. that does not require a transaction to occur.
 *
 * @param args - The arguments to pass to the function (if any)
 *
 * @param overrides -
 * `CallOverrides` object to send with your request.
 *
 * To include the sender's address (msg.sender) when calling view functions within your smart contract, include the property `{from: 0X123}` passing the relevant address.
 *
 * ```ts
 * const { data, isLoading, error } = useContractRead(contract, "getName", ["arg1", "arg2"], {
 *     blockTag: 123,
 *     from: "0x123",
 *   });
 * ```
 *
 * @returns Query result object that includes the data returned by the function call
 * @contract
 */
export declare function useContractRead<TContractAddress extends GeneratedContractAddress | ContractAddress, TContract extends TContractAddress extends GeneratedContractAddress ? BaseContractForAddress<TContractAddress> : ValidContractInstance, TContractInstance extends TContractAddress extends GeneratedContractAddress ? SmartContract<BaseContractForAddress<TContractAddress>> : ValidContractInstance, TFunctionName extends TContractAddress extends GeneratedContractAddress ? TContract extends BaseContractForAddress<TContractAddress> ? keyof TContract["functions"] : never : Parameters<TContractInstance["call"]>[0], TArgs extends TContractAddress extends GeneratedContractAddress ? TContract extends BaseContractForAddress<TContractAddress> ? TFunctionName extends keyof TContract["functions"] ? Parameters<TContract["functions"][TFunctionName]> : unknown[] : unknown[] : unknown[], TReturnType extends TContractAddress extends GeneratedContractAddress ? TContract extends BaseContractForAddress<TContractAddress> ? TFunctionName extends keyof TContract["functions"] ? ReturnType<TContract["functions"][TFunctionName]> : any : any : any>(contract: TContractInstance extends ValidContractInstance ? RequiredParam<TContractInstance> | undefined : TContractAddress extends GeneratedContractAddress ? RequiredParam<SmartContract<BaseContractForAddress<TContractAddress>>> | undefined : RequiredParam<SmartContract> | undefined, functionName: RequiredParam<TFunctionName & string>, args?: TArgs, overrides?: CallOverrides): UseQueryResult<TReturnType, unknown>;
/**
 * Generic hook for calling any smart contract function that requires a transaction to take place.
 *
 * Provide your smart contract instance returned from the `useContract` hook, along with the name of the function you wish to call on your smart contract as arguments to the hook.
 *
 * Then call the `mutate` or `mutateAsync` function returned by the hook, providing an array of arguments to send to your smart contract function.
 *
 * If you provide too many or too few arguments, the `error` property will be populated with an error message.
 *
 * If your function has no arguments, provide an empty array by calling the function with `{ args: [] }`
 *
 * @example
 * ```javascript
 * import { useContractWrite, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync, isLoading, error } = useContractWrite(
 *     contract,
 *     "setName",
 *   );
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       // Calls the "setName" function on your smart contract with "My Name" as the first argument
 *       action={() => mutateAsync({ args: ["My Name"] })}
 *     >
 *       Send Transaction
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @remarks
 *
 * If you have cached the ABI of your smart contract using [thirdweb generate](https://portal.thirdweb.com/cli/generate), the functionName and args parameters are strongly typed according to your smart contract’s ABI.
 *
 *
 * @param contract - The contract instance of the contract to call a function on
 * @param functionName - The name of the function to call in the smart contract.
 * @returns A mutation object that includes the write function to call
 * @contract
 */
export declare function useContractWrite<TContractAddress extends GeneratedContractAddress | ContractAddress, TContract extends TContractAddress extends GeneratedContractAddress ? BaseContractForAddress<TContractAddress> : ValidContractInstance, TContractInstance extends TContractAddress extends GeneratedContractAddress ? SmartContract<BaseContractForAddress<TContractAddress>> : ValidContractInstance, TFunctionName extends TContractAddress extends GeneratedContractAddress ? TContract extends BaseContractForAddress<TContractAddress> ? keyof TContract["functions"] : never : Parameters<TContractInstance["call"]>[0], TArgs extends TContractAddress extends GeneratedContractAddress ? TContract extends BaseContractForAddress<TContractAddress> ? TFunctionName extends keyof TContract["functions"] ? Parameters<TContract["functions"][TFunctionName]> : unknown[] : unknown[] : any[]>(contract: TContractInstance extends ValidContractInstance ? RequiredParam<TContractInstance> | undefined : TContractAddress extends GeneratedContractAddress ? RequiredParam<SmartContract<BaseContractForAddress<TContractAddress>>> | undefined : RequiredParam<SmartContract> | undefined, functionName: RequiredParam<TFunctionName & string>): UseMutationResult<Omit<{
    receipt: providers.TransactionReceipt;
    data: () => Promise<unknown>;
}, "data">, unknown, {
    args?: TArgs | undefined;
    overrides?: CallOverrides | undefined;
}, unknown>;
export {};
//# sourceMappingURL=contracts.d.ts.map