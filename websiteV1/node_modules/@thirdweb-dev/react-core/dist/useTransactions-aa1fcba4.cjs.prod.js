'use strict';

var mime = require('mime/lite.js');
var react = require('react');
var reactQuery = require('@tanstack/react-query');
var invariant = require('tiny-invariant');
var jsxRuntime = require('react/jsx-runtime');
var chains = require('@thirdweb-dev/chains');
var evm = require('@thirdweb-dev/sdk/evm');
var sdk = require('@thirdweb-dev/sdk');
var wallets = require('@thirdweb-dev/wallets');
var ethers = require('ethers');
var auth = require('@thirdweb-dev/auth');
var functions = require('@thirdweb-dev/sdk/evm/functions');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var mime__default = /*#__PURE__*/_interopDefault(mime);
var invariant__default = /*#__PURE__*/_interopDefault(invariant);

// TODO legacy remove this when possible

/**
 * @internal
 */
async function resolveMimeType(url) {
  if (!url) {
    return undefined;
  }
  const mimeType = mime__default["default"].getType(url);
  if (mimeType) {
    return mimeType;
  }
  const res = await fetch(url, {
    method: "HEAD"
  });
  if (res.ok && res.headers.has("content-type")) {
    return res.headers.get("content-type") || undefined;
  }
  // we failed to resolve the mime type, return null
  return undefined;
}

/**
 * @internal
 */
const ThirdwebThemeContext = /* @__PURE__ */react.createContext(undefined);

/**
 * Secure storage interface for storing auth tokens.
 *
 * The implementation of this interface should provide a secure way to store values. Either by encrypting the values or by storing them in a secure location.
 * @auth
 */

/**
 * The configuration to use by the React and React Native SDKs with an [auth](https://portal.thirdweb.com/wallets/auth) server.
 * @auth
 */

const ThirdwebAuthContext = /* @__PURE__ */react.createContext(undefined);

/**
 *
 * @internal
 */
function useThirdwebAuthContext() {
  return react.useContext(ThirdwebAuthContext);
}

const isWalletConnectReceiverEnabled = wallet => {
  const options = wallet?.getOptions();
  return options && "walletConnectReceiver" in options && options.walletConnectReceiver;
};

const LAST_CONNECTED_WALLET_STORAGE_KEY = "lastConnectedWallet";
let lastConnectedWalletStorage;
// maps wallet instance to it's wallet config
const walletInstanceToConfig = new Map();

/**
 * Maps a personal wallet instance to it's wrapper wallet instance ( like smartWallet or safeWallet ) to know it's "wrapper" wallet
 *
 * This is used to implement the "switch to personal wallet" and "switch to smart wallet" feature
 */
const personalWalletToWrapperWallet = new Map();
const ThirdwebWalletContext = /* @__PURE__ */react.createContext(undefined);
/**
 * setup states and methods for wallet connection
 */
function useWalletConnectionSetup(data, initialValue) {
  const {
    chains,
    chainToConnect,
    dAppMeta,
    clientId,
    activeChain
  } = data;
  const [signer, setSigner] = react.useState(undefined);
  const [connectionStatus, setConnectionStatus] = react.useState(initialValue.connectionStatus);
  const [activeWallet, setActiveWallet] = react.useState();
  const [createdWalletInstance, setCreatedWalletInstance] = react.useState();
  const [activeWalletConfig, setActiveWalletConfig] = react.useState();
  const [chainId, setChainId] = react.useState(undefined);
  const [walletAddress, setWalletAddress] = react.useState(undefined);
  const walletParams = react.useMemo(() => {
    return {
      chains: chains,
      dappMetadata: dAppMeta,
      chain: activeChain || chains[0],
      clientId: clientId
    };
  }, [chains, dAppMeta, activeChain, clientId]);
  const createWalletInstance = react.useCallback(walletConfig => {
    const walletInstance = walletConfig.create(walletParams);
    if (walletInstance.walletId === wallets.walletIds.magicLink) {
      // NOTE: removing this if statement causes the component to re-render
      // Patch for magic link wallet in react native
      // needed because we need to add a component to the view tree
      // from the instance, right before calling connect.
      // Check it out in RN's DappContextProvider.
      setCreatedWalletInstance(walletInstance);
    }
    walletInstanceToConfig.set(walletInstance, walletConfig);
    return walletInstance;
  }, [walletParams]);
  const setConnectedWallet = react.useCallback(async function (wallet, connectParams) {
    let isAutoConnect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const walletConfig = walletInstanceToConfig.get(wallet);
    if (!walletConfig) {
      throw new Error("Wallet config not found for given wallet instance. Do not create a wallet instance manually - use the useCreateWalletInstance() hook instead");
    }
    const [_signer, _chainId, _address] = await Promise.all([wallet.getSigner(), wallet.getChainId(), wallet.getAddress()]);

    // set states for the connected wallet
    setActiveWallet(wallet);
    setChainId(_chainId);
    setWalletAddress(_address);
    setSigner(_signer);
    setActiveWalletConfig(walletConfig);
    setConnectionStatus("connected");

    // if personal wallet exists, we need to replace the connectParams.personalWallet to a stringifiable version
    const personalWallet = wallet.getPersonalWallet();
    personalWalletToWrapperWallet.set(personalWallet, wallet);

    // it autoconnected, then the details is already saved in storage, no need to store again
    if (isAutoConnect) {
      return;
    }

    // save to storage

    const walletInfo = {
      walletId: walletConfig.id,
      connectParams: connectParams || wallet.getConnectParams()
    };
    const personalWalletConfig = walletInstanceToConfig.get(personalWallet);
    if (personalWallet && personalWalletConfig) {
      walletInfo.connectParams = {
        ...walletInfo.connectParams,
        personalWallet: {
          walletId: personalWalletConfig.id,
          connectParams: personalWallet.getConnectParams()
        }
      };
      saveLastConnectedWalletInfo(walletInfo);
    } else {
      saveLastConnectedWalletInfo(walletInfo);
    }
  }, []);
  const storeLastActiveChainId = react.useCallback(async _chainId => {
    const lastConnectedWallet = await lastConnectedWalletStorage.getItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
    if (!lastConnectedWallet) {
      return;
    }
    try {
      const parsedWallet = JSON.parse(lastConnectedWallet);
      if (parsedWallet.connectParams) {
        parsedWallet.connectParams.chainId = _chainId;
      } else {
        parsedWallet.connectParams = {
          chainId: _chainId
        };
      }
      await lastConnectedWalletStorage.setItem(LAST_CONNECTED_WALLET_STORAGE_KEY, JSON.stringify(parsedWallet));
    } catch (error) {
      console.error(`Error saving the last active chain: ${error}`);
    }
  }, []);
  const switchChain = react.useCallback(async _chainId => {
    if (!activeWallet) {
      throw new Error("No active wallet");
    }
    await activeWallet.switchChain(_chainId);
    const _signer = await activeWallet.getSigner();
    await storeLastActiveChainId(_chainId);
    setSigner(_signer);
  }, [activeWallet, storeLastActiveChainId]);
  const connectWallet = react.useCallback(async function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const [WalletObj, connectParams] = args;
    const _connectedParams = {
      chainId: chainToConnect?.chainId,
      ...(connectParams || {})
    };
    const wallet = createWalletInstance(WalletObj);
    setConnectionStatus("connecting");
    try {
      // if magic is using social login - it will redirect the page - so need to save walletInfo before connecting
      // TODO: find a better way to handle this
      if (WalletObj.id === wallets.walletIds.magicLink) {
        saveLastConnectedWalletInfo({
          walletId: WalletObj.id,
          connectParams: _connectedParams
        });
      }
      await wallet.connect(_connectedParams);
      setConnectedWallet(wallet, _connectedParams);
    } catch (e) {
      console.error(`Error connecting to wallet: ${e}`);
      setConnectionStatus("disconnected");
      throw e;
    }
    return wallet;
  }, [createWalletInstance, setConnectedWallet, chainToConnect]);
  const onWalletDisconnect = react.useCallback(() => {
    setConnectionStatus("disconnected");
    setSigner(undefined);
    setActiveWallet(undefined);
    setActiveWalletConfig(undefined);
    setChainId(undefined);
    setWalletAddress(undefined);
    lastConnectedWalletStorage.removeItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
  }, []);
  const disconnectWallet = react.useCallback(async () => {
    // if disconnect is called before the wallet is connected
    if (!activeWallet) {
      onWalletDisconnect();
      return;
    }
    onWalletDisconnect();
    const personalWallet = activeWallet.getPersonalWallet();
    await activeWallet.disconnect();
    if (personalWallet) {
      await personalWallet?.disconnect();
    }
  }, [activeWallet, onWalletDisconnect]);

  // handle wallet change event
  react.useEffect(() => {
    if (!activeWallet) {
      setSigner(undefined);
      setChainId(undefined);
      setWalletAddress(undefined);
      return;
    }
    const update = async () => {
      Promise.all([activeWallet.getSigner(), activeWallet.getChainId(), activeWallet.getAddress()]).then(_ref => {
        let [_signer, _chainId, _address] = _ref;
        setSigner(_signer);
        setChainId(_chainId);
        setWalletAddress(_address);
      });
    };
    update();
    activeWallet.addListener("change", update);
    activeWallet.addListener("disconnect", onWalletDisconnect);
    return () => {
      activeWallet.removeListener("change", update);
      activeWallet.removeListener("disconnect", onWalletDisconnect);
    };
  }, [activeWallet, onWalletDisconnect]);

  // if props.chains is updated, update the active wallet's chains
  react.useEffect(() => {
    if (activeWallet) {
      activeWallet.updateChains(chains);
    }
  }, [activeWallet, chains]);
  return {
    signer,
    connectionStatus,
    setConnectionStatus,
    activeWallet,
    createdWalletInstance,
    activeWalletConfig,
    createWalletInstance,
    setConnectedWallet,
    switchChain,
    connectWallet,
    disconnectWallet,
    chainId,
    address: walletAddress
  };
}
function ThirdwebWalletProvider(props) {
  // if autoSwitch is enabled - enforce connection to activeChain
  const chainToConnect = props.autoSwitch ? props.activeChain : undefined;
  const autoConnectTimeout = props.autoConnectTimeout || 15000;
  const walletSetupData = {
    chains: props.chains,
    dAppMeta: props.dAppMeta,
    activeChain: props.activeChain,
    clientId: props.clientId,
    chainToConnect
  };
  const {
    signer,
    connectionStatus,
    setConnectionStatus,
    activeWallet,
    createdWalletInstance,
    activeWalletConfig,
    createWalletInstance,
    setConnectedWallet,
    switchChain,
    connectWallet,
    disconnectWallet,
    address,
    chainId
  } = useWalletConnectionSetup(walletSetupData, {
    connectionStatus: "unknown"
  });
  const personalWalletConnection = useWalletConnectionSetup(walletSetupData, {
    connectionStatus: "disconnected"
  });

  /**
   * This is used to know if auto connect is in progress
   */
  const [isAutoConnecting, setIsAutoConnecting] = react.useState(false);
  const [walletConnectHandler, setWalletConnectHandler] = react.useState();
  if (!lastConnectedWalletStorage) {
    lastConnectedWalletStorage = props.createWalletStorage("coordinatorStorage");
  }
  react.useEffect(() => {
    if (!activeWallet) {
      return;
    }
    const initWCHandler = async () => {
      const wcReceiverOptions = activeWallet?.getOptions();
      const handler = new wallets.WalletConnectV2Handler({
        walletConnectReceiver: {
          ...(wcReceiverOptions?.walletConnectReceiver === true ? {} : wcReceiverOptions?.walletConnectReceiver)
        }
      }, activeWallet);
      await handler.init();
      setWalletConnectHandler(handler);
    };
    if (isWalletConnectReceiverEnabled(activeWallet)) {
      initWCHandler();
    }
  }, [activeWallet]);
  const autoConnectTriggered = react.useRef(false);

  // Auto Connect
  react.useEffect(() => {
    if (autoConnectTriggered.current) {
      return;
    }
    autoConnectTriggered.current = true;

    // do not auto connect if signerWallet is given
    if (props.signerWallet) {
      return;
    }
    if (activeWallet) {
      // there's already an active wallet, don't auto connect
      return;
    }
    if (connectionStatus !== "unknown") {
      // only try to auto connect if we're in the unknown state
      return;
    }

    // if explicitly set to false, don't auto connect
    // by default, auto connect
    if (props.shouldAutoConnect === false) {
      setConnectionStatus("disconnected");
      return;
    }
    async function autoconnect() {
      const walletInfo = await getLastConnectedWalletInfo();
      if (!walletInfo) {
        setConnectionStatus("disconnected");
        return;
      }
      const walletObj = props.supportedWallets.find(W => W.id === walletInfo.walletId);
      if (!walletObj) {
        // last connected wallet is no longer present in the supported wallets
        setConnectionStatus("disconnected");
        return;
      }
      let _personalWalletInfo = walletInfo.connectParams?.personalWallet;
      let shouldSetPersonalWalletAsActive = false;

      // if the wallet requires a personal wallet (like smartWallet), but the saved data does not have it
      // this can happen when user clicks on "switch to personal wallet" and reloads the page
      // OR when user clicks on magic link social login
      if (walletObj.personalWallets && !_personalWalletInfo) {
        // for magicLink social login - don't switch to personal wallet because smartWallet did not have a chance to connect because of page change
        if (walletInfo.walletId === wallets.walletIds.magicLink && walletInfo.connectParams && "oauthProvider" in walletInfo.connectParams) {
          shouldSetPersonalWalletAsActive = false;
        } else {
          shouldSetPersonalWalletAsActive = true;
        }

        // fix the connectParams by adding the personal wallet info
        _personalWalletInfo = {
          walletId: walletInfo.walletId,
          connectParams: walletInfo.connectParams
        };
      }
      const personalWalletInfo = _personalWalletInfo;
      let personalWalletInstance;
      if (personalWalletInfo) {
        const personalWallets = walletObj.personalWallets || [];
        const personalWalletObj = personalWallets.find(W => W.id === personalWalletInfo.walletId);
        if (personalWalletObj) {
          // create a personal wallet instance and auto connect it
          personalWalletInstance = createWalletInstance(personalWalletObj);
          try {
            await timeoutPromise(personalWalletInstance.autoConnect(personalWalletInfo.connectParams), {
              ms: autoConnectTimeout,
              message: autoConnectTimeoutErrorMessage
            });
            if (shouldSetPersonalWalletAsActive) {
              setConnectedWallet(personalWalletInstance, personalWalletInfo.connectParams, true);
            }
          } catch (e) {
            console.error("Failed to auto connect personal wallet");
            console.error(e);
            setConnectionStatus("disconnected");
            return;
          }

          // set the personal wallet instance to the connectParams
          walletInfo.connectParams = {
            ...walletInfo.connectParams,
            personalWallet: personalWalletInstance
          };
        } else {
          // last used personal wallet is no longer present in the supported wallets
          setConnectionStatus("disconnected");
          return;
        }
      }

      // create a wallet instance and auto connect it
      const wallet = createWalletInstance(walletObj);
      try {
        setIsAutoConnecting(true);
        setConnectionStatus("connecting");
        if (personalWalletInstance) {
          personalWalletToWrapperWallet.set(personalWalletInstance, wallet);
        }
        await timeoutPromise(wallet.autoConnect(walletInfo.connectParams), {
          ms: autoConnectTimeout,
          message: autoConnectTimeoutErrorMessage
        });
        if (!shouldSetPersonalWalletAsActive) {
          setConnectedWallet(wallet, walletInfo.connectParams, true);
        }
      } catch (e) {
        console.error("Failed to auto connect wallet");
        console.error(e);
        if (e instanceof Error && e.message === autoConnectTimeoutErrorMessage) {
          lastConnectedWalletStorage.removeItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
        }
        setConnectionStatus("disconnected");
      }
      setIsAutoConnecting(false);
    }
    autoconnect();
  }, [createWalletInstance, props.supportedWallets, setConnectedWallet, props.shouldAutoConnect, activeWallet, connectionStatus, props.signerWallet, setConnectionStatus, autoConnectTimeout]);

  // connect signerWallet immediately if it's passed
  // and disconnect it if it's not passed
  const signerConnected = react.useRef();
  react.useEffect(() => {
    if (!props.signerWallet) {
      if (signerConnected.current) {
        disconnectWallet();
        signerConnected.current = undefined;
      }
      return;
    }
    if (signerConnected.current === props.signerWallet) {
      return;
    }
    const wallet = createWalletInstance(props.signerWallet);
    setConnectedWallet(wallet);
    signerConnected.current = props.signerWallet;
  }, [createWalletInstance, props.supportedWallets, setConnectedWallet, props.signerWallet, disconnectWallet]);
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebWalletContext.Provider, {
    value: {
      address,
      chainId,
      disconnect: disconnectWallet,
      wallets: props.supportedWallets,
      connect: connectWallet,
      signer,
      activeWallet,
      activeWalletConfig,
      connectionStatus,
      setConnectionStatus,
      createWalletInstance: createWalletInstance,
      createdWalletInstance: createdWalletInstance,
      createWalletStorage: props.createWalletStorage,
      switchChain,
      setConnectedWallet: setConnectedWallet,
      activeChain: props.activeChain,
      chainToConnect,
      getWalletConfig: walletInstance => {
        return walletInstanceToConfig.get(walletInstance);
      },
      getWrapperWallet: personalWallet => {
        return personalWalletToWrapperWallet.get(personalWallet);
      },
      activeChainSetExplicitly: props.activeChainSetExplicitly,
      clientId: props.clientId,
      walletConnectHandler: walletConnectHandler,
      personalWalletConnection,
      isAutoConnecting
    },
    children: props.children
  });
}

/**
 * @internal
 */
function useWalletContext() {
  const ctx = react.useContext(ThirdwebWalletContext);
  if (!ctx) {
    throw new Error(`useWalletContext() can only be used inside <ThirdwebProvider />`);
  }
  return ctx;
}

/**
 * Get WalletConnect handler instance
 */
function useWalletConnectHandler() {
  const ctx = useWalletContext();
  if (!ctx) {
    throw new Error(`useWalletConnectHandler() can only be used inside <ThirdwebProvider />`);
  }
  return ctx.walletConnectHandler;
}
async function getLastConnectedWalletInfo() {
  const str = await lastConnectedWalletStorage.getItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
  if (!str) {
    return null;
  }
  try {
    return JSON.parse(str);
  } catch {
    await lastConnectedWalletStorage.removeItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
    return null;
  }
}
async function saveLastConnectedWalletInfo(walletInfo) {
  try {
    await lastConnectedWalletStorage.setItem(LAST_CONNECTED_WALLET_STORAGE_KEY, JSON.stringify(walletInfo));
  } catch (e) {
    console.error("Error saving the last connected wallet info", e);
  }
}

/**
 * Timeout a promise with a given Error message if the promise does not resolve in given time
 *
 * @param promise - Promise to track for timeout
 * @param option - timeout options
 * @returns
 */
function timeoutPromise(promise, option) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new Error(option.message));
    }, option.ms);
    promise.then(res => {
      clearTimeout(timeoutId);
      resolve(res);
    }, err => {
      clearTimeout(timeoutId);
      reject(err);
    });
  });
}
const autoConnectTimeoutErrorMessage = `Failed to Auto connect. Auto connect timed out. You can increase the timeout duration using the autoConnectTimeout prop on <ThirdwebProvider />`;

/**
 * @wallet
 */

/**
 * Hook to get the instance of the currently connected wallet.
 *
 * @example
 * ```jsx
 * import { useWallet } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const walletInstance = useWallet();
 * }
 * ```
 * @returns Currently connected `WalletInstance` , or `undefined` if no wallet is connected.
 * @walletConnection
 */

/**
 * Hook to get the instance of the currently connected wallet if it matches the given `walletId`.
 *
 * @example
 * ```jsx
 * import { useWallet } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const metamaskWalletInstance = useWallet('metamask');
 * }
 * ```
 *
 * @returns Currently connected `WalletInstance` with given `walletId` , or `undefined` if no wallet is connected or if the connected wallet does not match the given `walletId`.
 * @walletConnection
 */

function useWallet(walletId) {
  const context = useWalletContext();
  invariant__default["default"](context, "useWallet() hook must be used within a <ThirdwebProvider/>");
  const activeWallet = context.activeWallet;
  if (!activeWallet) {
    return undefined;
  }

  // if walletId is provided, return the wallet instance only if it matches the walletId
  if (walletId) {
    if (activeWallet.walletId === walletId) {
      return activeWallet;
    } else {
      return undefined;
    }
  }
  return activeWallet;
}

/**
 *
 * Hook to get the `WalletConfig` object of the currently connected wallet.
 *
 * This is useful to get metadata about the connected wallet, such as the wallet name, logo, etc
 *
 * @example
 *
 * ```jsx
 * import { useWalletConfig } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const walletConfig = useWalletConfig();
 *
 *   const walletName = walletConfig?.meta.name;
 *   const walletLogo = walletConfig?.meta.iconURL;
 * }
 * ```
 *
 * @returns The current connected wallet's configuration object or `undefined` if no wallet is connected.
 *
 * @walletConnection
 */
function useWalletConfig() {
  const context = useWalletContext();
  invariant__default["default"](context, "useWallet() hook must be used within a <ThirdwebProvider/>");
  return context.activeWalletConfig;
}

/**
 * @internal
 * Get `supportedWallets` passed in the `<ThirdwebProvider/>`
 * @returns `supportedWallets` configured in the `<ThirdwebProvider/>`
 */
function useWallets() {
  const context = useWalletContext();
  invariant__default["default"](context, "useWallets() hook must be used within a <ThirdwebProvider/>");
  return context.wallets;
}

/**
 * Hook for connecting a wallet to your app.
 *
 * The wallet also needs to be added in `ThirdwebProvider`'s `supportedWallets` prop to enable auto-connection on page load.
 *
 * @example
 * ```jsx
 * import { useConnect, metamaskWallet } from "@thirdweb-dev/react";
 *
 * const metamaskConfig = metamaskWallet();
 *
 * function App() {
 *   const connect = useConnect();
 *
 *   return (
 *     <button
 *       onClick={async () => {
 *         const wallet = await connect(metamaskConfig, connectOptions);
 *         console.log("connected to ", wallet);
 *       }}
 *     >
 *       Connect to MetaMask
 *     </button>
 *   );
 * }
 * ```
 *
 * @returns A function to connect a wallet
 *
 * ```ts
 * const connect = useConnect();
 *
 * function handleConnect() {
 *  const wallet = await connect(walletConfig, connectOptions);
 * }
 * ```
 *
 * The function accepts two arguments: `walletConfig` and `connectOptions`
 *
 * #### walletConfig
 * The wallet to connect. Must be of type `WalletConfig`.
 *
 * [Learn more about the available wallet options](https://portal.thirdweb.com/react/v4/connecting-wallets).
 *
 * #### connectOptions
 * The typeof `connectOptions` object depends on the wallet you are connecting. For some wallets, it may be optional
 *
 * If you are using typescript, `connect` will automatically infer the type of `connectOptions` based on the `walletConfig` you pass in as the first argument and will show type errors if you pass in invalid options.
 *
 * @walletConnection
 */
function useConnect() {
  const context = useWalletContext();
  invariant__default["default"](context, "useConnect() hook must be used within a <ThirdwebProvider/>");
  return context.connect;
}

/**
 * Hook for disconnecting the currently connected wallet.
 *
 * @example
 * ```jsx
 * import { useDisconnect } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const disconnect = useDisconnect();
 *
 *   return <button onClick={disconnect}>Disconnect</button>;
 * }
 * ```
 *
 * @returns A function to disconnect from current connected wallet
 * @walletConnection
 */
function useDisconnect() {
  const context = useWalletContext();
  invariant__default["default"](context, "useDisconnect() hook must be used within a <ThirdwebProvider/>");
  return context.disconnect;
}

/**
 * Hook for checking whether your app is connected to a wallet or not.
 *
 * @example
 * ```jsx
 * import { useConnectionStatus } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const connectionStatus = useConnectionStatus();
 *
 *   if (connectionStatus === "unknown") return <p> Loading... </p>;
 *   if (connectionStatus === "connecting") return <p> Connecting... </p>;
 *   if (connectionStatus === "connected") return <p> You are connected </p>;
 *   if (connectionStatus === "disconnected")
 *     return <p> You are not connected to a wallet </p>;
 * }
 * ```
 *
 * @returns The wallet connection status
 *
 * It can be one of the following:
 * - `unknown`: connection status is not known yet. This is the initial state.
 * - `connecting`: wallet is being connected. Either because of a user action, or when the wallet is auto-connecting on page load.
 * - `connected`: the wallet is connected and ready to be used.
 * - `disconnected`: the wallet is not connected.
 *
 * @walletConnection
 */
function useConnectionStatus() {
  const context = useWalletContext();
  invariant__default["default"](context, "useConnectionStatus() must be used within a <ThirdwebProvider/>");
  return context.connectionStatus;
}

/**
 * Hook for setting the `connectionStatus` of the wallet which is returned by the `useConnectionStatus` hook
 *
 * This is only useful if you are manually connecting a wallet instance as mentioned in [Build your Wallet](https://portal.thirdweb.com/wallet-sdk/v2/build)
 *
 * @example
 *
 * ```ts
 * import {
 *   useCreateWalletInstance,
 *   useSetConnectionStatus,
 *   useSetConnectedWallet,
 *   metamaskWallet
 * } from "@thirdweb-dev/react";
 *
 * const walletConfig = metamaskWallet();
 *
 * function Example() {
 *   const createWalletInstance = useCreateWalletInstance();
 *   const setConnectionStatus = useSetConnectionStatus();
 *   const setConnectedWallet = useSetConnectedWallet();
 *
 *   // Call this function to connect your wallet
 *   const handleConnect = async () => {
 *     // 1. create instance
 *     const walletInstance = createWalletInstance(walletConfig);
 *     setConnectionStatus("connecting");
 *
 *     try {
 *       // 2. Call `connect` method of your wallet
 *       await walletInstance.connect(
 *         connectOptions, // if your wallet.connect method accepts any options, specify it here
 *       );
 *
 *       // 3. Set connected wallet
 *       setConnectedWallet(walletInstance);
 *       props.close();
 *     } catch (e) {
 *       setConnectionStatus("disconnected");
 *       console.error("failed to connect", e);
 *     }
 *   };
 *
 *   return <div> ... </div>;
 * }
 * ```
 *
 * @returns A function that sets the `connectionStatus` of the wallet
 * @walletConnection
 */
function useSetConnectionStatus() {
  const context = useWalletContext();
  invariant__default["default"](context, "useSetConnectionStatus() must be used within a <ThirdwebProvider/>");
  return context.setConnectionStatus;
}

/**
 * Hook for creating a wallet instance from given `WalletConfig` object.
 *
 * If you just want to connect the wallet and don't need the wallet instance before connecting the wallet, use the `useConnect` hook instead.
 *
 * @example
 *
 * ```jsx
 * import { useConnect, metamaskWallet } from "@thirdweb-dev/react";
 *
 * const metamaskConfig = metamaskWallet();
 *
 * function App() {
 *   const createWalletInstance = useCreateWalletInstance();
 *
 *   return (
 *     <button
 *       onClick={() => {
 *         const metamaskWalletInstance = createWalletInstance(metamaskConfig);
 *         console.log(metamaskWalletInstance);
 *       }}
 *     >
 *       create wallet instance
 *     </button>
 *   );
 * }
 * ```
 *
 * @returns A function that creates a wallet instance for given `WalletConfig` object.
 *
 * @walletConnection
 */
function useCreateWalletInstance() {
  const context = useWalletContext();
  invariant__default["default"](context, "useCreateWalletInstance() must be used within a <ThirdwebProvider/>");
  return context.createWalletInstance;
}

/**
 * Hook for switching to a different network.
 *
 * @example
 * ```jsx
 * import { useSwitchChain } from "@thirdweb-dev/react";
 * import { Goerli } from "@thirdweb-dev/chains";
 *
 * function App() {
 *   const switchChain = useSwitchChain();
 *   return (
 *     <button onClick={() => switchChain(Goerli.chainId)}>
 *       Switch to Goerli
 *     </button>
 *   );
 * }
 * ```
 *
 * @returns A function to switch the network in the currently connected wallet to network with given `chainId`
 * @networkConnection
 */
function useSwitchChain() {
  const context = useWalletContext();
  invariant__default["default"](context, "useSwitchChain() must be used within a <ThirdwebProvider/>");
  return context.switchChain;
}

/**
 * Hook for setting a wallet instance as "connected" - once done, the wallet connection hooks like `useWallet`, `useAddress`, `useSigner`, `useConnectionStatus` etc will return the data for that wallet instance
 *
 * This is only useful if you are manually connecting a wallet instance as mentioned in [Build your Wallet](https://portal.thirdweb.com/wallet-sdk/v2/build)
 *
 * @example
 *
 * ```ts
 * import {
 *   useCreateWalletInstance,
 *   useSetConnectionStatus,
 *   useSetConnectedWallet,
 *   metamaskWallet
 * } from "@thirdweb-dev/react";
 *
 * const walletConfig = metamaskWallet();
 *
 * function Example() {
 *   const createWalletInstance = useCreateWalletInstance();
 *   const setConnectionStatus = useSetConnectionStatus();
 *   const setConnectedWallet = useSetConnectedWallet();
 *
 *   // Call this function to connect your wallet
 *   const handleConnect = async () => {
 *     // 1. create instance
 *     const walletInstance = createWalletInstance(walletConfig);
 *     setConnectionStatus("connecting");
 *
 *     try {
 *       // 2. Call `connect` method of your wallet
 *       await walletInstance.connect(
 *         connectOptions, // if your wallet.connect method accepts any options, specify it here
 *       );
 *
 *       // 3. Set connected wallet
 *       setConnectedWallet(walletInstance);
 *       props.close();
 *     } catch (e) {
 *       setConnectionStatus("disconnected");
 *       console.error("failed to connect", e);
 *     }
 *   };
 *
 *   return <div> ... </div>;
 * }
 * ```
 *
 * @returns A function to set a wallet instance as "connected".
 * @walletConnection
 */
function useSetConnectedWallet() {
  const context = useWalletContext();
  invariant__default["default"](context, "useSwitchChain() must be used within a <ThirdwebProvider/>");
  return context.setConnectedWallet;
}

const AUTH_TOKEN_STORAGE_KEY = "auth_token_storage_key";

const TW_CACHE_KEY_PREFIX = "tw-cache";

/**
 * @internal
 */
function enforceCachePrefix(input) {
  return [TW_CACHE_KEY_PREFIX, ...input.filter(i => typeof i !== "string" || i !== TW_CACHE_KEY_PREFIX)];
}

/**
 * @internal
 */
function createContractCacheKey() {
  let contractAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ethers.constants.AddressZero;
  let input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return enforceCachePrefix(["contract", contractAddress, ...input]);
}

/**
 @internal
 */
function createCacheKeyWithNetwork(input, chainId) {
  return enforceCachePrefix(cacheKeys.network.active(chainId).concat(input));
}

/**
 * @internal
 */
function invalidateContractAndBalances(queryClient, contractAddress, chainId) {
  return Promise.all([queryClient.invalidateQueries(enforceCachePrefix(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), chainId))), invalidateBalances(queryClient, chainId)]);
}

/**
 * @internal
 */
function invalidateBalances(queryClient, chainId) {
  return queryClient.invalidateQueries(enforceCachePrefix(createCacheKeyWithNetwork(["balance"], chainId)));
}

/**
 @internal
 */
const cacheKeys = {
  auth: {
    user: () => enforceCachePrefix(["user"])
  },
  network: {
    active: chainId => enforceCachePrefix(["chainId", chainId])
  },
  wallet: {
    balance: (chainId, walletAddress, tokenAddress) => enforceCachePrefix(createCacheKeyWithNetwork(enforceCachePrefix(["balance", {
      walletAddress,
      tokenAddress
    }]), chainId))
  },
  contract: {
    read: (contractAddress, fnIdentity) => createContractCacheKey(contractAddress, ["read", fnIdentity]),
    type: contractAddress => createContractCacheKey(contractAddress, ["contract-type"]),
    compilerMetadata: contractAddress => createContractCacheKey(contractAddress, ["publish-metadata"]),
    typeAndCompilerMetadata: contractAddress => createContractCacheKey(contractAddress, ["contract-type-and-metadata"]),
    metadata: contractAddress => createContractCacheKey(contractAddress, ["metadata"]),
    extractFunctions: contractAddress => createContractCacheKey(contractAddress, ["extractFunctions"]),
    call: (contractAddress, functionName, args, overrides) => createContractCacheKey(contractAddress, ["call", functionName, args, overrides]),
    accountFactory: {
      getAll: contractAddress => createContractCacheKey(contractAddress, ["accountFactory"]),
      isAccountDeployed: (contractAdress, admin) => createContractCacheKey(contractAdress, ["isAccountDeployed", admin]),
      getAllForAddress: (contractAdress, address) => createContractCacheKey(contractAdress, ["getAllForAddress", address])
    },
    account: {
      signers: contractAddress => createContractCacheKey(contractAddress, ["account", "signers"])
    },
    app: {
      get: contractAddress => createContractCacheKey(contractAddress, ["appURI"])
    },
    events: {
      getEvents: (contractAddress, eventName) => createContractCacheKey(contractAddress, ["events", "getEvents", {
        eventName
      }]),
      getAllEvents: contractAddress => createContractCacheKey(contractAddress, ["events", "getAllEvents"])
    },
    // specific contract types
    nft: {
      get: (contractAddress, tokenId) => createContractCacheKey(contractAddress, ["get", {
        tokenId
      }]),
      balanceOf: (contractAddress, owner, tokenId) => createContractCacheKey(contractAddress, ["balanceOf", {
        owner,
        tokenId
      }]),
      query: {
        all: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["query", "all", params] : ["query", "all"]),
        totalCirculatingSupply: (contractAddress, tokenId) => createContractCacheKey(contractAddress, ["query", "totalCirculatingSupply", tokenId ?? "0"]),
        totalCount: contractAddress => createContractCacheKey(contractAddress, ["query", "totalCount"]),
        owned: {
          all: (contractAddress, owner) => createContractCacheKey(contractAddress, ["query", "owned", "all", owner])
        }
      },
      sharedMetadata: {
        get: contractAddress => createContractCacheKey(contractAddress)
      },
      drop: {
        getAllUnclaimed: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllUnclaimed", params] : ["getAllUnclaimed"]),
        getAllClaimed: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllClaimed", params] : ["getAllClaimed"]),
        totalUnclaimedSupply: contractAddress => createContractCacheKey(contractAddress, ["totalUnclaimedSupply"]),
        totalClaimedSupply: contractAddress => createContractCacheKey(contractAddress, ["totalClaimedSupply"]),
        revealer: {
          getBatchesToReveal: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getBatchesToReveal", params] : ["getBatchesToReveal"])
        }
      }
    },
    token: {
      totalSupply: contractAddress => createContractCacheKey(contractAddress, ["totalSupply"]),
      decimals: contractAddress => createContractCacheKey(contractAddress, ["decimals"]),
      balanceOf: (contractAddress, walletAddress) => createContractCacheKey(contractAddress, ["balanceOf", {
        walletAddress
      }])
    },
    marketplace: {
      getListing: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["getListing", {
        listingId
      }]),
      getAllListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllListings", params] : ["getAllListings"]),
      getTotalCount: contractAddress => createContractCacheKey(contractAddress, ["getTotalCount"]),
      getActiveListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getActiveListings", params] : ["getActiveListings"]),
      auction: {
        getBidBufferBps: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getBidBufferBps", {
          listingId
        }]),
        getWinningBid: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinningBid", {
          listingId
        }]),
        getMinimumNextBid: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getMinimumNextBid", {
          listingId
        }]),
        getWinner: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinner", {
          listingId
        }])
      },
      directListings: {
        getAll: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["directListings", "getAll", params] : ["directListings", "getAll"]),
        getAllValid: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["directListings", "getAllValid", params] : ["directListings", "getAllValid"]),
        getListing: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["directListings", "getListing", {
          listingId
        }]),
        getTotalCount: contractAddress => createContractCacheKey(contractAddress, ["directListings", "getTotalCount"])
      },
      englishAuctions: {
        getAll: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["englishAuctions", "getAll", params] : ["englishAuctions", "getAll"]),
        getAllValid: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["englishAuctions", "getAllValid", params] : ["englishAuctions", "getAllValid"]),
        getAuction: (contractAddress, auctionId) => createContractCacheKey(contractAddress, ["englishAuctions", "getAuction", {
          auctionId
        }]),
        getWinningBid: (contractAddress, auctionId) => createContractCacheKey(contractAddress, ["englishAuctions", "getWinningBid", {
          auctionId
        }]),
        getTotalCount: contractAddress => createContractCacheKey(contractAddress, ["englishAuctions", "getTotalCount"])
      }
    }
  },
  // extensions
  extensions: {
    claimConditions: {
      getActive: (contractAddress, tokenId, options) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getActive", {
        tokenId
      }, options] : ["claimConditions", "getActive", options]),
      getAll: (contractAddress, tokenId, options) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getAll", {
        tokenId
      }, options] : ["claimConditions", "getAll", options]),
      getClaimerProofs: (contractAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getClaimerProofs", {
        tokenId
      }] : ["claimConditions", "getClaimerProofs"]),
      getClaimIneligibilityReasons: (contractAddress, params, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getIneligibilityReasons", {
        tokenId
      }, params] : ["claimConditions", "getIneligibilityReasons", params]),
      // combinations of queries cache keys
      useActiveClaimConditionForWallet: (contractAddress, walletAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "useActiveClaimConditionForWallet", {
        tokenId,
        walletAddress
      },,] : ["claimConditions", "getIneligibilityReasons", {
        walletAddress
      }])
    },
    // primary sale contracts
    sales: {
      getRecipient: contractAddress => createContractCacheKey(contractAddress, ["sales"])
    },
    // royalties
    royalties: {
      getDefaultRoyaltyInfo: contractAddress => createContractCacheKey(contractAddress, ["royalties"])
    },
    // platform fees
    platformFees: {
      get: contractAddress => createContractCacheKey(contractAddress, ["platformFees"])
    },
    // contract metadata
    metadata: {
      get: contractAddress => createContractCacheKey(contractAddress, ["metadata"])
    },
    roles: {
      getAll: contractAddress => createContractCacheKey(contractAddress, ["roles"]),
      get: (contractAddress, role) => createContractCacheKey(contractAddress, ["roles", {
        role
      }])
    }
  }
};

/**
 * Hook for signing out of a wallet after a user has logged in using `useLogin`
 *
 * @example
 * ```jsx
 * import { useLogout } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { logout, isLoading } = useLogout();
 *
 *   return (
 *     <button onClick={() => logout()}>
 *       {isLoading ? "Logging out..." : "Logout"}
 *     </button>
 *   );
 * }
 * ```
 *
 * @returns object containing a `logout` function and an `isLoading` state that indicates if the logout request is in progress
 *
 * @auth
 */
function useLogout() {
  const queryClient = reactQuery.useQueryClient();
  const authConfig = useThirdwebAuthContext();
  const logout = reactQuery.useMutation({
    mutationFn: async () => {
      invariant__default["default"](authConfig, "Please specify an authConfig in the ThirdwebProvider");
      invariant__default["default"](authConfig.authUrl, "Please specify an authUrl in the authConfig.");
      await fetch(`${authConfig.authUrl}/logout`, {
        method: "POST",
        credentials: "include"
      });
      authConfig.secureStorage?.removeItem(AUTH_TOKEN_STORAGE_KEY);
      queryClient.invalidateQueries(cacheKeys.auth.user());
    }
  });
  return {
    logout: logout.mutateAsync,
    isLoading: logout.isLoading
  };
}

/**
 * Hook to switch the account of the active wallet
 *
 * @example
 * ```ts
 * const { switchAccount, isLoading } = useSwitchAccount();
 *
 * const handleSwitchAccount = async (address: string) => {
 *  await switchAccount(address);
 * }
 * ```
 *
 * @returns A function to invoke to switch account and a boolean to indicate if it is in progress
 *
 * @auth
 */
function useSwitchAccount() {
  const queryClient = reactQuery.useQueryClient();
  const authConfig = useThirdwebAuthContext();
  const switchAccount = reactQuery.useMutation({
    mutationFn: async address => {
      invariant__default["default"](authConfig, "Please specify an authConfig in the ThirdwebProvider");
      invariant__default["default"](authConfig.authUrl, "Please specify an authUrl in the authConfig.");
      await fetch(`${authConfig.authUrl}/switch-account`, {
        method: "POST",
        credentials: "include",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          address
        })
      });
      queryClient.invalidateQueries(cacheKeys.auth.user());
    }
  });
  return {
    switchAccount: switchAccount.mutateAsync,
    isLoading: switchAccount.isLoading
  };
}

const ThirdwebAuthProvider = _ref => {
  let {
    value,
    children
  } = _ref;
  // Remove trailing slash from URL if present
  const authContext = react.useMemo(() => {
    if (!value) {
      return undefined;
    }
    const context = {
      ...value,
      authUrl: value.authUrl?.replace(/\/$/, "")
    };
    return context;
  }, [value]);
  return /*#__PURE__*/jsxRuntime.jsxs(ThirdwebAuthContext.Provider, {
    value: authContext,
    children: [children, /*#__PURE__*/jsxRuntime.jsx(ChangeActiveWalletOnAccountSwitch, {})]
  });
};
function ChangeActiveWalletOnAccountSwitch() {
  const wallet = useWallet();
  const {
    logout
  } = useLogout();
  const {
    switchAccount
  } = useSwitchAccount();
  const authConfig = useThirdwebAuthContext();
  const queryClient = reactQuery.useQueryClient();

  // When active wallet switches, switch the active account cookie and invalidate user query
  react.useEffect(() => {
    const handleSwitchAccount = async data => {
      if (!data.address) {
        return;
      }
      try {
        await switchAccount(data.address);
      } catch (err) {
        console.debug(`[Auth] Failed to switch account to ${data.address} with error:\n`, err);
      }
    };
    const handleLogout = async () => {
      try {
        await logout();
      } catch (err) {
        console.debug(`[Auth] Failed to logout with error:\n`, err);
      }
    };
    const shouldAddListener = !!wallet && authConfig && authConfig.authUrl;
    if (shouldAddListener) {
      wallet.addListener("connect", handleSwitchAccount);
      wallet.addListener("change", handleSwitchAccount);
      wallet.addListener("disconnect", handleLogout);
    }
    return () => {
      if (shouldAddListener) {
        wallet.removeListener("connect", handleSwitchAccount);
        wallet.removeListener("change", handleSwitchAccount);
        wallet.removeListener("disconnect", handleLogout);
      }
    };
  }, [wallet, queryClient, authConfig, logout, switchAccount]);
  return null;
}

function useUpdateChainsWithClientId(supportedChains, activeChain, clientId) {
  const supportedChainsWithKey = react.useMemo(() => {
    return supportedChains.map(chain => chains.updateChainRPCs(chain, clientId));
  }, [supportedChains, clientId]);
  const activeChainIdOrObjWithKey = react.useMemo(() => {
    if (!activeChain || typeof activeChain === "string" || typeof activeChain === "number") {
      return activeChain;
    }
    return chains.updateChainRPCs(activeChain, clientId);
  }, [activeChain, clientId]);
  return [supportedChainsWithKey, activeChainIdOrObjWithKey];
}

const QueryClientProviderWithDefault = _ref => {
  let {
    queryClient,
    children
  } = _ref;
  const queryClientWithDefault = react.useMemo(() => {
    return queryClient ? queryClient : new reactQuery.QueryClient();
  }, [queryClient]);
  return /*#__PURE__*/jsxRuntime.jsx(reactQuery.QueryClientProvider, {
    client: queryClientWithDefault,
    children: children
  });
};

const ThirdwebConfigContext = /* @__PURE__ */react.createContext(undefined);

/**
 * @internal
 */
const ThirdwebConfigProvider = _ref => {
  let {
    value,
    children
  } = _ref;
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebConfigContext.Provider, {
    value: value,
    children: children
  });
};

/**
 * @internal
 */
function useThirdwebConfigContext() {
  const context = react.useContext(ThirdwebConfigContext);
  invariant__default["default"](context, "useThirdwebConfigContext() hook must be used within a <ThirdwebProvider/>");
  return context;
}

const ThirdwebSDKContext = /* @__PURE__ */react.createContext({});

/** @internal */
// eslint-disable-next-line turbo/no-undeclared-env-vars, better-tree-shaking/no-top-level-side-effects
const __DEV__ =         "production" !== "production";

/**
 * @internal
 */
function useSDKContext() {
  const ctx = react.useContext(ThirdwebSDKContext);
  invariant__default["default"](ctx._inProvider, "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?");
  return ctx;
}

/**
 * Hook to get the instance of the `ThirdwebSDK` class being used by the `ThirdwebProvider` component.
 *
 * This gives access to all of the functionality of the TypeScript SDK in your React app.
 *
 * - If there is a connected wallet, the SDK is instantiated from the connected wallet’s signer. Meaning all transactions are initiated from the connected wallet.
 * - If there is no connected wallet, the SDK is in read-only mode on the activeChain.
 *
 * @example
 * ```tsx
 * import { useSDK } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const sdk = useSDK();
 *
 *   // Now you use all of the TypeScript SDK functionality
 *   // For example, deploy a new contract from the connected wallet.
 *   async function deployContract() {
 *     sdk?.deployer.deployNFTDrop({
 *       name: "My NFT Drop",
 *       primary_sale_recipient: "{{wallet_address}}",
 *     });
 *   }
 * }
 * ```
 */
function useSDK() {
  const {
    sdk
  } = useSDKContext();
  return sdk;
}

/**
 * @internal
 */
function useSDKChainId() {
  const sdk = useSDK();
  return sdk?._chainId;
}

const INITIAL_CONTEXT_VALUE = {
  wallet: undefined,
  address: undefined,
  chainId: undefined,
  signer: undefined
};
const ThirdwebConnectedWalletContext = /* @__PURE__ */react.createContext(undefined);

/**
 * @internal
 */
const ThirdwebConnectedWalletProvider = _ref => {
  let {
    signer,
    children
  } = _ref;
  const {
    chains: chains$1,
    clientId
  } = useThirdwebConfigContext();
  const storage = useSDK()?.storage;
  const [contextValue, setContextValue] = react.useState({
    ...INITIAL_CONTEXT_VALUE,
    signer: signer ? signer : undefined
  });
  react.useEffect(() => {
    setContextValue(val => ({
      ...val,
      signer: signer ? signer : undefined
    }));
  }, [signer]);
  react.useEffect(() => {
    if (!storage) {
      return;
    }
    let s = signer;
    if (signer) {
      // just get both of these up front and keep them around with the context
      Promise.all([signer.getAddress(), signer.getChainId()]).then(_ref2 => {
        let [address, chainId] = _ref2;
        const chain = chains$1.find(c => c.chainId === chainId);
        let rpcUrl = undefined;
        if (chain) {
          try {
            rpcUrl = chains.getValidChainRPCs(chain, clientId)[0];
          } catch (e) {
            // failed to get a viable rpc url, nothing we can do
            console.error(e);
          }
        }

        // only if the signer is still the same!
        if (signer === s) {
          const wallet = new sdk.UserWallet(signer, {
            readonlySettings: rpcUrl ? {
              rpcUrl,
              chainId
            } : undefined
          }, storage);
          setContextValue({
            wallet,
            address,
            chainId,
            signer
          });
        }
      }).catch(err => {
      });
    } else {
      // if signer is not provided, re-set the context value to initial values
      setContextValue(INITIAL_CONTEXT_VALUE);
    }
    return () => {
      // set the previous signer to undefined because it is invalid now
      s = undefined;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [signer, clientId]);
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebConnectedWalletContext.Provider, {
    value: contextValue,
    children: children
  });
};

/**
 *
 * @internal
 */
function useThirdwebConnectedWalletContext() {
  const context = react.useContext(ThirdwebConnectedWalletContext);
  invariant__default["default"](context, "useThirdwebConnectedWalletContext() hook must be used within a <ThirdwebProvider/>");
  return context;
}

const WrappedThirdwebSDKProvider = _ref => {
  let {
    sdkOptions = {},
    storageInterface,
    supportedChains,
    activeChain,
    signer,
    children,
    clientId,
    secretKey
  } = _ref;
  const activeChainId = react.useMemo(() => {
    if (!activeChain) {
      return supportedChains[0]?.chainId;
    }
    if (typeof activeChain === "number") {
      return activeChain;
    }
    if (typeof activeChain === "string") {
      return supportedChains.find(c => c.slug === activeChain)?.chainId;
    }
    return activeChain.chainId;
  }, [activeChain, supportedChains]);
  const sdk = react.useMemo(() => {
    // on the server we can't do anything (?)
    if (typeof window === "undefined") {
      return undefined;
    }
    let chainId = activeChainId;
    const supportedChain = supportedChains.find(c => c.chainId === chainId);
    if (!supportedChain && chainId !== undefined) {
      console.warn(`The chainId ${chainId} is not in the configured chains, please add it to the ThirdwebProvider`);
      // reset the chainId as to not trigger an error in the sdk constructor
      chainId = undefined;
    }
    let readonlySettings = undefined;
    if (supportedChain && supportedChain.rpc.length > 0) {
      try {
        const rpcUrl = chains.getValidChainRPCs(supportedChain, clientId)[0];
        readonlySettings = {
          chainId: supportedChain.chainId,
          rpcUrl
        };
      } catch (e) {
        // no-op
      }
    }

    // TODO: find a better way to fix the type error

    const mergedOptions = {
      readonlySettings,
      ...sdkOptions,
      supportedChains: supportedChains
    };
    let sdk_ = undefined;
    if (chainId) {
      // sdk from chainId
      sdk_ = new evm.ThirdwebSDK(chainId, {
        ...mergedOptions,
        clientId,
        secretKey
      }, storageInterface);
    }
    // if we still have no sdk fall back to the first element in chains
    if (!sdk_) {
      if (supportedChains.length > 0) {
        chainId = supportedChains[0].chainId;
        sdk_ = new evm.ThirdwebSDK(chainId, mergedOptions, storageInterface);
      } else {
        console.error("No chains configured, please pass a chain or chains to the ThirdwebProvider");
        return undefined;
      }
    }

    // set the chainId on the sdk instance to compare things later
    sdk_._chainId = chainId;
    return sdk_;
  }, [activeChainId, supportedChains, sdkOptions, storageInterface, clientId, secretKey]);
  react.useEffect(() => {
    // if we have an sdk and a signer update the signer
    if (sdk && sdk._chainId === activeChainId) {
      if (signer) {
        sdk.updateSignerOrProvider(signer);
      } else if (activeChainId) {
        sdk.updateSignerOrProvider(activeChainId);
      }
    }
    // we know what we're doing
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sdk, sdk?._chainId, signer, activeChainId]);
  const ctxValue = react.useMemo(() => ({
    sdk: sdk && sdk._chainId === activeChainId ? sdk : undefined,
    _inProvider: true
  }), [activeChainId, sdk]);
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebSDKContext.Provider, {
    value: ctxValue,
    children: children
  });
};

/**
 * The `ThirdwebSDKProvider` is used when you want to provide your own wallet connection logic and just use the thirdweb SDK to interact with smart contracts and the blockchain.
 * This means you can use everything in the SDK except for wallet connection-related components and hooks. if you need those please use the `ThirdwebProvider` instead.
 *
 * `ThirdwebSDKProvider` allows you to set a provider & signer to the Thirdweb SDK.
 *
 * @example
 * Wrap your app in the ThirdwebSDKProvider to access the SDK’s functionality from anywhere in your app.
 *
 * ```tsx
 * import { ThirdwebSDKProvider } from "@thirdweb-dev/react";
 * import { ethers } from "ethers";
 *
 * // Example shows how to get the signer from the injected provider ( wallet extension )
 * function Example() {
 *  return (
 *    <ThirdwebSDKProvider
 *      activeChain="ethereum"
 *      clientId="YOUR_CLIENT_ID"
 *      signer={new ethers.providers.Web3Provider(window.ethereum).getSigner()}
 *    >
 *      <App />
 *    </ThirdwebSDKProvider>
 *  )
 * }
 * ```
 *
 * @param props -
 * The props for the ThirdwebSDKProvider component
 *
 * ### clientId (optional)
 * The clientId prop is required to use the thirdweb infrastructure services with the SDK.
 *
 * ### activeChain (optional)
 * The activeChain prop determines which chain you want your app to be operating on.
 *
 * There are 1000+ chains available in the `@thirdweb-dev/chains` package. Import the chain you want and pass it to the `activeChain` prop.
 *
 * You can override the imported object or pass a custom chain object with required properties.
 *
 * You can get a client ID by creating an API key on [thirdweb dashboard](https://thirdweb.com/dashboard/settings/api-keys)
 *
 * ### supportedChains (optional)
 * An array of chains supported by your app.
 * There are 1000+ chains available in the `@thirdweb-dev/chains` package. You can import the chain you want and pass it to the `supportedChains` prop in an array.
 *
 * If not provided, it will default to the default supported chains supported by the thirdweb SDK.
 *
 * ```tsx
 * import { Ethereum, Polygon } from "@thirdweb-dev/chains";
 *
 * function Example() {
 *  return (
 *    <ThirdwebSDKProvider supportedChains={[ Ethereum, Polygon ]} activeChain={Ethereum}>
 *       <App />
 *    </ThirdwebSDKProvider>
 *  )
 * }
 * ```
 *
 * ### signer (optional)
 * A signer is an abstraction of an Ethereum Account, which can be used to sign messages and initiate transactions.
 *
 * Since the ThirdwebSDKProvider is used when you want to provide your own wallet connection logic, you will need to provide a signer prop to inform the SDK of the wallet you want to use to sign transactions.
 *
 * Libraries such as ethers.js, web3.js, wagmi, etc. all provide ways to get a signer.
 *
 * To use this signer with the SDK, pass it to the `signer` prop. If the signer is connected, the SDK will use this wallet to sign transactions for all write operations on the blockchain.
 *
 * ### sdkOptions (optional)
 * The thirdweb SDK Options to pass to the thirdweb SDK which includes Gas settings, gasless transactions, RPC configuration, and more.
 *
 * This Overrides any of the default values for the SDK. If not provided, it uses sensible defaults.
 *
 * ### storageInterface (optional)
 * Override the default [Storage](https://portal.thirdweb.com/infrastructure/storage/overview) interface used by the SDK.
 *
 * It allows you to create an instance of `ThirdwebStorage` with your own customized config, and pass it to the SDK.
 *
 * *This requires the `@thirdweb-dev/storage` package to be installed.*
 *
 * ```tsx
 * import { ThirdwebSDKProvider } from "@thirdweb-dev/react";
 * import {
 *   ThirdwebStorage,
 *   StorageDownloader,
 *   IpfsUploader,
 * } from "@thirdweb-dev/storage";
 *
 * // Configure a custom ThirdwebStorage instance
 * const gatewayUrls = {
 *   "ipfs://": [
 *     "https://gateway.ipfscdn.io/ipfs/",
 *     "https://cloudflare-ipfs.com/ipfs/",
 *     "https://ipfs.io/ipfs/",
 *   ],
 * };
 * const downloader = new StorageDownloader();
 * const uploader = new IpfsUploader();
 * const storage = new ThirdwebStorage({ uploader, downloader, gatewayUrls });
 *
 * // Provide the custom storage instance to the SDK
 * function MyApp() {
 *   return (
 *     <ThirdwebSDKProvider
 *       storageInterface={storage}
 *     >
 *       <YourApp />
 *     </ThirdwebSDKProvider>
 *   );
 * }
 * ```
 *
 * ### authConfig (optional)
 * The configuration object for setting up [Auth](https://portal.thirdweb.com/wallets/auth); allowing users to sign in with their wallet.
 *
 * ### secretKey (optional)
 * secretKey for thirdweb services. This is only required if server side rendering is being used.
 *
 * @public
 */
const ThirdwebSDKProvider = props => {
  const {
    signer,
    children,
    queryClient,
    supportedChains: _supportedChains,
    activeChain,
    clientId,
    ...restProps
  } = props;
  if (!clientId) {
    sdk.checkClientIdOrSecretKey("No API key. Please provide a clientId. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key", clientId, undefined);
  }
  const supportedChains = _supportedChains || chains.defaultChains;
  const supportedChainsNonNull = react.useMemo(() => {
    const isActiveChainObject = typeof activeChain === "object" && activeChain !== null;
    if (!isActiveChainObject) {
      return supportedChains;
    }
    const isActiveChainInSupportedChains = supportedChains.find(c => c.chainId === activeChain.chainId);

    // if activeChain is not in supportedChains - add it
    if (!isActiveChainInSupportedChains) {
      return [...supportedChains, activeChain];
    }

    // if active chain is in supportedChains - replace it with object in activeChain
    return supportedChains.map(c => c.chainId === activeChain.chainId ? activeChain : c);
  }, [supportedChains, activeChain]);
  const [supportedChainsWithKey, activeChainIdOrObjWithKey] = useUpdateChainsWithClientId(supportedChainsNonNull, activeChain || supportedChainsNonNull[0], clientId);
  const mergedChains = react.useMemo(() => {
    if (!activeChainIdOrObjWithKey || typeof activeChainIdOrObjWithKey === "string" || typeof activeChainIdOrObjWithKey === "number") {
      return supportedChainsWithKey;
    }
    const _mergedChains = [...supportedChainsWithKey.filter(c => c.chainId !== activeChainIdOrObjWithKey.chainId), activeChainIdOrObjWithKey];
    // return a _mergedChains uniqued by chainId key
    return _mergedChains.filter((chain, index, self) => index === self.findIndex(c => c.chainId === chain.chainId));
  }, [supportedChainsWithKey, activeChainIdOrObjWithKey]);
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebConfigProvider, {
    value: {
      chains: mergedChains,
      clientId
    },
    children: /*#__PURE__*/jsxRuntime.jsx(QueryClientProviderWithDefault, {
      queryClient: queryClient,
      children: /*#__PURE__*/jsxRuntime.jsx(WrappedThirdwebSDKProvider, {
        signer: signer,
        supportedChains: mergedChains,
        clientId: clientId,
        activeChain: activeChainIdOrObjWithKey,
        ...restProps,
        children: /*#__PURE__*/jsxRuntime.jsx(ThirdwebConnectedWalletProvider, {
          signer: signer,
          children: children
        })
      })
    })
  });
};

/**
 * @internal
 */
const ThirdwebProviderCore = props => {
  const {
    activeChain,
    createWalletStorage = wallets.createAsyncLocalStorage
  } = props;
  const supportedChains = props.supportedChains || chains.defaultChains;
  const supportedChainsNonNull = react.useMemo(() => {
    const isActiveChainObject = typeof activeChain === "object" && activeChain !== null;
    if (!isActiveChainObject) {
      return supportedChains;
    }
    const isActiveChainInSupportedChains = supportedChains.find(c => c.chainId === activeChain.chainId);

    // if activeChain is not in supportedChains - add it
    if (!isActiveChainInSupportedChains) {
      return [...supportedChains, activeChain];
    }

    // if active chain is in supportedChains - replace it with object in activeChain
    return supportedChains.map(c => c.chainId === activeChain.chainId ? activeChain : c);
  }, [supportedChains, activeChain]);
  const [supportedChainsWithKey, activeChainIdOrObjWithKey] = useUpdateChainsWithClientId(supportedChainsNonNull, props.activeChain || supportedChainsNonNull[0], props.clientId);
  const activeChainWithKey = react.useMemo(() => {
    if (typeof activeChainIdOrObjWithKey === "number") {
      const resolveChain = supportedChainsWithKey.find(chain => chain.chainId === activeChainIdOrObjWithKey);
      if (!resolveChain) {
        throw new Error(`Invalid chainId: ${activeChainIdOrObjWithKey}. It is not one of supportedChains`);
      }
      return resolveChain;
    }
    if (typeof activeChainIdOrObjWithKey === "string") {
      const resolvedChain = supportedChainsWithKey.find(chain => chain.slug === activeChainIdOrObjWithKey);
      if (!resolvedChain) {
        throw new Error(`Invalid chain: "${activeChainIdOrObjWithKey}". It is not one of supportedChains`);
      }
      return resolvedChain;
    }
    return activeChainIdOrObjWithKey;
  }, [activeChainIdOrObjWithKey, supportedChainsWithKey]);
  const dAppMeta = props.dAppMeta;
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebThemeContext.Provider, {
    value: props.theme,
    children: /*#__PURE__*/jsxRuntime.jsx(ThirdwebWalletProvider, {
      chains: supportedChainsWithKey,
      supportedWallets: props.supportedWallets,
      shouldAutoConnect: props.autoConnect,
      createWalletStorage: createWalletStorage,
      dAppMeta: dAppMeta,
      activeChain: activeChainWithKey,
      autoSwitch: props.autoSwitch,
      autoConnectTimeout: props.autoConnectTimeout,
      clientId: props.clientId,
      activeChainSetExplicitly: !!props.activeChain,
      signerWallet: props.signerWallet,
      children: /*#__PURE__*/jsxRuntime.jsx(ThirdwebSDKProviderWrapper, {
        queryClient: props.queryClient,
        sdkOptions: props.sdkOptions,
        supportedChains: supportedChainsWithKey,
        activeChain: activeChainWithKey,
        storageInterface: props.storageInterface,
        authConfig: props.authConfig,
        clientId: props.clientId,
        secretKey: props.secretKey,
        children: /*#__PURE__*/jsxRuntime.jsx(ThirdwebAuthProvider, {
          value: props.authConfig,
          children: props.children
        })
      })
    })
  });
};
const ThirdwebSDKProviderWrapper = _ref => {
  let {
    children,
    ...props
  } = _ref;
  const signer = useWalletContext()?.signer;
  return /*#__PURE__*/jsxRuntime.jsx(ThirdwebSDKProvider, {
    signer: signer,
    ...props,
    children: children
  });
};

/**
 * Hook to get the `supportedChains` which returns the array passed to the `supportedChains` prop of the `ThirdwebProvider` or the default supported chains if not specified.
 *
 * If `activeChain` is set in the `ThirdwebProvider` then it is also added to the `supportedChains` array
 *
 */
function useSupportedChains() {
  const context = react.useContext(ThirdwebConfigContext);
  invariant__default["default"](context, "useSupportedChains() hook must be used within a <ThirdwebProvider/>");
  return context.chains;
}

/**
 * Hook for getting a wallet's current balance of native or (optional) ERC20 token balance
 *
 * @example
 *
 * ### get the balance of the native token
 *
 * ```jsx
 * import { useBalance } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { data, isLoading } = useBalance();
 * }
 * ```
 *
 * ### get the balance of any other token
 *
 * ```jsx
 * import { useBalance } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { data, isLoading } = useBalance(tokenAddress);
 * }
 * ```
 *
 * @param tokenAddress - The address of the token contract, if not provided, it defaults to the native token
 *
 * @returns
 * The hook's `data` property contains the token's balance in the `value` property as a `BigNumber` object.
 *
 * @token
 */
function useBalance(tokenAddress) {
  const walletAddress = useAddress();
  const {
    wallet,
    address,
    chainId
  } = useThirdwebConnectedWalletContext();
  const cacheKey = react.useMemo(() => {
    return cacheKeys.wallet.balance(chainId || -1, address, tokenAddress);
  }, [chainId, tokenAddress, address]);
  return reactQuery.useQuery(cacheKey, () => {
    return wallet?.balance(tokenAddress);
  }, {
    // if user is not logged in no reason to try to fetch
    enabled: !!wallet && !!walletAddress && !!chainId,
    retry: true,
    keepPreviousData: false
  });
}

/**
 * This hook is similar to the `useBalance` hook, but it for fetching the native token balance of any given wallet address.
 *
 * This hook only fetches the native token balance of the given wallet address. If you want to get the ERC20 balance from a given wallet, use `useTokenBalance`
 *
 * @example
 * ```ts
 * const { data, isLoading } = useBalanceForAddress(walletAddress)
 * ```
 *
 * @param walletAddress - The address of the wallet that you want to get the native balance
 *
 * @returns
 * The hook's `data` property contains the native token's balance in the `value` property as a `BigNumber` object.
 *
 * @token
 */
function useBalanceForAddress(walletAddress) {
  invariant__default["default"](walletAddress, "wallet address is not provided");
  const {
    activeChain
  } = useWalletContext();
  const chainId = activeChain.chainId;
  const sdk = useSDK();
  const cacheKey = react.useMemo(() => {
    return cacheKeys.wallet.balance(chainId, walletAddress);
  }, [chainId, walletAddress]);
  return reactQuery.useQuery(cacheKey, async () => {
    invariant__default["default"](sdk, "SDK is not initialized");
    return await sdk.getBalance(walletAddress);
  });
}

/**
 * @internal
 */
function useConnectedWallet() {
  const context = react.useContext(ThirdwebConnectedWalletContext);
  invariant__default["default"](context, "useConnectedWallet() hook must be used within a <ThirdwebProvider/>");
  return context.signer;
}

/**
 * Get the address of the connected wallet.
 *
 * Returns `undefined` if no wallet is connected.
 *
 * @example
 * ```tsx
 * import { useAddress } from "@thirdweb-dev/react"
 *
 * function Example() {
 *   const address = useAddress()
 *
 *   return <div>{address}</div>
 * }
 * ```
 *
 * @walletConnection
 */
function useAddress() {
  const context = react.useContext(ThirdwebConnectedWalletContext);
  const walletCtx = react.useContext(ThirdwebWalletContext);

  // if ThirdwebWalletContext is present, use the address from there because address from ThirdwebConnectedWalletContext also uses that address but it lags behind
  // walletCtx is undefined if only ThirdwebSDKProvider is used
  if (walletCtx) {
    return walletCtx.address;
  }
  invariant__default["default"](context, "useAddress() hook must be used within a <ThirdwebProvider/>");
  return context.address;
}

/**
 * Hook for accessing the chain ID of the network the current wallet is connected to
 *
 * ```javascript
 * import { useChainId } from "@thirdweb-dev/react"
 * ```
 *
 * @example
 * ```javascript
 * import { useChainId } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const chainId = useChainId()
 *
 *   return <div>{chainId}</div>
 * }
 * ```
 *
 * @returns
 * A `number` representing the current chain id, or `undefined` if the user is not connected to a wallet.
 *
 * For Example, if the user is connected to the Ethereum Mainnet, the return value will be `1`.
 *
 * @networkConnection
 */
function useChainId() {
  const context = react.useContext(ThirdwebConnectedWalletContext);
  const walletCtx = react.useContext(ThirdwebWalletContext);

  // if ThirdwebWalletContext is present, use the chainId from there because chainId from ThirdwebConnectedWalletContext also uses that chainId but it lags behind
  // walletCtx is undefined if only ThirdwebSDKProvider is used
  if (walletCtx) {
    return walletCtx.chainId;
  }
  invariant__default["default"](context, "useChainId() hook must be used within a <ThirdwebProvider/> or <ThirdwebSDKProvider/> component");
  return context.chainId;
}

/**
 * Hook for getting the `Chain` object of the network that the user is connected - but only if
 * it's a supported network (added in the `ThirdwebProvider`'s `supportedChains` or one of default chains
 *
 * Returns `undefined` if the network is not supported or the user is not connected to a wallet. You can use the `useConnectionStatus` hook to check if the user is connected to a wallet or not to differentiate between the two cases.
 *
 * If you only want to get the chain id of the network the user is connected to regardless of whether it's supported or not, use `useChainId` instead.
 *
 * ```jsx
 * import { useChain } from "@thirdweb-dev/react";
 *
 * const chain = useChain();
 * ```
 *
 * @example
 *
 * ```jsx
 * import { useChain, useConnectionStatus } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const chain = useChain();
 *   const status = useConnectionStatus();
 *
 *   if (status === "unknown") return <div> Loading... </div>;
 *   if (status === "disconnected") return <div> disconnected </div>;
 *   if (status === "connecting") return <div> connecting... </div>;
 *
 *   if (chain) {
 *     return <p> Connected to {chain.name} </p>;
 *   }
 *
 *   return <p> Connected to an unsupported network </p>;
 * }
 * ```
 *
 * @returns
 * An object of type `Chain` from [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package containing various information about the network, or `undefined` if the network is not supported or user is not connected to a wallet.
 *
 * @networkConnection
 */
function useChain() {
  const chainId = useChainId();
  const chains$1 = useSupportedChains();
  const chain = react.useMemo(() => {
    return chains$1.find(_chain => _chain.chainId === chainId);
  }, [chainId, chains$1]);
  const unknownChain = react.useMemo(() => {
    if (!chain) {
      return chains.defaultChains.find(c => c.chainId === chainId);
    }
  }, [chainId, chain]);
  return chain || unknownChain;
}

/**
 * @internal
 * @deprecated
 *
 * This hook is renamed to `useChain`
 *
 * use the `useChain` hook instead
 */
function useActiveChain() {
  return useChain();
}

// this hook is only for backwards compatibility

/**
 *
 *
 * Hook for getting metadata about the network the current wallet is connected to and switching networks
 *
 * It's important to note that some wallet apps do not support programmatic network switching and switchNetwork will be undefined.
 * For those situations, you can typically switch networks in the wallet app this hook will still work.
 *
 * Hook for getting information about the current network and switching to a different network.
 *
 * Returns an array value containing two elements.
 *
 * 1. An object containing the following properties:
 *
 *    - `data` object contains information about the wallet's current and supported networks.
 *    - `loading` indicates if the switch network request is in progress.
 *    - `error` holds the `Error` object if there was an error when attempting to switch network.
 *
 * 2. A function to switch to a different network.
 *
 * @example
 * ```javascript
 * import { useNetwork } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const [{ data, error, loading }, switchNetwork] = useNetwork();
 *
 *   return (
 *     <button
 *       onClick={async () => {
 *         if (!switchNetwork) {
 *           console.log("can not switch network");
 *           return;
 *         }
 *
 *         const result = await switchNetwork(80001);
 *         if (result.data) {
 *           console.log("Switched to Mumbai testnet successfully");
 *         } else {
 *           console.log("Error switching to Mumbai testnet", result.error);
 *         }
 *       }}
 *     >
 *       Switch to Mumbai
 *     </button>
 *   );
 * }
 * ```
 *
 * @returns
 *
 * ```ts
 * const [{ data, error, loading }, switchNetwork] = useNetwork();
 * ```
 * #### data
 *
 * If wallet is connected to a network that is one of `supportedChains` provided in `ThirdwebProvider` or one of the default supported chains, `data` object will contain the following:
 *
 * ```ts
 * {
 *   chain: Chain; // The connected network
 *   chains: Chain[]; // All supported networks
 * }
 * ```
 *
 * If wallet is connected to a network that is NOT one of `supportedChains` provided in `ThirdwebProvider` or default supported, `data` object will contain the following:
 *
 * ```ts
 * {
 *   // chainId of current connected network + unsupported flag
 *   chain: { chainId: number, unsupported: true };
 *   // All supported networks
 *   chains: Chain[];
 * }
 * ```
 *
 * If wallet is not connected, `data` object will contain the following:
 *
 * ```ts
 * {
 *   chain: undefined;
 *   chains: []; // Empty array
 * }
 * ```
 *
 * #### error
 *
 * `error` contains an `Error` object if there was an error when attempting to switch network using the `switchNetwork` function
 *
 * `undefined` if there is no switch network error
 *
 * ```ts
 * Error | undefined;
 * ```
 *
 * #### loading
 *
 * `loading` is `true` when switching network using the `switchNetwork` function, and `false` otherwise.
 *
 *
 * #### switchNetwork
 *
 * `switchNetwork` is a function to switch to a different network. It takes a `chainId` as an argument and returns a promise that resolves to an object containing `data` and `error` properties.
 *
 * If switching network was successful, `data` will contain the new network information. and `error` will be `undefined`. If switching network failed, `data` will be `undefined` and `error` will contain an `Error` object.
 *
 * `switchNetwork` is `undefined` if not connected to a wallet or if the connected wallet does not allow programmatic switching.
 *
 * ```ts
 * type SwitchNetwork = undefined | (chainId: number) => Promise<
 *   | {
 *       data: Chain | undefined;
 *       error: undefined;
 *     }
 *   | {
 *       data: undefined;
 *       error: Error;
 *     }>
 * ```
 *
 * @deprecated use `useChain`, `useSwitchChain`, `useChainId` instead
 * @internal
 */
function useNetwork() {
  const chain = useChain();
  const chainId = useChainId();
  const switchChain = useSwitchChain();
  const supportedChains = useSupportedChains();
  const wallet = useWallet();
  const isMetamaskInstalled = wallets.assertWindowEthereum(globalThis.window) ? globalThis.window.ethereum.isMetaMask : false;
  const isCoinbaseInstalled = wallets.assertWindowEthereum(globalThis.window) ? globalThis.window.ethereum.isCoinbaseWallet : false;

  // switch not supported if connected to a mobile wallet
  const switchChainNotSupported = !wallet || wallet.walletId === wallets.walletIds.walletConnectV1 || wallet.walletId === wallets.walletIds.walletConnect || wallet.walletId === wallets.walletIds.metamask && !isMetamaskInstalled || wallet.walletId === wallets.walletIds.coinbase && !isCoinbaseInstalled;

  // error when switching network
  const [error, setError] = react.useState(undefined);

  // loading: true when switching network
  const [loading, setLoading] = react.useState(false);
  const switchNetwork = react.useCallback(async _chainId => {
    // reset error and loading
    setLoading(true);
    setError(undefined);
    try {
      await switchChain(_chainId);
    } catch (e) {
      setError(e);
      setLoading(false);
      return {
        data: undefined,
        error: e
      };
    }
    setLoading(false);
    return {
      data: supportedChains.find(c => c.chainId === _chainId) || chains.defaultChains.find(c => c.chainId === _chainId),
      error: undefined
    };
  }, [switchChain, supportedChains]);
  return [{
    data: {
      chain: chainId === undefined ? undefined : chain || {
        chainId,
        unsupported: true
      },
      chains: wallet ? supportedChains : []
    },
    error: error,
    loading
  }, switchChainNotSupported ? undefined : switchNetwork];
}

/**
 * Hook for getting the address of the personal wallet connected to the current wallet connection.
 *
 * This is only relevant if the current connected wallet uses a personal wallet - For Example - Smart Wallet and Safe.
 * @walletConnection
 */
const usePersonalWalletAddress = () => {
  const [personalWalletAddress, setPersonalWalletAddress] = react.useState();
  const activeWallet = useWallet();
  react.useEffect(() => {
    (async () => {
      const possiblePersonalWallet = activeWallet?.getPersonalWallet();
      if (!possiblePersonalWallet) {
        setPersonalWalletAddress(undefined);
        return;
      }
      const address = await (await possiblePersonalWallet?.getSigner())?.getAddress();
      setPersonalWalletAddress(address);
    })();
  }, [activeWallet]);
  return personalWalletAddress;
};

// we prefix all our query keys with this to avoid possible collisions with user-defined queries that share the same query client
// marker to make sure the query will not get stored in local storage by a query persister
const NEVER_PERSIST_QUERY_POSTFIX = {
  persist: false
};
function neverPersist(key) {
  return [...key, NEVER_PERSIST_QUERY_POSTFIX];
}

/**
 * @internal
 */
function shouldNeverPersistQuery(key) {
  return key[key.length - 1] === NEVER_PERSIST_QUERY_POSTFIX;
}

/**
 * Makes a parameter required to be passed, but still allows it to be null or undefined.
 * @internal
 */

function requiredParamInvariant(condition, message) {
  invariant__default["default"](condition !== null || condition !== undefined, message);
}

/**
 * @internal
 */

/**
 * A wallet address.
 * @walletConnection
 */

/**
 * A contract address.
 */

/**
 * The parameters to pass to the mint and transfer functions.
 * @token
 */

/**
 * The parameters to pass to the burn function.
 * @token
 */

// NFTS //

/**
 * The possible NFT contract types.
 * @nft
 */

/**
 * The possible Token contract types.
 * @token
 */

/**
 * Possible NFT contract types.
 * @internal
 */

/**
 * The params to pass to `useTransferNFT`.
 * @nft
 */

/**
 * The params to pass to `useTransferBatchNFT`.
 * @nft
 */

/**
 * The params to pass to `useMintNFTSupply`.
 * @nft
 */

/**
 * The params for the `useMintNFT` hook mutation.
 * @nft
 */

/**
 * The return type of the `useMintNFT` hook.
 * @nft
 */

/**
 * The params for the `useBurnNFT` hook mutation.
 *
 * @nft
 */

// DROPS //

/**
 * The possible DROP contract types.
 * @nftDrop
 */

/**
 * The possible revealable contract types.
 * @delayedReveal
 */

/**
 * The params for the {@link useDelayedRevealLazyMint} hook mutation.
 * @delayedReveal
 */

/**
 * The params for the {@link useRevealLazyMint} hook mutation.
 * @delayedReveal
 */

/**
 * The params for the `useClaimNFT` hook mutation.
 * @nftDrop
 */

/**
 * The return type of the `useClaimNFT` hook.
 * @nftDrop
 */

// MARKETPLACE //

/**
 * @marketplace
 */

/**
 * @marketplace
 */

/**
 * @marketplace
 */

/**
 * @marketplace
 */

/**
 * @marketplace
 */

// TOKEN DROP //

/**
 * @token
 */

// Helpers

/**
 * @internal
 */
function getErcs(contract) {
  return {
    erc1155: getErc1155(contract),
    erc721: getErc721(contract),
    erc20: getErc20(contract)
  };
}

/**
 * @internal
 */
function getErc1155(contract) {
  if (!contract) {
    return undefined;
  }
  try {
    if ("erc1155" in contract) {
      return contract.erc1155;
    }
  } catch (error) {
    return undefined;
  }
  return undefined;
}

/**
 * @internal
 */
function getErc721(contract) {
  if (!contract) {
    return undefined;
  }
  try {
    if ("erc721" in contract) {
      return contract.erc721;
    }
  } catch (error) {
    return undefined;
  }
  return undefined;
}

/**
 * @internal
 */
function getErc20(contract) {
  if (!contract) {
    return undefined;
  }
  try {
    if ("erc20" in contract) {
      return contract.erc20;
    }
  } catch (error) {
    return undefined;
  }
  return undefined;
}

/** @internal */
function useQueryWithNetwork(queryKey, queryFn, options) {
  const activeChainId = useSDKChainId();
  const mergedOptions = {
    ...options,
    enabled: !!(activeChainId && options?.enabled)
  };
  return reactQuery.useQuery(createCacheKeyWithNetwork(queryKey, activeChainId), queryFn, mergedOptions);
}

/**
 * The options to be passed as the second parameter to the `useClaimIneligibilityReasons` hook.
 * @claimConditions
 */

/**
 * The params for the {@link useSetClaimConditions} hook mutation.
 * @claimConditions
 */

/** **********************/
/**     READ  HOOKS     **/
/** **********************/

/**
 * Hook for getting the active claim condition for a given drop contract.
 *
 * Available for contracts that implement the "ClaimConditions" interface;
 * such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * @example
 * ```javascript
 * import { useActiveClaimCondition, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useActiveClaimCondition(contract);
 * }
 * ```
 *
 * @param contract -
 * Instance of contract that implement the "ClaimConditions" interface;
 * such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * @param tokenId -
 * When using the hook with ERC1155 contracts such as the [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), pass the `tokenId` as the second parameter; as each token can have unique claim conditions.
 *
 * Pass `undefined`, or leave this field out if you are using ERC721 or ERC20 drop contracts.
 *
 * ```tsx
 * import { useActiveClaimCondition, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *
 *   // "data" now includes a "snapshot" property that contains the allowlist.
 *   const { data, isLoading, error } = useActiveClaimCondition(
 *     contract,
 *     0, // Token ID required for ERC1155 contracts here.
 *   );
 * }
 * ```
 *
 * @param options - Additional options to pass to the claim condition fetch
 *
 * #### withAllowlist
 *
 * By default, the hook will not include the allowlist or "snapshot" in the returned data. To include the allowlist in the returned data, pass `withAllowlist: true` in options object.
 *
 * This will add a snapshot property to the returned data, which contains the allowlist in an array.
 *
 * ```tsx
 * import { useActiveClaimCondition, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *
 *   // "data" now includes a "snapshot" property that contains the allowlist.
 *   const { data, isLoading, error } = useActiveClaimCondition(
 *     contract,
 *     undefined, // Token ID required for ERC1155 contracts here.
 *     {
 *       withAllowlist: true,
 *     },
 *   );
 * }
 * ```
 *
 * @returns A query result object with the currently active claim condition
 *
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 * @claimConditions
 */
function useActiveClaimCondition(contract, tokenId, options) {
  const contractAddress = contract?.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getActive(contractAddress, tokenId, options), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.getActive(tokenId, options);
    }
    if (erc721) {
      return erc721.claimConditions.getActive(options);
    }
    if (erc20) {
      return erc20.claimConditions.getActive(options);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== undefined : !!erc721 || !!erc20
  });
}

/**
 * Hook to get the claimer proofs for an address for [ERC20](https://portal.thirdweb.com/contracts/build/base-contracts/erc-20/drop), [ERC721](https://portal.thirdweb.com/contracts/build/base-contracts/erc-721/drop), and [ERC1155](https://portal.thirdweb.com/contracts/build/base-contracts/erc-1155/drop) drop contracts.
 *
 * A claimer proof is a set of data about a claimer's claim condition, including the claimer's address, the claimer's proof, and the claimer's max claimable amount, price, and currency address.
 *
 * This is available for available for contracts that implement the "ClaimConditions" interface; such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * @example
 * ```javascript
 * import { useClaimerProofs, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *
 *   const {
 *     data: proof,
 *     isLoading,
 *     error,
 *   } = useClaimerProofs(contract, "{{claimer_address}}");
 * }
 * ```
 *
 * @param contract -
 * Instance of a contract that extends the ERC721, ERC1155 or ERC20 spec and implements the "ClaimConditions" extension.
 *
 * @param claimerAddress -
 * This is the address of the user you want to get the proof for.
 *
 * Likely, you will want to check proofs of the currently connected wallet address. You can use the `useAddress` hook to get this value.
 *
 * @param tokenId -
 * When using the hook with ERC1155 contracts, pass the `tokenId`; as each token can have unique claim conditions.
 *
 * Pass `undefined`, or leave this field out if you are using ERC721 or ERC20 drop contracts.
 *
 * @param claimConditionId -
 * This is the ID of the claim condition you want to get the proof for.
 *
 * @returns Query result object with the snapshot for the provided address
 *
 * @claimConditions
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 */
function useClaimerProofs(contract, claimerAddress, tokenId, claimConditionId) {
  const contractAddress = contract?.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getClaimerProofs(contractAddress, tokenId), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.getClaimerProofs(tokenId, claimerAddress, claimConditionId);
    }
    if (erc721) {
      return erc721.claimConditions.getClaimerProofs(claimerAddress, claimConditionId);
    }
    if (erc20) {
      return erc20.claimConditions.getClaimerProofs(claimerAddress, claimConditionId);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== undefined : !!erc721 || !!erc20
  });
}

/**
 * Hook for fetching all claim conditions for a given drop contract.
 *
 * This is available for available for contracts that implement the "ClaimConditions" interface; such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * @example
 * ```javascript
 * import { useClaimConditions, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useClaimConditions(contract);
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the ERC721, ERC1155 or ERC20 spec and implements the "ClaimConditions" extension.
 *
 * @param tokenId -
 * When using the hook with ERC1155 contracts, pass the `tokenId` parameter; as each token can have unique claim conditions.
 *
 * Pass `undefined`, or leave this field out if you are using ERC721 or ERC20 drop contracts.
 *
 * ```tsx
 * import { useClaimConditions, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *
 *   const { data, isLoading, error } = useClaimConditions(
 *     contract,
 *     0, // Token ID required for ERC1155 contracts here.
 *   );
 * }
 * ```
 *
 * @param options - additional options to pass to the claim condition fetch
 *
 * #### withAllowlist
 *
 * By default, the hook will not include the allowlist in the returned data. To include the allowlist in the returned data, set the `withAllowlist` option to true.
 *
 * This will add a `snapshot` property to the returned data, which contains the allowlist in an array.
 *
 * ```tsx
 * import { useClaimConditions, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *
 *   // "data" now includes a "snapshot" property that contains the allowlist.
 *   const { data, isLoading, error } = useClaimConditions(
 *     contract,
 *     undefined, // Token ID required for ERC1155 contracts here.
 *     {
 *       withAllowlist: true,
 *     },
 *   );
 * }
 * ```
 *
 * @returns Query Result object with the list of claim conditions
 *
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 * @claimConditions
 */
function useClaimConditions(contract, tokenId, options) {
  const contractAddress = contract?.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getAll(contractAddress, tokenId, options), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.getAll(tokenId, options);
    }
    if (erc721) {
      return erc721.claimConditions.getAll(options);
    }
    if (erc20) {
      return erc20.claimConditions.getAll(options);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== undefined : !!erc721 || !!erc20
  });
}

/**
 * Hook for fetching the reasons a wallet is not eligible to claim tokens from a drop, if any.
 *
 * This is available for available for contracts that implement the "ClaimConditions" interface; such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * @example
 * ```javascript
 * import { useClaimIneligibilityReasons, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useClaimIneligibilityReasons(contract, {
 *     walletAddress: "0x123...", // Use useAddress hook to get the user's wallet address
 *     quantity: 1, // Quantity to check eligibility for
 *   });
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the  ERC20, ERC721 or ERC1155 spec and implements the "ClaimConditions" extension.
 *
 * @param params -
 * The conditions to check eligibility for. The `walletAddress` and `quantity` properties are required.
 *
 * Use the `useAddress` hook to get the connected wallet address.
 *
 * @param tokenId -
 * When using ERC1155 contracts, provide a third argument to specify the token ID.
 *
 * ```tsx
 * import { useClaimIneligibilityReasons, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useClaimIneligibilityReasons(
 *     contract,
 *     {
 *       walletAddress: "0x123..",
 *       quantity: 1,
 *     },
 *     tokenId,
 *   );
 * }
 * ```
 *
 * @returns
 * The hook's `data` property, once loaded, contains an array of `ClaimEligibility` strings, which may be empty.
 *
 * For example, if the user is not in the allowlist, this hook will return `["This address is not on the allowlist."]`.
 *
 * If the user is eligible to claim tokens, the hook will return an empty array.
 *
 * @claimConditions
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 */
function useClaimIneligibilityReasons(contract, params, tokenId) {
  const contractAddress = contract?.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getClaimIneligibilityReasons(contractAddress, params, tokenId), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim ineligibility reasons");
      return erc1155.claimConditions.getClaimIneligibilityReasons(tokenId, params.quantity, params.walletAddress);
    }
    if (erc721) {
      return erc721.claimConditions.getClaimIneligibilityReasons(params.quantity, params.walletAddress);
    }
    if (erc20) {
      return erc20.claimConditions.getClaimIneligibilityReasons(params.quantity, params.walletAddress);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    // 3. has a params object been passed?
    // 4. does params have an address in it?
    enabled: (erc1155 ? tokenId !== undefined : !!erc721 || !!erc20) && !!params && !!params.walletAddress
  });
}

/**
 * Hook for getting the active claim condition on a drop contract for a specific wallet address.
 *
 * Each wallet address can have unique claim conditions at any given time. This hook allows you to get the active claim condition for a specific wallet address at this time.
 *
 * This is available for available for contracts that implement the "ClaimConditions" interface; such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 *  ---
 *
 * - Returns the claim condition specific to the wallet address if found in the claimer snapshot.
 * - Returns the default claim condition on the contract if the address is not found in the claimer snapshot.
 * - Populates the error field if there is no active claim condition on the contract.
 *
 * @example
 * ```javascript
 * import {
 *   useActiveClaimConditionForWallet,
 *   useContract,
 *   useAddress,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const address = useAddress();
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useActiveClaimConditionForWallet(
 *     contract,
 *     address,
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the  ERC20, ERC721 or ERC1155 spec and implements the "ClaimConditions" extension.
 *
 * @param walletAddress -
 * The wallet address to check the active claim condition for. You can use the `useAddress` hook to get the currently connected wallet's address.
 *
 * @param tokenId -
 * When using the hook with ERC1155 contracts, pass the `tokenId` as the third parameter; as each token can have unique claim conditions.
 *
 * Pass `undefined`, or leave this field out if you are using ERC721 or ERC20 drop contracts.
 *
 * @returns The active claim condition for the wallet address or `null` if there is no active claim condition
 *
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 * @claimConditions
 */
function useActiveClaimConditionForWallet(contract, walletAddress, tokenId) {
  const sdk$1 = useSDK();
  const contractAddress = contract?.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.useActiveClaimConditionForWallet(contractAddress, walletAddress || "_NO_WALLET_", tokenId), async () => {
    // if we do not have a walletAddress just do the same logic as basic useClaimCondition
    if (!walletAddress) {
      if (erc1155) {
        requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
        return erc1155.claimConditions.getActive(tokenId);
      }
      if (erc721) {
        return erc721.claimConditions.getActive();
      }
      if (erc20) {
        return erc20.claimConditions.getActive();
      }
      throw new Error("Contract must be ERC721, ERC1155 or ERC20");
    }
    invariant__default["default"](sdk$1, "sdk is required");
    let activeGeneralClaimCondition = null;
    let claimerProofForWallet = null;
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155");
      const [cc, cp] = await Promise.all([erc1155.claimConditions.getActive(tokenId), erc1155.claimConditions.getClaimerProofs(tokenId, walletAddress)]);
      activeGeneralClaimCondition = cc;
      claimerProofForWallet = cp;
    }
    if (erc721) {
      const [cc, cp] = await Promise.all([erc721.claimConditions.getActive(), erc721.claimConditions.getClaimerProofs(walletAddress)]);
      activeGeneralClaimCondition = cc;
      claimerProofForWallet = cp;
    }
    if (erc20) {
      const [cc, cp] = await Promise.all([erc20.claimConditions.getActive(), erc20.claimConditions.getClaimerProofs(walletAddress)]);
      activeGeneralClaimCondition = cc;
      claimerProofForWallet = cp;
    }
    // if there is no active claim condition nothing matters, return null
    if (!activeGeneralClaimCondition) {
      return null;
    }

    // if there is no claimer proof then just fall back to the active general claim condition
    if (!claimerProofForWallet) {
      return activeGeneralClaimCondition;
    }
    const {
      maxClaimable,
      currencyAddress,
      price
    } = claimerProofForWallet;
    const currencyWithOverride = currencyAddress || activeGeneralClaimCondition.currencyAddress;
    const currencyMetadata = await sdk.fetchCurrencyMetadata(sdk$1.getProvider(), currencyWithOverride);
    const normalizedPrize = price ? price === "unlimited" ? ethers.constants.MaxUint256 : ethers.utils.parseUnits(price, currencyMetadata.decimals) : null;
    const priceWithOverride = normalizedPrize || activeGeneralClaimCondition.price;
    const maxClaimableWithOverride = maxClaimable || activeGeneralClaimCondition.maxClaimablePerWallet;
    const currencyValueWithOverride = await sdk.fetchCurrencyValue(sdk$1.getProvider(), currencyWithOverride, priceWithOverride);
    return {
      // inherit the entire claim condition
      ...activeGeneralClaimCondition,
      // overwrite all keys that could be changed based on overwrites
      maxClaimablePerWallet: maxClaimableWithOverride,
      price: priceWithOverride,
      currency: currencyWithOverride,
      currencyAddress: currencyWithOverride,
      currencyMetadata: currencyValueWithOverride
    };
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== undefined : !!erc721 || !!erc20
  });
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/

/**
 * Hook for setting claim conditions on a drop contract.
 *
 * This is available for available for contracts that implement the "ClaimConditions" interface; such as [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721), [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155), and [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * When using an ERC1155 contract, you must also provide the token ID of the NFT you want to set claim conditions on as the second parameter to the hook.
 *
 * @example
 * ```tsx
 * import {
 *   useSetClaimConditions,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: setClaimConditions,
 *     isLoading,
 *     error,
 *   } = useSetClaimConditions(contract);
 *
 *   const claimConditions = {
 *     phases: [
 *       {
 *         metadata: {
 *           name: "Phase 1", // The name of the phase
 *         },
 *         currencyAddress: "0x...", // The address of the currency you want users to pay in
 *         price: 1, // The price of the token in the currency specified above
 *         maxClaimablePerWallet: 1, // The maximum number of tokens a wallet can claim
 *         maxClaimableSupply: 100, // The total number of tokens that can be claimed in this phase
 *         startTime: new Date(), // When the phase starts (i.e. when users can start claiming tokens)
 *         waitInSeconds: 60 * 60 * 24 * 7, // The period of time users must wait between repeat claims
 *         snapshot: [
 *           {
 *             address: "0x...", // The address of the wallet
 *             currencyAddress: "0x...", // Override the currency address this wallet pays in
 *             maxClaimable: 5, // Override the maximum number of tokens this wallet can claim
 *             price: 0.5, // Override the price this wallet pays
 *           },
 *         ],
 *         merkleRootHash: "0x...", // The merkle root hash of the snapshot
 *       },
 *     ],
 *   }
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() => setClaimConditions(claimConditions)}
 *     >
 *       Set Claim Conditions
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a {@link DropContract}
 * @returns
 *
 * A Mutation object to set claim conditions
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useSetClaimConditions(contract);
 *
 * function setPhases(phases) {
 *  mutateAsync({
 *    phases,
 *  });
 * }
 *
 * function reset() {
 *  mutateAsync({
 *    reset: true,
 *  })
 * }
 * ```
 *
 * ### options
 *
 * The mutation function takes an object with two possible properties:
 *
 * 1. `reset` - A boolean that determines whether to reset the claim conditions. This means you reset any previous claim conditions that existed and allow users to claim again as if the drop had just started.
 * 2. `phases` - An array of claim phases that occur in chronological order. You can only have one phase occur at a time. All properties of a phase are optional, with the default being a free, open, unlimited claim, in the native currency, starting immediately.
 *
 * ---
 *
 * #### reset (optional)
 *
 * A boolean value that determines whether to reset the claim conditions or to keep the existing state.
 *
 * By resetting them, any previous claims that were made will be ignored by the claim condition restrictions.
 *
 * For example, if you had a limit of 1 token per wallet, and a user claimed a token, then you reset the claim conditions, that user will be able to claim another token.
 *
 * Default value is `false`.
 *
 * ---
 *
 * #### phases (required)
 *
 * Provide an array of phases that occur in chronological order. All properties of a phase are optional and are described below:
 *
 * ##### metadata
 *
 * An object representing the metadata of the phase. This is only for display purposes in the dashboard and isn’t used elsewhere.
 *
 * ```js
 * {
 *   name: string;
 * }
 * ```
 *
 * ##### currencyAddress
 *
 * The address of the currency you want users to pay in.
 *
 * This can be any ERC20 token value. If you want users to pay in the native currency (e.g. Ether on Ethereum), you can import the `NATIVE_TOKEN_ADDRESS` constant from `@thirdweb-dev/sdk`. The default value is `NATIVE_TOKEN_ADDRESS`.
 *
 * ##### price
 *
 * The price per token in the currency specified above. The default value is `0`.
 *
 * ##### maxClaimablePerWallet
 *
 * The maximum number of tokens a wallet can claim. The default value is `"unlimited"`
 *
 * ##### maxClaimableSupply
 *
 * The total number of tokens that can be claimed in this phase.
 *
 * For example, if you lazy mint 1000 tokens and set the `maxClaimableSupply` to 100, then only 100 tokens will be claimable in this phase, leaving 900 tokens to be claimed in the next phases (if you have any).
 *
 * This is useful for "early bird" use cases, where you allow users to claim a limited number of tokens at a discounted price during the first X amount of time.
 *
 * ##### startTime
 *
 * When the phase starts (i.e. when users can start claiming tokens).
 *
 * The default value is `"immediately"`.
 *
 * ##### waitInSeconds
 *
 * The amount of time between claims a wallet must wait before they can claim again.
 *
 * The default value is `0`, meaning users can claim again immediately after claiming.
 *
 * ##### snapshot
 *
 * A list of wallets that you want to override the default claim conditions for.
 *
 * Wallet addresses within this list can be set to pay in a different currency, have a different price, and have a different maximum claimable amount.
 *
 * ```jsx
 * {
 *   address: string;
 *   currencyAddress?: string;
 *   maxClaimable?: number;
 *   price?: number;
 * }
 * ```
 *
 * [Learn more about improving claim conditions](https://blog.thirdweb.com/announcing-improved-claim-conditions/)
 *
 * ##### merkleRootHash
 *
 * If you want to provide your own merkle tree for your snapshot, provide the merkle root hash here. This is only recommended for advanced use cases.
 *
 * @claimConditions
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 */
function useSetClaimConditions(contract, tokenId) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(contract, "No Contract instance provided");
    const {
      phases,
      reset = false
    } = data;
    invariant__default["default"](phases, 'No "phases" provided');
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.set(tokenId, phases, reset);
    }
    if (erc721) {
      return erc721.claimConditions.set(phases, reset);
    }
    if (erc20) {
      return erc20.claimConditions.set(phases, reset);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    onSettled: () => {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/**
 * Hook for resetting the claim conditions on a drop contract.
 *
 * Available to use on contracts that implement
 * [`ERC721ClaimableWithConditions`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721ClaimConditions),
 * [`ERC1155ClaimableWithConditions`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155ClaimConditions) or
 * [`ERC20ClaimableWithConditions`](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20ClaimConditions).
 *
 * @example
 * ```jsx
 * import {
 *   useContract,
 *   useResetClaimConditions,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   // Contract must be a drop contract that implements claim conditions
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: resetClaimConditions,
 *     isLoading,
 *     error,
 *   } = useResetClaimConditions(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() => resetClaimConditions()}
 *     >
 *       Reset Claim Conditions
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `DropContract`
 * @param tokenId - For ERC1155 NFTs, provide the token ID of the NFT as the second argument to the hook.
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1 | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 * @nftDrop
 */
function useResetClaimConditions(contract, tokenId) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return reactQuery.useMutation(async () => {
    const cleanConditions = async conditions => {
      return conditions.map(c => ({
        ...c,
        price: c.currencyMetadata.displayValue
      }));
    };
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      const claimConditions = await erc1155.claimConditions.getAll(tokenId, {
        withAllowList: true
      });
      return erc1155.claimConditions.set(tokenId, await cleanConditions(claimConditions || []), true);
    }
    if (erc721) {
      const claimConditions = await erc721.claimConditions.getAll({
        withAllowList: true
      });
      return await erc721.claimConditions.set(await cleanConditions(claimConditions || []), true);
    }
    if (erc20) {
      const claimConditions = await erc20.claimConditions.getAll({
        withAllowList: true
      });
      return await erc20.claimConditions.set(await cleanConditions(claimConditions || []), true);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    onSettled: () => {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

// primary sales

/**
 * Hook for getting the primary sales recipient of a smart contract.
 *
 * Available to use on contracts that implement the [`PrimarySale`](https://portal.thirdweb.com/contracts/build/extensions/general/PrimarySale) interface.
 *
 * @example
 * ```jsx
 * import { useContract, usePrimarySaleRecipient } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = usePrimarySaleRecipient(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns The hook's `data` property, once loaded, is a `string` with the wallet address of the primary sales recipient.
 *
 * @twfeature PrimarySale
 * @platformFees
 */
function usePrimarySaleRecipient(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.sales.getRecipient(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.getRecipient();
  }, {
    enabled: !!contract || !!contractAddress
  });
}

/**
 * Hook for updating the primary sale recipient on a smart contract.
 *
 * Available to use on smart contracts that implement the [`PrimarySale`](https://portal.thirdweb.com/contracts/build/extensions/general/PrimarySale) interface.
 *
 * The wallet that initiates this transaction must have the required permissions to change the primary sale recipient (defaults to `"admin"` level).
 *
 * @example
 * ```jsx
 * import {
 *   useUpdatePrimarySaleRecipient,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: updatePrimarySaleRecipient,
 *     isLoading,
 *     error,
 *   } = useUpdatePrimarySaleRecipient(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() => updatePrimarySaleRecipient("{{wallet_address}}")}
 *     >
 *       Update Primary Sale Recipient
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 * @returns A mutation object to update the primary sales recipient
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useUpdatePrimarySaleRecipient(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes a `walletAddress` as argument:
 *
 * #### walletAddress
 *
 * The wallet address to set as the primary sale recipient.
 *
 * @twfeature PrimarySale
 * @platformFees
 */
function useUpdatePrimarySaleRecipient(contract) {
  const queryClient = reactQuery.useQueryClient();
  const contractAddress = contract?.getAddress();
  const activeChainId = useSDKChainId();
  return reactQuery.useMutation(newRecipient => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.setRecipient(newRecipient);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

// end primary sales

// royalties

/**
 * Hook for retrieving royalty settings of a smart contract.
 *
 * Available to use on contracts that implement the [`Royalty`](https://portal.thirdweb.com/contracts/build/extensions/general/Royalty) interface.
 *
 * @example
 * ```jsx
 * import { useContract, useRoyaltySettings } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useRoyaltySettings(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns
 * The hook's `data` property, once loaded, is an object with two properties:
 *
 * ```ts
 * {
 *   seller_fee_basis_points: number;
 *   fee_recipient: string;
 * }
 * ```
 *
 * - The `seller_fee_basis_points` is the royalty amount (in basis points) that the seller
 *   will receive for each token sale on secondary markets.
 * - The `fee_recipient` is the wallet address that will receive the royalty payments.
 *
 * @twfeature Royalty
 * @platformFees
 */
function useRoyaltySettings(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.royalties.getDefaultRoyaltyInfo(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.getDefaultRoyaltyInfo();
  }, {
    enabled: !!contract || !!contractAddress
  });
}

/**
 * Hook for updating royalty settings on a smart contract.
 *
 * Available to use on smart contracts that implement the [`Royalty`](https://portal.thirdweb.com/contracts/build/extensions/general/Royalty) interface.
 *
 * @example
 * ```jsx
 * import {
 *   useUpdateRoyaltySettings,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: updateRoyaltySettings,
 *     isLoading,
 *     error,
 *   } = useUpdateRoyaltySettings(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         updateRoyaltySettings({
 *           seller_fee_basis_points: 0,
 *           fee_recipient: "{{wallet_address}}",
 *         })
 *       }
 *     >
 *       Update Royalty Settings
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns
 * A mutation object to update the royalty settings
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useUpdateRoyaltySettings(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an object with below properties:
 *
 * #### seller_fee_basis_points
 *
 * The `seller_fee_basis_points` property is a `number` between `0` - `10000` that defines the fee rate.
 *
 * This number is in percentage points. i.e. `100` is a 1% fee and `10000` is a 100% fee.
 *
 * #### fee_recipient
 *
 * The `fee_recipient` property is the address of the wallet that will receive the fees.
 *
 * @twfeature Royalty
 * @platformFees
 */
function useUpdateRoyaltySettings(contract) {
  const queryClient = reactQuery.useQueryClient();
  const contractAddress = contract?.getAddress();
  const activeChainId = useSDKChainId();
  return reactQuery.useMutation(updatePayload => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.setDefaultRoyaltyInfo(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

// end royalties

// platformFees

/**
 * Hook for getting the platform fee settings of a contract.
 *
 * Available to use on contracts that implement the [`PlatformFee`](https://portal.thirdweb.com/contracts/build/extensions/general/PlatformFee) interface.
 *
 * @example
 *
 * ```jsx
 * import { useContract, usePlatformFees } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = usePlatformFees(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns
 * The hook's `data` property, once loaded, is an object containing two fields:
 *
 * - `platform_fee_basis_points`: the platform fee basis points set on the contract
 * - `platform_fee_recipient`: the wallet address of the platform fee recipient
 *
 * _Note_: The basis points are in percentage format, meaning that a value of `500` is equivalent to a `5%` fee.
 *
 * ```ts
 * {
 *   platform_fee_basis_points: number;
 *   platform_fee_recipient: string;
 * }
 * ```
 *
 * @twfeature PlatformFee
 * @platformFees
 */
function usePlatformFees(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.platformFees.get(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}

/**
 * Hook for updating platform fees on a smart contract.
 *
 * Available to use on smart contracts that implement the [`PlatformFee`](https://portal.thirdweb.com/contracts/build/extensions/general/PlatformFee) interface.
 *
 * ```jsx
 * import {
 *   useUpdatePlatformFees,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: updatePlatformFees,
 *     isLoading,
 *     error,
 *   } = useUpdatePlatformFees(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         updatePlatformFees({
 *           platform_fee_basis_points: 0,
 *           fee_recipient: "{{wallet_address}}",
 *         })
 *       }
 *     >
 *       Update Platform Fees
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns A mutation object to update the platform fees settings
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useUpdatePlatformFees(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an object with below properties:
 *
 * #### platform_fee_basis_points
 *
 * The `platform_fee_basis_points` property is a `number` between `0` - `10000` that defines the fee rate.
 *
 * This number is in percentage points. i.e. `100` is a 1% fee and `10000` is a 100% fee.
 *
 * #### fee_recipient
 *
 * The `fee_recipient` property is the address of the wallet that will receive the fees.
 *
 * Use the `useAddress` hook to get the current wallet address.
 *
 * @twfeature PlatformFee
 * @platformFees
 */
function useUpdatePlatformFees(contract) {
  const queryClient = reactQuery.useQueryClient();
  const contractAddress = contract?.getAddress();
  const activeChainId = useSDKChainId();
  return reactQuery.useMutation(updatePayload => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.set(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

// end platformFees

// metadata

/**
 * Hook for getting the metadata associated with a smart contract.
 *
 * Available to use on contracts that implement the [Contract Metadata](https://portal.thirdweb.com/contracts/build/extensions/general/ContractMetadata) interface.
 *
 * @example
 * ```jsx
 * import { useContract, useMetadata } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useMetadata(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 * @returns
 * A `CustomContractMetadata` object containing the metadata
 *
 * The hook's `data` property, once loaded, is an object containing the contract's metadata.
 *
 * ```ts
 * CustomContractMetadata | undefined;
 * ```
 *
 * ```ts
 * interface CustomContractMetadata {
 *   // The name of the contract.
 *   name: string;
 *   // A description of the contract.
 *   description?: string;
 *   // The image associated with the contract.
 *   image?: any;
 *   // An external link associated with the contract.
 *   external_link?: string;
 * }
 * ```
 *
 * @metadata
 */
function useMetadata(contract
// TODO figure out UseQueryResult type better
) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.metadata.get(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}

/**
 * Hook for updating the metadata of a smart contract.
 *
 * Available to use on smart contracts that implement the `ContractMetadata` interface.
 *
 * The wallet initiating this transaction must have the required permissions to update the metadata, (`admin` permissions required by default).
 *
 * Provide your contract instance from the `useContract` hook as the first argument, and
 * an object fitting the [contract-level metadata standards](https://docs.opensea.io/docs/contract-level-metadata) of
 * the new metadata as the second argument, including:
 *
 * - `name`: A `string` for the name of the smart contract (required).
 * - `description`: A `string` to describe the smart contract (optional).
 * - `image`: A `string` or `File` object containing the URL or file data of an image to associate with the contract (optional).
 * - `external_link`: A `string` containing a URL to view the smart contract on your website (optional).
 *
 * @example
 *
 * ```jsx
 * import {
 *   useUpdateMetadata,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: updateMetadata,
 *     isLoading,
 *     error,
 *   } = useUpdateMetadata(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         updateMetadata({
 *           name: "My App",
 *           description: "My awesome Ethereum App",
 *           image: "/path/to/image.jpg", // URL, URI, or File object
 *           external_link: "https://myapp.com",
 *         })
 *       }
 *     >
 *       Update Metadata
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 * @returns Mutation object that to update the metadata
 * @metadata
 */
function useUpdateMetadata(contract
// TODO figure out UseMutationResult type better
) {
  const queryClient = reactQuery.useQueryClient();
  const contractAddress = contract?.getAddress();
  const activeChainId = useSDKChainId();
  return reactQuery.useMutation(updatePayload => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"]("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.update(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

// end metadata

// contract type
async function fetchContractType(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return null;
  }
  try {
    return await sdk.resolveContractType(contractAddress);
  } catch (err) {
    console.error("failed to resolve contract type", err);
    // this error can happen if the contract is a custom contract -> assume "custom"
    return "custom";
  }
}

/**
 * Hook for determining the type of contract for a contract address.
 *
 * This is useful if you want to determine if a contract is a [prebuilt contract](https://portal.thirdweb.com/pre-built-contracts).
 *
 * @example
 * ```jsx
 * import { useContractType } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { data, isLoading, error } = useContractType(contractAddress);
 * }
 * ```
 *
 * @param contractAddress - The address of the contract
 * @returns Query result containing the type of the contract in the `data` property
 * @metadata
 */
function useContractType(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(cacheKeys.contract.type(contractAddress), () => fetchContractType(contractAddress, sdk),
  // is immutable, so infinite stale time
  {
    cacheTime: Infinity,
    staleTime: Infinity,
    enabled: !!contractAddress && !!sdk
  });
}

/**
 * @internal
 */
const contractType = {
  cacheKey: (contractAddress, chainId) => createCacheKeyWithNetwork(cacheKeys.contract.type(contractAddress), chainId),
  useQuery: useContractType,
  fetchQuery: fetchContractType
};

// end contract type

// contract compiler metadata
function fetchCompilerMetadata(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return null;
  }
  try {
    return sdk.getPublisher().fetchCompilerMetadataFromAddress(contractAddress);
  } catch (err) {
    // if we fail to get contract metadata just return null;
    return null;
  }
}

/**
 * Hook for retrieving information such as the ABI, license, and metadata of a smart contract using it's contract address.
 *
 * @example
 * ```jsx
 * import { useCompilerMetadata } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { data, isLoading, error } = useCompilerMetadata(contractAddress);
 * }
 *
 * export default App;
 * ```
 *
 * @param contractAddress - The address of the deployed contract
 * @returns Query result containing the compiler metadata of the deployed contract in the `data` property
 *
 * @metadata
 */
function useCompilerMetadata(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), () => fetchCompilerMetadata(contractAddress, sdk),
  // is immutable, so infinite stale time
  {
    cacheTime: Infinity,
    staleTime: Infinity,
    enabled: !!contractAddress && !!sdk
  });
}

/**
 * @internal
 */
const compilerMetadata = {
  cacheKey: (contractAddress, chainId) => createCacheKeyWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), chainId),
  useQuery: useCompilerMetadata,
  fetchQuery: fetchCompilerMetadata
};

// end compiler metadata

// useContract

/**
 * @contract
 */

/**
 * Hook for connecting to a smart contract.
 *
 * Provide your smart contract address as the first parameter. Once connected, the `contract` will be an instance of your smart contract.
 *
 * The ABI of the smart contract is resolved automatically for contracts deployed or imported using the [thirdweb dashboard](https://thirdweb.com/dashboard).
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract(contractAddress);
 * ```
 *
 * @remarks
 *
 * To cache the ABI of the smart contract, use [thirdweb generate](https://portal.thirdweb.com/cli/generate). This is recommended to improve performance and provide type-safety when interacting with your smart contract.
 *
 *
 * @param contractAddress - The address of the deployed contract
 * @returns Query result object that includes the contract once it is resolved
 * @contract
 */

/**
 * If your contract is a prebuilt contract, it is strongly recommended you provide the contract's name as the second argument to gain access to improved top-level functions and type inference.
 *
 * Available contract types are:
 * - `"nft-drop"`
 * - `"signature-drop"`
 * - `"edition-drop"`
 * - `"nft-collection"`
 * - `"edition"`
 * - `"multiwrap"`
 * - `"pack"`
 * - `"token-drop"`
 * - `"token"`
 * - `"marketplace"`
 * - `"marketplace-v3"`
 * - `"split"`
 * - `"vote"`
 *
 * When a contract type is provided, the contract object will be typed as the contract's class.
 * For example, if you provide the contract type `"pack"`, the contract object will be returned typed as an instance of the `Pack` class, unlocking all of the top-level functions specific to the pack.
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract(contractAddress, "pack");
 * ```
 *
 * @param contractAddress - The address of the deployed contract
 * @param _contractType - The type of the contract
 * @returns Query result object that includes the contract once it is resolved
 * @public
 */

/**
 * Optionally, (if you don’t want to use the dashboard import feature),
 * you can provide your smart contract’s ABI to the second parameter of the useContract hook.
 * This is useful when developing on a local node, where it may be faster to use the ABI than to import the contract using the dashboard.
 *
 * The ABI is only necessary if you have not deployed your contract with, or imported your contract to the [thirdweb dashboard](https://thirdweb.com/dashboard).
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract(contractAddress, contractAbi);
 * ```
 *
 * @param contractAddress - The address of the deployed contract
 * @param _abi - The ABI of the contract to use
 * @returns Query result object that includes the contract once it is resolved
 */

// TODO: add JSDoc for this signature

function useContract(contractAddress, contractTypeOrABI) {
  const sdk$1 = useSDK();
  const queryClient = reactQuery.useQueryClient();
  const activeChainId = useSDKChainId();
  const wallet = useAddress();
  const walletChainId = useChainId();

  // it's there because we put it there.
  const sdkTimestamp = sdk$1?._constructedAt;
  const contractQuery = useQueryWithNetwork(
  // need to add the wallet and walletChainId into the query key so this gets refreshed when the wallet / chain changes!
  neverPersist(["contract-instance", contractAddress, {
    wallet,
    walletChainId,
    sdkTimestamp,
    contractTypeOrABI
  }]), async () => {
    requiredParamInvariant(contractAddress, "contract address is required");
    invariant__default["default"](sdk$1, "SDK not initialized");
    invariant__default["default"](activeChainId, "active chain id is required");

    // if we don't have a contractType or ABI then we will have to resolve it regardless
    // we also handle it being "custom" just in case...
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      // First check local ABI cache
      const cachedAbi = sdk.getCachedAbiForContract(contractAddress);
      if (cachedAbi) {
        return sdk$1.getContract(contractAddress, cachedAbi);
      }

      // we just resolve here (sdk does this internally anyway)
      const resolvedContractType = await queryClient.fetchQuery(contractType.cacheKey(contractAddress, activeChainId), () => contractType.fetchQuery(contractAddress, sdk$1), {
        cacheTime: Infinity,
        staleTime: Infinity
      });
      let abi;
      if (resolvedContractType === "custom") {
        abi = (await queryClient.fetchQuery(compilerMetadata.cacheKey(contractAddress, activeChainId), () => compilerMetadata.fetchQuery(contractAddress, sdk$1), {
          cacheTime: Infinity,
          staleTime: Infinity,
          retry: 0
        }))?.abi;
      }
      invariant__default["default"](resolvedContractType, "failed to resolve contract type");
      // just let the sdk handle the rest
      // if we have resolved an ABI for a custom contract, use that otherwise use contract type
      return sdk$1.getContract(contractAddress, abi || resolvedContractType);
    }
    // every other case can just be handled by the sdk directly
    return sdk$1.getContract(contractAddress, contractTypeOrABI);
  }, {
    // keep the previous value around while we fetch the new one
    // this is important because otherwise it can lead to flickering (because we need to re-fetch the contract when sdk things change)
    keepPreviousData: true,
    // is immutable, so infinite cache & stale time (for a given key)
    cacheTime: Infinity,
    staleTime: Infinity,
    enabled: !!contractAddress && !!sdk$1 && !!activeChainId,
    // never retry
    retry: 0
  });

  // const previousCountract = usePrevious(contractQuery.data);

  return {
    ...contractQuery,
    data: contractQuery.data,
    contract: contractQuery.data
  };
}

/**
 * Get the metadata of given contract
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading } = useContractMetadata(contract);
 * ```
 *
 * @param contract - The `ValidContractInstance` instance of the contract to get the metadata for
 * @returns A Query result object that includes the contract metadata of the deployed contract
 * @twfeature ContractMetadata
 * @metadata
 */
function useContractMetadata(contract) {
  return useQueryWithNetwork(cacheKeys.contract.metadata(contract?.getAddress()), async () => {
    requiredParamInvariant(contract, "contract is required");
    return await contract.metadata.get(); // FIXME types
  }, {
    enabled: !!contract
  });
}

/**
 * Update the metadata of the given contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract("{{contract_address}}");
 *   const {
 *     mutate: updateContractMetadata,
 *     isLoading,
 *     error,
 *   } = useContractMetadataUpdate(contract);
 *
 *   if (error) {
 *     console.error("failed to update contract metadata", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updateContractMetadata({ name: "New name", description: "New description" })}
 *     >
 *       Update contract metadata
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - The `ValidContractInstance` instance of the contract to get the metadata for
 * @returns Mutation object to update the contract metadata
 * @twfeature ContractMetadata
 * @metadata
 */
function useContractMetadataUpdate(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async metadata => {
    requiredParamInvariant(contract, "contract must be defined");
    return contract.metadata.update(metadata);
  }, {
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), activeChainId))
  });
}

/**
 * CONTRACT EVENTS
 */

/**
 * Hook for reading events emitted by a smart contract, including new events as they are emitted (optional).
 *
 * By default, it reads all events emitted by the smart contract.
 *
 * @example
 * ```tsx
 * import { useContractEvents, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useContractEvents(contract);
 * }
 * ```
 *
 * @param contract - The contract instance of the contract to listen to events for
 *
 * @param eventName -
 * The name of the event to query for.
 *
 * For example, if your smart contract emits an event called `MyEvent`, you would pass `"MyEvent"` to this parameter.
 *
 * Omit this parameter or provide undefined to query for all events emitted by the smart contract.
 *
 * @param options -
 * An object containing options to filter the events being queried.
 *
 * Available options include
 * - `queryFilter` to refine which events you want to read,
 * - a boolean `subscribe` flag to subscribe to new events as they are emitted.
 *
 * ### Example
 * ```tsx
 * import {
 *   useContractEvents,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useContractEvents(
 *     contract,
 *     "MyEvent",
 *     {
 *       queryFilter: {
 *         filters: {
 *           tokenId: 123, // e.g. Only events where tokenId = 123
 *         },
 *         fromBlock: 0, // Events starting from this block
 *         toBlock: 100, // Events up to this block
 *         order: "asc", // Order of events ("asc" or "desc")
 *       },
 *       subscribe: true, // Subscribe to new events
 *     },
 *   );
 * ```
 *
 * @returns The hook's `data` property, once loaded, contains an array of `ContractEvent` objects
 * @contract
 *
 */
function useContractEvents(contract, eventName) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    subscribe: true
  };
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const activeChainId = useSDKChainId();
  const cacheKey = react.useMemo(() => createCacheKeyWithNetwork(eventName ? cacheKeys.contract.events.getEvents(contractAddress, eventName) : cacheKeys.contract.events.getAllEvents(contractAddress), activeChainId), [activeChainId, contractAddress, eventName]);
  react.useEffect(() => {
    // if we're not subscribing or query is not enabled yet we can early exit
    if (!options.subscribe || !contract || !contract) {
      return;
    }
    const cleanupListener = contract.events.listenToAllEvents(contractEvent => {
      // if we have a specific event name we are looking for we can early exist if it doesn't match
      if (eventName && eventName !== contractEvent.eventName) {
        return;
      }
      // insert new event to the front of the array (no duplicates, though)
      queryClient.setQueryData(cacheKey, oldData => {
        if (!oldData) {
          return [contractEvent];
        }
        const eventIsNotAlreadyInEventsList = oldData.findIndex(e => e.transaction.transactionHash === contractEvent.transaction.transactionHash && e.transaction.logIndex === contractEvent.transaction.logIndex) === -1;
        if (eventIsNotAlreadyInEventsList) {
          return [contractEvent, ...oldData];
        }
        return oldData;
      });
    });
    // cleanup listener on unmount
    return cleanupListener;
  }, [options.subscribe, cacheKey, contract, queryClient, eventName]);
  return reactQuery.useQuery(cacheKey, () => {
    requiredParamInvariant(contract, "contract must be defined");
    if (eventName) {
      return contract.events.getEvents(eventName, options.queryFilter);
    }
    return contract.events.getAllEvents(options.queryFilter);
  }, {
    enabled: !!contract,
    // we do not need to re-fetch if we're subscribing
    refetchOnWindowFocus: !options.subscribe,
    refetchOnMount: true,
    refetchOnReconnect: true
  });
}

/**
 * Generic hook for reading any data from a smart contract via it’s function/view/variable name.
 *
 * ```javascript
 * const { contract } = useContract("{{contract_address}}");
 * const { data, isLoading, error } = useContractRead(contract, "functionName", args);
 * ```
 *
 * @example
 * Provide your smart contract instance from `useContract`, a function name and the arguments to pass to the function (if any).
 *
 * For example, to read the value of a view on your smart contract called `getName` you would do the following:
 *
 * ```tsx
 * import { useContractRead, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useContractRead(contract, "getName");
 * }
 * ```
 *
 * @remarks
 * If you have cached the ABI of your smart contract using [thirdweb generate](https://portal.thirdweb.com/cli/generate), the functionName and args parameters are strongly typed according to your smart contract’s ABI.
 *
 * @param contract - The contract instance of the contract to call a function on
 *
 * @param functionName - The name of the function to call in the smart contract. This can be any function, view, variable, etc. that does not require a transaction to occur.
 *
 * @param args - The arguments to pass to the function (if any)
 *
 * @param overrides -
 * `CallOverrides` object to send with your request.
 *
 * To include the sender's address (msg.sender) when calling view functions within your smart contract, include the property `{from: 0X123}` passing the relevant address.
 *
 * ```ts
 * const { data, isLoading, error } = useContractRead(contract, "getName", ["arg1", "arg2"], {
 *     blockTag: 123,
 *     from: "0x123",
 *   });
 * ```
 *
 * @returns Query result object that includes the data returned by the function call
 * @contract
 */
function useContractRead(contract, functionName, args, overrides) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.call(contractAddress, functionName, args, overrides), () => {
    requiredParamInvariant(contract, "contract must be defined");
    requiredParamInvariant(functionName, "function name must be provided");
    return contract.call(functionName, args, overrides);
  }, {
    enabled: !!contract && !!functionName
  });
}

/**
 * Generic hook for calling any smart contract function that requires a transaction to take place.
 *
 * Provide your smart contract instance returned from the `useContract` hook, along with the name of the function you wish to call on your smart contract as arguments to the hook.
 *
 * Then call the `mutate` or `mutateAsync` function returned by the hook, providing an array of arguments to send to your smart contract function.
 *
 * If you provide too many or too few arguments, the `error` property will be populated with an error message.
 *
 * If your function has no arguments, provide an empty array by calling the function with `{ args: [] }`
 *
 * @example
 * ```javascript
 * import { useContractWrite, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync, isLoading, error } = useContractWrite(
 *     contract,
 *     "setName",
 *   );
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       // Calls the "setName" function on your smart contract with "My Name" as the first argument
 *       action={() => mutateAsync({ args: ["My Name"] })}
 *     >
 *       Send Transaction
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @remarks
 *
 * If you have cached the ABI of your smart contract using [thirdweb generate](https://portal.thirdweb.com/cli/generate), the functionName and args parameters are strongly typed according to your smart contract’s ABI.
 *
 *
 * @param contract - The contract instance of the contract to call a function on
 * @param functionName - The name of the function to call in the smart contract.
 * @returns A mutation object that includes the write function to call
 * @contract
 */
function useContractWrite(contract, functionName) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async _ref => {
    let {
      args,
      overrides
    } = _ref;
    requiredParamInvariant(contract, "contract must be defined");
    requiredParamInvariant(functionName, "function name must be provided");
    return contract.call(functionName, args, overrides);
  }, {
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), activeChainId))
  });
}

/** **********************/
/**       READ HOOKS    **/
/** **********************/

/**
 * Hook for fetching information about all NFTs that haven't been claimed yet from an NFT Drop contract.
 *
 * Available to use on contracts that extends the ERC721 spec
 *
 * @example
 *
 * ```jsx
 * import { useUnclaimedNFTs, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useUnclaimedNFTs(contract);
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the ERC721 spec (NFT drop, Signature Drop, or any custom contract that extends the ERC721 spec)
 *
 * @param queryParams -
 * query params to pass to the query for the sake of pagination
 * By default, the hook returns the first 100 unclaimed NFTs from the contract.
 *
 * Paginate the results by providing a `queryParams` object as the second argument.
 *
 * ```jsx
 * import { useUnclaimedNFTs, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useUnclaimedNFTs(
 *     contract,
 *     {
 *       count: 10, // Limit the number of results
 *       start: 0, // Start from the nth result (useful for pagination)
 *     },
 *   );
 * }
 * ```
 *
 * @returns
 * The hook's `data` property, once loaded, contains an array of `NFT` objects.
 *
 * @twfeature ERC721LazyMintable
 * @nftDrop
 */
function useUnclaimedNFTs(contract, queryParams) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.getAllUnclaimed(contractAddress, queryParams), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    // TODO make this work for custom contracts (needs ABI change)
    invariant__default["default"](contract.getAllUnclaimed, "Contract instance does not support getAllUnclaimed");
    const data = contract.getAllUnclaimed(queryParams);
    return data;
  }, {
    enabled: !!contract
  });
}

/**
 * Hook for fetching all claimed NFTs from a given NFT Drop contract.
 *
 * Available to use on contracts that implement [`ERC721Claimable`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721Claimable),
 * such as the [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721).
 *
 * @example
 *
 * ```jsx
 * import { useClaimedNFTs, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "nft-drop");
 *   const { data: nfts, isLoading, error } = useClaimedNFTs(contract);
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the ERC721 spec (NFT drop, Signature Drop, or any custom contract that extends the ERC721 spec)
 *
 * @param queryParams -
 * By default, the hook will return the first `100` claimed NFTs
 *
 * You can use the `queryParams` argument to paginate the NFTs that are returned.
 *
 * ```jsx
 * import { useClaimedNFTs, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "nft-drop");
 *   const { data, isLoading, error } = useClaimedNFTs(
 *     contract,
 *     {
 *       // For example, to only return the first 50 claimed NFTs in the collection
 *       // in order of token ID
 *       count: 50,
 *       start: 0,
 *     },
 *   );
 * }
 * ```
 *
 * @returns Query Result object that includes an array of NFTs that are claimed in the `data` property
 * @twfeature ERC721LazyMintable
 * @nftDrop
 */
function useClaimedNFTs(contract, queryParams) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.getAllClaimed(contractAddress, queryParams), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    // TODO make this work for custom contracts (needs ABI change)
    invariant__default["default"](contract.getAllClaimed, "Contract instance does not support getAllClaimed");
    return contract.getAllClaimed(queryParams);
  }, {
    enabled: !!contract
  });
}

/**
 * Hook for fetching the number of unclaimed NFTs from an NFT/Edition Drop contract.
 *
 * Unclaimed NFTs are tokens that were lazy-minted but have not yet been claimed by a user.
 *
 * Available to use on contracts that implement the [`LazyMint`](https://portal.thirdweb.com/contracts/build/extensions/general/LazyMint) extension;
 * such as the [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721) contract.
 *
 * @example
 *
 * ```jsx
 * import { useUnclaimedNFTSupply, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "nftDrop");
 *   const { data, isLoading, error } = useUnclaimedNFTSupply(contract);
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the ERC721 spec (NFT drop, Signature Drop, or any custom contract that extends the ERC721 spec)
 *
 * @returns
 * The hook's `data` property, once loaded, contains a `BigNumber` representing the number of unclaimed NFTs.
 *
 *
 * @twfeature ERC721LazyMintable
 *
 * @nftDrop
 */
function useUnclaimedNFTSupply(contract) {
  const contractAddress = contract?.getAddress();
  const {
    erc721
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalUnclaimedSupply(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      invariant__default["default"](erc721, "No ERC721 Contract instance provided");
      return erc721.totalUnclaimedSupply();
    }
    invariant__default["default"](false, "Contract is not an instance of ERC721");
  }, {
    enabled: !!erc721
  });
}

/**
 * Hook for retrieving the total supply of NFTs claimed from an NFT Drop contract.
 *
 * Available to use on contracts that implement [`ERC721Claimable`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721Claimable).
 *
 * @example
 *
 * ```jsx
 * import { useClaimedNFTSupply, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading } = useClaimedNFTSupply(contract);
 * }
 * ```
 *
 * @param contract - Instance of a contract that extends the ERC721 spec (NFT drop, Signature Drop, or any custom contract that extends the ERC721 spec)
 *
 * @returns
 * The hook's `data` property, once loaded, is a `BigNumber` representing the total supply of NFTs claimed from the NFT drop contract so far.
 *
 * @twfeature ERC721LazyMintable
 * @nftDrop
 */
function useClaimedNFTSupply(contract) {
  const contractAddress = contract?.getAddress();
  const {
    erc721
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalClaimedSupply(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      return erc721.totalClaimedSupply();
    }
    invariant__default["default"](false, "Contract is not an instance of ERC721");
  }, {
    enabled: !!erc721
  });
}

/**
 * Hook for fetching batches of lazy-minted NFTs that were set to be revealed at a later date, but have not yet been revealed.
 *
 * Available to use on contracts that implement the [ERC721Revealable](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721Revealable)
 * or [ERC1155Revealable](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155Revealable) interfaces,
 * such as the [NFT Drop](https://thirdweb.com/thirdweb.eth/DropERC721)
 * and [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155) smart contracts.
 *
 * @example
 * ```tsx
 * import { useBatchesToReveal, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data: batches, isLoading, error } = useBatchesToReveal(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `RevealableContract`
 *
 * @returns The hook's `data` property, once loaded, contains an array of batches that need to be revealed.
 *
 * Each batch is an object with the following properties:
 *
 * ```ts
 * {
 *   batchId: BigNumber;
 *   batchUri: string;
 *   placeholderMetadata: NFTMetadata;
 * }
 * ```
 *
 * @twfeature ERC721Revealable | ERC1155Revealable
 * @delayedReveal
 */
function useBatchesToReveal(contract) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.revealer.getBatchesToReveal(contractAddress), () => {
    if (erc721) {
      return erc721.revealer.getBatchesToReveal();
    }
    if (erc1155) {
      return erc1155.revealer.getBatchesToReveal();
    }
    invariant__default["default"](false, "Contract instance does not support getBatchesToReveal");
  }, {
    enabled: !!erc721 || !!erc1155
  });
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/
/**
 * Hook for claiming an NFT from a smart contract.
 *
 * Available to use on smart contracts that implement a  `Claimable` interface, and follow either the `ERC721`or `ERC1155` standard.
 *
 * @example
 * ```jsx
 * import { useContract, useClaimNFT, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: claimNft, isLoading, error } = useClaimNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         claimNft({
 *           to: "{{wallet_address}}", // Use useAddress hook to get current wallet address
 *           quantity: 1,
 *         })
 *       }
 *     >
 *       Claim NFT
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `DropContract`
 *
 * @returns A mutation object to claim a NFT to the wallet specified in the params
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useClaimNFT(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an object as argument with below properties:
 *
 * #### to
 *
 * The wallet address to mint the NFT(s) to.
 *
 * Use the `useAddress` hook to get the currently connected wallet address.
 *
 * #### quantity
 *
 * The number of NFTs you wish to claim.
 *
 * - With ERC721 contracts, this represents the number of unique tokens you wish to claim.
 * - With ERC1155 contracts, this represents the quantity of the specific `tokenId` you wish to claim.
 *
 * #### tokenId
 *
 * For ERC1155 contracts, you must specify a specific `tokenId` to claim.
 *
 * #### options (optional)
 *
 * Customizable `ClaimOptions` object to override the default behaviour of the hook.
 *
 * There are three options available:
 *
 * - `checkERC20Allowance` - Whether to check the ERC20 allowance of the sender, defaults to true.
 * - `currencyAddress` - The currency to pay for each token claimed, defaults to `NATIVE_TOKEN_ADDRESS` for native currency.
 * - `pricePerToken` - The price to pay for each token claimed. Not relevant when using claim conditions.
 *
 * ```jsx
 * import { useContract, useClaimNFT, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutate: claimNft, isLoading, error } = useClaimNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         claimNft({
 *           to: "{{wallet_address}}",
 *           quantity: 1,
 *           options: {
 *             checkERC20Allowance: true,
 *             currencyAddress: "{{erc20_address}}",
 *             pricePerToken: 0,
 *           },
 *         })
 *       }
 *     >
 *       Claim NFT
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @twfeature ERC721Claimable | ERC1155Claimable | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
 * @nftDrop
 */
function useClaimNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(contract, "contract is undefined");
    if (erc1155) {
      requiredParamInvariant(data.tokenId, "tokenId not provided");
      if (!data.to) {
        return await erc1155.claim(data.tokenId, data.quantity, data.options);
      }
      return await erc1155.claimTo(data.to, data.tokenId, data.quantity, data.options);
    }
    if (erc721) {
      if (!data.to) {
        return await erc721.claim(data.quantity, data.options);
      }
      return await erc721.claimTo(data.to, data.quantity, data.options);
    }
    invariant__default["default"](false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for lazy minting a batch of NFTs on a drop contract.
 *
 * Available to use on smart contracts that implement the "Drop" extension, and
 * follow either the `ERC721` or `ERC1155` standard.
 *
 * @example
 *
 * Provide your drop contract (ERC721 or ERC1155) as the argument to the hook, and an array
 * of metadata objects to lazy-mint.
 *
 * ```jsx
 * import { useContract, useLazyMint, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: lazyMint, isLoading, error } = useLazyMint(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         lazyMint({
 *           // Metadata of the NFTs to upload
 *           metadatas: [
 *             {
 *               name: "My NFT",
 *               description: "An example NFT",
 *               image: "{{image_url}}",
 *             },
 *           ],
 *         })
 *       }
 *     >
 *       Lazy Mint NFTs
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract` with the drop extension
 *
 * @param onProgress - Optional callback that will be called with the progress of the upload
 *
 * @returns A mutation object to lazy mint a batch of NFTs
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useLazyMint(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an object as argument with below properties:
 *
 * #### metadatas
 * An array of objects containing the metadata of the NFTs to lazy mint.
 *
 * Your metadata objects must follow the [Metadata standards](https://docs.opensea.io/docs/metadata-standards#metadata-structure).
 *
 * ```jsx
 * import { useContract, useLazyMint, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: lazyMint, isLoading, error } = useLazyMint(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         lazyMint({
 *           // Metadata of the NFTs to upload
 *           metadatas: [
 *             {
 *               name: "My NFT",
 *               description: "An example NFT",
 *               image: "{{image_url}}",
 *             },
 *           ],
 *         })
 *       }
 *     >
 *       Lazy Mint NFTs
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @twfeature ERC721LazyMintable | ERC1155LazyMintable
 * @nftDrop
 */
function useLazyMint(contract, onProgress) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(contract, "contract is undefined");
    let options;
    if (onProgress) {
      options = {
        onProgress
      };
    }
    if (erc721) {
      return erc721.lazyMint(data.metadatas, options);
    }
    if (erc1155) {
      return erc1155.lazyMint(data.metadatas, options);
    }
    invariant__default["default"](false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook to lazy-mint a batch of NFTs with [delayed reveal](https://portal.thirdweb.com/glossary/delayed-reveal);
 * allowing the owner to set placeholder metadata and reveal the metadata of the NFTs at a later time.
 *
 * Available to use on contracts that implement the
 * [ERC721Revealable](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721Revealable)
 * or [ERC1155Revealable](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155Revealable)
 * interfaces.
 *
 * @example
 * ```tsx
 * import {
 *   useDelayedRevealLazyMint,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: mintNft,
 *     isLoading,
 *     error,
 *   } = useDelayedRevealLazyMint(contract);
 *
 *   const nftData = {
 *     placeholder: {
 *       name: "My NFT",
 *       description: "This is my NFT",
 *       image: "ipfs://example.com/my-nft.png", // Accepts any URL or File type
 *     },
 *     metadatas: [
 *       {
 *         name: "My NFT",
 *         description: "This is my NFT",
 *         image: "ipfs://example.com/my-nft.png", // Accepts any URL or File type
 *       },
 *     ],
 *     password: "{{password}}", // Password to be used for encryption
 *   };
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() => mintNft(nftData)}
 *     >
 *       Mint NFTs
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a {@link DropContract}
 * @param onProgress - an optional callback that will be called with the progress of the upload
 * @returns Mutation object to lazy mint a batch of NFTs
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useDelayedRevealLazyMint(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as argument with below properties:
 *
 * #### metadatas
 * An array of metadata objects, representing the metadata of the NFTs to be lazy-minted. Each metadata object must conform to the [standard metadata properties](https://docs.opensea.io/docs/metadata-standards).
 *
 * #### password
 * The password used to encrypt the metadatas.
 *
 * __The password CANNOT be recovered once it is set. If you lose the password, you will not be able to reveal the metadata.__
 *
 * @twfeature ERC721Revealable | ERC1155Revealable
 * @delayedReveal
 */
function useDelayedRevealLazyMint(contract, onProgress) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(contract, "contract is undefined");
    let options;
    if (onProgress) {
      options = {
        onProgress
      };
    }
    const {
      erc721,
      erc1155
    } = getErcs(contract);
    if (erc721) {
      return await erc721.revealer.createDelayedRevealBatch(data.placeholder, data.metadatas, data.password, options);
    }
    if (erc1155) {
      return await erc1155.revealer.createDelayedRevealBatch(data.placeholder, data.metadatas, data.password, options);
    }
    invariant__default["default"](false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for revealing a batch of delayed reveal NFTs using [delayed reveal](https://portal.thirdweb.com/glossary/delayed-reveal).
 *
 * Available to use on contracts that implement the
 * [ERC721Revealable](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721Revealable)
 * or [ERC1155Revealable](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155Revealable)
 * interfaces.
 *
 * ```jsx
 * import { useRevealLazyMint } from "@thirdweb-dev/react";
 *
 * const { mutateAsync, isLoading, error } = useRevealLazyMint(contract);
 * ```
 *
 * @example
 * ```tsx
 * import {
 *   useContract,
 *   useRevealLazyMint,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   // Contract must be an ERC-721 or ERC-1155 contract that implements the ERC721Revealable or ERC1155Revealable interface
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: revealLazyMint,
 *     isLoading,
 *     error,
 *   } = useRevealLazyMint(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         revealLazyMint({
 *           batchId: "{{batch_id}}", // ID of the batch to reveal (use useBatchesToReveal to get the batch IDs)
 *           password: "{{password}}", // Password to reveal the batch
 *         })
 *       }
 *     >
 *       Reveal Lazy Mint
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `RevealableContract`
 * @twfeature ERC721Revealable | ERC1155Revealable
 * @delayedReveal
 */
function useRevealLazyMint(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(contract, "contract is undefined");
    const {
      erc721,
      erc1155
    } = getErcs(contract);
    if (erc721) {
      return await erc721.revealer.reveal(data.batchId, data.password);
    }
    if (erc1155) {
      return await erc1155.revealer.reveal(data.batchId, data.password);
    }
    invariant__default["default"](false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/
/**     READ  HOOKS     **/
/** **********************/

/**
 * Hook for getting a specific listing on a `Marketplace` contract.
 *
 * __This hook is only available for `Marketplace` contracts__
 *
 * If you are using [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3),
 * use `useDirectListing` or `useEnglishAuction` instead.
 *
 * @example
 *
 * ```jsx
 * import { useContract, useListing } from "@thirdweb-dev/react";
 *
 * const listingId = 0;
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useListing(contract, listingId);
 * }
 * ```
 *
 *
 * @param contract - Instance of a marketplace contract
 * @param listingId - The listing id to check
 *
 * @returns
 * Query Result object that includes the desired listing.
 *
 * The hook's `data` property, once loaded, is an object containing the desired listing data.
 *
 * The exact shape of the object depends on the type of listing.
 *
 * For auctions, it will be a
 * `AuctionListing` object.
 * For direct listings, it will be a `DirectListing` object.
 *
 * ```jsx
 * AuctionListing | DirectListing | undefined;
 * ```
 *
 * You can use the shared `type` property to determine which type of listing is being returned.
 *
 * ```ts
 * interface AuctionListing {
 *   // The id of the listing
 *   id: string;
 *
 *   // The address of the asset being listed.
 *   assetContractAddress: string;
 *
 *   // The ID of the token to list.
 *   tokenId: BigNumberish;
 *
 *   // The asset being listed.
 *   asset: NFTMetadata;
 *
 *   // The start time of the listing.
 *   startTimeInEpochSeconds: BigNumberish;
 *
 *   // Number of seconds until the auction expires.
 *   endTimeInEpochSeconds: BigNumberish;
 *
 *   // The quantity of tokens to include in the listing.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: BigNumberish;
 *
 *   // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *
 *   // The reserve price is the minimum price that a bid must be in order to be accepted.
 *   reservePrice: BigNumber;
 *
 *   // The buyout price of the listing.
 *   buyoutPrice: BigNumber;
 *
 *   // The `CurrencyValue` of the buyout price listing.
 *   // Useful for displaying the price information.
 *   buyoutCurrencyValuePerToken: CurrencyValue;
 *
 *   // The `CurrencyValue` of the reserve price.
 *   // Useful for displaying the price information.
 *   reservePriceCurrencyValuePerToken: CurrencyValue;
 *
 *   // The address of the seller.
 *   sellerAddress: string;
 *
 *   // The type of listing.
 *   type: ListingType.Auction;
 * }
 *
 * interface DirectListing {
 *   // The id of the listing.
 *   id: string;
 *
 *   // The address of the asset being listed.
 *   assetContractAddress: string;
 *
 *   // The ID of the token to list.
 *   tokenId: BigNumberish;
 *
 *   // The asset being listed.
 *   asset: NFTMetadata;
 *
 *   // The start time of the listing.
 *   startTimeInSeconds: BigNumberish;
 *
 *   // Number of seconds until the listing expires.
 *   secondsUntilEnd: BigNumberish;
 *
 *   // The quantity of tokens to include in the listing.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: BigNumberish;
 *
 *   // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *
 *   // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   buyoutCurrencyValuePerToken: CurrencyValue;
 *
 *   // The buyout price of the listing.
 *   buyoutPrice: BigNumber;
 *
 *   // The address of the seller.
 *   sellerAddress: string;
 *
 *   // The type of listing.
 *   type: ListingType.Direct;
 * }
 * ```
 *
 * @marketplace
 */
function useListing(contract, listingId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getListing(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    return contract.getListing(listingId);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook to get a specific direct listing from a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * __This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For `Marketplace` contracts, use `useListing` instead.
 *
 * @example
 * ```jsx
 * import { useDirectListing, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: directListing,
 *     isLoading,
 *     error,
 *   } = useDirectListing(contract, listingId);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace v3 contract
 * @param listingId - The ID of the listing to get. If the listing is not found (or is not a direct listing), the `error` property will be set in the return value of the hook.
 *
 * @returns
 * The hook's data property, once loaded, is a `DirectListingV3` object, containing the following properties:
 *
 * ```ts
 * {
 *   // The id of the listing.
 *   id: string;
 *   // The address of the creator of listing.
 *   creatorAddress: string;
 *   // The address of the asset being listed.
 *   assetContractAddress: string;
 *   // The ID of the token to list.
 *   tokenId: string;
 *   // The quantity of tokens to include in the listing.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: string;
 *   // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *   // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   currencyValuePerToken: CurrencyValue;
 *   // The price to pay per unit of NFTs listed.
 *   pricePerToken: string;
 *   // The asset being listed.
 *   asset: NFTMetadata;
 *   // The start time of the listing.
 *   startTimeInSeconds: number;
 *   // The end time of the listing.
 *   endTimeInSeconds: number;
 *   // Whether the listing is reserved to be bought from a specific set of buyers.
 *   isReservedListing: boolean;
 *   // Whether the listing is CREATED, COMPLETED, or CANCELLED.
 *   status: Status;
 * }
 * ```
 * @twfeature DirectListings
 * @marketplace
 */
function useDirectListing(contract, listingId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.directListings.getListing(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    return contract.directListings.getListing(listingId);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook to get an english auction listing from a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * **Note: This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.**
 *
 * For `Marketplace`
 * contracts, use `useListing` instead.
 *
 * @example
 * ```jsx
 * import { useEnglishAuction, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: englishAuction,
 *     isLoading,
 *     error,
 *   } = useEnglishAuction(contract, listingId);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace v3 contract
 * @param auctionId -
 * the auction id to check.  If the listing with this ID cannot be found (or is not an auction), the `error` property will be set.
 *
 * @returns
 * The hook's `data` property, once loaded, will be an `EnglishAuction` object, containing the following properties:
 *
 * ```ts
 * {
 *   // The id of the auction
 *   id: string;
 *   // The address of the creator of auction.
 *   creatorAddress: string;
 *   // The address of the asset being auctioned.
 *   assetContractAddress: string;
 *   // The ID of the token to auction.
 *   tokenId: string;
 *   // The quantity of tokens to include in the auction.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: string;
 *   // The address of the currency to accept for the auction.
 *   currencyContractAddress: string;
 *   // The minimum price that a bid must be in order to be accepted.
 *   minimumBidAmount: string;
 *   // The `CurrencyValue` of the minimum bid amount.
 *   // Useful for displaying the price information.
 *   minimumBidCurrencyValue: CurrencyValue;
 *   // The buyout price of the auction.
 *   buyoutBidAmount: string;
 *   // The `CurrencyValue` of the buyout price.
 *   // Useful for displaying the price information.
 *   buyoutCurrencyValue: CurrencyValue;
 *   // This is a buffer e.g. x seconds.
 *   // If a new winning bid is made less than x seconds before expirationTimestamp, the
 *   // expirationTimestamp is increased by x seconds.
 *   timeBufferInSeconds: number;
 *   // This is a buffer in basis points e.g. x%.
 *   // To be considered as a new winning bid, a bid must be at least x% greater than
 *   // the current winning bid.
 *   bidBufferBps: number;
 *   // The start time of the auction.
 *   startTimeInSeconds: number;
 *   // The end time of the auction.
 *   endTimeInSeconds: number;
 *   // The asset being auctioned.
 *   asset: NFTMetadata;
 *   // Whether the listing is CREATED, COMPLETED, or CANCELLED.
 *   status: Status;
 * }
 * ```
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useEnglishAuction(contract, auctionId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.englishAuctions.getAuction(contractAddress, auctionId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(auctionId, "No auction id provided");
    return contract.englishAuctions.getAuction(auctionId);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook for getting all listings (including expired ones) from a `Marketplace` contract.
 *
 * __This hook is only available for `Marketplace` contracts__
 *
 * If you are using [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3),
 * use `useDirectListings` or `useEnglishAuctions` instead.
 *
 * @example
 * ```jsx
 * import { useContract, useListings } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useListings(contract);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace contract
 *
 * @param filter - filter to pass to the query for the sake of pagination & filtering
 * ```jsx
 * import { useContract, useListings } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useListings(
 *     contract,
 *     {
 *       count: 100, // number of listings to fetch
 *       offeror: "{{offeror_address}}", // only show listings with offers from this address
 *       seller: "{{seller_address}}", // only show listings where this address is the seller
 *       start: 0, // start at this listing index (pagination)
 *       tokenContract: "{{token_contract_address}}", // only show listings from this collection
 *       tokenId: "{{token_id}}", // only show listings for this token
 *     },
 *   );
 * }
 * ```
 *
 * @returns Query result object that includes an array of listings
 *
 * The hook's `data` property, once loaded, is an array of listing objects.
 *
 * The exact shape of each object depends on the type of listing.
 *
 * For auctions, it will be a
 * `AuctionListing` object.
 * For direct listings, it will be a `DirectListing` object.
 *
 * ```ts
 * (AuctionListing | DirectListing)[] | undefined;
 * ```
 *
 * You can use the shared `type` property to determine which type of listing is being returned.
 *
 * ```ts
 * interface AuctionListing {
 *
 *    // The id of the listing
 *   id: string;
 *
 *    // The address of the asset being listed.
 *   assetContractAddress: string;
 *
 *    // The ID of the token to list.
 *   tokenId: BigNumberish;
 *
 *    // The asset being listed.
 *   asset: NFTMetadata;
 *
 *    // The start time of the listing.
 *   startTimeInEpochSeconds: BigNumberish;
 *
 *    // Number of seconds until the auction expires.
 *   endTimeInEpochSeconds: BigNumberish;
 *
 *    // The quantity of tokens to include in the listing.
 *    // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: BigNumberish;
 *
 *    // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *
 *    // The reserve price is the minimum price that a bid must be in order to be accepted.
 *   reservePrice: BigNumber;
 *
 *    // The buyout price of the listing.
 *   buyoutPrice: BigNumber;
 *
 *    // The `CurrencyValue` of the buyout price listing.
 *    // Useful for displaying the price information.
 *   buyoutCurrencyValuePerToken: CurrencyValue;
 *
 *    // The `CurrencyValue` of the reserve price.
 *    // Useful for displaying the price information.
 *   reservePriceCurrencyValuePerToken: CurrencyValue;
 *
 *    // The address of the seller.
 *   sellerAddress: string;
 *
 *   // type of listing
 *   type: ListingType.Auction;
 * }
 *
 * interface DirectListing {
 *
 *    // The id of the listing.
 *   id: string;
 *
 *    // The address of the asset being listed.
 *   assetContractAddress: string;
 *
 *    // The ID of the token to list.
 *   tokenId: BigNumberish;
 *
 *    // The asset being listed.
 *   asset: NFTMetadata;
 *
 *    // The start time of the listing.
 *   startTimeInSeconds: BigNumberish;
 *
 *    // Number of seconds until the listing expires.
 *   secondsUntilEnd: BigNumberish;
 *
 *    // The quantity of tokens to include in the listing.
 *    // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: BigNumberish;
 *
 *    // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *
 *    // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   buyoutCurrencyValuePerToken: CurrencyValue;
 *
 *    // The buyout price of the listing.
 *   buyoutPrice: BigNumber;
 *
 *    // The address of the seller.
 *   sellerAddress: string;
 *
 *   // type of listing
 *   type: ListingType.Direct;
 * ```
 *
 * @marketplace
 */
function useListings(contract, filter) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getAllListings(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getAllListings(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook to get all the direct listings from a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * __This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For `Marketplace` contracts, use `useListings` instead.
 *
 * @example
 * ```jsx
 * import { useDirectListings, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: directListings,
 *     isLoading,
 *     error,
 *   } = useDirectListings(contract);
 * }
 * ```
 *
 *
 * @param contract - Instance of a `MarketplaceV3` contract
 *
 * @param filter -
 * filter to pass to the query for the sake of pagination & filtering
 *
 * ```tsx
 * import { useDirectListings, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: directListings,
 *     isLoading,
 *     error,
 *   } = useDirectListings(
 *     contract,
 *     {
 *       count: 100, // Number of listings to fetch
 *       offeror: "{{offeror_address}}", // Has offers from this address
 *       seller: "{{seller_address}}", // Being sold by this address
 *       start: 0, // Start from this index (pagination)
 *       tokenContract: "{{token_contract_address}}", // Only show listings for NFTs from this collection
 *       tokenId: "{{token_id}}", // Only show listings with this NFT ID
 *     },
 *   );
 * }
 * ```
 *
 * @returns
 * The hook's data property, once loaded, is a `DirectListingV3` object, containing the following properties:
 *
 * ```ts
 * {
 *   // The id of the listing.
 *   id: string;
 *   // The address of the creator of listing.
 *   creatorAddress: string;
 *   // The address of the asset being listed.
 *   assetContractAddress: string;
 *   // The ID of the token to list.
 *   tokenId: string;
 *   // The quantity of tokens to include in the listing.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: string;
 *   // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *   // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   currencyValuePerToken: CurrencyValue;
 *   // The price to pay per unit of NFTs listed.
 *   pricePerToken: string;
 *   // The asset being listed.
 *   asset: NFTMetadata;
 *   // The start time of the listing.
 *   startTimeInSeconds: number;
 *   // The end time of the listing.
 *   endTimeInSeconds: number;
 *   // Whether the listing is reserved to be bought from a specific set of buyers.
 *   isReservedListing: boolean;
 *   // Whether the listing is CREATED, COMPLETED, or CANCELLED.
 *   status: Status;
 * }
 * ```
 *
 * @twfeature DirectListings
 * @marketplace
 */
function useDirectListings(contract, filter) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.directListings.getAll(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.directListings.getAll(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook to get a list of valid direct listings from a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * A listing is considered valid if the:
 *
 * - Seller still owns the NFT
 * - Listing has not expired (time is before `endTimeInSeconds`)
 * - Listing has not been canceled
 * - Listing has not been bought out (all `quantity` of the NFTs have not been purchased)
 *
 *
 * **Note: This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.**
 *
 * For `Marketplace` contracts, use `useActiveListings` instead.
 *
 * @example
 * ```jsx
 * import { useValidDirectListings, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: directListings,
 *     isLoading,
 *     error,
 *   } = useValidDirectListings(contract);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace v3 contract
 *
 * @param filter - filter to pass to the query for the sake of pagination & filtering
 * ```jsx
 * import { useValidDirectListings, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: directListings,
 *     isLoading,
 *     error,
 *   } = useValidDirectListings(
 *     contract,
 *     {
 *       count: 100, // Number of listings to fetch
 *       offeror: "{{offeror_address}}", // Has offers from this address
 *       seller: "{{seller_address}}", // Being sold by this address
 *       start: 0, // Start from this index (pagination)
 *       tokenContract: "{{token_contract_address}}", // Only show NFTs from this collection
 *       tokenId: "{{token_id}}", // Only show NFTs with this token ID
 *     },
 *   );
 * }
 * ```
 *
 * @returns
 * The hook's `data` property, once loaded, is an array of `DirectListingV3` objects, each containing the following properties:
 *
 * ```ts
 * Array<{
 *   // The id of the listing.
 *   id: string;
 *
 *   // The address of the creator of listing.
 *   creatorAddress: string;
 *
 *   // The address of the asset being listed.
 *   assetContractAddress: string;
 *
 *   // The ID of the token to list.
 *   tokenId: string;
 *
 *   // The quantity of tokens to include in the listing.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: string;
 *
 *   // The address of the currency to accept for the listing.
 *   currencyContractAddress: string;
 *
 *   // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   currencyValuePerToken: CurrencyValue;
 *
 *   // The price to pay per unit of NFTs listed.
 *   pricePerToken: string;
 *
 *   // The asset being listed.
 *   asset: NFTMetadata;
 *
 *   // The start time of the listing.
 *   startTimeInSeconds: number;
 *
 *   // The end time of the listing.
 *   endTimeInSeconds: number;
 *
 *   // Whether the listing is reserved to be bought from a specific set of buyers.
 *   isReservedListing: boolean;
 *
 *   // Whether the listing is CREATED, COMPLETED, or CANCELLED.
 *   status: Status;
 * }>;
 * ```
 *
 * @twfeature DirectListings
 * @marketplace
 */
function useValidDirectListings(contract, filter) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.directListings.getAllValid(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.directListings.getAllValid(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook to get a list of all English auctions from a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * **Note: This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.**
 *
 * For `Marketplace` contracts, use `useListings` instead.
 *
 * @example
 *
 * ```jsx
 * import { useEnglishAuctions, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: englishAuctions,
 *     isLoading,
 *     error,
 *   } = useEnglishAuctions(contract);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace v3 contract
 *
 * @param filter -
 * filter to pass to the query for the sake of pagination & filtering
 *
 * ```ts
 * import { useEnglishAuctions, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: englishAuctions,
 *     isLoading,
 *     error,
 *   } = useEnglishAuctions(
 *     contract,
 *     {
 *       count: 100, // Number of auctions to fetch
 *       offeror: "{{offeror_address}}", // Has offers from this address
 *       seller: "{{seller_address}}", // Being sold by this address
 *       start: 0, // Start from this index (pagination)
 *       tokenContract: "{{token_contract_address}}", // Only show NFTs from this collection
 *       tokenId: "{{token_id}}", // Only show NFTs with this ID
 *     },
 *   );
 * }
 * ```
 *
 * @returns
 * The hook's data property, once loaded, is an array of EnglishAuction objects, each containing the following properties:
 *
 * ```ts
 * Array<{
 *   // The id of the auction
 *   id: string;
 *
 *   // The address of the creator of auction.
 *   creatorAddress: string;
 *
 *   // The address of the asset being auctioned.
 *   assetContractAddress: string;
 *
 *   // The ID of the token to auction.
 *   tokenId: string;
 *
 *   // The quantity of tokens to include in the auction.
 *   //  For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: string;
 *
 *   // The address of the currency to accept for the auction.
 *   currencyContractAddress: string;
 *
 *   // The minimum price that a bid must be in order to be accepted.
 *   minimumBidAmount: string;
 *
 *   // The `CurrencyValue` of the minimum bid amount.
 *   // Useful for displaying the price information.
 *   minimumBidCurrencyValue: CurrencyValue;
 *
 *   // The buyout price of the auction.
 *   buyoutBidAmount: string;
 *
 *   // The `CurrencyValue` of the buyout price.
 *   // Useful for displaying the price information.
 *   buyoutCurrencyValue: CurrencyValue;
 *
 *   // This is a buffer e.g. x seconds.
 *   // If a new winning bid is made less than x seconds before expirationTimestamp, the
 *   // expirationTimestamp is increased by x seconds.
 *   timeBufferInSeconds: number;
 *
 *   // This is a buffer in basis points e.g. x%.
 *   // To be considered as a new winning bid, a bid must be at least x% greater than
 *   // the current winning bid.
 *   bidBufferBps: number;
 *
 *   // The start time of the auction.
 *   startTimeInSeconds: number;
 *
 *   // The end time of the auction.
 *   endTimeInSeconds: number;
 *
 *   // The asset being auctioned.
 *   asset: NFTMetadata;
 *
 *   // Whether the listing is CREATED, COMPLETED, or CANCELLED.
 *   status: Status;
 * }>;
 * ```
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useEnglishAuctions(contract, filter) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.englishAuctions.getAll(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.englishAuctions.getAll(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook to get all valid English auctions from a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * A listing is considered valid if the:
 *
 * - Auction has not expired (i.e. current time is before the end time of the auction)
 * - Auction has not been canceled
 * - Auction has not been bought out (all quantity has been sold)
 *
 * __This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For [Marketplace](https://thirdweb.com/thirdweb.eth/Marketplace)
 * contracts, use [useActiveListings](/react/react.useactivelistings) instead.
 *
 * @example
 *
 * ```jsx
 * import { useValidEnglishAuctions, useContract } from "@thirdweb-dev/react";
 *
 * // Your smart contract address
 * const contractAddress = "{{contract_address}}";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: englishAuctions,
 *     isLoading,
 *     error,
 *   } = useValidEnglishAuctions(contract);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace v3 contract
 *
 * @param filter -
 * The `filter` object allows you to filter the auctions returned by the hook.
 *
 * ```jsx
 * import { useEnglishAuctions, useContract } from "@thirdweb-dev/react";
 *
 * // Your smart contract address
 * const contractAddress = "{{contract_address}}";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: englishAuctions,
 *     isLoading,
 *     error,
 *   } = useEnglishAuctions(
 *     contract,
 *     // highlight-start
 *     {
 *       count: 100, // Number of auctions to fetch
 *       offeror: "{{offeror_address}}", // Has offers from this address
 *       seller: "{{seller_address}}", // Being sold by this address
 *       start: 0, // Start from this index (pagination)
 *       tokenContract: "{{token_contract_address}}", // Only show NFTs from this collection
 *       tokenId: "{{token_id}}", // Only show NFTs with this ID
 *     },
 *     // highlight-end
 *   );
 * }
 * ```
 *
 * @returns A Query Result object that includes an array of english auctions
 * The hook's `data` property, once loaded, is an
 * array of `EnglishAuction` objects, each containing the following properties:
 *
 * ```ts
 * Array<{
 *   // The id of the auction
 *   id: string;
 *
 *   // The address of the creator of auction.
 *   creatorAddress: string;
 *
 *   // The address of the asset being auctioned.
 *   assetContractAddress: string;
 *
 *   // The ID of the token to auction.
 *   tokenId: string;
 *
 *   // The quantity of tokens to include in the auction.
 *   // For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
 *   quantity: string;
 *
 *   // The address of the currency to accept for the auction.
 *   currencyContractAddress: string;
 *
 *   // The minimum price that a bid must be in order to be accepted.
 *   minimumBidAmount: string;
 *
 *   // The `CurrencyValue` of the minimum bid amount.
 *   // Useful for displaying the price information.
 *   minimumBidCurrencyValue: CurrencyValue;
 *
 *   // The buyout price of the auction.
 *   buyoutBidAmount: string;
 *
 *   // The `CurrencyValue` of the buyout price.
 *   // Useful for displaying the price information.
 *   buyoutCurrencyValue: CurrencyValue;
 *
 *   // This is a buffer e.g. x seconds.
 *   // If a new winning bid is made less than x seconds before expirationTimestamp, the
 *   // expirationTimestamp is increased by x seconds.
 *   timeBufferInSeconds: number;
 *
 *   // This is a buffer in basis points e.g. x%.
 *   // To be considered as a new winning bid, a bid must be at least x% greater than
 *   // the current winning bid.
 *   bidBufferBps: number;
 *
 *   // The start time of the auction.
 *   startTimeInSeconds: number;
 *
 *   // The end time of the auction.
 *   endTimeInSeconds: number;
 *
 *   // The asset being auctioned.
 *   asset: NFTMetadata;
 *
 *   // Whether the listing is CREATED, COMPLETED, or CANCELLED.
 *   status: Status;
 * }>;
 * ```
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useValidEnglishAuctions(contract, filter) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.englishAuctions.getAllValid(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.englishAuctions.getAllValid(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook for getting the total number of listings on a `Marketplace` contract.
 *
 * __This hook is only available for `Marketplace` contracts__
 *
 * If you are using [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3),
 * use `useDirectListingsCount` or `useEnglishAuctionsCount` instead.
 *
 * @example
 * ```jsx
 * import { useContract, useListingsCount } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data: listingsCount, isLoading, error } = useListingsCount(contract);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace contract
 *
 * @returns
 * The hook's `data` property, once loaded, is a `BigNumber` containing the total number of listings on the contract.
 *
 * @marketplace
 */
function useListingsCount(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getTotalCount(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getTotalCount();
  }, {
    enabled: !!contract
  });
}

/**
 * Hook to get the total number of direct listings on a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * __This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For `Marketplace` contracts, use `useListingsCount` instead.
 *
 * @example
 * ```jsx
 * import { useDirectListingsCount, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: listingsCount,
 *     isLoading,
 *     error,
 *   } = useDirectListingsCount(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `MarketplaceV3` contract
 *
 * @returns
 * The hook's `data` property, once loaded, is a `BigNumber` containing the number of direct listings on the Marketplace V3 contract.
 *
 * @twfeature DirectListings
 * @marketplace
 */
function useDirectListingsCount(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.directListings.getTotalCount(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.directListings.getTotalCount();
  }, {
    enabled: !!contract
  });
}

/**
 * Hook to get the total number of direct listings on a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * __This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For `Marketplace` contracts, use `useListingsCount` instead.
 *
 * @example
 * ```jsx
 * import { useEnglishAuctionsCount, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: englishAuctionsCount,
 *     isLoading,
 *     error,
 *   } = useEnglishAuctionsCount(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `MarketplaceV3` contract
 *
 * @returns
 * The hook's `data` property, once loaded, is a `BigNumber` representing the number of direct listings on the Marketplace V3 contract.
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useEnglishAuctionsCount(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.englishAuctions.getTotalCount(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.englishAuctions.getTotalCount();
  }, {
    enabled: !!contract
  });
}

/**
 * Hook for fetching all active listings from a `Marketplace` contract.
 *
 * __Note: This hook is only for Marketplace contracts. For Marketplace V3 contracts, use `useValidDirectListings` or `useValidEnglishAuctions` instead__
 *
 *
 * @example
 * ```javascript
 * import { useActiveListings, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useActiveListings(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 * @param filter -
 * By default, the hook returns all active listings from the marketplace.
 *
 * You can filter the results by providing a filter object as the second argument for the sake of pagination & filtering
 *
 * ```tsx
 * import { useActiveListings, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *
 *   const { data, isLoading, error } = useActiveListings(
 *     contract,
 *     {
 *       seller: "{{wallet_address}}", // Filter by seller
 *       tokenContract: "{{contract_address}}", // Filter by token contract
 *       offeror: "{{wallet_address}}", // Filter by offeror
 *       tokenId: "{{token_id}}", // Filter by token ID
 *       count: 10, // Limit the number of results
 *       start: 0, // Start from the nth result (useful for pagination)
 *     },
 *   );
 * }
 * ```
 *
 * @returns
 * The hook's `data` property, once loaded, returns an array containing both `AuctionListing` and `DirectListing` objects.
 *
 * Use the `type` property to determine which type of listing each one is.
 *
 * #### AuctionListing
 *
 * ```ts
 * {
 *     // The id of the listing
 *     id: string;
 *
 *     // The address of the asset being listed.
 *     assetContractAddress: string;
 *
 *     // The ID of the token to list.
 *     tokenId: BigNumberish;
 *
 *     // The asset being listed.
 *     asset: NFTMetadata;
 *
 *     // The start time of the listing.
 *     startTimeInEpochSeconds: BigNumberish;
 *
 *     // Number of seconds until the auction expires.
 *     endTimeInEpochSeconds: BigNumberish;
 *
 *     // The quantity of tokens in the listing.
 *     // For ERC721s, this value should always be 1
 *     quantity: BigNumberish;
 *
 *     // The address of the currency to accept for the listing.
 *     currencyContractAddress: string;
 *
 *     // The reserve price is the minimum price that a bid must be in order to be accepted.
 *     reservePrice: BigNumber;
 *
 *     // The buyout price of the listing.
 *     buyoutPrice: BigNumber;
 *
 *     // The `CurrencyValue` of the buyout price listing.
 *     // Useful for displaying the price information.
 *     buyoutCurrencyValuePerToken: CurrencyValue;
 *
 *     // The `CurrencyValue` of the reserve price.
 *     // Useful for displaying the price information.
 *     reservePriceCurrencyValuePerToken: CurrencyValue;
 *
 *     // The address of the seller.
 *     sellerAddress: string;
 *
 *     // Listing type Enum
 *     type: ListingType.Auction;
 * }
 * ```
 *
 * ### DirectListing
 *
 * ```ts
 * {
 *     // The id of the listing.
 *     id: string;
 *
 *     //The address of the asset being listed.
 *     assetContractAddress: string;
 *
 *     // The ID of the token to list.
 *     tokenId: BigNumberish;
 *
 *     //The asset being listed.
 *     asset: NFTMetadata;
 *
 *     //The start time of the listing.
 *     startTimeInSeconds: BigNumberish;
 *
 *     //Number of seconds until the listing expires.
 *     secondsUntilEnd: BigNumberish;
 *
 *     // The quantity of tokens to include in the listing.
 *     // For ERC721s, this value should always be 1
 *     quantity: BigNumberish;
 *
 *     // The address of the currency to accept for the listing.
 *     currencyContractAddress: string;
 *
 *     // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *     buyoutCurrencyValuePerToken: CurrencyValue;
 *
 *     // The buyout price of the listing.
 *     buyoutPrice: BigNumber;
 *
 *     // The address of the seller.
 *     sellerAddress: string;
 *
 *     // Listing type Enum
 *     type: ListingType.Direct;
 * }
 * ```
 *
 * @marketplace
 */
function useActiveListings(contract, filter) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getActiveListings(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getActiveListings(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}

/**
 * Hook for getting the winning bid of an auction listing on a `Marketplace` contract.
 *
 * @example
 *
 * ```jsx
 * import { useContract, useWinningBid } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useWinningBid(contract, listingId);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace contract
 *
 * @param listingId -
 * The ID of the listing to get the winning bid for.
 * If the listing cannot be found, is not an auction listing, or is not active, the `error` property will be set.
 *
 * @returns
 * Query result object that includes the `Offer` that is winning the auction
 * The hook's `data` property, once loaded, is an object of type `Offer`, or `undefined` if no winning bid exists.
 *
 * ```ts
 * {
 *    // The id of the listing.
 *   listingId: BigNumberish;
 *
 *    // The address of the buyer who made the offer.
 *   buyerAddress: string;
 *
 *    // The quantity of tokens to be bought.
 *   quantityDesired: BigNumberish;
 *
 *    // The amount of coins offered per token.
 *   pricePerToken: BigNumber;
 *
 *    // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   currencyValue: CurrencyValue;
 *
 *    // The currency contract address of the offer token.
 *   currencyContractAddress: string;
 * } | undefined;
 * ```
 *
 * @marketplace
 */
function useWinningBid(contract, listingId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinningBid(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    invariant__default["default"](contract.auction.getWinningBid, "contract does not support auction.getWinningBid");
    return contract.auction.getWinningBid(listingId);
  }, {
    enabled: !!contract && listingId !== undefined
  });
}

/**
 * Hook to get the winning bid for an English auction listing from a
 * [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * @example
 * ```jsx
 * import { useEnglishAuctionWinningBid, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     data: winningBid,
 *     isLoading,
 *     error,
 *   } = useEnglishAuctionWinningBid(contract, listingId);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace contract
 *
 * @param auctionId - The auction id to check
 * If the listing cannot be found, or is not an English auction, the `error` property will be set.
 *
 * @returns
 * If there are no bids, the `data` property will be `undefined`. Use the `isLoading` property to differentiate between
 * the loading state and the no bids state.
 *
 * If there is a bid, the hook's `data` property, once loaded, will be an object of type `Bid`, containing the following properties:
 *
 * ```ts
 * {
 *   // The id of the auction.
 *   auctionId: string;
 *   // The address of the buyer who made the offer.
 *   bidderAddress: string;
 *   // The currency contract address of the offer token.
 *   currencyContractAddress: string;
 *   // The amount of coins offered per token.
 *   bidAmount: string;
 *   // The `CurrencyValue` of the listing. Useful for displaying the price information.
 *   bidAmountCurrencyValue: {
 *     symbol: string;
 *     value: BigNumber;
 *     name: string;
 *     decimals: number;
 *     displayValue: string;
 *   }
 * }
 * ```
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useEnglishAuctionWinningBid(contract, auctionId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.englishAuctions.getWinningBid(contractAddress, auctionId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(auctionId, "No auction id provided");
    invariant__default["default"](contract.englishAuctions.getWinningBid, "contract does not support englishAuctions.getWinningBid");
    return contract.englishAuctions.getWinningBid(auctionId);
  }, {
    enabled: !!contract && auctionId !== undefined
  });
}

/**
 * Hook for getting the winner of an auction (or english auction) on a `Marketplace` or [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * @example
 * ```javascript
 * import { useAuctionWinner, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useAuctionWinner(
 *     contract,
 *     listingId, // The listing id of the item that you want to get the auction winner for
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` or `MarketplaceV3` contract
 *
 * @param listingId -
 * The listing ID of the item that you want to get the auction winner for.
 *
 * The listing must be an auction (or english auction) listing, the hook will populate the error property if it is not.
 *
 * @returns
 * The hook's `data` property, once loaded, contains a `string` representing the address of the auction winner, or `undefined` if there is no winner.
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useAuctionWinner(contract, listingId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinner(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    const isV1 = isMarketplaceV1(contract);
    if (isV1) {
      invariant__default["default"](contract.auction.getWinner, "contract does not support auction.getWinner");
      return contract.auction.getWinner(listingId);
    } else if (!isV1) {
      invariant__default["default"](contract.englishAuctions.getWinner, "contract does not support englishAuctions.getWinner");
      return contract.englishAuctions.getWinner(listingId);
    }
    invariant__default["default"](false, "Contract is not a valid marketplace contract");
  }, {
    enabled: !!contract && listingId !== undefined
  });
}

/**
 * Hook for determining the current bid buffer on a `Marketplace` or [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * The bid buffer is what percentage higher the next bid must be than the current highest bid, or the starting price if there are no bids.
 *
 * @example
 * ```javascript
 * import { useBidBuffer, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const {
 *     data: bidBuffer,
 *     isLoading,
 *     error,
 *   } = useBidBuffer(contract, listingId);
 * ```
 *
 * @param contract - Instance of a `Marketplace` or `MarketplaceV3` contract
 *
 * @param listingId -
 * The listing ID of the item that you want to get the bid buffer for.
 * The listing must be an auction (or english auction) listing, the hook will populate the `error` property if it is not.
 *
 * @returns
 * The hook's `data` property, once loaded, returns a `BigNumber` value representing the current bid buffer.
 *
 * The `bidBuffer` value returned is in percentage format.
 * For example, a value of `500` means that the next bid must be 5% higher than the current highest bid.
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useBidBuffer(contract, listingId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getBidBufferBps(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    const isV1 = isMarketplaceV1(contract);
    if (isV1) {
      invariant__default["default"](contract.getBidBufferBps, "contract does not support getBidBufferBps");
      return contract.getBidBufferBps();
    } else if (!isV1) {
      invariant__default["default"](contract.englishAuctions.getBidBufferBps, "contract does not support englishAuctions.getBidBufferBps");
      requiredParamInvariant(listingId, "No listing id provided");
      return ethers.BigNumber.from(contract.englishAuctions.getBidBufferBps(listingId));
    }
    invariant__default["default"](false, "Contract is not a valid marketplace contract");
  }, {
    enabled: !!contract
  });
}

/**
 * Hook for getting the minimum value a bid must be to be valid
 * in an auction listing on a `Marketplace` or
 * [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * Takes into account the current highest bid, or the reserve price if there is no bid,
 * and increments it by the bid buffer to calculate the minimum next bid.
 *
 * @example
 * ```jsx
 * import { useContract, useMinimumNextBid } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data, isLoading, error } = useMinimumNextBid(contract, listingId);
 * }
 * ```
 *
 * @param contract - Instance of a marketplace contract
 *
 * @param listingId -
 * The ID of the listing to get the minimum next bid for.
 *
 * If the listing cannot be found, is not an auction listing, or is not active, the `error` property will be set.
 *
 * @returns Query result object that includes the minimum next bid for the auction listing
 * @twfeature EnglishAuction
 * @marketplace
 */
function useMinimumNextBid(contract, listingId) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getMinimumNextBid(contractAddress, listingId), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    const isV1 = isMarketplaceV1(contract);
    if (isV1) {
      invariant__default["default"](contract.auction.getMinimumNextBid, "contract does not support auction.getMinimumNextBid");
      return contract.auction.getMinimumNextBid(listingId);
    } else if (!isV1) {
      invariant__default["default"](contract.englishAuctions.getMinimumNextBid, "contract does not support englishAuctions.getMinimumNextBid");
      return contract.englishAuctions.getMinimumNextBid(listingId);
    }
    invariant__default["default"](false, "Contract is not a valid marketplace contract");
  }, {
    enabled: !!contract && listingId !== undefined
  });
}

/**
 * Hook for getting all of the offers made on a
 * direct listing on a `Marketplace` contract.
 *
 * @example
 * ```jsx
 * import { useOffers, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { data: offers, isLoading, error } = useOffers(contract, listingId);
 * }
 * ```
 *
 * @param contract - Instance of a Marketplace contract
 *
 * @param listingId - The id of the listing to fetch offers for
 * If the listing cannot be found, is not a direct listing, or is not active, the `error` property will be set.
 *
 * @returns
 * This hook uses the `useEvents` hook under the hood to fetch `NewOffer` events for the given listing ID.
 *
 * The return value is an array of `NewOffer` event objects. Each event object has the following properties:
 *
 * ```ts
 * {
 *   offeror: string;
 *   offerId: BigNumber;
 *   assetContract: string;
 *   offer: {
 *     offerId: BigNumber;
 *     offeror: string;
 *     assetContract: string;
 *     tokenId: BigNumber;
 *     quantity: BigNumber;
 *     currency: string;
 *     totalPrice: BigNumber;
 *     expirationTimestamp: BigNumber;
 *     tokenType: "ERC721" | "ERC1155";
 *     status: "UNSET" | "CREATED" | "COMPLETED" | "CANCELLED";
 *   }
 * }
 * ```
 *
 * @marketplace
 */
function useOffers(contract, listingId) {
  const result = useContractEvents(contract, "NewOffer");
  return {
    ...result,
    data: result.data?.filter(ev => ev.data.listingId.eq(listingId))?.map(ev => ev.data)
  };
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/

/**
 * Hook for creating a new direct listing on a `Marketplace`
 * or [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) smart contract.
 *
 * Direct listings require the user to approve the marketplace to transfer the NFTs on their behalf as part of the listing creation process.
 * This is because the marketplace needs permission to execute sales and transfer the NFTs to the buyer when a sale is made.
 *
 * @example
 * ```jsx
 * import {
 *   useCreateDirectListing,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     mutateAsync: createDirectListing,
 *     isLoading,
 *     error,
 *   } = useCreateDirectListing(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         createDirectListing({
 *           assetContractAddress: "{{asset_contract_address}}",
 *           tokenId: "{{token_id}}",
 *           pricePerToken: "{{price_per_token}}",
 *           currencyContractAddress: "{{currency_contract_address}}",
 *           isReservedListing: false,
 *           quantity: "{{quantity}}",
 *           startTimestamp: new Date(),
 *           endTimestamp: new Date(
 *             new Date().getTime() + 7 * 24 * 60 * 60 * 1000,
 *           ),
 *         })
 *       }
 *     >
 *       Create Direct Listing
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a Marketplace contract
 *
 * @returns Mutation object to create a new direct listing
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useCreateDirectListing(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### assetContractAddress (required)
 * The address of the NFT smart contract that you want to list.
 *
 * #### tokenId (required)
 * The token ID of the NFT that you want to list.
 *
 * #### pricePerToken (required)
 * The price to **buy** each token in the listing.
 *
 * - For ERC721 NFTs, this is the price to buy the NFT outright.
 * - For ERC1155 NFTs, this is the price to `1` quantity of the NFT.
 *
 * #### currencyContractAddress (optional)
 * The address of the currency you want users to pay with and make bids in.
 *
 * You likely want to use the token native to the chain you are on, e.g. Ether on Ethereum.
 *
 * To do that, you can import the `NATIVE_TOKEN_ADDRESS` constant from `@thirdweb-dev/sdk`.
 *
 * The default value is `NATIVE_TOKEN_ADDRESS`.
 *
 * #### isReservedListing (optional)
 * When set to true, the seller must explicitly approve which wallet addresses can buy the NFT.
 *
 * #### quantity (optional)
 * How many tokens to include in the listing.
 *
 * - For ERC721 NFTs, this is always `1`.
 * - For ERC1155 NFTs, this is the quantity of tokens to include in the listing.
 *
 * #### startTimestamp (optional)
 * A `Date` object for the start time of the listing.
 *
 * The default value is `new Date()`, which is the current time.
 *
 * #### endTimestamp (optional)
 * A `Date` object for the end time of the listing (when the listing will expire).
 *
 * @twfeature DirectListings
 * @marketplace
 */
function useCreateDirectListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "No wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    const isV1 = isMarketplaceV1(contract);
    if (isV1) {
      invariant__default["default"](contract.direct.createListing, "contract does not support direct.createListing");
      return await contract.direct.createListing(data);
    } else if (!isV1) {
      invariant__default["default"](contract.directListings.createListing, "contract does not support directListings.createListing");
      return await contract.directListings.createListing(data);
    }
    invariant__default["default"](false, "Contract is not a valid marketplace contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Create multiple direct listings in one batch
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract("{{contract_address}}");
 *   const {
 *     mutate: createDirectListingBatch,
 *     isLoading,
 *     error,
 *   } = useCreateDirectListingBatch(contract);
 *
 *   if (error) {
 *     console.error("failed to create direct listing batch", error);
 *   }
 *   
 *   // Sample data
 *   const directListingData = [
 *     {
 *       assetContractAddress: "nft-contract-address",
 *       tokenId: "token-id-1",
 *       quantity: "quantity-1",
 *       currencyContractAddress: "currency-address",
 *       pricePerToken: 1
 *     },
 *     {
 *       assetContractAddress: "nft-contract-address",
 *       tokenId: "token-id-2",
 *       quantity: 1,
 *       currencyContractAddress: "currency-address",
 *       pricePerToken: 0
 *     },
 *   ];
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => createDirectListingBatch(directListingData)}
 *     >
 *       Create batch Direct Listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to create a new batch of direct listings
 * @twfeature DirectListings
 */
function useCreateDirectListingBatch(contract) {
  const contractAddress = contract?.getAddress();
  const activeChainId = useSDKChainId();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](walletAddress, "No wallet connected, cannot create listing");
    invariant__default["default"](contract.directListings.createListingsBatch, "contract does not support directListings.createListingsBatch");
    return await contract.directListings.createListingsBatch(data);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for creating an auction listing on a `Marketplace` or
 * [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) smart contract.
 *
 * Auction listings hold the NFTs in escrow; requiring the seller to transfer the NFTs to the marketplace contract
 * as part of the listing creation process.
 *
 * Provide your `Marketplace`
 * or
 * [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3)
 * contract as the argument to the hook.
 *
 * Then, provide the information about the listing you want to create as the argument to the mutation.
 *
 * @example
 * ```jsx
 * import {
 *   useCreateAuctionListing,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 * import { NATIVE_TOKEN_ADDRESS } from "@thirdweb-dev/sdk";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     mutateAsync: createAuctionListing,
 *     isLoading,
 *     error,
 *   } = useCreateAuctionListing(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         createAuctionListing({
 *           tokenId: "{{token_id}}", // The ID of the token to list.
 *           assetContractAddress: "{{asset_contract_address}}", // The contract address of the asset being listed.
 *           currencyContractAddress: NATIVE_TOKEN_ADDRESS, // The address of the currency to accept for the listing.
 *           quantity: "{{quantity}}",
 *           startTimestamp: new Date(),
 *           buyoutBidAmount: "{{buyout_bid_amount}}",
 *           minimumBidAmount: "{{minimum_bid_amount}}",
 *           endTimestamp: new Date(),
 *           bidBufferBps: "{{bid_buffer_bps}}",
 *           timeBufferInSeconds: "{{time_buffer_in_seconds}}",
 *         })
 *       }
 *     >
 *       Create Auction Listing
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 *
 * @returns
 * A mutation object to create a new auction listing.
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useCreateAuctionListing(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an object of type `NewAuctionListing` or `EnglishAuctionInputParams` as its argument which contains the following properties:
 *
 * #### tokenId (required)
 * The token ID of the NFT you are listing for auction.
 *
 * #### assetContractAddress (required)
 * The smart contract address of the NFT you are listing for auction.
 *
 * #### buyoutBidAmount (required)
 * The price to **buy** each token in the listing.
 *
 * - For ERC721 NFTs, this is the price to buy the NFT outright.
 * - For ERC1155 NFTs, this is the price to `1` quantity of the NFT.
 *
 * #### currencyContractAddress (optional)
 * The address of the currency you want users to pay with and make bids in.
 *
 * You likely want to use the token native to the chain you are on, e.g. Ether on Ethereum.
 *
 * To do that, you can import the `NATIVE_TOKEN_ADDRESS` constant from `@thirdweb-dev/sdk`.
 *
 * The default value is `NATIVE_TOKEN_ADDRESS`.
 *
 *
 * #### quantity (optional)
 * How many tokens to include in the listing.
 *
 * - For ERC721 NFTs, this is always `1`.
 * - For ERC1155 NFTs, this is the quantity of tokens to include in the listing.
 *
 * The default value is `1`.
 *
 * #### minimumBidAmount (required)
 * The minimum price that a bid must be in order to be placed on the listing, per token.
 *
 * Bids that are lower than the reserve price will be rejected by the contract.
 *
 * The default value is `0`.
 *
 *
 * #### startTimestamp (optional)
 * A `Date` object for the start time of the listing.
 *
 * The default value is `new Date()`, which is the current time.
 *
 *
 * #### endTimestamp (optional)
 * A `Date` object for the end time of the listing (when the listing will expire).
 *
 * #### bidBufferBps (optional)
 * Bid buffer in basis points (1/100th of a percent).
 *
 * The bid buffer is what percentage higher the next bid must be than the current highest bid.
 *
 * For example, if you set a bid buffer of `100`, then the next bid must be at least `1%` higher than the current highest bid.
 *
 * #### timeBufferInSeconds (optional)
 * Time buffer in seconds.
 *
 * The time buffer is how much time is added to the listing when a new bid is placed.
 *
 * This is to prevent users from placing a bid at the last second and winning the auction.
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useCreateAuctionListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    const isV1 = isMarketplaceV1(contract);
    if (isV1) {
      invariant__default["default"](contract.auction.createListing, "contract does not support auction.createListing");
      return await contract.auction.createListing(data);
    } else if (!isV1) {
      invariant__default["default"](contract.englishAuctions.createAuction, "contract does not support englishAuctions.createAuction");
      return await contract.englishAuctions.createAuction(data);
    }
    invariant__default["default"](false, "Contract is not a valid marketplace contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for canceling an existing auction or listing on a `Marketplace` contract.
 *
 * __Auction listings cannot be canceled if a bid has been placed__
 *
 * __This hook is only for `Marketplace` contracts.__
 *
 * For [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3)
 * contracts, use `useCancelDirectListing` or `useCancelEnglishAuction` instead.
 *
 * @example
 * ```jsx
 * import { useCancelListing, useContract, Web3Button } from "@thirdweb-dev/react";
 * import { ListingType } from "@thirdweb-dev/sdk";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const {
 *     mutateAsync: cancelListing,
 *     isLoading,
 *     error,
 *   } = useCancelListing(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         cancelListing({
 *           id: "{{listing_id}}",
 *           type: ListingType.Direct, // Direct (0) or Auction (1)
 *         })
 *       }
 *     >
 *       Cancel Listing
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a Marketplace contract
 * @returns
 * Mutation object to cancel a listing.
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useCancelListing(contract);
 * ```
 *
 * The `error` property is set if the listing is not active, or was not created by the wallet.
 *
 * ### options
 *
 * The mutation function takes an object with the following properties as an argument:
 *
 * #### listingId
 * The ID of the listing you want to cancel.
 *
 * #### listingType
 * The type of listing you are canceling. Either `ListingType.Direct` (0) or `ListingType.Auction` (1).
 *
 * @marketplace
 */
function useCancelListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    if (data.type === sdk.ListingType.Auction) {
      invariant__default["default"](contract.auction.cancelListing, "contract does not support auction.cancelListing");
      return await contract.auction.cancelListing(data.id);
    } else {
      invariant__default["default"](contract.direct.cancelListing, "contract does not support direct.cancelListing");
      return await contract.direct.cancelListing(data.id);
    }
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for canceling a direct listing on a [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * Direct listings can be canceled at any time, (unless the listing has already been sold).
 * Only the creator of the listing can cancel it.
 *
 * __Note: This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For `Marketplace` contracts, use `useCancelListing` instead.
 *
 * @example
 * ```jsx
 * import {
 *   useCancelDirectListing,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 * import { ListingType } from "@thirdweb-dev/sdk";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     mutateAsync: cancelDirectListing,
 *     isLoading,
 *     error,
 *   } = useCancelDirectListing(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() => cancelDirectListing(listingId)}
 *     >
 *       Cancel Direct Listing
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `MarketplaceV3` contract
 * @returns Mutation object to cancel a direct listing by passing the ID of the listing you want to cancel.
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useCancelDirectListing(contract);
 * ```
 *
 * The mutation function takes the `listingId` as an argument.
 *
 * The `error` property is set if the listing is not active, or was not created by the wallet
 *
 * ### listingId
 *
 * The ID of the listing you want to cancel.
 *
 * @twfeature DirectListings
 * @marketplace
 */
function useCancelDirectListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async listingId => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    invariant__default["default"](contract.directListings.cancelListing, "contract does not support directListings.cancelListing");
    return await contract.directListings.cancelListing(listingId);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for canceling an english auction on a [MarketplaceV3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contract.
 *
 * __English auctions cannot be canceled if a bid has been placed__
 *
 * __This hook is only for [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) contracts.__
 *
 * For `Marketplace` contracts, use `useCancelListing` instead.
 *
 * @example
 * ```jsx
 * import {
 *   useCancelEnglishAuction,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     mutateAsync: cancelEnglishAuction,
 *     isLoading,
 *     error,
 *   } = useCancelEnglishAuction(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() => cancelEnglishAuction(listingId)}
 *     >
 *       Cancel English Auction
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `MarketplaceV3` contract
 *
 * @returns
 * Mutation object to cancel an english auction
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useCancelEnglishAuction(contract);
 * ```
 *
 * The mutation function takes the `listingId` as an argument.
 *
 * The `error` property is set if the listing is not active, cannot be canceled, or was not created by the wallet.
 *
 * ### listingId
 *
 * The ID of the listing you want to cancel.
 *
 * @twfeature EnglishAuctions
 * @marketplace
 */
function useCancelEnglishAuction(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async auctionId => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(auctionId, "No auction id provided");
    invariant__default["default"](contract.englishAuctions.cancelAuction, "contract does not support englishAuctions.cancelAuction");
    return await contract.englishAuctions.cancelAuction(auctionId);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for placing a bid on a `Marketplace` auction listing.
 *
 * Bids have several important properties:
 *
 * - Cannot be canceled once placed.
 * - Are automatically refunded if they are outbid.
 * - Must be higher than the current highest bid by the percentage defined in the bid buffer.
 * - Must be higher than the reserve price (if there is no bid yet).
 *
 * @example
 * ```jsx
 * import { useMakeBid, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { mutateAsync: makeBid, isLoading, error } = useMakeBid(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         makeBid({
 *           listingId: "1", // ID of the listing to bid on. Must be an auction.
 *           bid: "1", // Uses the currencyContractAddress of the listing.
 *         })
 *       }
 *     >
 *       Make Bid
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 *
 * @returns
 * Mutation object to make a bid on an auction listing
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useMakeBid(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### listingId
 * The ID of the listing to bid on. Must be an auction type listing.
 * (Use `useMakeOffer` for direct listings).
 *
 * If the listing cannot be found, is not an auction, or is not active, the `error` property will be set.
 *
 * #### bid
 * The amount to bid on the listing. Uses the `currencyContractAddress` of the listing.
 *
 * For example, if the listing uses the `NATIVE_TOKEN_ADDRESS` on Ethereum, the bid amount is the amount of ETH to bid. Can be
 * in the form of a number, string, or BigNumber.
 *
 * The bid value **must** be either:
 *
 * - Greater than or equal to the reserve price if there is no current bid.
 * - Greater than the current highest bid by the percentage defined in the bid buffer.
 *
 * Use the `useNextMinimumBid` hook to get the next minimum bid amount required.
 *
 * @marketplace
 */
function useMakeBid(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.auction.makeBid, "contract does not support auction.makeBid");
    return await contract.auction.makeBid(data.listingId, data.bid);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for placing an offer on a `Marketplace` direct listing.
 *
 * @example
 *
 * ```jsx
 * import { useMakeOffer, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { mutateAsync: makeOffer, isLoading, error } = useMakeOffer(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         makeOffer({
 *           listingId: 1, // ID of the listing to make an offer on
 *           pricePerToken: 1, // Price per token to offer (in the listing's currency)
 *           quantity: 1, // Number of NFTs you want to buy (used for ERC1155 NFTs)
 *         })
 *       }
 *     >
 *       Make Bid
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 *
 * @returns Mutation object to make a bid on an auction listing
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useMakeOffer(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### listingId (required)
 * The ID of the listing to make an offer on.
 *
 * If the listing cannot be found, is not a direct listing, or is not active, the `error` property will be set.
 *
 * #### pricePerToken (required)
 * The price to offer per token.
 *
 * - For ERC1155, this is the price to offer per quantity of the NFT (see [`quantity`](#quantity) below).
 * - For ERC721, this is the price to offer to buy the NFT.
 *
 * #### quantity (optional)
 * Used for ERC1155 NFTs, where multiple quantity of the same NFT can be bought at once.
 *
 * This field works with the `pricePerToken` field to calculate the total price of the offer.
 * For example, if you want to buy 5 NFTs at a price of 1 ETH each, you would set `pricePerToken` to `1` and `quantity` to `5`, for a total of `5` ETH as the offer.
 *
 * For ERC721 NFTs, this value is ignored and `1` is used instead.
 *
 * The default value is `1`.
 *
 * @marketplace
 */
function useMakeOffer(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract, "No Contract instance provided");
    return await contract.makeOffer(data.listingId, data.pricePerToken, data.quantity);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for accepting an offer from a direct listing on a `Marketplace` contract.
 *
 * Allows the seller (the user who listed the NFT for sale) to accept an offer on their listing, triggering a sale event, meaning the:
 * - NFT(s) are transferred from the seller to the buyer.
 * - Funds from the offeror are sent to the seller.
 *
 * @example
 * ```tsx
 * import {
 *   useAcceptDirectListingOffer,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const {
 *     mutateAsync: acceptDirectOffer,
 *     isLoading,
 *     error,
 *   } = useAcceptDirectListingOffer(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         acceptDirectOffer({
 *           listingId: "{{listing_id}}",
 *           addressOfOfferor: "{{offeror_address}}",
 *         })
 *       }
 *     >
 *       Accept Offer
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 * @returns  Mutation object to accept an offer on a direct listing
 * ```ts
 * const { mutateAsync, isLoading, error } = useAcceptDirectListingOffer(contract);
 * ```
 *
 * ### options
 *
 * The mutation function accepts an object as argument with the following properties:
 *
 * #### listingId
 * The `listingId` of the listing you wish to accept.
 *
 * #### addressOfOfferor
 * The wallet address of the user who made the offer you wish to accept.
 *
 * The `useContractEvents` hook can be used to read all `NewOffer` events on your `Marketplace` contract.
 *
 * @marketplace
 */
function useAcceptDirectListingOffer(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract?.direct, "No Direct instance provided");
    return await contract.direct.acceptOffer(data.listingId, data.addressOfOfferor);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for executing a sale of an auction listing on a `Marketplace` contract.
 *
 * Triggers a new sale, transferring the NFT(s) to the buyer and the funds to the seller.
 *
 * A sale must be executed when an auction ends, and the auction has a winning bid that was below the buyout price. This means the
 * auction has finished, and the highest bidder has won the auction. **Any wallet** can now execute the sale, transferring the NFT(s)
 * to the buyer and the funds to the seller.
 *
 * @example
 * ```jsx
 * import {
 *   useExecuteAuctionSale,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const {
 *     mutateAsync: executeAuctionSale,
 *     isLoading,
 *     error,
 *   } = useExecuteAuctionSale(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         executeAuctionSale({
 *           // The listingId of the auction to execute
 *           listingId: "{{listing_id}}",
 *         })
 *       }
 *     >
 *       Execute Auction Sale
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 *
 * @returns Mutation object to accept an offer on a direct listing
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useExecuteAuctionSale(contract);
 * ```
 *
 * ### options
 * The mutation function accepts an object as argument with the following properties:
 *
 * #### listingId
 * The ID of the auction listing to execute the sale on. If the listing cannot be found, is not an auction, or is not ready to be executed, the `error` property will be set.
 *
 * @marketplace
 */
function useExecuteAuctionSale(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract?.auction, "No Auction marketplace instance provided");
    return await contract.auction.executeSale(data.listingId);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for buying a listing on a `Marketplace` smart contract.
 *
 * If the listing is in a currency that is not native to the chain (e.g. not Ether on Ethereum), the hook will prompt the user
 * to approve the marketplace contract to spend the currency on their behalf before performing the buy.
 *
 * __This hook is only for `Marketplace` contracts. Not for `MarketplaceV3`__
 *
 * @example
 * ```jsx
 * import { useBuyNow, useContract, Web3Button } from "@thirdweb-dev/react";
 * import { ListingType } from "@thirdweb-dev/sdk";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace");
 *   const { mutateAsync: buyNow, isLoading, error } = useBuyNow(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         buyNow({
 *           id: "{{listing_id}}", // ID of the listing to buy
 *           type: ListingType.Direct, // Direct (0) or Auction (1)
 *           buyAmount: "{{buy_amount}}", // Amount to buy
 *           buyForWallet: "{{wallet_address}}", // Wallet to buy for, defaults to current wallet
 *         })
 *       }
 *     >
 *       Buy Now
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Marketplace` contract
 * @returns Mutation object to buy out an auction listing
 * ```ts
 * const { mutateAsync, isLoading, error } = useBuyNow(contract);
 * ```
 *
 * ## Options
 *
 * The mutation function accepts an object as argument with the following properties:
 *
 * ### id
 *
 * The ID of the listing you want to buy.
 *
 * ### type
 *
 * The type of listing. Either `ListingType.Direct` (0) or `ListingType.Auction` (1).
 *
 * ### buyAmount
 *
 * The amount of tokens you want to buy from the listing.
 *
 * Applicable for ERC1155 listings only, should always be 1 for ERC721 listings.
 *
 * ### buyForWallet (optional)
 *
 * Optionally, specify a different wallet address to buy the listing for.
 *
 * @marketplace
 */
function useBuyNow(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract, "No Contract instance provided");
    if (data.type === sdk.ListingType.Direct) {
      invariant__default["default"](contract.direct.buyoutListing, "contract does not support direct.buyoutListing");
      return await contract.direct.buyoutListing(data.id, data.buyAmount, data.buyForWallet);
    }
    invariant__default["default"](contract.auction.buyoutListing, "contract does not support auction.buyoutListing");
    return await contract.auction.buyoutListing(data.id);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for buying a direct listing on a [Marketplace V3](https://thirdweb.com/thirdweb.eth/MarketplaceV3) smart contract.
 *
 * If the listing is in a currency that is not native to the chain (e.g. not Ether on Ethereum), the hook will prompt the user
 * to approve the marketplace contract to spend the currency on their behalf before performing the buy.
 *
 * ```jsx
 * import { useBuyDirectListing } from "@thirdweb-dev/react";
 *
 * const { mutateAsync, isLoading, error } = useBuyDirectListing(contract);
 * ```
 *
 * @example
 * ```jsx
 * import {
 *   useBuyDirectListing,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 * import { ListingType } from "@thirdweb-dev/sdk";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "marketplace-v3");
 *   const {
 *     mutateAsync: buyDirectListing,
 *     isLoading,
 *     error,
 *   } = useBuyDirectListing(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         buyDirectListing({
 *           listingId: "{{listing_id}}", // ID of the listing to buy
 *           quantity: "1",
 *           buyer: "{{wallet_address}}", // Wallet to buy for
 *         })
 *       }
 *     >
 *       Buy Now
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `MarketplaceV3` contract
 * @returns Mutation object to buy out a direct listing
 * ```ts
 * const { mutateAsync, isLoading, error } = useBuyDirectListing(contract);
 * ```
 *
 * ## Options
 *
 * The mutation function accepts an object as argument with the following properties:
 *
 * ### listingId
 *
 * The ID of the direct listing you want to buy.
 *
 * ### quantity
 *
 * The amount of tokens you want to buy from the listing.
 *
 * Applicable for ERC1155 listings only, should always be `1` for ERC721 listings.
 *
 * ### buyer
 *
 * Specify a different wallet address to buy the listing for.
 *
 * @marketplace
 */
function useBuyDirectListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const walletAddress = useAddress();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](walletAddress, "no wallet connected, cannot buy from listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.directListings.buyFromListing, "contract does not support directListings.buyFromListing");
    return await contract.directListings.buyFromListing(data.listingId, data.quantity, data.buyer);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function isMarketplaceV1(contract) {
  return contract.getAllListings !== undefined;
}

/** **********************/
/**     READ  HOOKS     **/
/** **********************/

/**
 * Hook for fetching information about an NFT from a smart contract.
 *
 * Available to use on smart contracts that implement the [`ERC721`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * or [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * NFT metadata is automatically fetched from where the `tokenUri` is hosted (e.g. IPFS), and makes the `image`
 * property available as a URL through our IPFS gateway (if the image is hosted on IPFS).
 *
 * @example
 *
 * Provide your NFT collection contract object and the token ID of the NFT you want to fetch as
 * arguments.
 *
 * ```jsx
 * import { useContract, useNFT } from "@thirdweb-dev/react";
 *
 * // The token ID of the NFT you want to fetch
 * const tokenId = 0;
 *
 * function App() {
 *   const { contract } = useContract("{{contract_address}}");
 *   const { data: nft, isLoading, error } = useNFT(contract, tokenId);
 *
 *   if (isLoading) return <div>Fetching NFT…</div>;
 *   if (error) return <div>Error fetching NFT</div>;
 *   if (!nft) return <div>NFT not found</div>;
 *   return <div>NFT: {nft.metadata.name}</div>;
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 *
 * @param tokenId - The token ID of the NFT you want to fetch.
 * ```jsx
 * import { useContract, useNFT } from "@thirdweb-dev/react";
 *
 * // The token ID of the NFT you want to fetch
 * const tokenId = 0;
 *
 * function App() {
 *   const { contract } = useContract("{{contract_address}}");
 *   const {
 *     data: nft,
 *     isLoading,
 *     error,
 *   } = useNFT(
 *     contract,
 *     tokenId,
 *   );
 * }
 * ```
 *
 * @returns Query result object that includes the metadata for the given tokenId in `data` property
 * @twfeature ERC721 | ERC1155
 * @nft
 */
function useNFT(contract, tokenId) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.get(contractAddress, tokenId), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc1155) {
      invariant__default["default"](erc1155.get, "Contract instance does not support get");
      return await erc1155.get(ethers.BigNumber.from(tokenId || 0));
    }
    if (erc721) {
      invariant__default["default"](erc721.get, "Contract instance does not support get");
      return await erc721.get(ethers.BigNumber.from(tokenId || 0));
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && tokenId !== undefined
  });
}

/**
 * Hook to query all NFTs associated with a smart contract.
 *
 * Available to use on smart contracts that implement the [`ERC721`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * or [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * NFT metadata is automatically fetched from where the `tokenUri` is hosted (e.g. IPFS), and makes the `image`
 * property available as a URL through our IPFS gateway (if the image is hosted on IPFS).
 *
 * By default, only returns the first `100` NFTs in the collection. You can use the `queryParams` argument to
 * filter the NFTs that are returned or to paginate through the collection.
 *
 * @example
 *
 * ```jsx
 * import { useNFTs, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useNFTs(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 *
 * @param queryParams -
 * By default, the hook will return the first 100 NFTs associated with the contract.
 *
 * You can use the `queryParams` argument to paginate the NFTs that are returned.
 *
 * @returns Query result object that includes an array of `NFT` objects
 * @twfeature ERC721Supply | ERC721Enumerable | ERC1155Enumerable
 * @nft
 */
function useNFTs(contract, queryParams) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.all(contractAddress, queryParams), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      invariant__default["default"](erc721.getAll, "Contract instance does not support getAll");
      return await erc721.getAll(queryParams);
    }
    if (erc1155) {
      invariant__default["default"](erc1155.getAll, "Contract instance does not support getAll");
      return await erc1155.getAll(queryParams);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155
  });
}

/**
 * Hook to get the total count of **unique** NFTs minted on a smart contract.
 *
 * Available to use on smart contracts that implement the [`ERC721`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * or [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * When used for ERC1155 contracts, the total count is the number of unique token IDs minted, _not_ the total supply of all tokens in circulation.
 *
 * @example
 * ```jsx
 * import { useTotalCount, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data: totalCount, isLoading, error } = useTotalCount(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 * @returns A `BigNumber` that includes the total count of NFTs
 * @twfeature ERC721Supply | ERC1155Enumerable
 * @nft
 */
function useTotalCount(contract) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCount(contractAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc1155) {
      invariant__default["default"](erc1155.totalCount, "Contract instance does not support totalCount");
      return await erc1155.totalCount();
    }
    if (erc721) {
      invariant__default["default"](erc721.totalCount, "Contract instance does not support totalCount");
      return await erc721.totalCount();
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155
  });
}

/**
 * Hook for fetching the total number of NFTs in circulation for a given smart contract.
 *
 * This takes into account the increase in supply due to minting and the decrease in supply due to burning.
 *
 * Available to use on contracts that implement either the [ERC721](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * or [ERC1155](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * @example
 *
 * ```jsx
 * import { useTotalCirculatingSupply, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useTotalCirculatingSupply(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 *
 * @param tokenId - Required for ERC1155, the tokenId to look up. This will return the total quantity of the given token ID in circulation.
 * ```ts
 * import { useTotalCirculatingSupply, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useTotalCirculatingSupply(
 *     contract,
 *     "{{token_id}}",
 *   );
 * }
 * ```
 *
 * @returns A `BigNumber` representing the total circulating supply.
 *
 * @twfeature ERC721Supply | ERC1155Enumerable
 * @nft
 */
function useTotalCirculatingSupply(contract, tokenId) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCirculatingSupply(contractAddress, tokenId ?? undefined), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc1155) {
      invariant__default["default"](erc1155.totalCirculatingSupply, "Contract instance does not support totalCirculatingSupply");
      requiredParamInvariant(tokenId, "No tokenId provided");
      return await erc1155.totalCirculatingSupply(tokenId);
    }
    if (erc721) {
      invariant__default["default"](erc721.totalCirculatingSupply, "Contract instance does not support totalCirculatingSupply");
      return await erc721.totalCirculatingSupply();
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && tokenId !== undefined
  });
}

/**
 * Hook for accessing a list of NFTs owned by a single wallet address.
 *
 * Available to use on smart contracts that implement either ERC721Enumerable, ERC1155Enumerable, or ERC721Supply extensions.
 *
 * @example
 *
 * ```jsx
 * import { useOwnedNFTs, useContract, useAddress } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const address = useAddress();
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useOwnedNFTs(contract, address);
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 * @param ownerWalletAddress -
 * The wallet address to get owned tokens for. Likely, you will want to view the connected wallet’s NFTs. use the `useAddress` hook to get this value.
 *
 * @param queryParams - 
 * Paginate the results by providing a `queryParams` object as an argument.
 *
 * ```jsx
 * import { useOwnedNFTs, useContract, useAddress } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const address = useAddress();
 *   const { data, isLoading, error } = useOwnedNFTs(
 *     contract,
 *     address
 *     {
 *       count: 10, // Limit the number of results
 *       start: 0, // Start from the nth result (useful for pagination)
 *     },
 *   );
 * }
 * ```
 * 
 * @returns Query result object that includes the list of owned `NFT` objects
 *
 * @twfeature ERC721Enumerable | ERC1155Enumerable | ERC721Supply
 * @nft
 */
function useOwnedNFTs(contract, ownerWalletAddress, queryParams) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.owned.all(contractAddress, ownerWalletAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](ownerWalletAddress, "No wallet address provided");
    if (erc721) {
      return await erc721.getOwned(ownerWalletAddress, queryParams);
    }
    if (erc1155) {
      return await erc1155.getOwned(ownerWalletAddress, queryParams);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: (!!erc721 || !!erc1155) && !!ownerWalletAddress
  });
}

/**
 * Hook to get the quantity a user owns of a specific [ERC1155](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) NFT.
 *
 * Available to use on smart contracts that implement the [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * @example
 * ```jsx
 * import { useNFTBalance, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { isLoading, data, error } = useNFTBalance(
 *     contract,
 *     "{{wallet_address}}",
 *     "{{token_id}}",
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 * @param ownerWalletAddress - The wallet address to check the balance of. Use the `useAddress` hook to get the current wallet address.
 * @param tokenId - Required for ERC1155, the tokenId to look up
 * @returns The hook's `data` property, once loaded, returns a `BigNumber` representing the quantity of the NFT owned by the wallet.
 * @twfeature ERC721 | ERC1155
 * @nft
 */
function useNFTBalance(contract, ownerWalletAddress, tokenId) {
  const contractAddress = contract?.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.balanceOf(contractAddress, ownerWalletAddress, tokenId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](ownerWalletAddress, "No owner wallet address provided");
    if (erc1155) {
      requiredParamInvariant(tokenId, "No tokenId provided");
      invariant__default["default"](erc1155.balanceOf, "Contract instance does not support balanceOf");
      return erc1155.balanceOf(ownerWalletAddress, tokenId);
    }
    if (erc721) {
      invariant__default["default"](erc721.balanceOf, "Contract instance does not support balanceOf");
      return erc721.balanceOf(ownerWalletAddress);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && !!ownerWalletAddress
  });
}

/**
 * Get the shared metadata of an Open Edition NFT contract
 *
 * @example
 * ```javascript
 * const { data: sharedMetadata, isLoading, error } = useSharedMetadata(contract);
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 * @returns Query result object that includes the shared metadata of the contract
 * @twfeature ERC721SharedMetadata
 * @nft
 */
function useSharedMetadata(contract) {
  const contractAddress = contract?.getAddress();
  const {
    erc721
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.sharedMetadata.get(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      invariant__default["default"](erc721.sharedMetadata.get, "Contract instance does not support sharedMetadata.get");
      return erc721.sharedMetadata.get();
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    enabled: !!contract
  });
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/

/**
 * Hook for minting a new NFT on a smart contract.
 *
 * Available to use on smart contracts that implement the [`ERC721`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * or [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * By default, the process uploads and pins the NFT metadata to IPFS before minting.
 *
 * @example
 * ```jsx
 * import { useMintNFT, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: mintNft, isLoading, error } = useMintNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         mintNft({
 *           metadata: {
 *             name: "My NFT",
 *             description: "This is my NFT",
 *             image: "ipfs://example.com/my-nft.png", // Accepts any URL or File type
 *           },
 *           to: "{{wallet_address}}", // Use useAddress hook to get current wallet address
 *         })
 *       }
 *     >
 *       Mint NFT
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 * @returns Mutation object that to mint a new NFT token to the connected wallet
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useMintNFT(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object with the following properties:
 *
 * #### metadata
 * The metadata of the NFT to mint.
 *
 * By default, the `metadata` object is uploaded and pinned to IPFS before minting.
 *
 * You can override this behavior by providing a `string` to the metadata property. The string must be a URL that points to a valid JSON object containing [standard metadata properties](https://docs.opensea.io/docs/metadata-standards)
 *
 * ```jsx
 * import { useMintNFT, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * // Your smart contract address
 * const contractAddress = "{{contract_address}}";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: mintNft, isLoading, error } = useMintNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         mintNft({
 *           // Any valid IPFS or HTTP URL that points to a JSON object
 *           metadata: "https://<url>/<to>/<your>/<metadata>.json",
 *           to: "{{wallet_address}}",
 *         })
 *       }
 *     >
 *       Mint NFT
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * #### to (required)
 * The wallet address to mint the NFT to.
 *
 * Likely, you will want to mint the NFT to the currently connected wallet address.
 * Use the `useAddress` hook to get this value.
 *
 * @twfeature ERC721Mintable | ERC1155Mintable
 * @nft
 */
function useMintNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc1155,
    erc721
  } = getErcs(contract);
  return reactQuery.useMutation(async data => {
    invariant__default["default"](data.to, 'No "to" address provided');
    requiredParamInvariant(contract, "contract is undefined");
    if (erc1155) {
      invariant__default["default"]("supply" in data, "supply not provided");
      const {
        to,
        metadata,
        supply
      } = data;
      return await erc1155.mintTo(to, {
        metadata,
        supply: ethers.BigNumber.from(supply || 1)
      });
    }
    if (erc721) {
      return await erc721.mintTo(data.to, data.metadata);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for minting additional supply to an _existing_ ERC-1155 token.
 *
 * Available to use on contracts that implement the
 * [ERC1155Mintable](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155Mintable)
 * interface, such as the [Edition](https://thirdweb.com/thirdweb.eth/TokenERC1155) or [Edition Drop](https://thirdweb.com/thirdweb.eth/DropERC1155).
 *
 * The wallet address that initiates this transaction must have minting permissions on the contract.
 *
 * @example
 *
 * ```jsx
 * import { useContract, useMintNFTSupply, Web3Button } from "@thirdweb-dev/react";
 *
 * const contractAddress = "{{contract_address}}";
 * const walletAddress = "{{wallet_address}}";
 * const tokenId = "{{token_id}}";
 * const additionalSupply = "{{additional_supply}}";
 *
 * function App() {
 *   // Contract must be an ERC-1155 contract that implements the ERC1155Mintable interface
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: mintNftSupply,
 *     isLoading,
 *     error,
 *   } = useMintNFTSupply(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         mintNftSupply({
 *           additionalSupply: additionalSupply, // Quantity to mint
 *           to: walletAddress, // Address to mint to
 *           tokenId: tokenId, // Token ID to add supply to
 *         })
 *       }
 *     >
 *       Mint NFT Supply
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Erc1155`
 *
 * @returns Mutation object to mint a more supply of a token id to the provided wallet
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useMintNFTSupply(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an object with the following properties:
 *
 * #### additionalSupply
 * The quantity of additional supply to mint.
 *
 * For example, if you have 10 quantity so far, and you want to mint 5 more, set `additionalSupply` to `5`.
 *
 * Can be a `string` or `number`.
 *
 *
 * #### to
 * The wallet address to mint the new supply to.
 *
 * To use the connected wallet address, use the `useAddress` hook.
 *
 *
 * #### tokenId
 * The token ID of the NFT to mint additional supply to.
 *
 * Can be a `string` or `number`.
 *
 * @twfeature ERC1155Mintable
 * @nft
 */
function useMintNFTSupply(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async data => {
    invariant__default["default"](data.to, 'No "to" address provided');
    requiredParamInvariant(contract, "contract is undefined");
    requiredParamInvariant(data.tokenId, "tokenId not provided");
    invariant__default["default"]("additionalSupply" in data, "additionalSupply not provided");
    const {
      to,
      tokenId,
      additionalSupply
    } = data;
    return await contract.mintAdditionalSupplyTo(to, tokenId, additionalSupply);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for transferring ERC721 or ERC1155 NFTs to another wallet address.
 *
 * Available to use on contracts that implement either the
 * [ERC721](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * and [ERC1155](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155)
 * interfaces, such as the [Edition](https://thirdweb.com/thirdweb.eth/TokenERC1155)
 * or [NFT Collection](https://thirdweb.com/thirdweb.eth/TokenERC721).
 *
 * The wallet address that initiates this transaction must have transfer permissions on the contract (i.e. the tokens are not soulbound).
 * It also must have the required amount of token(s) available to transfer.
 *
 * @example
 *
 * ```jsx
 * import { useContract, useTransferNFT, Web3Button } from "@thirdweb-dev/react";
 *
 * // Your NFT collection contract address
 * const contractAddress = "{{contract_address}}";
 * const walletAddress = "{{wallet_address}}";
 * const tokenId = "{{token_id}}";
 *
 * function App() {
 *   // Contract must be an ERC-721 or ERC-1155 contract
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutateAsync: transferNFT,
 *     isLoading,
 *     error,
 *   } = useTransferNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         transferNFT({
 *           to: walletAddress, // Address to transfer the token to
 *           tokenId: tokenId, // Token ID to transfer
 *         })
 *       }
 *     >
 *       Transfer
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 *
 * @returns Mutation object to transfer NFTs
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useTransferNFT(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object with the following properties:
 *
 * #### to
 * The wallet address to transfer the token(s) to.
 *
 * To use the connected wallet address, use the `useAddress` hook.
 *
 *
 * #### tokenId
 * The token ID of the NFT to transfer.
 *
 * Can be a `string` or `number`.
 *
 * #### amount (ERC1155 only)
 * If you are using an ERC1155 contract, specify the amount of tokens to transfer.
 *
 * @twfeature ERC721 | ERC1155
 * @nft
 */
function useTransferNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc1155,
    erc721
  } = getErcs(contract);
  return reactQuery.useMutation(data => {
    invariant__default["default"]("to" in data, "to not provided");
    if (erc1155) {
      invariant__default["default"](erc1155.transfer, "contract does not support transfer");
      requiredParamInvariant(data.tokenId, "tokenId not provided");
      invariant__default["default"]("amount" in data, "amount not provided");
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return erc1155.transfer(data.to, data.tokenId, data.amount);
    }
    if (erc721) {
      return erc721.transfer(data.to, data.tokenId);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for airdropping [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) NFT tokens to multiple wallet addresses at once.
 *
 * Available to use on smart contracts that implement the `ERC1155` standard.
 *
 * Performs a batch transfer from the connected wallet to the specified addresses.
 * This means you need to have the total number of tokens you wish to airdrop available in the wallet that performs this transaction.
 *
 * @example
 * ```jsx
 * import { useAirdropNFT, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: airdropNft, isLoading, error } = useAirdropNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         airdropNft({
 *           addresses: [
 *             {
 *               address: "0x123",
 *               quantity: 1,
 *             },
 *           ],
 *           tokenId: tokenId,
 *         })
 *       }
 *     >
 *       Airdrop NFT
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `Erc1155`
 * @returns Mutation object that to transfer batch NFTs
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useAirdropNFT(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object with the following properties:
 *
 * #### tokenId
 * The token ID of the NFT to airdrop.
 *
 * #### addresses
 * An array of objects containing an `address` and `quantity` of NFTs to airdrop to each address.
 *
 * @twfeature ERC1155
 * @nft
 */
function useAirdropNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(_ref => {
    let {
      tokenId,
      addresses
    } = _ref;
    requiredParamInvariant(contract, "contract is undefined");
    invariant__default["default"](contract.airdrop, "contract does not support airdrop");
    return contract.airdrop(tokenId, addresses);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for burning a NFT on a smart contract.
 *
 * Available to use on smart contracts that implement the [`ERC721`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721)
 * or [`ERC1155`](https://portal.thirdweb.com/contracts/build/extensions/erc-1155/ERC1155) standard.
 *
 * @example
 *
 * ```jsx
 * import { useBurnNFT, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * const contractAddress = "{{contract_address}}";
 * // The tokenId of the NFT you want to burn
 * const tokenIdToBurn = "{{tokenId}}}}";
 * const amount = 1;
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: burnNft, isLoading, error } = useBurnNFT(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         burnNft({
 *           tokenId: tokenIdToBurn,
 *           amount: amount,
 *         })
 *       }
 *     >
 *       Burn NFT
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `NFTContract`
 * @returns Mutation object that to burn an NFT token from the connected wallet
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useBurnNFT(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object with the following properties:
 *
 * #### tokenId
 * The token ID of the NFT you want to burn.
 *
 * #### amount (optional)
 * When using ERC1155 NFTs, you can specify the quantity you want to burn.
 *
 * Defaults value is `1`
 *
 * @twfeature ERC721Burnable | ERC1155Burnable
 * @nft
 */
function useBurnNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc1155,
    erc721
  } = getErcs(contract);
  return reactQuery.useMutation(async data => {
    requiredParamInvariant(data.tokenId, "No tokenId provided");
    requiredParamInvariant(contract, "contract is undefined");
    if (erc1155) {
      invariant__default["default"]("amount" in data, "amount not provided");
      const {
        tokenId,
        amount
      } = data;
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return await erc1155.burn(tokenId, amount);
    }
    if (erc721) {
      const {
        tokenId
      } = data;
      return await erc721.burn(tokenId);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Set shared metadata
 * TODO add docs
 * @internal
 */
function useSetSharedMetadata(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const {
    erc721
  } = getErcs(contract);
  return reactQuery.useMutation(async data => {
    if (erc721) {
      return await erc721.sharedMetadata.set(data);
    }
    invariant__default["default"](false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/
/**         UTILS       **/
/** **********************/

/**
 * @internal
 */

/**
 * @permissionControl
 */

/**
 * @internal
 */

/** **********************/
/**     READ  HOOKS     **/
/** **********************/

/**
 * Hook for getting all wallet addresses that have a role in a smart contract.
 *
 * Available to use on contracts that implement [`Permissions`](https://portal.thirdweb.com/contracts/build/extensions/general/Permissions).
 *
 * @example
 *
 * ```jsx
 * import { useAllRoleMembers, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useAllRoleMembers(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns
 * The hook's `data` property, once loaded, is an object, where the keys are the role names and the values are arrays of wallet addresses that have that role.
 *
 * For example, if the contract has two roles, `admin` and `transfer`, and the `admin` role has two members, the `data` property will look like this:
 *
 * ```ts
 * {
 *   admin: ["0x1234", "0x5678"],
 *   transfer: [],
 * }
 * ```
 *
 * #### Type
 *
 * ```ts
 * Record<
 *   | "admin"
 *   | "transfer"
 *   | "minter"
 *   | "pauser"
 *   | "lister"
 *   | "asset"
 *   | "unwrap"
 *   | "factory"
 *   | (string & {}),
 *   string[]
 * > | undefined;
 * ```
 *
 * @twfeature PermissionsEnumerable
 * @permissionControl
 */
function useAllRoleMembers(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.getAll(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"](contract.roles, "Contract does not support roles");
    // have to cast to any because of role bs, type is defined in the useQueryWithNetwork definition above
    return contract.roles.getAll();
  }, {
    enabled: !!contract && !!contractAddress
  });
}

/**
 * Hook for getting all wallet addresses that have a specific role in a smart contract.
 *
 * Available to use on contracts that implement the [`Permissions`](https://portal.thirdweb.com/contracts/build/extensions/general/Permissions) interface.
 *
 * @example
 * ```jsx
 * import { useContract, useRoleMembers } from "@thirdweb-dev/react";
 *
 * // Your smart contract address (must implement permission controls)
 * const contractAddress = "{{contract_address}}";
 *
 * const roleName = "admin";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useRoleMembers(contract, roleName);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 * @param role -
 *  The name of the role to get the members of
 *
 * Can be any custom role, or a built-in role, such as:
 * - `"admin"`
 * - `"transfer"`
 * - `"minter"`
 * - `"pauser"`
 * - `"lister"`
 * - `"asset"`
 * - `"unwrap"`
 * - `"factory"`
 *
 * @returns The hook's `data` property, once loaded, is an array of wallet addresses that have the specified role
 *
 * @twfeature Permissions
 * @permissionControl
 */
function useRoleMembers(contract, role) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.get(contractAddress, role), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"](contract.roles, "Contract does not support roles");
    return contract.roles.get(role);
  }, {
    enabled: !!contract && !!contractAddress && !!role
  });
}

/**
 * Hook to check if an address is a member of a role on a smart contract.
 *
 * Available to use on contracts that implement [`Permissions`](https://portal.thirdweb.com/contracts/build/extensions/general/Permissions) interface
 *
 * Provide the following arguments to the hook:
 *
 * 1. `contract` - The contract instance to check the role on.
 * 2. `roleName` - The name of the role to check.
 * 3. `address` - The wallet address to see if it is a member of the role.
 *
 * @example
 *
 * ```jsx
 * import { useIsAddressRole, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const isMember = useIsAddressRole(contract, roleName, walletAddress);
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @param role - The name of the role to check. Can be any custom role, or a built-in role, such as:
 * - `"admin"`
 * - `"transfer"`
 * - `"minter"`
 * - `"pauser"`
 * - `"lister"`
 * - `"asset"`
 * - `"unwrap"`
 * - `"factory"`
 *
 * @param walletAddress -
 * The wallet address to check if it is a member of the role.
 * Use the `useAddress` hook to get the current wallet address.
 *
 * @returns `true` if the address is a member of the role, or `false` if not
 *
 * @twfeature PermissionsEnumerable
 * @permissionControl
 */
function useIsAddressRole(contract, role, walletAddress) {
  // TODO this might be possible to do with `verify` fn instead?
  const contractHasRoles = !!(contract && contract.roles);
  const {
    data
  } = useRoleMembers(contractHasRoles ? contract : undefined, role);

  // if the contract does not have roles then everything is allowed === true
  if (contractHasRoles === false) {
    return true;
  }

  // switch logic (if address 0 is in the role list then anyone has permissions to it)
  if (data?.includes(ethers.constants.AddressZero)) {
    return true;
  }

  // actual role check logic
  return !!(walletAddress && data?.includes(walletAddress));
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/

/**
 * Overwrite the list of members for specific roles
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract("{{contract_address}}");
 *   const {
 *     mutate: overwriteRoles,
 *     isLoading,
 *     error,
 *   } = useSetAllRoleMembers(contract);
 *
 *   if (error) {
 *     console.error("failed to overwrite roles", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => overwriteRoles({ rolesWithAddresses: { minter: ["{{wallet_address}"] } })}
 *     >
 *       Overwrite Roles
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 * @returns A mutation object to overwrite all roles on the contract
 * @twfeature Permissions
 * @permissionControl
 */
function useSetAllRoleMembers(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async rolesWithAddresses => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"](contract.roles, "Contract does not support roles");
    await contract.roles.setAll(rolesWithAddresses);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for granting a role on a smart contract.
 *
 * Available to use on smart contracts that implement the [`Permissions`](https://portal.thirdweb.com/contracts/build/extensions/general/Permissions) interface.
 *
 * @example
 * ```jsx
 * import { useGrantRole, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * const contractAddress = "{{contract_address}}";
 * const roleToGrant = "{{role}}";
 * const walletAddressToGrant = "{{wallet_address}}";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: grantRole, isLoading, error } = useGrantRole(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         grantRole({
 *           role: roleToGrant, // name of your role.
 *           address: walletAddressToGrant, // address to grant the role to.
 *         })
 *       }
 *     >
 *       Grant Role
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns A mutation object to grant a member of a role on the contract
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useGrantRole(contract);
 * ```
 *
 * ### options
 * The mutation function accepts an object with the following properties:
 *
 * #### role
 * The name of the role to grant the address.
 *
 * Accepts any `string` value to include custom-defined roles.
 *
 * Also accepts the default roles available on the [prebuilt contracts](https://portal.thirdweb.com/pre-built-contracts):
 *
 * ```ts
 *  string |
 *  "admin" |
 *  "minter" |
 *  "transfer" |
 *  "lister" |
 *  "asset" |
 *  "unwrap" |
 *  "pauser" |
 *  "factory";
 * ```
 *
 * #### address
 * The address to grant the role to.
 *
 * To use the address of the connected wallet, use the `useAddress` hook.
 *
 * @twfeature Permissions | PermissionsEnumerable
 * @permissionControl
 */
function useGrantRole(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async params => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"](contract.roles, "Contract does not support roles");
    await contract.roles.grant(params.role, params.address);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for revoking a wallet address from a role on a smart contract.
 *
 * Available to use on contracts that implement [`Permissions`](https://portal.thirdweb.com/contracts/build/extensions/general/Permissions) interface
 *
 * The wallet address that initiates this transaction must have the relevant permissions on the contract to remove the role from the wallet address (typically `"admin"` level required).
 *
 * ```jsx
 * import { useContract, useRevokeRole, Web3Button } from "@thirdweb-dev/react";
 *
 * // Your smart contract address (must implement permission controls)
 * const contractAddress = "{{contract_address}}";
 * const walletAddress = "{{wallet_address}}";
 *
 * function App() {
 *   // Contract must be a contract that implements the Permission Controls interface
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: revokeRole, isLoading, error } = useRevokeRole(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         revokeRole({
 *           role: "admin",
 *           address: walletAddress,
 *         })
 *       }
 *     >
 *       Revoke Role
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 *
 * @returns A mutation object to revoke a role from a member on the contract
 * #### role (required)
 *
 * The role to revoke from the wallet address.
 *
 * Can be any custom role, or a built-in role, such as:
 * - `"admin"`
 * - `"transfer"`
 * - `"minter"`
 * - `"pauser"`
 * - `"lister"`
 * - `"asset"`
 * - `"unwrap"`
 * - `"factory"`
 *
 * #### address
 *
 * The wallet address to revoke the role from.
 *
 * To use the connected wallet address, use the `useAddress` hook.
 *
 * @twfeature Permissions | PermissionsEnumerable
 * @permissionControl
 */
function useRevokeRole(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async params => {
    requiredParamInvariant(contract, "No contract provided");
    invariant__default["default"](contract.roles, "Contract does not support roles");
    await contract.roles.revoke(params.role, params.address);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/
/**     READ  HOOKS     **/
/** **********************/

/**
 * Hook for fetching the total supply of an ERC20 token.
 *
 * This takes into account the increase and decrease in supply when tokens are minted and burned.
 *
 * @example
 * ```jsx
 * import { useTokenSupply } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { data, isLoading, error } = useTokenSupply(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns Hook's `data` object includes the total supply of the token in the `value` property as a `BigNumber` object.
 *
 * @twfeature ERC20
 * @token
 */
function useTokenSupply(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.token.totalSupply(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    const erc20 = getErc20(contract);
    if (erc20) {
      return erc20.totalSupply();
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    enabled: !!contract || !!contractAddress
  });
}

/**
 * Hook for fetching the balance a wallet has for a specific ERC20 token.
 *
 * __This hook is for _custom_ ERC20 tokens. For native tokens such as Ether, use `useBalance` or `useBalanceForAddress`__
 *
 * Available to use on contracts that implement the ERC20 interface.
 *
 * @example
 * ```jsx
 * import { useTokenBalance, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "token");
 *   const { data, isLoading, error } = useTokenBalance(contract, walletAddress);
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns Hook's `data` object includes the token balance for given wallet address
 *
 * @twfeature ERC20
 * @token
 */
function useTokenBalance(contract, walletAddress) {
  const contractAddress = contract?.getAddress();
  const erc20 = getErc20(contract);
  return useQueryWithNetwork(cacheKeys.contract.token.balanceOf(contractAddress, walletAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](walletAddress, "No address provided");
    if (erc20) {
      return await erc20.balanceOf(walletAddress);
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    enabled: !!walletAddress && !!contract
  });
}

/**
 * Hook for fetching the [decimals](https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals)
 * of an [ERC20](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20) token.
 *
 * Tokens usually opt for a value of `18`, imitating the relationship between Ether and Wei.
 * Therefore, `18` is the default value returned by this function, unless your ERC20 contract explicitly overrides it.
 *
 * @example
 *
 * ```jsx
 * import { useTokenDecimals, useContract } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "token");
 *   const { data, isLoading, error } = useTokenDecimals(contract);
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns The hook's `data` property, once loaded, contains the `number` that represents the number of decimals of the ERC20 token.
 *
 * @twfeature ERC20
 * @token
 */
function useTokenDecimals(contract) {
  const contractAddress = contract?.getAddress();
  const erc20 = getErc20(contract);
  return useQueryWithNetwork(cacheKeys.contract.token.decimals(contractAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc20) {
      return (await erc20.get()).decimals;
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    enabled: !!contract
  });
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/

/**
 * Hook for minting new tokens in an ERC20 smart contract.
 *
 * Available to use on contracts that implement the [ERC20Mintable](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20BatchMintable)
 * interface, such as the [Token](https://thirdweb.com/thirdweb.eth/TokenERC20) contract.
 *
 * The wallet address that initiates this transaction must have minting permissions on the contract.
 *
 * @example
 *
 * ```jsx
 * import { useContract, useMintToken, Web3Button } from "@thirdweb-dev/react";
 *
 * const contractAddress = "{{contract_address}}";
 * const walletAddress = "{{wallet_address}}";
 * const tokenAmount = "{{token_amount}}";
 *
 * function App() {
 *   // Contract must be an ERC-20 contract that implements the ERC20Mintable interface
 *   const { contract } = useContract(contractAddress, "token");
 *   const { mutateAsync: mintToken, isLoading, error } = useMintToken(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         mintToken({
 *           amount: tokenAmount, // Quantity to mint
 *           to: walletAddress, // Address to mint to
 *         })
 *       }
 *     >
 *       Mint Token
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns A mutation object to mint new tokens to the connected wallet
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useMintToken(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### amount
 * The quantity of tokens to mint. Can be a `string` or `number`.
 *
 * #### to
 * The wallet address to mint the new tokens to.
 *
 * To use the connected wallet address, use the `useAddress` hook.
 *
 * @twfeature ERC20Mintable
 * @token
 */
function useMintToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const erc20 = getErc20(contract);
  return reactQuery.useMutation(data => {
    const {
      to,
      amount
    } = data;
    requiredParamInvariant(contract, "contract is undefined");
    if (erc20) {
      return erc20.mintTo(to, amount);
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for claiming a ERC20 tokens from a smart contract.
 *
 * Available to use on smart contracts that implement both the [ERC20](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20) interface
 * and the [`claim`](https://portal.thirdweb.com/contracts/build/extensions/erc-721/ERC721Claimable) function,
 * such as the [Token Drop](https://thirdweb.com/thirdweb.eth/DropERC20).
 *
 * @example
 *
 * ```jsx
 * import { useClaimToken, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: claimToken, isLoading, error } = useClaimToken(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         claimToken({
 *           to: "{{wallet_address}}", // Use useAddress hook to get current wallet address
 *           amount: 100, // Amount of token to claim
 *         })
 *       }
 *     >
 *       Claim Token
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns A mutation object to tokens to the wallet specified in the params
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useClaimToken(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### to (required)
 * Likely, you will want to claim the token to the currently connected wallet address.
 *
 * You can use the `useAddress` hook to get this value.
 *
 * #### amount (required)
 * The amount of tokens to be claimed.
 *
 * #### checkERC20Allowance (optional)
 * Boolean value to check whether the current wallet has enough allowance to pay for claiming the tokens before
 * attempting to claim the tokens.
 *
 * Defaults to `true`.
 *
 * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
 * @token
 */
function useClaimToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const erc20 = getErc20(contract);
  return reactQuery.useMutation(async data => {
    invariant__default["default"](data.to, 'No "to" address provided');
    if (erc20) {
      invariant__default["default"](erc20?.claimTo, "contract does not support claimTo");
      return await erc20.claimTo(data.to, data.amount, {
        checkERC20Allowance: data.checkERC20Allowance
      });
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for transferring tokens on an ERC20 contract.
 *
 * Available to use on contracts that implement the [ERC20](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20)
 * interface, such as the [Token](https://thirdweb.com/thirdweb.eth/TokenERC20) contract.
 *
 * The wallet address that initiates this transaction must have a balance of tokens
 * greater than or equal to the amount being transferred.
 *
 * @example
 * ```jsx
 * import { useContract, useTransferToken, Web3Button } from "@thirdweb-dev/react";
 *
 * const contractAddress = "{{contract_address}}";
 * const toAddress = "{{to_address}}";
 * const amount = "{{amount}}";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const {
 *     mutate: transferTokens,
 *     isLoading,
 *     error,
 *   } = useTransferToken(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         transferTokens({
 *           to: toAddress, // Address to transfer to
 *           amount: amount, // Amount to transfer
 *         })
 *       }
 *     >
 *       Transfer
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns A mutation object to transfer tokens
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useTransferToken(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### to
 * The wallet address to transfer tokens to.
 *
 * #### amount
 * The quantity of tokens to transfer. Can be a `string` or `number`.
 *
 * @twfeature ERC20
 * @token
 */
function useTransferToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const erc20 = getErc20(contract);
  return reactQuery.useMutation(data => {
    const {
      to,
      amount
    } = data;
    if (erc20) {
      invariant__default["default"](erc20?.transfer, "contract does not support transfer");
      return erc20.transfer(to, amount);
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * A hook to transfer native token (of the active chain) to another wallet
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: transferNativeToken,
 *     isLoading,
 *     error,
 *   } = useTransferNativeToken();
 *
 *   if (error) {
 *     console.error("failed to transfer tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferNativeToken({ to: "{{wallet_address}}", amount: "0.1" })}
 *     >
 *       Transfer
 *     </button>
 *   );
 * };
 * ```
 *
 * @returns A Mutation object to transfer native tokens
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useTransferNativeToken();
 * ```
 *
 * ### options
 * The mutation function takes an object containing `to` and `amount` properties.
 *
 * - `to` - The wallet address to transfer tokens to. Must be a `string`.
 * - `amount` - The amount of tokens to transfer. Must be a `number`.
 *
 * @token
 */
function useTransferNativeToken() {
  const sdk = useSDK();
  const activeChainId = useSDKChainId();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(data => {
    const {
      to,
      amount
    } = data;
    invariant__default["default"](sdk, "SDK is not initialized");
    return sdk.wallet.transfer(to, amount);
  }, {
    onSettled: () => invalidateBalances(queryClient, activeChainId)
  });
}

/**
 * Hook for transferring ERC20 tokens to multiple recipients in a single transaction (i.e. airdrop).
 *
 * Available to use on contracts that implement the [ERC20](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20) interface.
 *
 * The wallet that initiates this transaction must have sufficient balance to cover the total amount of tokens being transferred
 * and must have transfer permissions on the contract, i.e. tokens are not soulbound.
 *
 * @example
 *
 * Provide your token contract instance from the `useContract` hook to the hook.
 *
 * Then, provide an array of objects with the `to` and `amount` properties to the function.
 *
 * ```jsx
 * import {
 *   useTransferBatchToken,
 *   useContract,
 *   Web3Button,
 * } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress, "token");
 *   const {
 *     mutateAsync: transferBatchToken,
 *     isLoading,
 *     error,
 *   } = useTransferBatchToken(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         transferBatchToken([
 *           {
 *             to: "{{wallet_address}}", // Transfer 10 tokens to a wallet
 *             amount: 10,
 *           },
 *           {
 *             to: "{{wallet_address}}", // Transfer 20 tokens to another wallet
 *             amount: 20,
 *           },
 *         ])
 *       }
 *     >
 *       Transfer Batch Tokens
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns A Mutation object to transfer batch tokens
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useTransferBatchToken(contract);
 * ```
 *
 * ### options
 *
 * The mutation function takes an array of objects containing `to` and `amount` properties.
 *
 * - `to` - The wallet address to transfer tokens to. Must be a `string`.
 * - `amount` - The amount of tokens to transfer. Must be a `number`.
 *
 * @twfeature ERC20
 * @token
 */
function useTransferBatchToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const erc20 = getErc20(contract);
  return reactQuery.useMutation(data => {
    if (erc20) {
      invariant__default["default"](erc20.transferBatch, "contract does not support transferBatch");
      const convertedData = data.map(token => ({
        toAddress: token.to,
        amount: token.amount
      }));
      return erc20.transferBatch(convertedData);
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 * Hook for burning ERC20 tokens on a smart contract.
 *
 * Available to use on smart contracts that implement the [ERC20](https://portal.thirdweb.com/contracts/build/extensions/erc-20/ERC20) standard.
 *
 * @example
 *
 * ```jsx
 * import { useBurnToken, useContract, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { contract } = useContract(contractAddress);
 *   const { mutateAsync: burnToken, isLoading, error } = useBurnToken(contract);
 *
 *   return (
 *     <Web3Button
 *       contractAddress={contractAddress}
 *       action={() =>
 *         burnToken({
 *           amount: "10", // Amount of tokens to burn
 *         })
 *       }
 *     >
 *       Burn Token
 *     </Web3Button>
 *   );
 * }
 * ```
 *
 * @param contract - Instance of a `TokenContract`
 *
 * @returns
 * A mutation object to burn tokens from the connected wallet
 * ```ts
 * const { mutateAsync, isLoading, error } = useBurnToken(contract);
 * ```
 *
 * ### options
 * The mutation function takes an object as an argument with the following properties:
 *
 * #### amount (required)
 * The amount of tokens to burn.
 *
 * The wallet initiating this transaction must have at least this amount of tokens.
 *
 * @twfeature ERC20Burnable
 * @token
 */
function useBurnToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  const erc20 = getErc20(contract);
  return reactQuery.useMutation(data => {
    const {
      amount
    } = data;
    requiredParamInvariant(contract, "contract is undefined");
    if (erc20) {
      invariant__default["default"](erc20.burn, "contract does not support burn");
      return erc20.burn(amount);
    }
    invariant__default["default"](false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/
/**       READ HOOKS    **/
/** **********************/

/**
 * Get all accounts
 *
 * @example
 * ```javascript
 * const { data: accounts, isLoading, error } = useAccounts(contract);
 * ```
 *
 * @param contract - Instance of a account factory contract
 * @returns Query result object that includes an array of all accounts with their associated admin
 * @twfeature AccountFactory
 * @smartWallet
 */
function useAccounts(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.accountFactory.getAll(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.accountFactory.getAllAccounts, "Contract instance does not support contract.accountFactory.getAllAccounts");
    return contract.accountFactory.getAllAccounts();
  }, {
    enabled: !!contract
  });
}

/**
 * Get all accounts associated with the provided address
 *
 * @example
 * ```javascript
 * const { data: accountsForAddress, isLoading, error } = useAccountsForAddress(contract, "{{account_address}}");
 * ```
 *
 * @param contract - Instance of a account factory contract
 * @param address - The address to get associated accounts for
 * @returns Query result object that includes an array of all accounts associated with the address
 *
 * @twfeature AccountFactory
 * @smartWallet
 */
function useAccountsForAddress(contract, address) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.accountFactory.getAllForAddress(contractAddress, address), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.accountFactory.getAssociatedAccounts, "Contract instance does not support contract.accountFactory.getAssociatedAccounts");
    return contract.accountFactory.getAssociatedAccounts(address || "");
  }, {
    enabled: !!contract
  });
}

/**
 * Check if a account has been deployed for the given admin in the account factory contract
 *
 * @example
 * ```javascript
 * const { data: isAccountDeployed, isLoading, error } = useIsAccountDeployed(contract);
 * ```
 *
 * @param contract - Instance of a account factory contract
 * @returns A boolean indicating if a account has been deployed for the given admin
 * @twfeature AccountFactory
 * @smartWallet
 */
function useIsAccountDeployed(contract, admin, extraData) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.accountFactory.isAccountDeployed(contractAddress, admin), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.accountFactory.isAccountDeployed, "Contract instance does not support contract.accountFactory.getAllAccounts");
    invariant__default["default"](admin, "No account address provided");
    return contract.accountFactory.isAccountDeployed(admin, extraData);
  }, {
    enabled: !!contract
  });
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/
/**
 * Create a account in the account factory contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract("{{contract_address}}");
 *   const {
 *     mutate: createAccount,
 *     isLoading,
 *     error,
 *   } = useCreateAccount(contract);
 *
 *   if (error) {
 *     console.error("failed to create account", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => createAccount("0x...")}
 *     >
 *       Create Account
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - Instance of a account factory contract
 * @returns A mutation object to create a account
 * @twfeature AccountFactory
 * @smartWallet
 */
function useCreateAccount(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract?.getAddress();
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation(async (admin, extraData) => {
    requiredParamInvariant(contract, "contract is undefined");
    return contract.accountFactory.createAccount(admin, extraData);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/
/**       READ HOOKS    **/
/** **********************/

/**
 * Get all signers of account
 *
 * @example
 * ```javascript
 * const { data: accounts, isLoading, error } = useAccountSigners(contract);
 * ```
 *
 * @param contract - Instance of a `SmartContract`
 * @returns hook's `data` property contains an array of all signers
 * @twfeature Account
 * @smartWallet
 */
function useAccountSigners(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.account.signers(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.account.getAllSigners, "Contract instance does not support contract.account.getAllSigners");
    return contract.account.getAllSigners();
  }, {
    enabled: !!contract
  });
}

/**
 * Get all the admins on a smart wallet account
 *
 * @example
 * ```javascript
 * const { data: accounts, isLoading, error } = useAccountAdmins(contract);
 * ```
 *
 * @param contract - Instance of `SmartContract`
 * @returns The hook's `data` property, once loaded, contains an array of all admins of the provided account
 * @twfeature Account
 * @smartWallet
 */
function useAccountAdmins(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.account.signers(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.account.getAllAdmins, "Contract instance does not support contract.account.getAllAdmins");
    return contract.account.getAllAdmins();
  }, {
    enabled: !!contract
  });
}

/**
 * Get all signers and admins on a smart wallet account.
 *
 * ```jsx
 * import { useAccountAdminsAndSigners } from "@thirdweb-dev/react";
 *
 * const { data: accounts, isLoading, error } = useAccountAdminsAndSigners(contract);
 * ```
 *
 * @param contract - Instance of `SmartContract`
 * @returns hook's `data` property containing an array of all admins and signers
 *
 * @twfeature Account
 * @smartWallet
 */
function useAccountAdminsAndSigners(contract) {
  const contractAddress = contract?.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.account.signers(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant__default["default"](contract.account.getAllAdminsAndSigners, "Contract instance does not support contract.account.getAllAdminsAndSigners");
    return contract.account.getAllAdminsAndSigners();
  }, {
    enabled: !!contract
  });
}

/** **********************/
/**     WRITE HOOKS     **/
/** **********************/

/**
 * Create and add a session key for the smart wallet account
 *
 * @example
 * ```jsx
 *  const Component = () => {
 *    const {
 *      mutate: createSessionKey,
 *      isLoading,
 *      error,
 *    } = useCreateSessionKey();
 *
 *    if (error) {
 *      console.error("failed to create session key", error);
 *    }
 *
 *    return (
 *      <button
 *        disabled={isLoading}
 *        onClick={() => createSessionKey(
 *          keyAddress,
 *          {
 *            approvedCallTargets: ["0x..."], // the addresses of contracts that the session key can call
 *            nativeTokenLimitPerTransaction: 0.1, // the maximum amount of native token (in ETH) that the session key can spend per transaction
 *            startDate: new Date(), // the date when the session key becomes active
 *            expirationDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // the date when the session key expires
 *          }
 *         )}
 *      >
 *        Create Session Key
 *      </button>
 *    );
 *  };
 * ```
 *
 * @twfeature Account
 *
 * @returns  Mutation object to create and add a session key for the smart wallet
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useCreateSessionKey();
 * ```
 *
 * ### options
 * The mutation function takes an object with the following properties as argument:
 *
 * #### address
 * The address to add as an admin on the account as a `string`.
 *
 * #### approvedCallTargets
 * An array of addresses that the session key can call as a `string[]`.
 *
 * #### nativeTokenLimitPerTransaction
 * The maximum amount of native token (in ETH) that the session key can spend per transaction as a `number`.
 *
 * #### startDate
 * The date when the session key becomes active as a `Date`.
 *
 * #### startDate
 * The date when the session key expires as a `Date`.
 *
 * @smartWallet
 */
function useCreateSessionKey() {
  const smartWallet = useWallet("smartWallet");
  return reactQuery.useMutation(async args => {
    requiredParamInvariant(smartWallet, "wallet is not connected");
    return smartWallet.createSessionKey(args.keyAddress, args.permissions);
  });
}

/**
 * Revoke a session key (or signer) on the smart wallet account
 *
 * @example
 * ```jsx
 * import { useRevokeSessionKey } from "@thirdweb-dev/react";
 *
 * // Your ERC20 token smart contract address
 * const keyAddress = "{{key_address}}";
 *
 * const Component = () => {
 *   const { mutate: revokeSessionKey, isLoading, error } = useRevokeSessionKey();
 *
 *   if (error) {
 *     console.error("failed to revoke session key", error);
 *   }
 *
 *   return (
 *     <button disabled={isLoading} onClick={() => revokeSessionKey(keyAddress)}>
 *       Revoke Session Key
 *     </button>
 *   );
 * };
 * ```
 *
 * @twfeature Account
 * @returns
 * Mutation object to revoke a session key (or signer) on the smart wallet
 *
 * ```ts
 * const { mutateAsync, isLoading, error } = useRevokeSessionKey();
 * ```
 *
 * The mutation function takes an address of type `string` to remove as an admin.
 *
 * @smartWallet
 */
function useRevokeSessionKey() {
  const smartWallet = useWallet("smartWallet");
  return reactQuery.useMutation(async keyAddress => {
    requiredParamInvariant(smartWallet, "wallet is not connected");
    return smartWallet.revokeSessionKey(keyAddress);
  });
}

/**
 * Add an additional admin on the smart wallet account
 *
 * @example
 * ```jsx
 * import { useAddAdmin } from "@thirdweb-dev/react";
 *
 * const adminAddress = "{{admin_address}}";
 *
 * const Component = () => {
 *   const { mutate: addAdmin, isLoading, error } = useAddAdmin();
 *
 *   if (error) {
 *     console.error("failed to add admin", error);
 *   }
 *
 *   return (
 *     <button disabled={isLoading} onClick={() => addAdmin(adminAddress)}>
 *       Add admin
 *     </button>
 *   );
 * };
 * ```
 *
 * @returns  mutation object to add given address as an admin
 *
 * @twfeature Account
 * @smartWallet
 */
function useAddAdmin() {
  const smartWallet = useWallet("smartWallet");
  return reactQuery.useMutation(async adminAddress => {
    requiredParamInvariant(smartWallet, "wallet is not connected");
    return smartWallet.addAdmin(adminAddress);
  });
}

/**
 * Remove an admin on the smart wallet account. This action has to be performed by an admin on the account.
 *
 * ```jsx
 * import { useRemoveAdmin } from "@thirdweb-dev/react";
 *
 * const adminAddress = "{{admin_address}}";
 *
 * const Component = () => {
 *   const { mutate: removeAdmin, isLoading, error } = useRemoveAdmin();
 *
 *   if (error) {
 *     console.error("failed to remove admin", error);
 *   }
 *
 *   return (
 *     <button disabled={isLoading} onClick={() => removeAdmin(adminAddress)}>
 *       Remove admin
 *     </button>
 *   );
 * };
 * ```
 *
 * @twfeature Account
 * @returns  mutation object to remove given address as an admin
 * @smartWallet
 */
function useRemoveAdmin() {
  const smartWallet = useWallet("smartWallet");
  return reactQuery.useMutation(async adminAddress => {
    requiredParamInvariant(smartWallet, "wallet is not connected");
    return smartWallet.removeAdmin(adminAddress);
  });
}

/**
 * Hook to get `ThirdwebAuth` instance
 * @auth
 */
function useAuth() {
  const wallet = useWallet();
  const authConfig = useThirdwebAuthContext();
  return react.useMemo(() => {
    if (!authConfig?.domain) {
      return undefined;
    }
    if (!wallet) {
      return undefined;
    }
    return new auth.ThirdwebAuth(wallet, authConfig.domain);
  }, [wallet, authConfig?.domain]);
}

/**
 * Hook to prompt the user to sign in with their wallet using [auth](https://portal.thirdweb.com/wallets/auth)
 *
 * Requires the `authConfig` prop to be configured on the `ThirdwebProvider`
 *
 * @example
 *
 * ```jsx
 * import { useLogin } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { isLoading, login } = useLogin();
 *
 *   return (
 *     <button onClick={() => login()}>
 *       {isLoading ? "Loading..." : "Sign in with Ethereum"}
 *     </button>
 *   );
 * }
 * ```
 *
 * @returns  A function to invoke to login with the connected wallet, and an `isLoading` state that indicates if the login request is in progress
 *
 * ### login
 *
 * The `login` function accepts an optional `LoginOptions` object as an argument.
 *
 * This configuration follows the [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) Sign in with Ethereum standard.
 *
 * ```jsx
 * import { useLogin, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { login, isLoading } = useLogin();
 *
 *   const loginOptions = {
 *     domain: "https://your-domain.com", // Your dapp domain
 *     statement: "My statement", // Text that the user will sign
 *     uri: "https://your-domain.com/login", // RFC 3986 URI referring to the resource that is the subject of the signing
 *     version: "1.0", // The current version of the message, which MUST be 1 for this specification.
 *     chainId: "mainnet", // Chain ID to which the session is bound
 *     nonce: "my-nonce", // randomized token typically used to prevent replay attacks
 *     expirationTime: new Date(2021, 1, 1), // When this message expires
 *     invalidBefore: new Date(2020, 12, 1), // When this message becomes valid
 *     resources: ["balance", "history", "info"], // A list of information or references to information the user wishes to have resolved
 *   };
 *
 *   return <Web3Button action={() => login(loginOptions)}>Login</Web3Button>;
 * }
 * ```
 *
 * @auth
 */
function useLogin() {
  const queryClient = reactQuery.useQueryClient();
  const authConfig = useThirdwebAuthContext();
  const wallet = useWallet();
  const login = reactQuery.useMutation({
    mutationFn: async () => {
      invariant__default["default"](authConfig, "Please specify an authConfig in the ThirdwebProvider");
      invariant__default["default"](wallet, "You need a connected wallet to login.");
      invariant__default["default"](authConfig.authUrl, "Please specify an authUrl in the authConfig.");
      const address = await wallet.getAddress();
      const chainId = await wallet.getChainId();
      let res = await fetch(`${authConfig.authUrl}/payload`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          address,
          chainId: chainId.toString()
        })
      });
      if (!res.ok) {
        throw new Error(`Failed to get payload with status code ${res.status}`);
      }
      let payloadData;
      try {
        ({
          payload: payloadData
        } = await res.json());
      } catch {
        throw new Error(`Failed to get payload`);
      }
      const payload = await auth.signLoginPayload({
        wallet,
        payload: payloadData
      });
      res = await fetch(`${authConfig.authUrl}/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          payload
        }),
        credentials: "include"
      });
      if (!res.ok) {
        const data = await res.json();
        if (data.error) {
          throw new Error(data.error);
        }
        throw new Error(`Login request failed with status code ${res.status}`);
      }
      const {
        token
      } = await res.json();
      await authConfig.secureStorage?.setItem(AUTH_TOKEN_STORAGE_KEY, token);
      queryClient.invalidateQueries(cacheKeys.auth.user());
      return token;
    }
  });
  return {
    login: () => login.mutateAsync(),
    isLoading: login.isLoading
  };
}

/**
 * @auth
 */

/**
 * Hook for retrieving information about the currently signed-in user using [auth](https://portal.thirdweb.com/wallets/auth).
 *
 * Useful to get the user's address and session data, or `undefined` if no user is signed in.
 *
 * ```jsx
 * import { useUser } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { user, isLoggedIn, isLoading } = useUser();
 * }
 * ```
 *
 * @auth
 *
 */
function useUser() {
  const authConfig = useThirdwebAuthContext();
  const {
    data: user,
    isLoading
  } = reactQuery.useQuery(cacheKeys.auth.user(), async () => {
    invariant__default["default"](authConfig, "Please specify an authConfig in the ThirdwebProvider");
    invariant__default["default"](authConfig.authUrl, "Please specify an authUrl in the authConfig.");
    const token = await authConfig.secureStorage?.getItem(AUTH_TOKEN_STORAGE_KEY);
    // We include credentials so we can getUser even if API is on different URL
    const params = {
      credentials: "include",
      ...(token ? {
        headers: {
          Authorization: `Bearer ${token}`
        }
      } : {})
    };
    const res = await fetch(`${authConfig.authUrl}/user`, params);
    return await res.json();
  }, {
    enabled: !!authConfig
  });
  return {
    user,
    isLoggedIn: !!user,
    isLoading
  };
}

/**
 * Hook for getting an instance of an `EditionDrop` contract. This contract is used to interface with ERC1155 compliant NFTs that can be lazily minted.
 * @param contractAddress - The address of the Edition Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "edition-drop")
 *
 *   // Now you can use the edition drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(tokenId, quantity) {
 *     await contract.claim(tokenId, quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const editionDrop = useEditionDrop("0x1234...");
 * + const editionDrop = useContract("0x1234...", "edition-drop").contract;
 * ```
 * @internal
 */
function useEditionDrop(contractAddress) {
  return useContract(contractAddress, "edition-drop").contract;
}

/**
 *
 * Hook for getting an instance of an `Edition` contract. This contract is used to interface with ERC1155 compliant NFTs.
 * @param contractAddress - The address of the Edition contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "edition")
 *
 *   // Now you can use the edition contract in the rest of the component
 *
 *   // For example, this function will return all the NFTs on this contract
 *   async function getNFTs() {
 *     const nfts = await contract.getAll()
 *     return nfts
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const edition = useEdition("0x1234...");
 * + const edition = useContract("0x1234...", "edition").contract;
 * ```
 * @internal
 */
function useEdition(contractAddress) {
  return useContract(contractAddress, "edition").contract;
}

/**
 * Hook for getting an instance of an `NFTDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.
 * @param contractAddress - The address of the NFT Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "nft-drop")
 *
 *   // Now you can use the nft drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(quantity) {
 *     await contract.claim(quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const nftDrop = useNFTDrop("0x1234...");
 * + const nftDrop = useContract("0x1234...", "nft-drop").contract;
 * ```
 * @internal
 */
function useNFTDrop(contractAddress) {
  return useContract(contractAddress, "nft-drop").contract;
}

/**
 * Hook for getting an instance of a `Marketplace` contract. This contract is used to support marketplace for purchase and sale of on-chain assets.
 * @param contractAddress - The address of the Marketplace contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "marketplace")
 *
 *   // Now you can use the marketplace contract in the rest of the component
 *
 *   // For example, this function will return all the listings on the marketplace
 *   async function getListings() {
 *     const listings = await contract.getAll()
 *     return listings
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const marketplace = useMarketplace("0x1234...");
 * + const marketplace = useContract("0x1234...", "marketplace").contract;
 * ```
 * @internal
 */
function useMarketplace(contractAddress) {
  return useContract(contractAddress, "marketplace").contract;
}

/**
 * Hook for getting an instance of an `NFTCollection` contract. This contract is meant to interface with ERC721 compliant NFTs.
 * @param contractAddress - The address of the NFT Collection contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract, isLoading, error } = useContract("<YOUR-CONTRACT-ADDRESS>", "nft-collection")
 *
 *   // Now you can use the nftCollection contract in the rest of the component
 *
 *   // For example, this function will return all the NFTs on this contract
 *   async function getNFTs() {
 *     const nfts = await contract.getAll()
 *     return nfts
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const nftCollection = useNFTCollection("0x1234...");
 * + const nftCollection = useContract("0x1234...", "nft-collection").contract;
 * ```
 * @internal
 */
function useNFTCollection(contractAddress) {
  return useContract(contractAddress, "nft-collection").contract;
}

/**
 * Hook for getting an instance of a `Pack` contract. This contract supports the creation of on-chain luck-based lootboxes.
 * @param contractAddress - The address of the Pack contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = usePack("<YOUR-CONTRACT-ADDRESS>", "pack")
 *
 *   // Now you can use the pack contract in the rest of the component
 *
 *   // For example, this function will get all the packs on this contract
 *   async function getPacks() {
 *     const packs = await contract.getAll()
 *     return packs
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const pack = usePack("0x1234...");
 * + const pack = useContract("0x1234...", "pack").contract;
 * ```
 *
 * @internal
 */
function usePack(contractAddress) {
  return useContract(contractAddress, "pack").contract;
}

/**
 * Hook for getting an instance of a `Token` contract. This contract supports ERC20 compliant tokens.
 * @param contractAddress - The address of the Token contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "token")
 *
 *   // Now you can use the token contract in the rest of the component
 *
 *   // For example, this function will get the connected wallets token balance
 *   async function balance() {
 *     const balance = await contract.balance()
 *     return balance
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const token = useToken("0x1234...");
 * + const token = useContract("0x1234...", "token").contract;
 * ```
 *
 * @internal
 */
function useToken(contractAddress) {
  return useContract(contractAddress, "token").contract;
}

/**
 * Hook for getting an instance of a `Token Drop` contract.
 * @param contractAddress - The address of the Token Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "token-drop")
 *
 *   // Now you can use the token drop contract in the rest of the component
 *
 *   // For example, this function will get the connected wallets token balance
 *   async function balance() {
 *     const balance = await contract.balance()
 *     return balance
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const token = useTokenDrop("0x1234...");
 * + const token = useContract("0x1234...", "token-drop").contract;
 * ```
 *
 * @token
 * @internal
 */
function useTokenDrop(contractAddress) {
  return useContract(contractAddress, "token-drop").contract;
}

/**
 * Hook for getting an instance of an `Vote` contract. This contract enables fully featured voting-based decentralized governance systems.
 * @param contractAddress - The address of the Vote contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "vote")
 *
 *   // Now you can use the vote contract in the rest of the component
 *
 *   // For example, this function will get all the proposals on this contract
 *   async function getProposals() {
 *     const proposals = await contract.getAll()
 *     return proposals
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const vote = useVote("0x1234...");
 * + const vote = useContract("0x1234...", "vote").contract;
 * ```
 *
 * @internal
 */
function useVote(contractAddress) {
  return useContract(contractAddress, "vote").contract;
}

/**
 * Hook for getting an instance of a `Split` contract. This contract supports fund distribution to multiple parties.
 * @param contractAddress - The address of the Split contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "split")
 *
 *   // Now you can use the split contract in the rest of the component
 *
 *   // For example, this function will return all the recipients of the split
 *   async function getRecipients() {
 *     const recipients = await contract.getAllRecipients()
 *     return recipients
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const split = useSplit("0x1234...");
 * + const split = useContract("0x1234...", "split").contract;
 * ```
 * @internal
 */
function useSplit(contractAddress) {
  return useContract(contractAddress, "split").contract;
}

/**
 * Hook for getting an instance of an `Multiwrap` contract. This contract is an ERC721 in which you can wrap ERC721, ERC1155 and ERC20 tokens.
 * @param contractAddress - The address of the Multiwrap contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "multiwrap")
 *
 *   // Now you can use the multiwrap contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet wrap tokens
 *   async function wrap(tokensToWrap, wrappedNFTMetadata) {
 *     await contract.wrap(tokensToWrap, wrappedNFTMetadata)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const multiwrap = useMultiwrap("0x1234...");
 * + const multiwrap = useContract("0x1234...", "multiwrap").contract;
 * ```
 * @internal
 */
function useMultiwrap(contractAddress) {
  return useContract(contractAddress, "multiwrap").contract;
}

/**
 * Hook for getting an instance of an `SignatureDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.
 * @param contractAddress - The address of the NFT Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useContract } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const { contract } = useContract("<YOUR-CONTRACT-ADDRESS>", "signature-drop")
 *
 *   // Now you can use the Signature drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(quantity) {
 *     await contract.claim(quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @deprecated
 * This hook is deprecated and will be removed in a future major version. You should use {@link useContract} instead.
 * ```diff
 * - const signatureDrop = useSignatureDrop("0x1234...");
 * + const signatureDrop = useContract("0x1234...", "signature-drop").contract;
 * ```
 * @internal
 */
function useSignatureDrop(contractAddress) {
  return useContract(contractAddress, "signature-drop").contract;
}

/**
 * Get the instance of the `ThirdwebStorage` class being used by the `ThirdwebProvider`
 *
 * Allows you to use the TypeScript SDK functionality of [Storage](https://portal.thirdweb.com/infrastructure/storage/overview) in your React app.
 *
 * @example
 *
 * ```jsx
 * import { useStorage } from "@thirdweb-dev/react";
 *
 * export default function Component() {
 *   const storage = useStorage();
 *
 *   // Now you can use the functionality of the ThirdwebStorage class:
 *   storage?.download(); // Download a file from IPFS
 *   storage?.upload(); // Upload a file to IPFS
 * }
 * ```
 *
 * @remarks
 *
 * ### API Key
 *
 * You will require an API key to use thirdweb’s storage services with the SDK. If you haven’t created a key yet you can do so for free from the [**thirdweb dashboard**](https://thirdweb.com/create-api-key).
 *
 * You can then obtain a `clientId` from the API key which you will need to pass to the `ThirdwebProvider` component:
 *
 *
 * ```jsx
 * import { ThirdwebProvider } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   return (
 *     <ThirdwebProvider clientId="YOUR_CLIENT_ID">
 *       <YourApp />
 *     </ThirdwebProvider>
 *   );
 * };
 * ```
 *
 * Storage can also be configured using the `storageInterface` prop on `ThirdwebProvider`
 *
 * @storage
 */
function useStorage() {
  const sdk = useSDK();
  return sdk?.storage;
}

/**
 * Hook for uploading files to IPFS and retrieving the IPFS URI.
 *
 * @example
 * ```jsx
 * import { useStorageUpload } from "@thirdweb-dev/react";
 *
 * export default function Component() {
 *   const { mutateAsync: upload, isLoading } = useStorageUpload();
 *
 *   async function uploadData() {
 *     const filesToUpload = [...];
 *     const uris = await upload({ data: files });
 *     console.log(uris);
 *   }
 *
 *   return (
 *     <button onClick={uploadData}>
 *       Upload
 *     </button>
 *   )
 * }
 * ```
 *
 * @remarks
 * ### API key
 *
 * You will require an API key to use thirdweb’s storage services with the SDK. If you haven’t created a key yet you can do so for free from the [**thirdweb dashboard**](https://thirdweb.com/create-api-key).
 *
 * You can then obtain a `clientId` from the API key which you will need to pass to the [`ThirdwebProvider`](/react/react.thirdwebprovider) component:
 *
 * ```jsx
 * import { ThirdwebProvider } from "@thirdweb/react";
 *
 * const App = () => {
 *   return (
 *     <ThirdwebProvider clientId="YOUR_CLIENT_ID">
 *       <YourApp />
 *     </ThirdwebProvider>
 *   );
 * };
 * ```
 *
 * @param options - Configure the options for your upload
 * ### rewriteFileNames (optional)
 *
 * If specified, will rewrite file names to numbers for use on-chain.
 *
 * Useful to use with NFT contracts that map token IDs to files.
 *
 * ```jsx
 * import { useStorageUpload } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { mutateAsync: upload } = useStorageUpload({
 *     rewriteFileNames: {
 *       fileStartNumber: 1,
 *     },
 *   });
 * }
 * ```
 *
 * ### uploadWithGatewayUrl (optional)
 *
 * If specified, any URLs with schemes will be replaced with resolved URLs before upload.
 *
 * ```jsx
 * import { useStorageUpload } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { mutateAsync: upload } = useStorageUpload({
 *     uploadWithGatewayUrl: true,
 *   });
 * }
 * ```
 *
 * ### onProgress (optional)
 *
 * Callback that gets triggered when file upload progresses.
 *
 * ```jsx
 * import { useStorageUpload } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { mutateAsync: upload } = useStorageUpload({
 *     onProgress: (progress) => {
 *       console.log(progress);
 *     },
 *   });
 * }
 * ```
 *
 * ### uploadWithoutDirectory (optional)
 *
 * If specified, will upload a single file without wrapping it in a directory.
 *
 * ```jsx
 * import { useStorageUpload } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const { mutateAsync: upload } = useStorageUpload({
 *     uploadWithoutDirectory: true,
 *   });
 * }
 * ```
 *
 * @storage
 */
function useStorageUpload(uploadOptions) {
  const sdk = useSDK();
  return reactQuery.useMutation(async _ref => {
    let {
      data,
      options
    } = _ref;
    invariant__default["default"](sdk, "sdk must be defined");
    return await sdk.storage.uploadBatch(data, options || uploadOptions);
  });
}

/**
 * Hook for checking whether the connected wallet is currently on the correct chain,
 * i.e. the chain specified in the `activeChain` on the `ThirdwebProvider`.
 *
 * @example
 *
 * ```jsx
 * import { useNetworkMismatch } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   const isMismatched = useNetworkMismatch();
 * };
 * ```
 *
 * Using this value, you can prompt users to switch their network using the `useSwitchChain` hook.
 *
 * @returns
 * Returns `true` if the `chainId` of the connected wallet is different from the `chainId` of the `activeChain` on the `ThirdwebProvider` component
 *
 * @networkConnection
 */
function useNetworkMismatch() {
  const walletChainId = useChainId();
  const sdkChainId = useSDKChainId();
  if (!sdkChainId) {
    // we don't know yet
    return false;
  }
  if (sdkChainId === -1) {
    // means no network is set in the <ThirdwebProvider />, so we don't care about the network mismatch
    return false;
  }
  if (!walletChainId) {
    // means no wallet is connected yet, so we don't care about the network mismatch
    return false;
  }
  // check if the chainIds are different
  return sdkChainId !== walletChainId;
}

/**
 * @internal
 */
function useReadonlySDK(readonlyRpcUrl, sdkOptions, storageInterface) {
  return react.useMemo(() => {
    return new sdk.ThirdwebSDK(readonlyRpcUrl, sdkOptions, storageInterface);
    // storageInterface should be constant!
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [readonlyRpcUrl, sdkOptions]);
}

/**
 * Hook for getting the [ethers signer](https://docs.ethers.org/v5/api/signer/) of the connected wallet.
 *
 * @example
 *
 * ```jsx
 * import { useSigner, Web3Button } from "@thirdweb-dev/react";
 *
 * function App() {
 *   const signer = useSigner();
 * }
 * ```
 *
 * @returns
 *
 * `Signer` if wallet is connected, otherwise `undefined`.
 *
 * @walletConnection
 */
function useSigner() {
  const context = react.useContext(ThirdwebConnectedWalletContext);
  const walletCtx = react.useContext(ThirdwebWalletContext);

  // if ThirdwebWalletContext is present, use the signer from there because signer from ThirdwebConnectedWalletContext also uses that signer but it lags behind
  // walletCtx is undefined if only ThirdwebSDKProvider is used
  if (walletCtx) {
    return walletCtx.signer;
  }
  invariant__default["default"](context, "useSigner() hook must be used within a <ThirdwebProvider/> or <ThirdwebSDKProvider/> component");
  return context.signer;
}

/**
 * @deprecated use `useWallet` instead
 * @internal
 */
function useSupportedWallet(id) {
  const context = useWalletContext();
  const wallet = context?.wallets.find(_wallet => _wallet.id === id);
  if (!wallet) {
    throw new Error(`Wallet with id "${id}" is not supported`);
  }
  return wallet;
}

/**
 * Get App URI of the contract
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading, error } = useAppURI(contract);
 * ```
 *
 * @param contract - The `SmartContract` instance of the contract to get the appURI of
 * @returns Query result object that includes the appURI of the contract
 * @twfeature AppURI
 * @appURI
 */
function useAppURI(contract) {
  return useQueryWithNetwork(cacheKeys.contract.app.get(contract?.getAddress()), async () => {
    requiredParamInvariant(contract, "Contract is required");
    invariant__default["default"](contract.app, "Contract does not support app");
    return await contract.app.get();
  }, {
    enabled: !!contract
  });
}

/**
 * Set App URI of the contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: useSetAppURI,
 *     isLoading,
 *     error,
 *   } = useSetAppURI(contract);
 *
 *   if (error) {
 *     console.error("failed to update appURI", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => useSetAppURI({ uri })}
 *     >
 *       Update App URI
 *     </button>
 *   );
 * };
 * ```
 * @param contract - Instance of a `SmartContract`
 * @returns A mutation object to update the appURI of a contract
 *
 * @twfeature AppURI
 * @appURI
 */
function useSetAppURI(contract) {
  const queryClient = reactQuery.useQueryClient();
  const contractAddress = contract?.getAddress();
  const activeChainId = useSDKChainId();
  return reactQuery.useMutation(params => {
    requiredParamInvariant(contract, "Contract is required");
    invariant__default["default"](contract.app, "Contract does not support app");
    return contract.app.set(params.uri);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/**
 *
 * @internal
 */
function useENS() {
  const address = useAddress();
  const supportedChains = useSupportedChains();
  const {
    clientId
  } = useWalletContext();
  const ethereum = supportedChains.find(chain => chain.chainId === 1);
  return reactQuery.useQuery({
    queryKey: ["ens", address, ethereum?.rpc],
    cacheTime: 60 * 60 * 24 * 1000,
    // 24h
    staleTime: 60 * 60 * 1000,
    // 1h
    retry: false,
    enabled: !!address,
    queryFn: async () => {
      if (!address) {
        return null;
      }
      const provider = evm.getChainProvider(1, {
        clientId,
        supportedChains: ethereum ? [{
          chainId: 1,
          rpc: [...ethereum.rpc],
          nativeCurrency: ethereum.nativeCurrency,
          slug: ethereum.slug
        }] : undefined
      });
      if (provider instanceof ethers.providers.JsonRpcProvider) {
        const [ens, avatarUrl] = await Promise.all([provider.lookupAddress(address), provider.getAvatar(address)]);
        return {
          ens,
          avatarUrl
        };
      }
      return {
        ens: await provider.lookupAddress(address),
        avatarUrl: null
      };
    }
  });
}

/**
 * @internal
 */
function shortenString(str) {
  let extraShort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}

/**
 * This function shortens an address if it is a valid EVM address.
 *
 * @param address - The address to shorten
 * @param extraShort - If true, show the first 4 and last 3 characters
 * @returns The shortened address
 *
 * @remarks
 * Note that this function will not check if the address is an ENS.
 *
 * @example Calling shortenAddress with extraShort set to true
 * ```ts
 * const address = shortenIfAddress("0x1234567890123456789012345678901234567890", true); // result will be "0x1234...890"
 * ```
 *
 */
function shortenAddress(address) {
  let extraShort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!address) {
    return "";
  }
  try {
    const formattedAddress = ethers.utils.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch {
    return address;
  }
}

/**
 * @internal
 */
function shortenIfAddress(address) {
  let extraShort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (address && ethers.utils.isAddress(address)) {
    return shortenAddress(address, extraShort);
  }
  return address || "";
}

/**
 * @internal
 */
function isEnsName(name) {
  return name?.endsWith(".eth");
}

/**
 * @internal
 */
function isPossibleEVMAddress(address, ignoreEns) {
  if (!address) {
    return false;
  }
  if (isEnsName(address) && !ignoreEns) {
    return true;
  }
  return ethers.utils.isAddress(address);
}

/**
 * Hook that listens to transactions on a given chain for a given address.
 *
 * ```javascript
 * import { useWatchTransactions } from "@thirdweb-dev/react"
 * ```
 *
 * @example
 * ```js
 * const transactions = useWatchTransactions({
 *  address: "0x1234",
 *  network: "ethereum",
 * });
 * ```
 *
 * @param watchTransactionParams - Options for watching transactions
 *
 * #### address
 * The address to watch transactions for
 *
 * #### network
 * The network to watch transactions on
 *
 * #### sdkOptions
 * Options to pass to the thirdweb SDK
 *
 * @returns An array of `Transaction` objects
 */
function useWatchTransactions(watchTransactionParams) {
  const {
    address,
    network,
    sdkOptions,
    // default to 1000, max 10k
    limit: paramLimit = 1000
  } = watchTransactionParams;
  // max limit of 10k transactions to let the array grow to, then we'll start dropping the oldest ones
  const limit = Math.min(paramLimit, 10000);
  const [transactions, setTransactions] = react.useState([]);
  react.useEffect(() => {
    if (!address || !network) {
      // cant run yet
      return;
    }
    // since this already returns a function to unsubscribe, we can just return it
    return functions.watchTransactions({
      address,
      network,
      sdkOptions,
      onTransactions: newTransactions => {
        setTransactions(prevTransactions => {
          const mergedTxns = [...newTransactions, ...prevTransactions];
          // only keep the latest transactions
          return mergedTxns.slice(0, limit);
        });
      }
    });
  }, [address, limit, network, sdkOptions]);
  return transactions;
}

exports.ThirdwebAuthProvider = ThirdwebAuthProvider;
exports.ThirdwebConfigProvider = ThirdwebConfigProvider;
exports.ThirdwebConnectedWalletProvider = ThirdwebConnectedWalletProvider;
exports.ThirdwebProviderCore = ThirdwebProviderCore;
exports.ThirdwebSDKProvider = ThirdwebSDKProvider;
exports.ThirdwebThemeContext = ThirdwebThemeContext;
exports.__DEV__ = __DEV__;
exports.compilerMetadata = compilerMetadata;
exports.contractType = contractType;
exports.getErc1155 = getErc1155;
exports.getErc20 = getErc20;
exports.getErc721 = getErc721;
exports.getErcs = getErcs;
exports.invalidateContractAndBalances = invalidateContractAndBalances;
exports.isEnsName = isEnsName;
exports.isPossibleEVMAddress = isPossibleEVMAddress;
exports.resolveMimeType = resolveMimeType;
exports.shortenAddress = shortenAddress;
exports.shortenIfAddress = shortenIfAddress;
exports.shortenString = shortenString;
exports.shouldNeverPersistQuery = shouldNeverPersistQuery;
exports.useAcceptDirectListingOffer = useAcceptDirectListingOffer;
exports.useAccountAdmins = useAccountAdmins;
exports.useAccountAdminsAndSigners = useAccountAdminsAndSigners;
exports.useAccountSigners = useAccountSigners;
exports.useAccounts = useAccounts;
exports.useAccountsForAddress = useAccountsForAddress;
exports.useActiveChain = useActiveChain;
exports.useActiveClaimCondition = useActiveClaimCondition;
exports.useActiveClaimConditionForWallet = useActiveClaimConditionForWallet;
exports.useActiveListings = useActiveListings;
exports.useAddAdmin = useAddAdmin;
exports.useAddress = useAddress;
exports.useAirdropNFT = useAirdropNFT;
exports.useAllRoleMembers = useAllRoleMembers;
exports.useAppURI = useAppURI;
exports.useAuctionWinner = useAuctionWinner;
exports.useAuth = useAuth;
exports.useBalance = useBalance;
exports.useBalanceForAddress = useBalanceForAddress;
exports.useBatchesToReveal = useBatchesToReveal;
exports.useBidBuffer = useBidBuffer;
exports.useBurnNFT = useBurnNFT;
exports.useBurnToken = useBurnToken;
exports.useBuyDirectListing = useBuyDirectListing;
exports.useBuyNow = useBuyNow;
exports.useCancelDirectListing = useCancelDirectListing;
exports.useCancelEnglishAuction = useCancelEnglishAuction;
exports.useCancelListing = useCancelListing;
exports.useChain = useChain;
exports.useChainId = useChainId;
exports.useClaimConditions = useClaimConditions;
exports.useClaimIneligibilityReasons = useClaimIneligibilityReasons;
exports.useClaimNFT = useClaimNFT;
exports.useClaimToken = useClaimToken;
exports.useClaimedNFTSupply = useClaimedNFTSupply;
exports.useClaimedNFTs = useClaimedNFTs;
exports.useClaimerProofs = useClaimerProofs;
exports.useCompilerMetadata = useCompilerMetadata;
exports.useConnect = useConnect;
exports.useConnectedWallet = useConnectedWallet;
exports.useConnectionStatus = useConnectionStatus;
exports.useContract = useContract;
exports.useContractEvents = useContractEvents;
exports.useContractMetadata = useContractMetadata;
exports.useContractMetadataUpdate = useContractMetadataUpdate;
exports.useContractRead = useContractRead;
exports.useContractType = useContractType;
exports.useContractWrite = useContractWrite;
exports.useCreateAccount = useCreateAccount;
exports.useCreateAuctionListing = useCreateAuctionListing;
exports.useCreateDirectListing = useCreateDirectListing;
exports.useCreateDirectListingBatch = useCreateDirectListingBatch;
exports.useCreateSessionKey = useCreateSessionKey;
exports.useCreateWalletInstance = useCreateWalletInstance;
exports.useDelayedRevealLazyMint = useDelayedRevealLazyMint;
exports.useDirectListing = useDirectListing;
exports.useDirectListings = useDirectListings;
exports.useDirectListingsCount = useDirectListingsCount;
exports.useDisconnect = useDisconnect;
exports.useENS = useENS;
exports.useEdition = useEdition;
exports.useEditionDrop = useEditionDrop;
exports.useEnglishAuction = useEnglishAuction;
exports.useEnglishAuctionWinningBid = useEnglishAuctionWinningBid;
exports.useEnglishAuctions = useEnglishAuctions;
exports.useEnglishAuctionsCount = useEnglishAuctionsCount;
exports.useExecuteAuctionSale = useExecuteAuctionSale;
exports.useGrantRole = useGrantRole;
exports.useIsAccountDeployed = useIsAccountDeployed;
exports.useIsAddressRole = useIsAddressRole;
exports.useLazyMint = useLazyMint;
exports.useListing = useListing;
exports.useListings = useListings;
exports.useListingsCount = useListingsCount;
exports.useLogin = useLogin;
exports.useLogout = useLogout;
exports.useMakeBid = useMakeBid;
exports.useMakeOffer = useMakeOffer;
exports.useMarketplace = useMarketplace;
exports.useMetadata = useMetadata;
exports.useMinimumNextBid = useMinimumNextBid;
exports.useMintNFT = useMintNFT;
exports.useMintNFTSupply = useMintNFTSupply;
exports.useMintToken = useMintToken;
exports.useMultiwrap = useMultiwrap;
exports.useNFT = useNFT;
exports.useNFTBalance = useNFTBalance;
exports.useNFTCollection = useNFTCollection;
exports.useNFTDrop = useNFTDrop;
exports.useNFTs = useNFTs;
exports.useNetwork = useNetwork;
exports.useNetworkMismatch = useNetworkMismatch;
exports.useOffers = useOffers;
exports.useOwnedNFTs = useOwnedNFTs;
exports.usePack = usePack;
exports.usePersonalWalletAddress = usePersonalWalletAddress;
exports.usePlatformFees = usePlatformFees;
exports.usePrimarySaleRecipient = usePrimarySaleRecipient;
exports.useReadonlySDK = useReadonlySDK;
exports.useRemoveAdmin = useRemoveAdmin;
exports.useResetClaimConditions = useResetClaimConditions;
exports.useRevealLazyMint = useRevealLazyMint;
exports.useRevokeRole = useRevokeRole;
exports.useRevokeSessionKey = useRevokeSessionKey;
exports.useRoleMembers = useRoleMembers;
exports.useRoyaltySettings = useRoyaltySettings;
exports.useSDK = useSDK;
exports.useSDKChainId = useSDKChainId;
exports.useSetAllRoleMembers = useSetAllRoleMembers;
exports.useSetAppURI = useSetAppURI;
exports.useSetClaimConditions = useSetClaimConditions;
exports.useSetConnectedWallet = useSetConnectedWallet;
exports.useSetConnectionStatus = useSetConnectionStatus;
exports.useSetSharedMetadata = useSetSharedMetadata;
exports.useSharedMetadata = useSharedMetadata;
exports.useSignatureDrop = useSignatureDrop;
exports.useSigner = useSigner;
exports.useSplit = useSplit;
exports.useStorage = useStorage;
exports.useStorageUpload = useStorageUpload;
exports.useSupportedChains = useSupportedChains;
exports.useSupportedWallet = useSupportedWallet;
exports.useSwitchAccount = useSwitchAccount;
exports.useSwitchChain = useSwitchChain;
exports.useThirdwebAuthContext = useThirdwebAuthContext;
exports.useThirdwebConfigContext = useThirdwebConfigContext;
exports.useThirdwebConnectedWalletContext = useThirdwebConnectedWalletContext;
exports.useToken = useToken;
exports.useTokenBalance = useTokenBalance;
exports.useTokenDecimals = useTokenDecimals;
exports.useTokenDrop = useTokenDrop;
exports.useTokenSupply = useTokenSupply;
exports.useTotalCirculatingSupply = useTotalCirculatingSupply;
exports.useTotalCount = useTotalCount;
exports.useTransferBatchToken = useTransferBatchToken;
exports.useTransferNFT = useTransferNFT;
exports.useTransferNativeToken = useTransferNativeToken;
exports.useTransferToken = useTransferToken;
exports.useUnclaimedNFTSupply = useUnclaimedNFTSupply;
exports.useUnclaimedNFTs = useUnclaimedNFTs;
exports.useUpdateMetadata = useUpdateMetadata;
exports.useUpdatePlatformFees = useUpdatePlatformFees;
exports.useUpdatePrimarySaleRecipient = useUpdatePrimarySaleRecipient;
exports.useUpdateRoyaltySettings = useUpdateRoyaltySettings;
exports.useUser = useUser;
exports.useValidDirectListings = useValidDirectListings;
exports.useValidEnglishAuctions = useValidEnglishAuctions;
exports.useVote = useVote;
exports.useWallet = useWallet;
exports.useWalletConfig = useWalletConfig;
exports.useWalletConnectHandler = useWalletConnectHandler;
exports.useWalletContext = useWalletContext;
exports.useWallets = useWallets;
exports.useWatchTransactions = useWatchTransactions;
exports.useWinningBid = useWinningBid;
