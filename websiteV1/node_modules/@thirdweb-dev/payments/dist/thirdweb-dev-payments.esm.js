// UNCHANGED: MERGE BETWEEN sdk-common-utilities/settings and js-client-sdk/settings
const isDev = () => {
  return !!(typeof window !== "undefined" && window.localStorage.getItem("IS_PAPER_DEV") === "true");
};
const isOldPaperDomain = () => typeof window !== "undefined" && (window.location.hostname === "paper.xyz" || window.location.hostname.endsWith(".paper.xyz"));
const isThirdwebDomain = () => typeof window !== "undefined" && (window.location.hostname === "thirdweb.com" || window.location.hostname.endsWith(".thirdweb.com"));
const getPaperOriginUrl = () => {
  if (isDev()) {
    return window.localStorage.getItem("PAPER_DEV_URL") ?? "http://localhost:3000";
  }
  if (isOldPaperDomain()) {
    return window.location.origin;
  }
  if (isThirdwebDomain()) {
    return window.location.origin;
  }
  return "https://payments.thirdweb.com";
};

// eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
const PAPER_APP_URL = getPaperOriginUrl();
const CHECKOUT_WITH_ETH_IFRAME_URL = "/sdk/2022-08-12/checkout-with-eth";
const CHECKOUT_WITH_CARD_IFRAME_URL = "/sdk/2022-08-12/checkout-with-card";
const CREATE_WALLET_IFRAME_URL = "/sdk/v2/verify-email";

// UNCHANGED: MERGED FROM sdk-common-utilities/blockchain
const ChainToPublicRpc = {
  Ethereum: "https://ethereum.rpc.thirdweb.com",
  Goerli: "https://goerli.rpc.thirdweb.com",
  Mumbai: "https://mumbai.rpc.thirdweb.com",
  Polygon: "https://polygon.rpc.thirdweb.com",
  Avalanche: "https://avalanche.rpc.thirdweb.com",
  Optimism: "https://optimism.rpc.thirdweb.com",
  OptimismGoerli: "https://optimism-goerli.rpc.thirdweb.com",
  BSC: "https://binance.rpc.thirdweb.com",
  BSCTestnet: "https://binance-testnet.rpc.thirdweb.com",
  ArbitrumOne: "https://arbitrum.rpc.thirdweb.com",
  ArbitrumGoerli: "https://arbitrum-goerli.rpc.thirdweb.com",
  Fantom: "https://fantom.rpc.thirdweb.com",
  FantomTestnet: "https://fantom-testnet.rpc.thirdweb.com",
  Sepolia: "https://sepolia.rpc.thirdweb.com",
  AvalancheFuji: "https://avalanche-fuji.rpc.thirdweb.com"
};
const ChainIdToChain = {
  1: "Ethereum",
  5: "Goerli",
  80001: "Mumbai",
  137: "Polygon",
  43114: "Avalanche",
  10: "Optimism",
  420: "OptimismGoerli",
  56: "BSC",
  97: "BSCTestnet",
  42161: "ArbitrumOne",
  421613: "ArbitrumGoerli",
  250: "Fantom",
  4002: "FantomTestnet",
  11155111: "Sepolia",
  43113: "AvalancheFuji"
};

// General Embedded wallet types

// // UNCHANGED: MERGED FROM sdk-common-utilities/style

const DEFAULT_BRAND_OPTIONS = {
  colorPrimary: "#cf3781",
  colorBackground: "#ffffff",
  colorText: "#1a202c",
  borderRadius: 12,
  fontFamily: "Open Sans"
};

// CHANGED: Updated name to Payments

let PaymentsSDKErrorCode = /*#__PURE__*/function (PaymentsSDKErrorCode) {
  PaymentsSDKErrorCode["UserAbandonedCheckout"] = "User abandoned the checkout";
  PaymentsSDKErrorCode["UserLoginFailed"] = "User login failed";
  PaymentsSDKErrorCode["InvalidProps"] = "The props you passed in to this component are not valid.";
  PaymentsSDKErrorCode["InvalidCard"] = "The card information is invalid. Please double check that the Card, CVC, and Zip code are all correct.";
  PaymentsSDKErrorCode["EmailNotVerified"] = "The email was unable to be verified.";
  PaymentsSDKErrorCode["NotEnoughSupply"] = "There is not enough supply to claim.";
  PaymentsSDKErrorCode["AddressNotAllowed"] = "This address is not on the allowlist.";
  PaymentsSDKErrorCode["NoActiveClaimPhase"] = "There is no active claim phase at the moment.";
  return PaymentsSDKErrorCode;
}({});
let PayWithCryptoErrorCode = /*#__PURE__*/function (PayWithCryptoErrorCode) {
  PayWithCryptoErrorCode["ErrorConnectingToWallet"] = "Error connecting to wallet";
  PayWithCryptoErrorCode["ErrorSendingTransaction"] = "Something went wrong sending transaction";
  PayWithCryptoErrorCode["InsufficientBalance"] = "Insufficient ETH";
  PayWithCryptoErrorCode["TransactionCancelled"] = "Transaction Cancelled";
  PayWithCryptoErrorCode["WrongChain"] = "Wrong Chain Detected";
  PayWithCryptoErrorCode["ChainSwitchUnderway"] = "There is a network switch already underway";
  PayWithCryptoErrorCode["PendingSignature"] = "Pending Signature";
  return PayWithCryptoErrorCode;
}({});

// CHANGED: added clientId to link

class LinksManager {
  constructor(baseLink) {
    this.link = baseLink;
  }
  addStylingOptions(options) {
    if (options.colorPrimary) {
      this.link.searchParams.set("colorPrimary", options.colorPrimary);
    }
    if (options.colorBackground) {
      this.link.searchParams.set("colorBackground", options.colorBackground);
    }
    if (options.colorText) {
      this.link.searchParams.set("colorText", options.colorText);
    }
    if (options.borderRadius !== undefined) {
      this.link.searchParams.set("borderRadius", options.borderRadius.toString());
    }
    if (options.fontFamily) {
      this.link.searchParams.set("fontFamily", options.fontFamily);
    }
    if (options.inputBackgroundColor) {
      this.link.searchParams.set("inputBackgroundColor", options.inputBackgroundColor);
    }
    if (options.inputBorderColor) {
      this.link.searchParams.set("inputBorderColor", options.inputBorderColor);
    }
  }
  addClientSecret(sdkClientSecret) {
    this.link.searchParams.set("sdkClientSecret", sdkClientSecret);
  }
  addClientId(clientId) {
    this.link.searchParams.set("clientId", clientId);
  }
  addLocale(locale) {
    if (locale) {
      this.link.searchParams.set("locale", locale.toString());
    }
  }
  addOTP() {
    this.link.searchParams.set("withOTP", "true");
  }
  addAppName(appName) {
    if (appName) {
      this.link.searchParams.set("appName", appName);
    }
  }
  addShowConnectWalletOptions(showConnectWalletOptions) {
    this.link.searchParams.append("showConnectWalletOptions", showConnectWalletOptions.toString());
  }
  addReceivingWalletType(walletType) {
    this.link.searchParams.append("walletType", walletType || "Preset");
  }
  addRecipientWalletAddress(address) {
    this.link.searchParams.set("recipientWalletAddress", address);
  }
  addPayerWalletAddress(address) {
    this.link.searchParams.append("payerWalletAddress", address);
  }
  addDate(date) {
    this.link.searchParams.set("date", date ? date.toString() : Date.now().toString());
  }
  getLink() {
    return this.link;
  }
}

// UNCHANGED
/**
 * Opens a popup centered on the current window.
 * Note that modern browsers may prevent popups from opening automatically,
 * so try to handle the case where the window returned is null.
 *
 * @returns Window | null - The Window object that was opened. If null is returned, the popup failed to open.
 */
const openCenteredPopup = _ref => {
  let {
    url,
    width = 440,
    height = 700
  } = _ref;
  if (!window?.top) {
    return null;
  }
  const y = window.top.outerHeight / 2 + window.top.screenY - height / 2;
  const x = window.top.outerWidth / 2 + window.top.screenX - width / 2;
  return window.open(url, "_blank", `popup=true,width=${width},height=${height},top=${y},left=${x}`);
};

// UNCHANGED
function postMessageToIframe(frame, eventType, data) {
  frame.contentWindow?.postMessage({
    eventType,
    ...data
  }, "*");
}

var packageJson = {
	name: "@thirdweb-dev/payments",
	version: "1.0.2",
	main: "dist/thirdweb-dev-payments.cjs.js",
	module: "dist/thirdweb-dev-payments.esm.js",
	types: "dist/thirdweb-dev-payments.cjs.d.ts",
	browser: {
		"./dist/thirdweb-dev-payments.esm.js": "./dist/thirdweb-dev-payments.browser.esm.js"
	},
	exports: {
		".": {
			module: {
				browser: "./dist/thirdweb-dev-payments.browser.esm.js",
				"default": "./dist/thirdweb-dev-payments.esm.js"
			},
			"default": "./dist/thirdweb-dev-payments.cjs.js"
		},
		"./package.json": "./package.json"
	},
	repository: "https://github.com/thirdweb-dev/js/tree/main/packages/payments",
	license: "Apache-2.0",
	bugs: {
		url: "https://github.com/thirdweb-dev/js/issues"
	},
	author: "thirdweb eng <eng@thirdweb.com>",
	files: [
		"dist/"
	],
	preconstruct: {
		entrypoints: [
			"index.ts"
		],
		exports: {
			envConditions: [
				"browser"
			]
		}
	},
	sideEffects: false,
	dependencies: {
		ethers: "^5.7.2"
	},
	devDependencies: {
		"@thirdweb-dev/tsconfig": "workspace:*",
		"eslint-config-thirdweb": "workspace:*",
		typescript: "^5.1.6",
		"@preconstruct/cli": "2.7.0"
	},
	scripts: {
		format: "prettier --write 'src/**/*'",
		lint: "eslint src/",
		fix: "eslint src/ --fix",
		clean: "rm -rf dist/",
		build: "tsc && preconstruct build",
		"preconstruct:fix": "preconstruct fix",
		push: "yalc push"
	}
};

// CHANGED: packageJson import + version string
class PaperPaymentElement {
  constructor(_ref) {
    let {
      elementOrId,
      onLoad
    } = _ref;
    this.elementOrId = elementOrId;
    this.onLoad = onLoad;
  }
  createPaymentElement(_ref2) {
    let {
      handler,
      link,
      iframeId
    } = _ref2;
    const iframe = document.createElement("iframe");
    iframe.src = link.href;
    iframe.id = iframeId;
    iframe.allow = "payment";
    iframe.setAttribute("style", "margin-left:auto; margin-right:auto; width:100%; height: 100%; min-height:375px; transition-property:all; transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1); transition-duration:150ms; color-scheme: light;");
    iframe.onload = event => {
      if (this.onLoad) {
        this.onLoad(event);
      }
    };
    iframe.setAttribute("data-thirdweb-sdk-version", `${packageJson.name}@${packageJson.version}`);
    if (!this.elementOrId) {
      window.addEventListener("message", handler(iframe));
      return iframe;
    }
    let container = this.elementOrId;
    if (typeof container === "string") {
      const domElement = document.getElementById(container);
      if (!domElement) {
        throw new Error("Invalid id given");
      }
      container = domElement;
    }
    const existing = container.querySelector("#" + iframeId);
    // if we already created an iframe, consider updating the iframe link if it's new
    if (existing) {
      if (existing.src === link.href) {
        return existing;
      }
      existing.src = link.href;
      return existing;
    }
    window.addEventListener("message", handler(iframe));
    return container.appendChild(iframe);
  }
}

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

const fullScreen$1 = {
  top: "0px",
  left: "0px",
  right: "0px",
  bottom: "0px"
};
const getDefaultModalStyles$1 = () => ({
  main: {
    ...fullScreen$1,
    position: "fixed",
    zIndex: "10000",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    pointerEvents: "auto"
  },
  overlay: {
    ...fullScreen$1,
    position: "absolute",
    backgroundColor: "rgba(0, 0, 0, 0.33)",
    pointerEvents: "auto"
  },
  body: {
    background: "transparent",
    borderRadius: "12px",
    position: "relative",
    overflow: "hidden",
    width: "100%",
    maxWidth: "500px",
    height: "700px",
    maxHeight: "80%",
    animation: "pew-modal-slideIn 0.2s forwards",
    pointerEvents: "auto"
  },
  spinner: {
    position: "absolute",
    top: "0",
    bottom: "0",
    left: "0",
    right: "0",
    margin: "auto",
    borderWidth: "3px",
    borderColor: "#2D3748 #2D3748 transparent transparent",
    borderRadius: "50%",
    width: "30px",
    height: "30px",
    animation: "spin 1s linear infinite"
  },
  iframe: {
    position: "relative",
    height: "100%",
    width: "100%",
    border: "none",
    background: "transparent"
  }
});
const modalKeyframeAnimations = `
  @keyframes pew-modal-slideIn {
    from {opacity: 0; transform: translate3d(0, 20px, 0);}
    to {opacity: 1; transform: translate3d(0, 0, 0);}
  }

  @keyframes pew-modal-slideOut {
    from {opacity: 1; transform: translate3d(0, 0, 0);}
    to {opacity: 0; transform: translate3d(0, 20px, 0);}
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
`;

const MODAL_ID = "paper-js-sdk-modal";
class Modal {
  constructor(container, styles) {
    // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
    _defineProperty(this, "styles", getDefaultModalStyles$1());
    this.container = container || document.body;
    if (styles) {
      this.mergeStyles(styles);
    }
    this.main = document.createElement("div");
    this.main.id = MODAL_ID;
    this.overlay = document.createElement("div");
    this.overlay.id = `${MODAL_ID}-overlay`;
    this.body = document.createElement("div");
    this.body.id = `${MODAL_ID}-body`;
    this.spinner = document.createElement("div");
    this.spinner.id = `${MODAL_ID}-spinner`;
    this.iframe = document.createElement("iframe");
    this.iframe.id = `${MODAL_ID}-iframe`;
    this.iframe.allow = "camera; microphone; payment";
    this.iframe.setAttribute("data-thirdweb-sdk-version", `${packageJson.name}@${packageJson.version}`);
    this.style = document.createElement("style");
    this.style.innerHTML = modalKeyframeAnimations;
    this.assignStyles(this.main, this.styles.main);
    this.assignStyles(this.overlay, this.styles.overlay);
    this.assignStyles(this.body, this.styles.body);
    this.assignStyles(this.spinner, this.styles.spinner);
    this.assignStyles(this.iframe, this.styles.iframe);
  }
  open() {
    let {
      iframeUrl
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (iframeUrl) {
      this.body.appendChild(this.spinner);
      this.iframe.src = iframeUrl;
      // Remove the spinner when the iframe loads.
      this.iframe.onload = () => this.body.removeChild(this.spinner);
      this.body.appendChild(this.iframe);
    }
    this.addAccessibility();
    this.main.appendChild(this.overlay);
    this.main.appendChild(this.style);
    this.main.appendChild(this.body);
    this.container.appendChild(this.main);
    document.body.style.overflow = "hidden";
  }
  close() {
    this.body.style.animation = "pew-modal-slideOut 0.2s forwards";
    window.setTimeout(() => this.main.remove(), 250);
  }
  mergeStyles(styles) {
    this.styles.body = {
      ...this.styles.body,
      ...(styles.body || {})
    };
    this.styles.spinner = {
      ...this.styles.spinner,
      ...(styles.spinner || {})
    };
    this.styles.overlay = {
      ...this.styles.overlay,
      ...(styles.overlay || {})
    };
    this.styles.main = {
      ...this.styles.main,
      ...(styles.main || {})
    };
    this.styles.iframe = {
      ...this.styles.iframe,
      ...(styles.iframe || {})
    };
  }
  addAccessibility() {
    this.main.setAttribute("aria-hidden", "true");
    this.overlay.setAttribute("aria-hidden", "true");
    this.body.setAttribute("aria-modal", "true");
    this.body.setAttribute("role", "dialog");
  }
  assignStyles(el, styles) {
    Object.assign(el.style, styles);
  }
}

// CHANGED: Added clientId to interface
function createCheckoutWithCardLink(_ref) {
  let {
    clientId,
    sdkClientSecret,
    appName,
    options = {
      ...DEFAULT_BRAND_OPTIONS
    },
    locale,
    configs
  } = _ref;
  const CheckoutWithCardUrlBase = new URL(CHECKOUT_WITH_CARD_IFRAME_URL, PAPER_APP_URL);
  let clientSecret = sdkClientSecret;
  if (!clientSecret && configs) {
    clientSecret = btoa(JSON.stringify(configs));
  }
  if (!clientSecret) {
    const error = `Must have either sdkClientSecret or configs field set. Received neither`;
    const destination = `/error?errorMessage=${error}`;
    const domain = getPaperOriginUrl();
    return new URL(destination, domain);
  }
  if (!clientId) {
    const error = `Must have clientId field set. Please add clientId`;
    const destination = `/error?errorMessage=${error}`;
    const domain = getPaperOriginUrl();
    return new URL(destination, domain);
  }
  const checkoutWithCardLink = new LinksManager(CheckoutWithCardUrlBase);
  checkoutWithCardLink.addClientId(clientId ?? "");
  checkoutWithCardLink.addClientSecret(clientSecret ?? "");
  checkoutWithCardLink.addStylingOptions(options);
  checkoutWithCardLink.addLocale(locale);
  checkoutWithCardLink.addAppName(appName);
  return checkoutWithCardLink.getLink();
}
function createCheckoutWithCardMessageHandler(_ref2) {
  let {
    iframe,
    onError,
    onReview,
    onPaymentSuccess,
    onBeforeModalOpen,
    onPriceUpdate
  } = _ref2;
  let modal;
  return event => {
    if (!event.origin.startsWith(PAPER_APP_URL)) {
      return;
    }
    const {
      data
    } = event;
    switch (data.eventType) {
      case "checkoutWithCardError":
        if (onError) {
          onError({
            code: data.code,
            error: data.error
          });
        }
        break;
      case "paymentSuccess":
        if (onPaymentSuccess) {
          onPaymentSuccess({
            transactionId: data.id,
            id: data.id
          });
        }
        if (data.postToIframe) {
          postMessageToIframe(iframe, data.eventType, data);
        }
        break;
      case "reviewComplete":
        if (onReview) {
          onReview({
            id: data.id,
            cardholderName: data.cardholderName
          });
        }
        break;
      case "openModalWithUrl":
        if (onBeforeModalOpen && data.url && data.url.includes("promptKYCModal")) {
          onBeforeModalOpen({
            url: data.url
          });
        } else {
          modal = new Modal(undefined, {
            body: {
              colorScheme: "light"
            }
          });
          modal.open({
            iframeUrl: data.url
          });
        }
        break;
      case "completedSDKModal":
        modal.close();
        if (data.postToIframe) {
          postMessageToIframe(iframe, data.eventType, data);
        }
        break;
      case "requestedPopup":
        {
          // The iframe requested a popup.
          // The reference to this window is not stored so the popup cannot
          // be programmatically closed.
          const popupRef = openCenteredPopup({
            url: data.url,
            width: data.width,
            height: data.height
          });
          if (!popupRef) {
            console.error("CheckoutWithCard: Unable to open popup.");
          }
          break;
        }
      case "sizing":
        iframe.style.height = data.height + "px";
        iframe.style.maxHeight = data.height + "px";
        break;
      case "onPriceUpdate":
        {
          onPriceUpdate?.(data);
          break;
        }
      // Ignore unrecognized event
    }
  };
}

function createCheckoutWithCardElement(_ref3) {
  let {
    clientId,
    onCloseKycModal,
    onOpenKycModal,
    sdkClientSecret,
    appName,
    elementOrId,
    onLoad,
    onError,
    locale,
    options,
    onPaymentSuccess,
    onReview,
    onBeforeModalOpen,
    onPriceUpdate,
    useAltDomain = true,
    configs
  } = _ref3;
  const checkoutWithCardId = "checkout-with-card-iframe";
  const checkoutWithCardMessageHandler = iframe => createCheckoutWithCardMessageHandler({
    iframe,
    onCloseKycModal,
    onOpenKycModal,
    onError,
    onPaymentSuccess,
    onReview,
    onBeforeModalOpen,
    onPriceUpdate,
    useAltDomain
  });
  const checkoutWithCardUrl = createCheckoutWithCardLink({
    clientId,
    sdkClientSecret,
    appName,
    locale,
    options,
    useAltDomain,
    configs
  });
  const paymentElement = new PaperPaymentElement({
    onLoad,
    elementOrId
  });
  return paymentElement.createPaymentElement({
    handler: checkoutWithCardMessageHandler,
    iframeId: checkoutWithCardId,
    link: checkoutWithCardUrl
  });
}

// Changed: Updated PaperSDKError
const handlePayWithCryptoError = async (error, onError, postToParent) => {
  if ("isErrorObject" in error) {
    if (onError) {
      await onError({
        code: error.title,
        error: new Error(error.title)
      });
    }
    if (postToParent) {
      postToParent({
        ...error
      });
    }
  } else if (!("message" in error)) {
    if (onError) {
      await onError({
        code: PayWithCryptoErrorCode.ErrorSendingTransaction,
        error: new Error(JSON.stringify(error))
      });
    }
    if (postToParent) {
      postToParent({
        description: `${error}`,
        title: PayWithCryptoErrorCode.ErrorSendingTransaction
      });
    }
  } else {
    if (error.message.includes("rejected") || error.message.includes("denied transaction")) {
      if (onError) {
        await onError({
          code: PayWithCryptoErrorCode.TransactionCancelled,
          error
        });
      }
      if (postToParent) {
        postToParent({
          description: "",
          title: PayWithCryptoErrorCode.TransactionCancelled
        });
      }
    } else if (error.message.includes("insufficient funds")) {
      if (onError) {
        await onError({
          code: PayWithCryptoErrorCode.InsufficientBalance,
          error
        });
      }
      if (postToParent) {
        postToParent({
          description: "Check your wallet's ETH balance to make sure you have enough!",
          title: PayWithCryptoErrorCode.InsufficientBalance
        });
      }
    } else if (error.message.includes("Error switching chain")) {
      if (onError) {
        await onError({
          code: PayWithCryptoErrorCode.ChainSwitchUnderway,
          error
        });
      }
      if (postToParent) {
        postToParent({
          description: "Check your wallet app",
          title: PayWithCryptoErrorCode.ChainSwitchUnderway
        });
      }
    } else {
      if (onError) {
        await onError({
          code: PayWithCryptoErrorCode.ErrorSendingTransaction,
          error
        });
      }
      if (postToParent) {
        postToParent({
          description: `${error.message}`,
          title: PayWithCryptoErrorCode.ErrorSendingTransaction
        });
      }
    }
  }
};

// CHANGED: Imports only
const PAY_WITH_ETH_ERROR = "payWithEthError";
async function checkAndSendEth(_ref) {
  let {
    data,
    iframe,
    payingWalletSigner,
    suppressErrorToast,
    onError,
    onPaymentSuccess
  } = _ref;
  try {
    const chainId = await payingWalletSigner.getChainId();
    if (chainId !== data.chainId) {
      throw {
        isErrorObject: true,
        title: PayWithCryptoErrorCode.WrongChain,
        description: `Please change to ${data.chainName} to proceed.`
      };
    }
  } catch (e) {
    await handlePayWithCryptoError(e, onError, errorObject => {
      postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
        error: errorObject,
        suppressErrorToast
      });
    });
    return;
  }

  // send the transaction
  try {
    console.log("sending funds...", data);
    const result = await payingWalletSigner.sendTransaction({
      chainId: data.chainId,
      data: data.blob,
      to: data.paymentAddress,
      value: data.value
    });
    const receipt = await result.wait();
    if (onPaymentSuccess && result) {
      await onPaymentSuccess({
        onChainTxResponse: result,
        onChainTxReceipt: receipt,
        transactionId: data.transactionId
      });
    }
    if (result) {
      postMessageToIframe(iframe, "paymentSuccess", {
        suppressErrorToast,
        transactionHash: result.hash
      });
    }
  } catch (error) {
    console.log("error sending funds", error);
    await handlePayWithCryptoError(error, onError, errorObject => {
      postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
        error: errorObject,
        suppressErrorToast
      });
    });
  }
}
function createCheckoutWithEthMessageHandler(_ref2) {
  let {
    iframe,
    onError,
    onPaymentSuccess,
    onPriceUpdate,
    payingWalletSigner,
    suppressErrorToast = false,
    setUpUserPayingWalletSigner
  } = _ref2;
  return async event => {
    if (!event.origin.startsWith(PAPER_APP_URL)) {
      return;
    }
    const data = event.data;
    switch (data.eventType) {
      case "payWithEth":
        {
          if (data.error) {
            await handlePayWithCryptoError(new Error(data.error), onError, errorObject => {
              postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
                error: errorObject,
                suppressErrorToast
              });
            });
            return;
          }
          // Allows Dev's to inject any chain switching for their custom signer here.
          if (setUpUserPayingWalletSigner) {
            try {
              console.log("setting up signer");
              await setUpUserPayingWalletSigner({
                chainId: data.chainId,
                chainName: data.chainName
              });
            } catch (error) {
              console.log("error setting up signer", error);
              await handlePayWithCryptoError(error, onError, errorObject => {
                postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
                  error: errorObject,
                  suppressErrorToast
                });
              });
              return;
            }
          }
          await checkAndSendEth({
            data,
            iframe,
            payingWalletSigner,
            suppressErrorToast,
            onError,
            onPaymentSuccess
          });
          break;
        }
      case "checkout-with-eth-sizing":
        {
          iframe.style.height = data.height + "px";
          iframe.style.maxHeight = data.height + "px";
          break;
        }
      case "onPriceUpdate":
        {
          onPriceUpdate?.(data);
          break;
        }
    }
  };
}
async function createCheckoutWithEthLink(_ref3) {
  let {
    sdkClientSecret,
    payingWalletSigner,
    receivingWalletType,
    showConnectWalletOptions = false,
    appName,
    locale,
    options = {
      ...DEFAULT_BRAND_OPTIONS
    },
    configs
  } = _ref3;
  const checkoutWithEthUrlBase = new URL(CHECKOUT_WITH_ETH_IFRAME_URL, PAPER_APP_URL);
  const address = await payingWalletSigner.getAddress();
  let clientSecret = sdkClientSecret;
  if (!clientSecret && configs) {
    clientSecret = btoa(JSON.stringify(configs));
  }
  if (!clientSecret) {
    const error = `Must have either sdkClientSecret or configs field set. Received neither`;
    const destination = `/error?errorMessage=${error}`;
    const domain = getPaperOriginUrl();
    return new URL(destination, domain);
  }
  const checkoutWithEthLink = new LinksManager(checkoutWithEthUrlBase);
  checkoutWithEthLink.addClientSecret(clientSecret ?? "");
  checkoutWithEthLink.addRecipientWalletAddress(address);
  checkoutWithEthLink.addPayerWalletAddress(address);
  checkoutWithEthLink.addReceivingWalletType(receivingWalletType);
  checkoutWithEthLink.addAppName(appName);
  checkoutWithEthLink.addShowConnectWalletOptions(showConnectWalletOptions);
  checkoutWithEthLink.addStylingOptions(options);
  checkoutWithEthLink.addLocale(locale);
  return checkoutWithEthLink.getLink();
}
async function createCheckoutWithEthElement(_ref4) {
  let {
    sdkClientSecret,
    suppressErrorToast,
    onError,
    onLoad,
    payingWalletSigner,
    receivingWalletType,
    appName,
    showConnectWalletOptions,
    locale,
    options,
    elementOrId,
    onPaymentSuccess: _onPaymentSuccess,
    onSuccess
  } = _ref4;
  const onPaymentSuccess = _onPaymentSuccess ?? onSuccess;
  const checkoutWithEthId = "checkout-with-eth-iframe";
  const checkoutWithEthMessageHandler = iframe => createCheckoutWithEthMessageHandler({
    iframe,
    onError,
    payingWalletSigner,
    suppressErrorToast,
    onPaymentSuccess
  });
  const checkoutWithEthUrl = await createCheckoutWithEthLink({
    payingWalletSigner,
    sdkClientSecret,
    appName,
    locale,
    options,
    receivingWalletType,
    showConnectWalletOptions
  });
  const paymentElement = new PaperPaymentElement({
    onLoad,
    elementOrId
  });
  return paymentElement.createPaymentElement({
    handler: checkoutWithEthMessageHandler,
    iframeId: checkoutWithEthId,
    link: checkoutWithEthUrl
  });
}

const fullScreen = {
  position: "fixed",
  top: "0px",
  left: "0px",
  right: "0px",
  bottom: "0px"
};
const getDefaultModalStyles = () => ({
  main: {
    ...fullScreen,
    zIndex: "2147483646",
    display: "flex",
    alignItems: "center",
    justifyContent: "end"
  },
  overlay: {
    ...fullScreen,
    backgroundColor: "rgba(0, 0, 0, 0)",
    transition: "background-color ease-out 0.2s"
  },
  body: {
    position: "fixed",
    width: "100%",
    maxWidth: "420px",
    top: "0px",
    bottom: "0px",
    right: "-100px",
    opacity: "0",
    boxShadow: "0px 10px 20px rgba(0, 0, 0, 0.25)",
    backgroundColor: window.matchMedia("(prefers-color-scheme: dark)").matches ? "#2F2F2F" : "white",
    overflow: "hidden",
    transition: "all ease-out 0.2s"
  },
  spinner: {
    position: "absolute",
    top: "0",
    bottom: "0",
    left: "0",
    right: "0",
    margin: "auto",
    borderWidth: "3px",
    borderColor: "#2D3748 #2D3748 transparent transparent",
    borderRadius: "50%",
    width: "30px",
    height: "30px",
    animation: "spin 1s linear infinite"
  },
  iframe: {
    height: "100%",
    width: "100%",
    border: "none",
    backgroundColor: "transparent"
  },
  closeButton: {
    position: "fixed",
    cursor: "pointer",
    top: "0.75rem",
    right: "1rem",
    color: "#888",
    padding: "2px 8px"
  }
});

const MAIN_CLASSNAME = "paper--drawer-main";
const OVERLAY_CLASSNAME = "paper--drawer-overlay";
const BODY_CLASSNAME = "paper--drawer-body";
const CLOSE_CLASSNAME = "paper--drawer-close";
class Drawer {
  constructor(container, styles) {
    // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
    _defineProperty(this, "styles", getDefaultModalStyles());
    this.container = container || document.body;
    if (styles) {
      this.mergeStyles(styles);
    }
    this.main = document.createElement("div");
    this.main.className = MAIN_CLASSNAME;
    this.overlay = document.createElement("div");
    this.overlay.className = OVERLAY_CLASSNAME;
    this.body = document.createElement("div");
    this.body.className = BODY_CLASSNAME;
    this.closeButton = document.createElement("button");
    this.closeButton.className = CLOSE_CLASSNAME;
    this.closeButton.innerHTML = "&#x2715;";
    this.closeButton.onclick = () => {
      this.close();
    };
    this.iframe = document.createElement("iframe");
    this.iframe.allow = "camera; microphone; payment";
    this.iframe.setAttribute("data-thirdweb-sdk-version", `${packageJson.name}@${packageJson.version}`);
    this.assignStyles(this.main, this.styles.main);
    this.assignStyles(this.overlay, this.styles.overlay);
    this.assignStyles(this.body, this.styles.body);
    this.assignStyles(this.iframe, this.styles.iframe);
    if (this.styles.closeButton) {
      this.assignStyles(this.closeButton, this.styles.closeButton);
    }
  }
  open() {
    let {
      iframeUrl
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (iframeUrl) {
      this.iframe.src = iframeUrl;
      this.body.appendChild(this.iframe);
    }
    this.addAccessibility();
    this.main.appendChild(this.overlay);
    this.main.appendChild(this.body);
    this.main.appendChild(this.closeButton);
    this.container.appendChild(this.main);
    document.body.style.overflow = "hidden";

    // Animate in.
    this.overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    this.body.style.right = "0px";
    this.body.style.opacity = "1";
    return this.iframe;
  }
  close() {
    this.closeButton.remove();

    // Animate out.
    this.overlay.style.backgroundColor = "rgba(0, 0, 0, 0)";
    this.body.style.right = "-100px";
    this.body.style.opacity = "0";

    // Remove drawer from DOM.
    this.closeTimeout = window.setTimeout(() => {
      document.body.style.overflow = "visible";
      this.main.remove();
      window.clearTimeout(this.closeTimeout);
      this.onCloseCallback?.();
    }, 250);
  }
  setOnCloseCallback(callback) {
    this.onCloseCallback = callback;
  }
  mergeStyles(styles) {
    this.styles.body = {
      ...this.styles.body,
      ...(styles.body || {})
    };
    this.styles.overlay = {
      ...this.styles.overlay,
      ...(styles.overlay || {})
    };
    this.styles.main = {
      ...this.styles.main,
      ...(styles.main || {})
    };
    this.styles.iframe = {
      ...this.styles.iframe,
      ...(styles.iframe || {})
    };
    this.styles.closeButton = {
      ...this.styles.closeButton,
      ...(styles.closeButton || {})
    };
  }
  addAccessibility() {
    this.main.setAttribute("aria-hidden", "true");
    this.overlay.setAttribute("aria-hidden", "true");
    this.body.setAttribute("aria-modal", "true");
    this.body.setAttribute("role", "dialog");
  }
  assignStyles(el, styles) {
    Object.assign(el.style, styles);
  }
}

// UNCHANGED
async function sleepForSeconds(seconds) {
  return new Promise(res => {
    setTimeout(() => {
      res(0);
    }, seconds * 1000);
  });
}
function renderPaperCheckoutLink(_ref) {
  let {
    checkoutLinkUrl,
    onPaymentSucceeded,
    onPaymentFailed,
    onTransferSucceeded,
    onModalClosed
  } = _ref;
  const drawer = new Drawer();
  const formattedCheckoutLinkUrl = new URL(checkoutLinkUrl);
  formattedCheckoutLinkUrl.searchParams.set("display", "DRAWER");
  drawer.open({
    iframeUrl: formattedCheckoutLinkUrl.href
  });
  if (onModalClosed) {
    drawer.setOnCloseCallback(onModalClosed);
  }
  const messageHandler = async e => {
    if (e.origin !== PAPER_APP_URL) {
      return;
    }
    const result = e.data;
    if (!result.eventType) {
      return;
    }
    switch (result.eventType) {
      case "paymentSuccess":
        {
          const transactionId = e.data.id;
          onPaymentSucceeded?.({
            transactionId
          });
          break;
        }
      case "claimSuccessful":
        {
          const {
            id: transactionId,
            claimedTokens
          } = e.data;
          onTransferSucceeded?.({
            transactionId,
            claimedTokens
          });
          await sleepForSeconds(3.5);
          drawer.close();
          break;
        }
      case "redirectAfterSuccess":
        {
          const redirectUrl = e.data.redirectUrl;
          window.location.assign(redirectUrl);
          break;
        }
      case "paymentFailed":
        {
          const transactionId = e.data.id;
          onPaymentFailed?.({
            transactionId
          });
          break;
        }
      case "modalClosed":
        {
          onModalClosed?.();
          break;
        }
      default:
        throw new Error(`Unsupported eventType ${result.eventType}`);
    }
  };
  window.addEventListener("message", messageHandler);
}

export { CHECKOUT_WITH_CARD_IFRAME_URL, CHECKOUT_WITH_ETH_IFRAME_URL, CREATE_WALLET_IFRAME_URL, ChainIdToChain, ChainToPublicRpc, DEFAULT_BRAND_OPTIONS, PAPER_APP_URL, PAY_WITH_ETH_ERROR, PayWithCryptoErrorCode, PaymentsSDKErrorCode, checkAndSendEth, createCheckoutWithCardElement, createCheckoutWithCardLink, createCheckoutWithCardMessageHandler, createCheckoutWithEthElement, createCheckoutWithEthLink, createCheckoutWithEthMessageHandler, getPaperOriginUrl, renderPaperCheckoutLink };
