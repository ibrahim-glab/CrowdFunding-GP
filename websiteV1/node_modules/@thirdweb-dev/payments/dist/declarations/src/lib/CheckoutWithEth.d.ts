import type { ethers } from "ethers";
import type { ICustomizationOptions, Locale } from "../constants/style";
import type { PaymentsSDKError } from "../interfaces/PaymentsSdkError";
import type { PriceSummary } from "../interfaces/PriceSummary";
import type { PaperPaymentElementConstructorArgs } from "./CreatePaymentElement";
export declare const PAY_WITH_ETH_ERROR = "payWithEthError";
export declare function checkAndSendEth({ data, iframe, payingWalletSigner, suppressErrorToast, onError, onPaymentSuccess, }: {
    payingWalletSigner: ethers.Signer;
    data: {
        chainId: number;
        chainName: string;
        blob: string;
        paymentAddress: string;
        value: string;
        transactionId: string;
    };
    suppressErrorToast: boolean;
    iframe: HTMLIFrameElement;
    onPaymentSuccess?: CheckoutWithEthMessageHandlerArgs["onPaymentSuccess"] | CheckoutWithEthMessageHandlerArgs["onSuccess"];
    onError?: (error: PaymentsSDKError) => Promise<void> | void;
}): Promise<void>;
export interface CheckoutWithEthMessageHandlerArgs {
    iframe: HTMLIFrameElement;
    onPaymentSuccess?: (props: {
        onChainTxReceipt: ethers.providers.TransactionReceipt;
        transactionId: string;
    }) => Promise<void> | void;
    /** @deprecated */
    onSuccess?: (props: {
        onChainTxResponse: ethers.providers.TransactionResponse;
        transactionId: string;
    }) => Promise<void> | void;
    onPriceUpdate?: (props: PriceSummary) => void;
    onError?: (error: PaymentsSDKError) => void;
    suppressErrorToast?: boolean;
    setUpUserPayingWalletSigner?: (args: {
        chainId: number;
        chainName?: string;
    }) => void | Promise<void>;
    payingWalletSigner: ethers.Signer;
}
export declare function createCheckoutWithEthMessageHandler({ iframe, onError, onPaymentSuccess, onPriceUpdate, payingWalletSigner, suppressErrorToast, setUpUserPayingWalletSigner, }: CheckoutWithEthMessageHandlerArgs): (event: MessageEvent) => Promise<void>;
export interface ICheckoutWithEthConfigs {
    contractId: string;
    walletAddress: string;
    email?: string;
    quantity?: number;
    mintMethod?: {
        name: string;
        args: Record<string, any>[];
        payment: {
            value: string;
            currency: string;
        };
    };
    contractArgs?: Record<string, any>;
    capturePaymentLater?: boolean;
    fiatCurrency?: string;
    title?: string;
    sendEmailOnTransferSucceeded?: boolean;
    postPurchaseMessageMarkdown?: string;
    postPurchaseButtonText?: string;
    successCallbackUrl?: string;
}
export interface CheckoutWithEthLinkArgs {
    sdkClientSecret?: string;
    appName?: string;
    payingWalletSigner: ethers.Signer;
    receivingWalletType?: "WalletConnect" | "MetaMask" | "Coinbase Wallet" | string;
    showConnectWalletOptions?: boolean;
    locale?: Locale;
    options?: ICustomizationOptions;
    configs?: ICheckoutWithEthConfigs;
}
export declare function createCheckoutWithEthLink({ sdkClientSecret, payingWalletSigner, receivingWalletType, showConnectWalletOptions, appName, locale, options, configs, }: CheckoutWithEthLinkArgs): Promise<URL>;
export type CheckoutWithEthElementArgs = Omit<Omit<CheckoutWithEthMessageHandlerArgs, "iframe">, "setUpUserPayingWalletSigner"> & CheckoutWithEthLinkArgs & PaperPaymentElementConstructorArgs;
export declare function createCheckoutWithEthElement({ sdkClientSecret, suppressErrorToast, onError, onLoad, payingWalletSigner, receivingWalletType, appName, showConnectWalletOptions, locale, options, elementOrId, onPaymentSuccess: _onPaymentSuccess, onSuccess, }: CheckoutWithEthElementArgs): Promise<HTMLIFrameElement>;
//# sourceMappingURL=CheckoutWithEth.d.ts.map