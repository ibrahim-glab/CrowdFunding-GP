'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fastifyCookie = require('@fastify/cookie');
var zod = require('zod');
var auth = require('../../dist/auth-04da1239.cjs.dev.js');
var fastifyTypeProviderZod = require('fastify-type-provider-zod');
require('uuid');
require('ethers');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var fastifyCookie__default = /*#__PURE__*/_interopDefault(fastifyCookie);

const PayloadBodySchema = zod.z.object({
  address: zod.z.string(),
  chainId: zod.z.string().optional()
});
const ActiveBodySchema = zod.z.object({
  address: zod.z.string()
});
const LoginPayloadBodySchema = zod.z.object({
  payload: auth.LoginPayloadOutputSchema
});
const ErrorResponseSchema = zod.z.object({
  error: zod.z.string()
});

const payloadHandler = (fastify, ctx) => {
  fastify.route({
    method: "POST",
    url: "/payload",
    schema: {
      body: PayloadBodySchema,
      response: {
        200: zod.z.any()
      }
    },
    handler: async (req, res) => {
      const payload = await ctx.auth.payload({
        address: req.body.address,
        statement: ctx.authOptions?.statement,
        uri: ctx.authOptions?.uri,
        version: ctx.authOptions?.version,
        chainId: req.body.chainId || ctx.authOptions?.chainId,
        resources: ctx.authOptions?.resources,
        expirationTime: ctx.authOptions?.loginPayloadDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.loginPayloadDurationInSeconds) : undefined
      });
      return res.status(200).send({
        payload
      });
    }
  });
};

const loginHandler = (fastify, ctx) => {
  fastify.route({
    method: "POST",
    url: "/login",
    schema: {
      body: LoginPayloadBodySchema,
      response: {
        200: zod.z.object({
          token: zod.z.string()
        })
      }
    },
    handler: async (req, res) => {
      const validateNonce = async nonce => {
        if (ctx.authOptions?.validateNonce) {
          await ctx.authOptions?.validateNonce(nonce);
        }
      };
      const getSession = async address => {
        if (ctx.callbacks?.onLogin) {
          return ctx.callbacks.onLogin(address, req);
        }
      };
      const expirationTime = ctx.authOptions?.tokenDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds) : undefined;
      const generateOptions = {
        verifyOptions: {
          statement: ctx.authOptions?.statement,
          uri: ctx.authOptions?.uri,
          version: ctx.authOptions?.version,
          chainId: ctx.authOptions?.chainId,
          validateNonce,
          resources: ctx.authOptions?.resources
        },
        expirationTime,
        session: getSession
      };
      let token;
      try {
        // Generate an access token with the SDK using the signed payload
        token = await ctx.auth.generate(req.body.payload, generateOptions);
      } catch (err) {
        if (err.message) {
          return res.status(400).send({
            error: err.message
          });
        } else if (typeof err === "string") {
          return res.status(400).send({
            error: err
          });
        } else {
          return res.status(400).send({
            error: "Invalid login payload"
          });
        }
      }
      if (ctx.callbacks?.onToken) {
        await ctx.callbacks.onToken(token, req);
      }
      const {
        payload: {
          exp
        }
      } = ctx.auth.parseToken(token);

      // Securely set httpOnly cookie on request to prevent XSS on frontend
      // And set path to / to enable thirdweb_auth_token usage on all endpoints
      res.setCookie(`${auth.THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${req.body.payload.payload.address}`, token, {
        domain: ctx.cookieOptions?.domain,
        path: ctx.cookieOptions?.path || "/",
        sameSite: ctx.cookieOptions?.sameSite || "none",
        expires: new Date(exp * 1000),
        httpOnly: true,
        secure: ctx.cookieOptions?.secure || true
      });
      res.setCookie(auth.THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, req.body.payload.payload.address, {
        domain: ctx.cookieOptions?.domain,
        path: ctx.cookieOptions?.path || "/",
        sameSite: ctx.cookieOptions?.sameSite || "none",
        expires: new Date(exp * 1000),
        httpOnly: true,
        secure: ctx.cookieOptions?.secure || true
      });

      // Send token in body and as cookie for frontend and backend use cases
      return res.status(200).send({
        token
      });
    }
  });
};

function getCookie(req, cookie) {
  return req.cookies[cookie];
}
function getActiveCookie(req) {
  if (!req.cookies) {
    return undefined;
  }
  const activeAccount = getCookie(req, auth.THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE);
  if (activeAccount) {
    return `${auth.THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${activeAccount}`;
  }

  // If active account is not present, then use the old default
  return auth.THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX;
}

/**
 * @internal
 * @param req
 * @returns
 */
function getToken(req) {
  if (req.headers.authorization) {
    const authorizationHeader = req.headers.authorization.split(" ");
    if (authorizationHeader?.length === 2) {
      return authorizationHeader[1];
    }
  }
  if (!req.cookies) {
    return undefined;
  }
  const activeCookie = getActiveCookie(req);
  if (!activeCookie) {
    return undefined;
  }
  return getCookie(req, activeCookie);
}
async function getUser(req, ctx) {
  const token = getToken(req);
  if (!token) {
    console.error("Error: No auth token found");
    return null;
  }
  let authenticatedUser;
  try {
    authenticatedUser = await ctx.auth.authenticate(token, {
      validateTokenId: async tokenId => {
        if (ctx.authOptions?.validateTokenId) {
          await ctx.authOptions?.validateTokenId(tokenId);
        }
      }
    });
  } catch (err) {
    console.error(`Authenticate Error: ${err?.message}`);
    return null;
  }
  if (!ctx.callbacks?.onUser) {
    return authenticatedUser;
  }
  const data = await ctx.callbacks.onUser(authenticatedUser, req);
  if (!data) {
    return authenticatedUser;
  }
  return {
    ...authenticatedUser,
    data: data
  };
}

const userHandler = (fastify, ctx) => {
  fastify.route({
    method: "GET",
    url: "/user",
    schema: {
      response: {
        200: zod.z.any()
      }
    },
    handler: async (req, res) => {
      const user = await getUser(req, ctx);

      // Importantly, make sure the user was actually logged in before refreshing
      if (user) {
        const token = getToken(req);
        if (token) {
          const payload = ctx.auth.parseToken(token);
          const refreshDate = ctx.authOptions?.refreshIntervalInSeconds ? new Date(payload.payload.iat * 1000 + ctx.authOptions.refreshIntervalInSeconds * 1000) : new Date(payload.payload.iat * 1000 + auth.THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS * 1000);
          if (new Date() > refreshDate) {
            const expirationTime = ctx.authOptions?.tokenDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds) : undefined;
            const refreshedToken = await ctx.auth.refresh(token, expirationTime);
            const refreshedPayload = ctx.auth.parseToken(refreshedToken);
            res.setCookie(`${auth.THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${user.address}`, refreshedToken, {
              domain: ctx.cookieOptions?.domain,
              path: ctx.cookieOptions?.path || "/",
              sameSite: ctx.cookieOptions?.sameSite || "none",
              expires: new Date(refreshedPayload.payload.exp * 1000),
              httpOnly: true,
              secure: ctx.cookieOptions?.secure || true
            });
            res.setCookie(auth.THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, user.address, {
              domain: ctx.cookieOptions?.domain,
              path: ctx.cookieOptions?.path || "/",
              sameSite: ctx.cookieOptions?.sameSite || "none",
              expires: new Date(refreshedPayload.payload.exp * 1000),
              httpOnly: true,
              secure: ctx.cookieOptions?.secure || true
            });
          }
        }
      }
      return res.status(200).send(user);
    }
  });
};

const logoutHandler = (fastify, ctx) => {
  fastify.route({
    method: "POST",
    url: "/logout",
    schema: {
      response: {
        200: zod.z.object({
          message: zod.z.string()
        }),
        400: ErrorResponseSchema
      }
    },
    handler: async (req, res) => {
      const activeCookie = getActiveCookie(req);
      if (!activeCookie) {
        return res.status(400).send({
          error: "No logged in user to logout."
        });
      }
      if (ctx.callbacks?.onLogout) {
        const user = await getUser(req, ctx);
        if (user) {
          await ctx.callbacks.onLogout(user, req);
        }
      }

      // Set the access token to 'none' and expire in 5 seconds
      res.setCookie(activeCookie, "", {
        domain: ctx.cookieOptions?.domain,
        path: ctx.cookieOptions?.path || "/",
        sameSite: ctx.cookieOptions?.sameSite || "none",
        expires: new Date(Date.now() + 5 * 1000),
        httpOnly: true,
        secure: ctx.cookieOptions?.secure || true
      });
      return res.status(200).send({
        message: "Successfully logged out"
      });
    }
  });
};

const switchAccountHandler = (fastify, ctx) => {
  fastify.route({
    method: "POST",
    url: "/switch-account",
    schema: {
      body: ActiveBodySchema,
      response: {
        200: zod.z.any(),
        400: ErrorResponseSchema
      }
    },
    handler: async (req, res) => {
      let cookieExpiration;
      const cookie = getCookie(req, `${auth.THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${req.body.address}`);
      if (cookie) {
        // If the new account is already logged in, get the expiration time from the cookie
        const {
          payload: {
            exp
          }
        } = ctx.auth.parseToken(cookie);
        cookieExpiration = new Date(exp * 1000);
      } else if (ctx.authOptions?.tokenDurationInSeconds) {
        // Otherwise, if we have a token duration in seconds, set it to that
        cookieExpiration = new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds);
      } else {
        // Otherwise, just default to 24 hours
        cookieExpiration = new Date(Date.now() + 1000 * auth.THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS);
      }
      res.setCookie(auth.THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, req.body.address, {
        domain: ctx.cookieOptions?.domain,
        path: ctx.cookieOptions?.path || "/",
        sameSite: ctx.cookieOptions?.sameSite || "none",
        expires: cookieExpiration,
        httpOnly: true,
        secure: ctx.cookieOptions?.secure || true
      });
      return res.status(200).send();
    }
  });
};

function ThirdwebAuth(cfg) {
  const ctx = {
    ...cfg,
    auth: new auth.ThirdwebAuth(cfg.wallet, cfg.domain)
  };
  const authRouter = async (fastify, _opts, done) => {
    // Setup plugin to use zod as a type provider
    fastify.setValidatorCompiler(fastifyTypeProviderZod.validatorCompiler);
    fastify.setSerializerCompiler(fastifyTypeProviderZod.serializerCompiler);
    const plugin = fastify.withTypeProvider();

    // Register the fastify cookie middleware with this plugin
    await plugin.register(fastifyCookie__default["default"]);

    // Register individual auth endpoints
    payloadHandler(plugin, ctx);
    loginHandler(plugin, ctx);
    logoutHandler(plugin, ctx);
    userHandler(plugin, ctx);
    switchAccountHandler(plugin, ctx);

    // Mark plugin creation as complete
    done();
  };
  return {
    authRouter,
    authMiddleware: fastifyCookie__default["default"],
    getUser: req => {
      return getUser(req, ctx);
    }
  };
}

exports.ActiveBodySchema = ActiveBodySchema;
exports.ErrorResponseSchema = ErrorResponseSchema;
exports.LoginPayloadBodySchema = LoginPayloadBodySchema;
exports.PayloadBodySchema = PayloadBodySchema;
exports.ThirdwebAuth = ThirdwebAuth;
exports.getToken = getToken;
