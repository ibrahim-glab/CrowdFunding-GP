import { n as THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, o as THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX, l as LoginPayloadOutputSchema, q as THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS, t as THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS, T as ThirdwebAuth$2 } from '../../dist/auth-3e6bcaed.esm.js';
import { z } from 'zod';
import { serialize } from 'cookie';
import { headers, cookies } from 'next/headers';
import { NextResponse } from 'next/server';
import 'uuid';
import 'ethers';

function getCookie$1(req, cookie) {
  if (typeof req.cookies.get === "function") {
    return req.cookies.get(cookie)?.value;
  }
  return req.cookies[cookie];
}
function getActiveCookie$1(req) {
  if (!req.cookies) {
    return undefined;
  }
  const activeAccount = getCookie$1(req, THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE);
  if (activeAccount) {
    return `${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${activeAccount}`;
  }

  // If active account is not present, then use the old default
  return THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX;
}
function getToken$1(req) {
  if (!!req.headers["authorization"]) {
    const authorizationHeader = req.headers["authorization"]?.split(" ");
    if (authorizationHeader?.length === 2) {
      return authorizationHeader[1];
    }
  }
  if (!req.cookies) {
    return undefined;
  }
  const activeCookie = getActiveCookie$1(req);
  if (!activeCookie) {
    return undefined;
  }
  return getCookie$1(req, activeCookie);
}
async function getUser$1(req, ctx) {
  const token = getToken$1(req);
  if (!token) {
    return null;
  }
  let authenticatedUser;
  try {
    authenticatedUser = await ctx.auth.authenticate(token, {
      validateTokenId: async tokenId => {
        if (ctx.authOptions?.validateTokenId) {
          await ctx.authOptions?.validateTokenId(tokenId);
        }
      }
    });
  } catch (err) {
    return null;
  }
  if (!ctx.callbacks?.onUser) {
    return authenticatedUser;
  }
  const data = await ctx.callbacks.onUser(authenticatedUser, req);
  if (!data) {
    return authenticatedUser;
  }
  return {
    ...authenticatedUser,
    data: data
  };
}

const PayloadBodySchema = z.object({
  address: z.string(),
  chainId: z.string().optional()
});
const ActiveBodySchema = z.object({
  address: z.string()
});
const LoginPayloadBodySchema = z.object({
  payload: LoginPayloadOutputSchema
});

async function handler$9(req, res, ctx) {
  if (req.method !== "POST") {
    return res.status(405).json({
      error: "Invalid method. Only POST supported"
    });
  }
  const parsedPayload = PayloadBodySchema.safeParse(req.body);
  if (!parsedPayload.success) {
    return res.status(400).json({
      error: "Please provide an address"
    });
  }

  // TODO: Add nonce generation + custom expiration + invalid before
  const payload = await ctx.auth.payload({
    address: parsedPayload.data.address,
    statement: ctx.authOptions?.statement,
    uri: ctx.authOptions?.uri,
    version: ctx.authOptions?.version,
    chainId: parsedPayload.data.chainId || ctx.authOptions?.chainId,
    resources: ctx.authOptions?.resources,
    expirationTime: ctx.authOptions?.loginPayloadDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.loginPayloadDurationInSeconds) : undefined
  });
  return res.status(200).json({
    payload
  });
}

async function handler$8(req, res, ctx) {
  if (req.method !== "POST") {
    return res.status(405).json({
      error: "Method not allowed"
    });
  }
  const parsedPayload = LoginPayloadBodySchema.safeParse(req.body);

  // Get signed login payload from the frontend
  if (!parsedPayload.success) {
    return res.status(400).json({
      error: "Invalid login payload"
    });
  }
  const payload = parsedPayload.data.payload;
  const validateNonce = async nonce => {
    if (ctx.authOptions?.validateNonce) {
      await ctx.authOptions?.validateNonce(nonce);
    }
  };
  const getSession = async address => {
    if (ctx.callbacks?.onLogin) {
      return ctx.callbacks.onLogin(address, req);
    }
  };
  const expirationTime = ctx.authOptions?.tokenDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds) : undefined;
  const generateOptions = {
    verifyOptions: {
      statement: ctx.authOptions?.statement,
      uri: ctx.authOptions?.uri,
      version: ctx.authOptions?.version,
      chainId: ctx.authOptions?.chainId,
      validateNonce,
      resources: ctx.authOptions?.resources
    },
    expirationTime,
    session: getSession
  };
  let token;
  try {
    // Generate an access token with the SDK using the signed payload
    token = await ctx.auth.generate(payload, generateOptions);
  } catch (err) {
    if (err.message) {
      return res.status(400).json({
        error: err.message
      });
    } else if (typeof err === "string") {
      return res.status(400).json({
        error: err
      });
    } else {
      return res.status(400).json({
        error: "Invalid login payload"
      });
    }
  }
  if (ctx.callbacks?.onToken) {
    await ctx.callbacks.onToken(token, req);
  }
  const {
    payload: {
      exp
    }
  } = ctx.auth.parseToken(token);

  // Securely set httpOnly cookie on request to prevent XSS on frontend
  // And set path to / to enable thirdweb_auth_token usage on all endpoints
  res.setHeader("Set-Cookie", [serialize(`${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${payload.payload.address}`, token, {
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: new Date(exp * 1000),
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  }), serialize(THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, payload.payload.address, {
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: new Date(exp * 1000),
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  })]);

  // Send token in body and as cookie for frontend and backend use cases
  return res.status(200).json({
    token
  });
}

async function handler$7(req, res, ctx) {
  if (req.method !== "POST") {
    return res.status(405).json({
      error: "Invalid method. Only POST supported"
    });
  }
  const activeCookie = getActiveCookie$1(req);
  if (!activeCookie) {
    return res.status(400).json({
      error: "No logged in user to logout"
    });
  }
  if (ctx.callbacks?.onLogout) {
    const user = await getUser$1(req, ctx);
    if (user) {
      await ctx.callbacks.onLogout(user, req);
    }
  }

  // Set the access token to 'none' and expire in 5 seconds
  res.setHeader("Set-Cookie", serialize(activeCookie, "", {
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: new Date(Date.now() + 5 * 1000),
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  }));
  return res.status(200).json({
    message: "Successfully logged out"
  });
}

async function handler$6(req, res, ctx) {
  if (req.method !== "GET") {
    return res.status(405).json({
      error: "Invalid method. Only GET supported"
    });
  }
  const user = await getUser$1(req, ctx);

  // Importantly, make sure the user was actually logged in before refreshing
  if (user) {
    const token = getToken$1(req);
    if (token) {
      const payload = ctx.auth.parseToken(token);
      const refreshDate = ctx.authOptions?.refreshIntervalInSeconds ? new Date(payload.payload.iat * 1000 + ctx.authOptions.refreshIntervalInSeconds * 1000) : new Date(payload.payload.iat * 1000 + THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS * 1000);
      if (new Date() > refreshDate) {
        const expirationTime = ctx.authOptions?.tokenDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds) : undefined;
        const refreshedToken = await ctx.auth.refresh(token, expirationTime);
        const refreshedPayload = ctx.auth.parseToken(refreshedToken);
        res.setHeader("Set-Cookie", [serialize(`${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${user.address}`, refreshedToken, {
          domain: ctx.cookieOptions?.domain,
          path: ctx.cookieOptions?.path || "/",
          sameSite: ctx.cookieOptions?.sameSite || "none",
          expires: new Date(refreshedPayload.payload.exp * 1000),
          httpOnly: true,
          secure: ctx.cookieOptions?.secure || true
        }), serialize(THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, user.address, {
          domain: ctx.cookieOptions?.domain,
          path: ctx.cookieOptions?.path || "/",
          sameSite: ctx.cookieOptions?.sameSite || "none",
          expires: new Date(refreshedPayload.payload.exp * 1000),
          httpOnly: true,
          secure: ctx.cookieOptions?.secure || true
        })]);
      }
    }
  }
  return res.status(200).json(user);
}

async function handler$5(req, res, ctx) {
  if (req.method !== "POST") {
    return res.status(405).json({
      error: "Invalid method. Only POST supported"
    });
  }
  const parsedPayload = ActiveBodySchema.safeParse(req.body);
  if (!parsedPayload.success) {
    return res.status(400).json({
      error: "Please provide an address"
    });
  }
  let cookieExpiration;
  const cookie = getCookie$1(req, `${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${parsedPayload.data.address}`);
  if (cookie) {
    // If the new account is already logged in, get the expiration time from the cookie
    const {
      payload: {
        exp
      }
    } = ctx.auth.parseToken(cookie);
    cookieExpiration = new Date(exp * 1000);
  } else if (ctx.authOptions?.tokenDurationInSeconds) {
    // Otherwise, if we have a token duration in seconds, set it to that
    cookieExpiration = new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds);
  } else {
    // Otherwise, just default to 24 hours
    cookieExpiration = new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS);
  }
  res.setHeader("Set-Cookie", [serialize(THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE, parsedPayload.data.address, {
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: cookieExpiration,
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  })]);
  return res.status(200).end();
}

async function ThirdwebAuthRouter$1(req, res, ctx) {
  // Catch-all route must be named with [...thirdweb]
  const {
    thirdweb
  } = req.query;
  const action = thirdweb?.[0];
  switch (action) {
    case "payload":
      return await handler$9(req, res, ctx);
    case "login":
      return await handler$8(req, res, ctx);
    case "user":
      return await handler$6(req, res, ctx);
    case "logout":
      return await handler$7(req, res, ctx);
    case "switch-account":
      return await handler$5(req, res, ctx);
    default:
      return res.status(400).json({
        message: "Invalid route for authentication."
      });
  }
}
function ThirdwebAuth$1(cfg) {
  const ctx = {
    ...cfg,
    auth: new ThirdwebAuth$2(cfg.wallet, cfg.domain)
  };
  function ThirdwebAuthHandler() {
    if (arguments.length === 0) {
      return async (req, res) => await ThirdwebAuthRouter$1(req, res, ctx);
    }
    return ThirdwebAuthRouter$1(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], ctx);
  }
  return {
    ThirdwebAuthHandler,
    getUser: req => {
      return getUser$1(req, ctx);
    }
  };
}

function getCookie(cookie) {
  return cookies().get(cookie)?.value;
}
function getActiveCookie() {
  const activeAccount = getCookie(THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE);
  if (activeAccount) {
    return `${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${activeAccount}`;
  }

  // If active account is not present, then use the old default
  return THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX;
}
function getToken() {
  const headerList = headers();
  if (headerList.has("authorization")) {
    const authorizationHeader = headerList.get("authorization")?.split(" ");
    if (authorizationHeader?.length === 2) {
      return authorizationHeader[1];
    }
  }
  const activeCookie = getActiveCookie();
  if (!activeCookie) {
    return undefined;
  }
  return getCookie(activeCookie);
}
async function getUser(ctx) {
  const token = getToken();
  if (!token) {
    return null;
  }
  let authenticatedUser;
  try {
    authenticatedUser = await ctx.auth.authenticate(token, {
      validateTokenId: async tokenId => {
        if (ctx.authOptions?.validateTokenId) {
          await ctx.authOptions?.validateTokenId(tokenId);
        }
      }
    });
  } catch (err) {
    return null;
  }
  if (ctx.callbacks?.onUser) {
    const data = await ctx.callbacks.onUser(authenticatedUser);
    if (data) {
      return {
        ...authenticatedUser,
        data
      };
    }
  }
  return authenticatedUser;
}

async function handler$4(req, ctx) {
  if (req.method !== "POST") {
    return Response.json({
      error: "Invalid method. Only POST supported"
    }, {
      status: 405
    });
  }
  const reqBody = await req.json();
  const parsedPayload = PayloadBodySchema.safeParse(reqBody);
  if (!parsedPayload.success) {
    return Response.json({
      error: "Please provide an address"
    }, {
      status: 400
    });
  }

  // TODO: Add nonce generation + custom expiration + invalid before
  const payload = await ctx.auth.payload({
    address: parsedPayload.data.address,
    statement: ctx.authOptions?.statement,
    uri: ctx.authOptions?.uri,
    version: ctx.authOptions?.version,
    chainId: parsedPayload.data.chainId || ctx.authOptions?.chainId,
    resources: ctx.authOptions?.resources,
    expirationTime: ctx.authOptions?.loginPayloadDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.loginPayloadDurationInSeconds) : undefined
  });
  const response = Response.json({
    payload
  }, {
    status: 200
  });
  return response;
}

async function handler$3(req, ctx) {
  if (req.method !== "POST") {
    return Response.json({
      error: "Invalid method. Only POST supported"
    }, {
      status: 405
    });
  }
  const reqBody = await req.json();
  const parsedPayload = LoginPayloadBodySchema.safeParse(reqBody);

  // Get signed login payload from the frontend
  if (!parsedPayload.success) {
    return Response.json({
      error: "Invalid login payload"
    }, {
      status: 400
    });
  }
  const payload = parsedPayload.data.payload;
  const validateNonce = async nonce => {
    if (ctx.authOptions?.validateNonce) {
      await ctx.authOptions?.validateNonce(nonce);
    }
  };
  const getSession = async address => {
    if (ctx.callbacks?.onLogin) {
      return ctx.callbacks.onLogin(address);
    }
  };
  const expirationTime = ctx.authOptions?.tokenDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds) : undefined;
  const generateOptions = {
    verifyOptions: {
      statement: ctx.authOptions?.statement,
      uri: ctx.authOptions?.uri,
      version: ctx.authOptions?.version,
      chainId: ctx.authOptions?.chainId,
      validateNonce,
      resources: ctx.authOptions?.resources
    },
    expirationTime,
    session: getSession
  };
  let token;
  try {
    // Generate an access token with the SDK using the signed payload
    token = await ctx.auth.generate(payload, generateOptions);
  } catch (err) {
    if (err.message) {
      return Response.json({
        error: err.message
      }, {
        status: 400
      });
    } else if (typeof err === "string") {
      return Response.json({
        error: err
      }, {
        status: 400
      });
    } else {
      return Response.json({
        error: "Invalid login payload"
      }, {
        status: 400
      });
    }
  }
  if (ctx.callbacks?.onToken) {
    await ctx.callbacks.onToken(token);
  }
  const {
    payload: {
      exp
    }
  } = ctx.auth.parseToken(token);

  // Securely set httpOnly cookie on request to prevent XSS on frontend
  // And set path to / to enable thirdweb_auth_token usage on all endpoints
  const response = NextResponse.json({
    token
  }, {
    status: 200
  });
  response.cookies.set({
    name: `${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${payload.payload.address}`,
    value: token,
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: new Date(exp * 1000),
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  });
  response.cookies.set({
    name: THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE,
    value: payload.payload.address,
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: new Date(exp * 1000),
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  });

  // Send token in body and as cookie for frontend and backend use cases
  return response;
}

async function handler$2(req, ctx) {
  if (req.method !== "POST") {
    return Response.json({
      error: "Invalid method. Only POST supported"
    }, {
      status: 405
    });
  }
  const activeCookie = getActiveCookie();
  if (!activeCookie) {
    return Response.json({
      error: "No logged in user to logout"
    }, {
      status: 400
    });
  }
  if (ctx.callbacks?.onLogout) {
    const user = await getUser(ctx);
    if (user) {
      await ctx.callbacks.onLogout(user);
    }
  }

  // Set the access token to 'none' and expire in 5 seconds
  const response = NextResponse.json({
    message: "Successfully logged out"
  }, {
    status: 200
  });
  response.cookies.set({
    name: activeCookie,
    value: '',
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: new Date(Date.now() + 5 * 1000),
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  });
  return response;
}

async function handler$1(req, ctx) {
  if (req.method !== "GET") {
    return Response.json({
      error: "Invalid method. Only GET supported"
    }, {
      status: 405
    });
  }
  const user = await getUser(ctx);
  const response = NextResponse.json(user, {
    status: 200
  });

  // Importantly, make sure the user was actually logged in before refreshing
  if (user) {
    const token = getToken();
    if (token) {
      const payload = ctx.auth.parseToken(token);
      const refreshDate = ctx.authOptions?.refreshIntervalInSeconds ? new Date(payload.payload.iat * 1000 + ctx.authOptions.refreshIntervalInSeconds * 1000) : new Date(payload.payload.iat * 1000 + THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS * 1000);
      if (new Date() > refreshDate) {
        const expirationTime = ctx.authOptions?.tokenDurationInSeconds ? new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds) : undefined;
        const refreshedToken = await ctx.auth.refresh(token, expirationTime);
        const refreshedPayload = ctx.auth.parseToken(refreshedToken);
        response.cookies.set({
          name: `${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${user.address}`,
          value: refreshedToken,
          domain: ctx.cookieOptions?.domain,
          path: ctx.cookieOptions?.path || "/",
          sameSite: ctx.cookieOptions?.sameSite || "none",
          expires: new Date(refreshedPayload.payload.exp * 1000),
          httpOnly: true,
          secure: ctx.cookieOptions?.secure || true
        });
        response.cookies.set({
          name: THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE,
          value: user.address,
          domain: ctx.cookieOptions?.domain,
          path: ctx.cookieOptions?.path || "/",
          sameSite: ctx.cookieOptions?.sameSite || "none",
          expires: new Date(refreshedPayload.payload.exp * 1000),
          httpOnly: true,
          secure: ctx.cookieOptions?.secure || true
        });
      }
    }
  }
  return response;
}

async function handler(req, ctx) {
  if (req.method !== "POST") {
    return Response.json({
      error: "Invalid method. Only POST supported"
    }, {
      status: 405
    });
  }
  const reqBody = await req.json();
  const parsedPayload = ActiveBodySchema.safeParse(reqBody);
  if (!parsedPayload.success) {
    return Response.json({
      error: "Please provide an address"
    }, {
      status: 400
    });
  }
  let cookieExpiration;
  const cookie = getCookie(`${THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX}_${parsedPayload.data.address}`);
  if (cookie) {
    // If the new account is already logged in, get the expiration time from the cookie
    const {
      payload: {
        exp
      }
    } = ctx.auth.parseToken(cookie);
    cookieExpiration = new Date(exp * 1000);
  } else if (ctx.authOptions?.tokenDurationInSeconds) {
    // Otherwise, if we have a token duration in seconds, set it to that
    cookieExpiration = new Date(Date.now() + 1000 * ctx.authOptions.tokenDurationInSeconds);
  } else {
    // Otherwise, just default to 24 hours
    cookieExpiration = new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS);
  }
  const response = NextResponse.json('', {
    status: 200
  });
  response.cookies.set({
    name: THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE,
    value: parsedPayload.data.address,
    domain: ctx.cookieOptions?.domain,
    path: ctx.cookieOptions?.path || "/",
    sameSite: ctx.cookieOptions?.sameSite || "none",
    expires: cookieExpiration,
    httpOnly: true,
    secure: ctx.cookieOptions?.secure || true
  });
  return response;
}

async function ThirdwebAuthRouter(req, ctx, authCtx) {
  // Catch-all route must be named with [...thirdweb]
  const action = ctx.params?.thirdweb?.[0];
  switch (action) {
    case "payload":
      return await handler$4(req, authCtx);
    case "login":
      return await handler$3(req, authCtx);
    case "user":
      return await handler$1(req, authCtx);
    case "logout":
      return await handler$2(req, authCtx);
    case "switch-account":
      return await handler(req, authCtx);
    default:
      return Response.json({
        message: "Invalid route for authentication."
      }, {
        status: 400
      });
  }
}
function ThirdwebAuth(cfg) {
  const authCtx = {
    ...cfg,
    auth: new ThirdwebAuth$2(cfg.wallet, cfg.domain)
  };
  async function ThirdwebAuthHandler(req, ctx) {
    return await ThirdwebAuthRouter(req, ctx, authCtx);
  }
  return {
    ThirdwebAuthHandler,
    getUser: async () => {
      return await getUser(authCtx);
    }
  };
}

export { ThirdwebAuth$1 as ThirdwebAuth, ThirdwebAuth as ThirdwebAuthAppRouter };
