'use strict';

var zod = require('zod');
var uuid = require('uuid');
var ethers = require('ethers');

const literalSchema = zod.z.union([zod.z.string(), zod.z.number(), zod.z.boolean(), zod.z.null()]);
const JsonSchema = zod.z.lazy(() => zod.z.union([literalSchema, zod.z.array(JsonSchema), zod.z.record(JsonSchema)]), {
  invalid_type_error: "Provided value was not valid JSON"
});
const AddressSchema = zod.z.string().refine(arg => ethers.utils.isAddress(arg), out => {
  return {
    message: `${out} is not a valid address`
  };
});
const RawDateSchema = zod.z.date().transform(i => {
  return Math.floor(i.getTime() / 1000);
});
const AccountTypeSchema = zod.z.literal("evm");

const AuthenticationPayloadDataSchema = zod.z.object({
  iss: zod.z.string(),
  sub: zod.z.string(),
  aud: zod.z.string(),
  exp: RawDateSchema,
  nbf: RawDateSchema,
  iat: RawDateSchema,
  jti: zod.z.string().default(() => uuid.v4()),
  ctx: JsonSchema.optional()
});
const AuthenticationPayloadSchema = zod.z.object({
  payload: AuthenticationPayloadDataSchema,
  signature: zod.z.string()
});
const AuthenticateOptionsSchema = zod.z.object({
  domain: zod.z.string(),
  issuerAddress: AddressSchema.optional(),
  validateTokenId: zod.z.function().args(zod.z.string()).optional()
});

const VerifyOptionsSchema = zod.z.object({
  domain: zod.z.string(),
  statement: zod.z.string().optional(),
  uri: zod.z.string().optional(),
  version: zod.z.string().optional(),
  chainId: zod.z.string().optional(),
  validateNonce: zod.z.function().args(zod.z.string()).optional(),
  resources: zod.z.array(zod.z.string()).optional()
});

const THIRDWEB_AUTH_COOKIE_PREFIX = `thirdweb_auth`;
const THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX = `${THIRDWEB_AUTH_COOKIE_PREFIX}_token`;
const THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE = `${THIRDWEB_AUTH_COOKIE_PREFIX}_active_account`;
const THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS = 60 * 10;
const THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS = 60 * 60 * 24;
const THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS = 5;

const GenerateOptionsSchema = zod.z.object({
  domain: zod.z.string(),
  tokenId: zod.z.string().optional(),
  expirationTime: zod.z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS)),
  invalidBefore: zod.z.date().optional(),
  session: zod.z.union([JsonSchema, zod.z.function().args(zod.z.string())]).optional(),
  verifyOptions: VerifyOptionsSchema.omit({
    domain: true
  }).optional()
});

const RefreshOptionsSchema = zod.z.object({
  expirationTime: zod.z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS))
});

const LoginOptionsSchema = zod.z.object({
  domain: zod.z.string(),
  address: zod.z.string().optional(),
  statement: zod.z.string().optional(),
  uri: zod.z.string().optional(),
  version: zod.z.string().optional(),
  chainId: zod.z.string().optional(),
  nonce: zod.z.string().optional(),
  expirationTime: zod.z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),
  invalidBefore: zod.z.date().default(() => new Date(Date.now() - 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),
  resources: zod.z.array(zod.z.string()).optional()
});
const LoginPayloadDataSchema = zod.z.object({
  type: AccountTypeSchema,
  domain: zod.z.string(),
  address: zod.z.string(),
  statement: zod.z.string().default("Please ensure that the domain above matches the URL of the current website."),
  uri: zod.z.string().optional(),
  version: zod.z.string().default("1"),
  chain_id: zod.z.string().optional(),
  nonce: zod.z.string().default(() => uuid.v4()),
  issued_at: zod.z.date().default(new Date()).transform(d => d.toISOString()),
  expiration_time: zod.z.date().transform(d => d.toISOString()),
  invalid_before: zod.z.date().default(new Date()).transform(d => d.toISOString()),
  resources: zod.z.array(zod.z.string()).optional()
});
const LoginPayloadSchema = zod.z.object({
  payload: LoginPayloadDataSchema,
  signature: zod.z.string()
});
const LoginPayloadOutputSchema = LoginPayloadSchema.extend({
  payload: LoginPayloadDataSchema.extend({
    issued_at: zod.z.string(),
    expiration_time: zod.z.string(),
    invalid_before: zod.z.string()
  })
});

/**
 * Create an EIP-4361 & CAIP-122 compliant message to sign based on the login payload
 */
function createLoginMessage(payload) {
  const typeField = "Ethereum";
  const header = `${payload.domain} wants you to sign in with your ${typeField} account:`;
  let prefix = [header, payload.address].join("\n");
  prefix = [prefix, payload.statement].join("\n\n");
  if (payload.statement) {
    prefix += "\n";
  }
  const suffixArray = [];
  if (payload.uri) {
    const uriField = `URI: ${payload.uri}`;
    suffixArray.push(uriField);
  }
  const versionField = `Version: ${payload.version}`;
  suffixArray.push(versionField);
  if (payload.chain_id) {
    const chainField = `Chain ID: ` + payload.chain_id || "1";
    suffixArray.push(chainField);
  }
  const nonceField = `Nonce: ${payload.nonce}`;
  suffixArray.push(nonceField);
  const issuedAtField = `Issued At: ${payload.issued_at}`;
  suffixArray.push(issuedAtField);
  const expiryField = `Expiration Time: ${payload.expiration_time}`;
  suffixArray.push(expiryField);
  if (payload.invalid_before) {
    const invalidBeforeField = `Not Before: ${payload.invalid_before}`;
    suffixArray.push(invalidBeforeField);
  }
  if (payload.resources) {
    suffixArray.push([`Resources:`, ...payload.resources.map(x => `- ${x}`)].join("\n"));
  }
  const suffix = suffixArray.join("\n");
  return [prefix, suffix].join("\n");
}
async function buildLoginPayload(_ref) {
  let {
    wallet,
    options
  } = _ref;
  const parsedOptions = LoginOptionsSchema.parse(options);
  let chainId = parsedOptions?.chainId;
  if (!chainId && wallet.getChainId) {
    try {
      chainId = (await wallet.getChainId()).toString();
    } catch {
      // ignore error
    }
  }
  return LoginPayloadDataSchema.parse({
    type: wallet.type,
    domain: parsedOptions.domain,
    address: parsedOptions?.address || (await wallet.getAddress()),
    statement: parsedOptions?.statement,
    version: parsedOptions?.version,
    uri: parsedOptions?.uri,
    chain_id: chainId,
    nonce: parsedOptions?.nonce,
    expiration_time: parsedOptions.expirationTime,
    invalid_before: parsedOptions.invalidBefore,
    resources: parsedOptions?.resources
  });
}
async function signLoginPayload(_ref2) {
  let {
    wallet,
    payload
  } = _ref2;
  const message = createLoginMessage(payload);
  const signature = await wallet.signMessage(message);
  return {
    payload,
    signature
  };
}
async function buildAndSignLoginPayload(_ref3) {
  let {
    wallet,
    options
  } = _ref3;
  const payload = await buildLoginPayload({
    wallet,
    options
  });
  return signLoginPayload({
    wallet,
    payload
  });
}
async function verifyLoginPayload(_ref4) {
  let {
    wallet,
    payload,
    options
  } = _ref4;
  const parsedOptions = VerifyOptionsSchema.parse(options);
  if (payload.payload.type !== wallet.type) {
    throw new Error(`Expected chain type '${wallet.type}' does not match chain type on payload '${payload.payload.type}'`);
  }

  // Check that the intended domain matches the domain of the payload
  if (payload.payload.domain !== parsedOptions.domain) {
    throw new Error(`Expected domain '${parsedOptions.domain}' does not match domain on payload '${payload.payload.domain}'`);
  }

  // Check that the payload statement matches the expected statement
  if (parsedOptions?.statement) {
    if (payload.payload.statement !== parsedOptions.statement) {
      throw new Error(`Expected statement '${parsedOptions.statement}' does not match statement on payload '${payload.payload.statement}'`);
    }
  }

  // Check that the intended URI matches the URI of the payload
  if (parsedOptions?.uri) {
    if (payload.payload.uri !== parsedOptions.uri) {
      throw new Error(`Expected URI '${parsedOptions.uri}' does not match URI on payload '${payload.payload.uri}'`);
    }
  }

  // Check that the intended version matches the version of the payload
  if (parsedOptions?.version) {
    if (payload.payload.version !== parsedOptions.version) {
      throw new Error(`Expected version '${parsedOptions.version}' does not match version on payload '${payload.payload.version}'`);
    }
  }

  // Check that the intended chain ID matches the chain ID of the payload
  if (parsedOptions?.chainId) {
    if (payload.payload.chain_id !== parsedOptions.chainId) {
      throw new Error(`Expected chain ID '${parsedOptions.chainId}' does not match chain ID on payload '${payload.payload.chain_id}'`);
    }
  }

  // Check that the payload nonce is valid
  if (parsedOptions?.validateNonce !== undefined) {
    try {
      await parsedOptions.validateNonce(payload.payload.nonce);
    } catch (err) {
      throw new Error(`Login request nonce is invalid`);
    }
  }

  // Check that it isn't before the invalid before time
  const currentTime = new Date();
  if (currentTime < new Date(payload.payload.invalid_before)) {
    throw new Error(`Login request is not yet valid`);
  }

  // Check that the payload hasn't expired
  if (currentTime > new Date(payload.payload.expiration_time)) {
    throw new Error(`Login request has expired`);
  }

  // Check that the specified resources are present on the payload
  if (parsedOptions?.resources) {
    const missingResources = parsedOptions.resources.filter(resource => !payload.payload.resources?.includes(resource));
    if (missingResources.length > 0) {
      throw new Error(`Login request is missing required resources: ${missingResources.join(", ")}`);
    }
  }

  // Check that the signing address is the claimed wallet address
  const message = createLoginMessage(payload.payload);
  const chainId = wallet.type === "evm" && payload.payload.chain_id ? parseInt(payload.payload.chain_id) : undefined;
  const verified = await wallet.verifySignature(message, payload.signature, payload.payload.address, chainId);
  if (!verified) {
    throw new Error(`Signer address does not match payload address '${payload.payload.address.toLowerCase()}'`);
  }
  return payload.payload.address;
}

function isBrowser() {
  return typeof window !== "undefined";
}
function base64encode(data) {
  if (isBrowser()) {
    return window.btoa(data);
  }
  return Buffer.from(data).toString("base64").replace(/=/g, "");
}
function base64decode(data) {
  if (isBrowser()) {
    return window.atob(data);
  }
  return Buffer.from(data, "base64").toString();
}

/**
 * Build JWT token based on the authentication payload
 */
async function buildJWT(_ref) {
  let {
    wallet,
    payload
  } = _ref;
  const payloadData = AuthenticationPayloadDataSchema.parse(payload);
  const message = JSON.stringify(payloadData);
  const signature = await wallet.signMessage(message);

  // Header used for JWT token specifying hash algorithm
  const header = {
    // Specify ECDSA with SHA-256 for hashing algorithm
    alg: "ES256",
    typ: "JWT"
  };
  const encodedHeader = base64encode(JSON.stringify(header));
  const encodedData = base64encode(JSON.stringify(payloadData));
  const encodedSignature = base64encode(signature);

  // Generate a JWT with base64 encoded header, payload, and signature
  const jwt = `${encodedHeader}.${encodedData}.${encodedSignature}`;
  return jwt;
}

/**
 * Generate a new JWT using a login payload
 */
async function generateJWT(_ref2) {
  let {
    wallet,
    payload,
    options
  } = _ref2;
  const parsedOptions = GenerateOptionsSchema.parse(options);
  const userAddress = await verifyLoginPayload({
    wallet,
    payload,
    options: {
      domain: parsedOptions.domain,
      ...parsedOptions.verifyOptions
    }
  });
  let session = undefined;
  if (typeof parsedOptions?.session === "function") {
    const sessionTrigger = await parsedOptions.session(userAddress);
    if (sessionTrigger) {
      session = sessionTrigger;
    }
  } else {
    session = parsedOptions?.session;
  }
  const adminAddress = await wallet.getAddress();
  return buildJWT({
    wallet,
    payload: {
      iss: adminAddress,
      sub: userAddress,
      aud: parsedOptions.domain,
      nbf: parsedOptions?.invalidBefore || new Date(),
      exp: parsedOptions.expirationTime,
      iat: new Date(),
      jti: parsedOptions?.tokenId,
      ctx: session
    }
  });
}

/**
 * Parse data from an encoded auth JWT
 */
function parseJWT(jwt) {
  const encodedPayload = jwt.split(".")[1];
  const encodedSignature = jwt.split(".")[2];
  const payload = JSON.parse(base64decode(encodedPayload));
  const signature = base64decode(encodedSignature);
  return {
    payload,
    signature
  };
}

/**
 * Refresh an existing JWT
 */
async function refreshJWT(_ref3) {
  let {
    wallet,
    jwt,
    options
  } = _ref3;
  const {
    payload
  } = parseJWT(jwt);
  const parsedOptions = RefreshOptionsSchema.parse(options);
  return buildJWT({
    wallet,
    payload: {
      iss: payload.iss,
      sub: payload.sub,
      aud: payload.aud,
      nbf: new Date(),
      exp: parsedOptions.expirationTime,
      iat: new Date(),
      ctx: payload.ctx
    }
  });
}

/**
 * Validate a JWT and extract the user's info
 */
async function authenticateJWT(_ref4) {
  let {
    wallet,
    jwt,
    options
  } = _ref4;
  const parsedOptions = AuthenticateOptionsSchema.parse(options);
  const {
    payload,
    signature
  } = parseJWT(jwt);

  // Check that the payload unique ID is valid
  if (parsedOptions?.validateTokenId !== undefined) {
    try {
      await parsedOptions.validateTokenId(payload.jti);
    } catch (err) {
      throw new Error(`Token ID is invalid`);
    }
  }

  // Check that the token audience matches the domain
  if (payload.aud !== parsedOptions.domain) {
    throw new Error(`Expected token to be for the domain '${parsedOptions.domain}', but found token with domain '${payload.aud}'`);
  }

  // Check that the token is past the invalid before time
  const currentTime = Math.floor(new Date().getTime() / 1000);
  if (currentTime < payload.nbf) {
    throw new Error(`This token is invalid before epoch time '${payload.nbf}', current epoch time is '${currentTime}'`);
  }

  // Check that the token hasn't expired
  if (currentTime > payload.exp) {
    throw new Error(`This token expired at epoch time '${payload.exp}', current epoch time is '${currentTime}'`);
  }

  // Check that the connected wallet matches the token issuer
  const issuerAddress = parsedOptions.issuerAddress ? parsedOptions.issuerAddress : await wallet.getAddress();
  if (issuerAddress.toLowerCase() !== payload.iss.toLowerCase()) {
    throw new Error(`The expected issuer address '${issuerAddress}' did not match the token issuer address '${payload.iss}'`);
  }
  let chainId = undefined;
  if (wallet.getChainId) {
    try {
      chainId = await wallet.getChainId();
    } catch {
      // ignore error
    }
  }
  const verified = await wallet.verifySignature(JSON.stringify(payload), signature, issuerAddress, chainId);
  if (!verified) {
    throw new Error(`The expected signer address '${issuerAddress}' did not sign the token`);
  }
  return {
    address: payload.sub,
    session: payload.ctx
  };
}

class ThirdwebAuth {
  constructor(wallet, domain) {
    this.wallet = wallet;
    this.domain = domain;
  }
  updateWallet(wallet) {
    this.wallet = wallet;
  }
  async payload(options) {
    return buildLoginPayload({
      wallet: this.wallet,
      options: this.formatOptions(options)
    });
  }
  async loginWithPayload(payload) {
    return signLoginPayload({
      wallet: this.wallet,
      payload
    });
  }
  async login(options) {
    return buildAndSignLoginPayload({
      wallet: this.wallet,
      options: this.formatOptions(options)
    });
  }
  async verify(payload, options) {
    return verifyLoginPayload({
      wallet: this.wallet,
      payload,
      options: this.formatOptions(options)
    });
  }
  async generate(payload, options) {
    return generateJWT({
      wallet: this.wallet,
      payload,
      options: this.formatOptions(options)
    });
  }
  async refresh(jwt, expirationTime) {
    return refreshJWT({
      wallet: this.wallet,
      jwt,
      options: {
        expirationTime
      }
    });
  }
  async authenticate(jwt, options) {
    return authenticateJWT({
      wallet: this.wallet,
      jwt,
      options: this.formatOptions(options)
    });
  }
  parseToken(jwt) {
    return parseJWT(jwt);
  }
  formatOptions(options) {
    return options ? {
      ...options,
      domain: options?.domain || this.domain
    } : {
      domain: this.domain
    };
  }
}

exports.AccountTypeSchema = AccountTypeSchema;
exports.AddressSchema = AddressSchema;
exports.AuthenticateOptionsSchema = AuthenticateOptionsSchema;
exports.AuthenticationPayloadDataSchema = AuthenticationPayloadDataSchema;
exports.AuthenticationPayloadSchema = AuthenticationPayloadSchema;
exports.GenerateOptionsSchema = GenerateOptionsSchema;
exports.JsonSchema = JsonSchema;
exports.LoginOptionsSchema = LoginOptionsSchema;
exports.LoginPayloadDataSchema = LoginPayloadDataSchema;
exports.LoginPayloadOutputSchema = LoginPayloadOutputSchema;
exports.LoginPayloadSchema = LoginPayloadSchema;
exports.RawDateSchema = RawDateSchema;
exports.RefreshOptionsSchema = RefreshOptionsSchema;
exports.THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE = THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE;
exports.THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS = THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS;
exports.THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS = THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS;
exports.THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX = THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX;
exports.ThirdwebAuth = ThirdwebAuth;
exports.VerifyOptionsSchema = VerifyOptionsSchema;
exports.authenticateJWT = authenticateJWT;
exports.buildAndSignLoginPayload = buildAndSignLoginPayload;
exports.buildJWT = buildJWT;
exports.buildLoginPayload = buildLoginPayload;
exports.generateJWT = generateJWT;
exports.parseJWT = parseJWT;
exports.refreshJWT = refreshJWT;
exports.signLoginPayload = signLoginPayload;
exports.verifyLoginPayload = verifyLoginPayload;
