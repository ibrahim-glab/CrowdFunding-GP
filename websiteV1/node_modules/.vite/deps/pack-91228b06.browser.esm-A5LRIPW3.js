import {
  StandardErc1155
} from "./chunk-CBPU7MWK.js";
import {
  PackMetadataInputSchema,
  PackRewardsOutputSchema
} from "./chunk-KPZQRWIA.js";
import {
  Erc20
} from "./chunk-UKVXXSPA.js";
import {
  hasERC20Allowance
} from "./chunk-QNCFKN2B.js";
import "./chunk-GB2PCLYH.js";
import "./chunk-EYSJPGEF.js";
import {
  ContractOwner,
  ContractRoyalty
} from "./chunk-HT4B25DF.js";
import "./chunk-4DRVVL7D.js";
import {
  assertEnabled
} from "./chunk-LZSJYQ2X.js";
import {
  isTokenApprovedForTransfer
} from "./chunk-GKTF4MIN.js";
import {
  ContractInterceptor
} from "./chunk-HSXVVCEX.js";
import {
  uploadOrExtractURI
} from "./chunk-TVBEQ3OD.js";
import {
  normalizePriceValue
} from "./chunk-C52BRAYJ.js";
import {
  ContractRoles
} from "./chunk-5XIQKRKG.js";
import {
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractMetadata,
  GasCostEstimator,
  detectContractFeature,
  fetchCurrencyMetadata
} from "./chunk-YQAUWGV2.js";
import {
  AbiSchema,
  ContractWrapper,
  FEATURE_PACK_VRF,
  IPackVRFDirect_default,
  LINK_TOKEN_ADDRESS,
  PACK_CONTRACT_ROLES,
  PackContractSchema,
  Transaction,
  buildTransactionFunction,
  getRoleHash,
  resolveAddress
} from "./chunk-4UWMVSMF.js";
import {
  require_utils
} from "./chunk-7NNND3QZ.js";
import "./chunk-LYEG5PGG.js";
import "./chunk-NI75G64R.js";
import "./chunk-NXQSFSYO.js";
import "./chunk-7JTQECNY.js";
import "./chunk-UHBWZKE6.js";
import "./chunk-FNDLL6VS.js";
import "./chunk-6D6UEHK3.js";
import "./chunk-YN6UTFQV.js";
import {
  require_bs58
} from "./chunk-AFD3C642.js";
import {
  require_fast_deep_equal
} from "./chunk-U7CFD5RQ.js";
import "./chunk-TVZY4654.js";
import "./chunk-XZ6OD6N5.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-WYHBVST3.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-SPBWBR4K.js";
import {
  require_bn
} from "./chunk-6OCL4JXY.js";
import "./chunk-A6WPANBE.js";
import "./chunk-OP3MHZRI.js";
import "./chunk-TZBESOIF.js";
import "./chunk-7GHALKSO.js";
import "./chunk-JVHSL6P6.js";
import "./chunk-XRYAEC2L.js";
import "./chunk-3JC5L5ZG.js";
import "./chunk-UFR7PFM3.js";
import "./chunk-RPXC7Q6H.js";
import {
  __publicField,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@thirdweb-dev/sdk/dist/pack-91228b06.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_utils = __toESM(require_utils());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var PackVRF = class {
  constructor(network, address, storage, options, chainId) {
    __publicField(this, "featureName", FEATURE_PACK_VRF.name);
    /**
     * Open pack
     *
     * @example
     * ```javascript
     * const tokenId = 0;
     * const amount = 1;
     * const receipt = await contract.pack.open(tokenId, amount);
     * ```
     *
     * @remarks
     * Open a pack using Chainlink VRFs random number generation
     * This will return a transaction result with the requestId of the open request, NOT the contents of the pack
     * To get the contents of the pack, you must call claimRewards once the VRF request has been fulfilled
     * You can use the canClaimRewards method to check if the VRF request has been fulfilled
     *
     * @param tokenId - the id of the pack to open
     * @param amount - Optional: the amount of packs to open, defaults to 1
     * @returns
     * @twfeature PackVRF
     */
    __publicField(this, "open", buildTransactionFunction(/* @__PURE__ */ (() => {
      var _this = this;
      return async function(tokenId) {
        let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
        return Transaction.fromContractWrapper({
          contractWrapper: _this.contractWrapper,
          method: "openPack",
          args: [tokenId, amount],
          overrides: {
            // Higher gas limit for opening packs
            gasLimit
          },
          parse: (receipt) => {
            let id = BigNumber.from(0);
            try {
              const event = _this.contractWrapper.parseLogs("PackOpenRequested", receipt == null ? void 0 : receipt.logs);
              id = event[0].args.requestId;
            } catch (e) {
            }
            return {
              receipt,
              id
            };
          }
        });
      };
    })()));
    /**
     * Claim the rewards from an opened pack
     *
     * @example
     * ```javascript
     * const rewards = await contract.pack.claimRewards();
     * ```
     *
     * @remarks This will return the contents of the pack
     * @remarks Make sure to check if the VRF request has been fulfilled using canClaimRewards() before calling this method
     * @returns The random rewards from opening a pack
     * @twfeature PackVRF
     */
    __publicField(this, "claimRewards", buildTransactionFunction(/* @__PURE__ */ (() => {
      var _this2 = this;
      return async function() {
        let gasLimit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5e5;
        return Transaction.fromContractWrapper({
          contractWrapper: _this2.contractWrapper,
          method: "claimRewards",
          args: [],
          overrides: {
            // Higher gas limit for opening packs
            gasLimit
          },
          parse: async (receipt) => {
            const event = _this2.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
            if (event.length === 0) {
              throw new Error("PackOpened event not found");
            }
            const rewards = event[0].args.rewardUnitsDistributed;
            return await _this2.parseRewards(rewards);
          }
        });
      };
    })()));
    let contractWrapper = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : new ContractWrapper(network, address, IPackVRFDirect_default, options, storage);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.chainId = chainId;
    this.events = new ContractEvents(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async parseRewards(rewards) {
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (const reward of rewards) {
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: utils_exports.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: reward.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  /**
   * Setup a listener for when a pack is opened
   *
   * @example
   * ```javascript
   * const unsubscribe = await contract.pack.addPackOpenEventListener((packId, openerAddress, rewards) => {
   *  console.log(`Pack ${packId} was opened by ${openerAddress} and contained:`, rewards);
   * });
   * ```
   *
   * @param callback - the listener to call when a pack is opened
   * @returns A unsubscribe function to cleanup the listener
   * @twfeature PackVRF
   */
  async addPackOpenEventListener(callback) {
    return this.events.addEventListener("PackOpened", async (event) => {
      callback(event.data.packId.toString(), event.data.opener, await this.parseRewards(event.data.rewardUnitsDistributed));
    });
  }
  /**
   * Check if a specific wallet can claim rewards after opening a pack
   *
   * @example
   * ```javascript
   * const canClaim = await contract.pack.canClaimRewards("{{wallet_address}}");
   * ```
   * @param claimerAddress - Optional: the address to check if they can claim rewards, defaults to the connected address
   * @returns whether the connected address can claim rewards after opening a pack
   * @twfeature PackVRF
   */
  async canClaimRewards(claimerAddress) {
    const address = await resolveAddress(claimerAddress || await this.contractWrapper.getSignerAddress());
    return await this.contractWrapper.read("canClaimRewards", [address]);
  }
  /**
   * Open a pack and claim the rewards
   * @remarks This function will only start the flow of opening a pack, the rewards will be granted automatically to the connected address after VRF request is fulfilled
   *
   * @example
   * ```javascript
   * const packId = 0;
   * const amount = 1;
   * const { id } = await contract.pack.openAndClaim(packId, amount);
   * ```
   *
   * @param packId - The id of the pack to open
   * @param amount - Optional: the amount of packs to open, defaults to 1
   * @param gasLimit - Optional: the gas limit to use for the VRF callback transaction, defaults to 500000
   * @returns
   * @twfeature PackVRF
   */
  async openAndClaim(packId) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
    const receipt = await this.contractWrapper.sendTransaction("openPackAndClaimRewards", [packId, amount, gasLimit], {
      // Higher gas limit for opening packs
      gasLimit: BigNumber.from(5e5)
    });
    let id = BigNumber.from(0);
    try {
      const event = this.contractWrapper.parseLogs("PackOpenRequested", receipt == null ? void 0 : receipt.logs);
      id = event[0].args.requestId;
    } catch (e) {
    }
    return {
      receipt,
      id
    };
  }
  /**
   * Get the LINK balance of the contract
   *
   * @example
   * ```javascript
   * const balance = await contract.pack.getLinkBalance();
   * ```
   *
   * @returns The balance of LINK in the contract
   * @twfeature PackVRF
   */
  async getLinkBalance() {
    const ERC20Abi = (await import("./IERC20-6KVZSVJS.js")).default;
    return this.getLinkContract(ERC20Abi).balanceOf(this.contractWrapper.address);
  }
  /**
   * Transfer LINK to this contract
   *
   * @example
   * ```javascript
   * const amount = 1;
   * await contract.pack.transferLink(amount);
   * ```
   *
   * @param amount - the amount of LINK to transfer to the contract
   * @twfeature PackVRF
   */
  async transferLink(amount) {
    const ERC20Abi = (await import("./IERC20-6KVZSVJS.js")).default;
    await this.getLinkContract(ERC20Abi).transfer(this.contractWrapper.address, amount);
  }
  getLinkContract(ERC20Abi) {
    const linkAddress = LINK_TOKEN_ADDRESS[this.chainId];
    if (!linkAddress) {
      throw new Error(`No LINK token address found for chainId ${this.chainId}`);
    }
    const contract = new ContractWrapper(this.contractWrapper.getSignerOrProvider(), linkAddress, ERC20Abi, this.contractWrapper.options, this.storage);
    return new Erc20(contract, this.storage, this.chainId);
  }
};
var _Pack = class _Pack extends StandardErc1155 {
  constructor(network, address, storage) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : void 0;
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options.gasless && "openzeppelin" in options.gasless ? {
      ...options,
      gasless: {
        ...options.gasless,
        openzeppelin: {
          ...options.gasless.openzeppelin,
          useEOAForwarder: true
        }
      }
    } : options, storage);
    super(contractWrapper, storage, chainId);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Create Pack
     * @remarks Create a new pack with the given metadata and rewards and mint it to the connected wallet. See {@link Pack.createTo}
     *
     * @param metadataWithRewards - the metadata and rewards to include in the pack
     * @example
     * ```javascript
     * const pack = {
     *   // The metadata for the pack NFT itself
     *   packMetadata: {
     *     name: "My Pack",
     *     description: "This is a new pack",
     *     image: "ipfs://...",
     *   },
     *   // ERC20 rewards to be included in the pack
     *   erc20Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       quantityPerReward: 5,
     *       quantity: 100,
     *       totalRewards: 20,
     *     }
     *   ],
     *   // ERC721 rewards to be included in the pack
     *   erc721Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       tokenId: 0,
     *     }
     *   ],
     *   // ERC1155 rewards to be included in the pack
     *   erc1155Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       tokenId: 0,
     *       quantityPerReward: 1,
     *       totalRewards: 100,
     *     }
     *   ],
     *   openStartTime: new Date(), // the date that packs can start to be opened, defaults to now
     *   rewardsPerPack: 1, // the number of rewards in each pack, defaults to 1
     * }
     *
     * const tx = await contract.create(pack);
     * ```
     */
    __publicField(this, "create", buildTransactionFunction(async (metadataWithRewards) => {
      const signerAddress = await this.contractWrapper.getSignerAddress();
      return this.createTo.prepare(signerAddress, metadataWithRewards);
    }));
    /**
     * Add Pack Contents
     * @remarks Add contents to an existing pack. See {@link Pack.addPackContents}
     *
     * @param packId - token Id of the pack to add contents to
     * @param packContents - the rewards to include in the pack
     * @example
     * ```javascript
     * const packContents = {
     *   // ERC20 rewards to be included in the pack
     *   erc20Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       quantityPerReward: 5,
     *       quantity: 100,
     *       totalRewards: 20,
     *     }
     *   ],
     *   // ERC721 rewards to be included in the pack
     *   erc721Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       tokenId: 0,
     *     }
     *   ],
     *   // ERC1155 rewards to be included in the pack
     *   erc1155Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       tokenId: 0,
     *       quantityPerReward: 1,
     *       totalRewards: 100,
     *     }
     *   ],
     * }
     *
     * const tx = await contract.addPackContents(packId, packContents);
     * ```
     */
    __publicField(this, "addPackContents", buildTransactionFunction(async (packId, packContents) => {
      const [signerAddress, parsedContents] = await Promise.all([this.contractWrapper.getSignerAddress(), PackRewardsOutputSchema.parseAsync(packContents)]);
      const {
        contents,
        numOfRewardUnits
      } = await this.toPackContentArgs(parsedContents);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "addPackContents",
        args: [packId, contents, numOfRewardUnits, signerAddress],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("PackUpdated", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackUpdated event not found");
          }
          const id = event[0].args.packId;
          return {
            id,
            receipt,
            data: () => this.erc1155.get(id)
          };
        }
      });
    }));
    /**
     * Create Pack To Wallet
     * @remarks Create a new pack with the given metadata and rewards and mint it to the specified address.
     *
     * @param to - the address to mint the pack to
     * @param metadataWithRewards - the metadata and rewards to include in the pack
     *
     * @example
     * ```javascript
     * const pack = {
     *   // The metadata for the pack NFT itself
     *   packMetadata: {
     *     name: "My Pack",
     *     description: "This is a new pack",
     *     image: "ipfs://...",
     *   },
     *   // ERC20 rewards to be included in the pack
     *   erc20Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       quantityPerReward: 5,
     *       quantity: 100,
     *       totalRewards: 20,
     *     }
     *   ],
     *   // ERC721 rewards to be included in the pack
     *   erc721Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       tokenId: 0,
     *     }
     *   ],
     *   // ERC1155 rewards to be included in the pack
     *   erc1155Rewards: [
     *     {
     *       contractAddress: "0x...",
     *       tokenId: 0,
     *       quantityPerReward: 1,
     *       totalRewards: 100,
     *     }
     *   ],
     *   openStartTime: new Date(), // the date that packs can start to be opened, defaults to now
     *   rewardsPerPack: 1, // the number of rewards in each pack, defaults to 1
     * }
     *
     * const tx = await contract.createTo("0x...", pack);
     * ```
     */
    __publicField(this, "createTo", buildTransactionFunction(async (to, metadataWithRewards) => {
      const [uri, parsedMetadata, toAddress] = await Promise.all([uploadOrExtractURI(metadataWithRewards.packMetadata, this.storage), PackMetadataInputSchema.parseAsync(metadataWithRewards), resolveAddress(to)]);
      const {
        erc20Rewards,
        erc721Rewards,
        erc1155Rewards
      } = parsedMetadata;
      const rewardsData = {
        erc20Rewards,
        erc721Rewards,
        erc1155Rewards
      };
      const {
        contents,
        numOfRewardUnits
      } = await this.toPackContentArgs(rewardsData);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createPack",
        args: [contents, numOfRewardUnits, uri, parsedMetadata.openStartTime, parsedMetadata.rewardsPerPack, toAddress],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("PackCreated", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackCreated event not found");
          }
          const packId = event[0].args.packId;
          return {
            id: packId,
            receipt,
            data: () => this.erc1155.get(packId)
          };
        }
      });
    }));
    /**
     * Open Pack
     *
     * @remarks - Open a pack to reveal the contained rewards. This will burn the specified pack and
     * the contained assets will be transferred to the opening users wallet.
     *
     * @param tokenId - the token ID of the pack you want to open
     * @param amount - the amount of packs you want to open
     *
     * @example
     * ```javascript
     * const tokenId = 0
     * const amount = 1
     * const tx = await contract.open(tokenId, amount);
     * ```
     */
    __publicField(this, "open", buildTransactionFunction(/* @__PURE__ */ (() => {
      var _this = this;
      return async function(tokenId) {
        let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
        if (_this._vrf) {
          throw new Error("This contract is using Chainlink VRF, use `contract.vrf.open()` or `contract.vrf.openAndClaim()` instead");
        }
        return Transaction.fromContractWrapper({
          contractWrapper: _this.contractWrapper,
          method: "openPack",
          args: [tokenId, amount],
          overrides: {
            // Higher gas limit for opening packs
            gasLimit
          },
          parse: async (receipt) => {
            const event = _this.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
            if (event.length === 0) {
              throw new Error("PackOpened event not found");
            }
            const rewards = event[0].args.rewardUnitsDistributed;
            const erc20Rewards = [];
            const erc721Rewards = [];
            const erc1155Rewards = [];
            for (const reward of rewards) {
              switch (reward.tokenType) {
                case 0: {
                  const tokenMetadata = await fetchCurrencyMetadata(_this.contractWrapper.getProvider(), reward.assetContract);
                  erc20Rewards.push({
                    contractAddress: reward.assetContract,
                    quantityPerReward: utils_exports.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
                  });
                  break;
                }
                case 1: {
                  erc721Rewards.push({
                    contractAddress: reward.assetContract,
                    tokenId: reward.tokenId.toString()
                  });
                  break;
                }
                case 2: {
                  erc1155Rewards.push({
                    contractAddress: reward.assetContract,
                    tokenId: reward.tokenId.toString(),
                    quantityPerReward: reward.totalAmount.toString()
                  });
                  break;
                }
              }
            }
            return {
              erc20Rewards,
              erc721Rewards,
              erc1155Rewards
            };
          }
        });
      };
    })()));
    this.abi = AbiSchema.parse(abi || []);
    this.metadata = new ContractMetadata(this.contractWrapper, PackContractSchema, this.storage);
    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Pack.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.owner = new ContractOwner(this.contractWrapper);
    this._vrf = this.detectVrf();
  }
  /**
   * Configure royalties
   * @remarks Set your own royalties for the entire contract or per pack
   * @example
   * ```javascript
   * // royalties on the whole contract
   * contract.royalties.setDefaultRoyaltyInfo({
   *   seller_fee_basis_points: 100, // 1%
   *   fee_recipient: "0x..."
   * });
   * // override royalty for a particular pack
   * contract.royalties.setTokenRoyaltyInfo(packId, {
   *   seller_fee_basis_points: 500, // 5%
   *   fee_recipient: "0x..."
   * });
   * ```
   */
  /**
   * @internal
   */
  /**
   * If enabled in the contract, use the Chainlink VRF functionality to open packs
   */
  get vrf() {
    return assertEnabled(this._vrf, FEATURE_PACK_VRF);
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    var _a;
    this.contractWrapper.updateSignerOrProvider(network);
    (_a = this._vrf) == null ? void 0 : _a.onNetworkUpdated(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get a single Pack
   *
   * @remarks Get all the data associated with every pack in this contract.
   *
   * By default, returns the first 100 packs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const pack = await contract.get(0);
   * console.log(packs;
   * ```
   */
  async get(tokenId) {
    return this.erc1155.get(tokenId);
  }
  /**
   * Get All Packs
   *
   * @remarks Get all the data associated with every pack in this contract.
   *
   * By default, returns the first 100 packs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const packs = await contract.getAll();
   * console.log(packs;
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The pack metadata for all packs queried.
   */
  async getAll(queryParams) {
    return this.erc1155.getAll(queryParams);
  }
  /**
   * Get Owned Packs
   *
   * @remarks Get all the data associated with the packs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the packs of
   * const address = "{{wallet_address}}";
   * const packss = await contract.getOwned(address);
   * ```
   *
   * @returns The pack metadata for all the owned packs in the contract.
   */
  async getOwned(walletAddress) {
    return this.erc1155.getOwned(walletAddress);
  }
  /**
   * Get the number of packs created
   * @returns The total number of packs minted in this contract
   * @public
   */
  async getTotalCount() {
    return this.erc1155.totalCount();
  }
  /**
   * Get whether users can transfer packs from this contract
   */
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.read("hasRole", [getRoleHash("transfer"), lib_exports.AddressZero]);
    return !anyoneCanTransfer;
  }
  /**
   * Get Pack Contents
   * @remarks Get the rewards contained inside a pack.
   *
   * @param packId - The id of the pack to get the contents of.
   * @returns  The contents of the pack.
   *
   * @example
   * ```javascript
   * const packId = 0;
   * const contents = await contract.getPackContents(packId);
   * console.log(contents.erc20Rewards);
   * console.log(contents.erc721Rewards);
   * console.log(contents.erc1155Rewards);
   * ```
   */
  async getPackContents(packId) {
    const {
      contents,
      perUnitAmounts
    } = await this.contractWrapper.read("getPackContents", [packId]);
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (let i = 0; i < contents.length; i++) {
      const reward = contents[i];
      const amount = perUnitAmounts[i];
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          const quantityPerReward = utils_exports.formatUnits(amount, tokenMetadata.decimals);
          const totalRewards = utils_exports.formatUnits(BigNumber.from(reward.totalAmount).div(amount), tokenMetadata.decimals);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward,
            totalRewards
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(reward.totalAmount).div(amount).toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  /** *****************************
   * PRIVATE FUNCTIONS
   *******************************/
  async toPackContentArgs(metadataWithRewards) {
    const contents = [];
    const numOfRewardUnits = [];
    const {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    } = metadataWithRewards;
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    for (const erc20 of erc20Rewards) {
      const normalizedQuantity = await normalizePriceValue(provider, erc20.quantityPerReward, erc20.contractAddress);
      const totalQuantity = normalizedQuantity.mul(erc20.totalRewards);
      const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, totalQuantity);
      if (!hasAllowance) {
        throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${totalQuantity});

`);
      }
      numOfRewardUnits.push(erc20.totalRewards);
      contents.push({
        assetContract: erc20.contractAddress,
        tokenType: 0,
        totalAmount: totalQuantity,
        tokenId: 0
      });
    }
    for (const erc721 of erc721Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
      }
      numOfRewardUnits.push("1");
      contents.push({
        assetContract: erc721.contractAddress,
        tokenType: 1,
        totalAmount: 1,
        tokenId: erc721.tokenId
      });
    }
    for (const erc1155 of erc1155Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
      }
      numOfRewardUnits.push(erc1155.totalRewards);
      contents.push({
        assetContract: erc1155.contractAddress,
        tokenType: 2,
        totalAmount: BigNumber.from(erc1155.quantityPerReward).mul(BigNumber.from(erc1155.totalRewards)),
        tokenId: erc1155.tokenId
      });
    }
    return {
      contents,
      numOfRewardUnits
    };
  }
  /**
   * @internal
   */
  async prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  /**
   * @internal
   */
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
  detectVrf() {
    if (detectContractFeature(this.contractWrapper, "PackVRF")) {
      return new PackVRF(this.contractWrapper.getSignerOrProvider(), this.contractWrapper.address, this.storage, this.contractWrapper.options, this.chainId);
    }
    return void 0;
  }
};
__publicField(_Pack, "contractRoles", PACK_CONTRACT_ROLES);
var Pack = _Pack;
export {
  Pack
};
//# sourceMappingURL=pack-91228b06.browser.esm-A5LRIPW3.js.map
