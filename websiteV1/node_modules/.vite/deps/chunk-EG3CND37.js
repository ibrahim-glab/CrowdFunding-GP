import {
  EndDateSchema,
  StartDateSchema
} from "./chunk-3M6RMWCZ.js";
import {
  NFTInputOrUriSchema,
  normalizePriceValue
} from "./chunk-R54CBKQA.js";
import {
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  isNativeToken
} from "./chunk-EWRZHZCC.js";
import {
  AddressOrEnsSchema,
  AddressSchema,
  AmountSchema,
  BasisPointsSchema,
  BigNumberSchema,
  BigNumberishSchema,
  BytesLikeSchema,
  ContractWrapper,
  DuplicateLeafsError,
  NATIVE_TOKEN_ADDRESS,
  QuantitySchema,
  SnapshotEntryWithProofSchema,
  SnapshotInputSchema,
  SnapshotSchema,
  z
} from "./chunk-DH5ORYRE.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4CCDGKES.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-RN5BNASC.js";
import {
  require_buffer
} from "./chunk-MC3ZE6YI.js";
import {
  v4_default
} from "./chunk-LKX6VO3E.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/buffer-reverse/index.js
var require_buffer_reverse = __commonJS({
  "node_modules/buffer-reverse/index.js"(exports, module) {
    module.exports = function reverse2(src) {
      var buffer = new Buffer(src.length);
      for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {
        buffer[i] = src[j];
        buffer[j] = src[i];
      }
      return buffer;
    };
  }
});

// node_modules/treeify/treeify.js
var require_treeify = __commonJS({
  "node_modules/treeify/treeify.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.treeify = factory();
      }
    })(exports, function() {
      function makePrefix(key, last) {
        var str = last ? "└" : "├";
        if (key) {
          str += "─ ";
        } else {
          str += "──┐";
        }
        return str;
      }
      function filterKeys(obj, hideFunctions) {
        var keys = [];
        for (var branch in obj) {
          if (!obj.hasOwnProperty(branch)) {
            continue;
          }
          if (hideFunctions && typeof obj[branch] === "function") {
            continue;
          }
          keys.push(branch);
        }
        return keys;
      }
      function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {
          lastStates.forEach(function(lastState, idx) {
            if (idx > 0) {
              line += (lastState[1] ? " " : "│") + "  ";
            }
            if (!circular && lastState[0] === root) {
              circular = true;
            }
          });
          line += makePrefix(key, last) + key;
          showValues && (typeof root !== "object" || root instanceof Date) && (line += ": " + root);
          circular && (line += " (circular ref.)");
          callback(line);
        }
        if (!circular && typeof root === "object") {
          var keys = filterKeys(root, hideFunctions);
          keys.forEach(function(branch) {
            lastKey = ++index === keys.length;
            growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
          });
        }
      }
      ;
      var Treeify = {};
      Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
        growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
      };
      Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = "";
        growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
          tree += line + "\n";
        });
        return tree;
      };
      return Treeify;
    });
  }
});

// node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js
var import_buffer = __toESM(require_buffer());
var import_buffer_reverse = __toESM(require_buffer_reverse());
var import_treeify = __toESM(require_treeify());
var Base = class _Base {
  /**
   * print
   * @desc Prints out a visual representation of the merkle tree.
   * @example
   *```js
   *tree.print()
   *```
   */
  print() {
    _Base.print(this);
  }
  /**
   * bufferIndexOf
   * @desc Returns the first index of which given buffer is found in array.
   * @param {Buffer[]} haystack - Array of buffers.
   * @param {Buffer} needle - Buffer to find.
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.bufferIndexOf(haystack, needle)
   *```
   */
  bufferIndexOf(array, element) {
    let isSorted = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (isSorted) {
      return this.binarySearch(array, element, import_buffer.Buffer.compare);
    }
    const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);
    return this.linearSearch(array, element, eqChecker);
  }
  /**
   * binarySearch
   * @desc Returns the first index of which given item is found in array using binary search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} compareFunction
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)
   *```
   */
  static binarySearch(array, element, compareFunction) {
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const ordering = compareFunction(array[mid], element);
      if (ordering === 0) {
        for (let i = mid - 1; i >= 0; i--) {
          if (compareFunction(array[i], element) === 0) {
            continue;
          }
          return i + 1;
        }
        return 0;
      } else if (ordering < 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    }
    return -1;
  }
  /**
   * binarySearch
   * @desc Returns the first index of which given item is found in array using binary search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} compareFunction
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.binarySearch(array, element, Buffer.compare)
   *```
   */
  binarySearch(array, element, compareFunction) {
    return _Base.binarySearch(array, element, compareFunction);
  }
  /**
   * linearSearch
   * @desc Returns the first index of which given item is found in array using linear search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} eqChecker
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)
   *```
   */
  static linearSearch(array, element, eqChecker) {
    for (let i = 0; i < array.length; i++) {
      if (eqChecker(array[i], element)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * linearSearch
   * @desc Returns the first index of which given item is found in array using linear search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} eqChecker
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.linearSearch(array, element, (a, b) => a === b)
   *```
   */
  linearSearch(array, element, eqChecker) {
    return _Base.linearSearch(array, element, eqChecker);
  }
  /**
   * bufferify
   * @desc Returns a buffer type for the given value.
   * @param {String|Number|Object|Buffer|ArrayBuffer} value
   * @return {Buffer}
   *
   * @example
   * ```js
   *const buf = MerkleTree.bufferify('0x1234')
   *```
   */
  static bufferify(value) {
    if (!import_buffer.Buffer.isBuffer(value)) {
      if (typeof value === "object" && value.words) {
        return import_buffer.Buffer.from(value.toString(convertWordsToBuffer), "hex");
      } else if (_Base.isHexString(value)) {
        return import_buffer.Buffer.from(value.replace(/^0x/, ""), "hex");
      } else if (typeof value === "string") {
        return import_buffer.Buffer.from(value);
      } else if (typeof value === "bigint") {
        return import_buffer.Buffer.from(value.toString(16), "hex");
      } else if (value instanceof Uint8Array) {
        return import_buffer.Buffer.from(value.buffer);
      } else if (typeof value === "number") {
        let s = value.toString();
        if (s.length % 2) {
          s = `0${s}`;
        }
        return import_buffer.Buffer.from(s, "hex");
      } else if (ArrayBuffer.isView(value)) {
        return import_buffer.Buffer.from(value.buffer, value.byteOffset, value.byteLength);
      }
    }
    return value;
  }
  bigNumberify(value) {
    return _Base.bigNumberify(value);
  }
  static bigNumberify(value) {
    if (typeof value === "bigint") {
      return value;
    }
    if (typeof value === "string") {
      if (value.startsWith("0x") && _Base.isHexString(value)) {
        return BigInt("0x" + value.replace("0x", "").toString());
      }
      return BigInt(value);
    }
    if (import_buffer.Buffer.isBuffer(value)) {
      return BigInt("0x" + value.toString("hex"));
    }
    if (value instanceof Uint8Array) {
      return uint8ArrayToBigInt(value);
    }
    if (typeof value === "number") {
      return BigInt(value);
    }
    throw new Error("cannot bigNumberify");
  }
  /**
   * isHexString
   * @desc Returns true if value is a hex string.
   * @param {String} value
   * @return {Boolean}
   *
   * @example
   * ```js
   *console.log(MerkleTree.isHexString('0x1234'))
   *```
   */
  static isHexString(v) {
    return typeof v === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v);
  }
  /**
   * print
   * @desc Prints out a visual representation of the given merkle tree.
   * @param {Object} tree - Merkle tree instance.
   * @return {String}
   * @example
   *```js
   *MerkleTree.print(tree)
   *```
   */
  static print(tree) {
    console.log(tree.toString());
  }
  /**
   * bufferToHex
   * @desc Returns a hex string with 0x prefix for given buffer.
   * @param {Buffer} value
   * @return {String}
   * @example
   *```js
   *const hexStr = tree.bufferToHex(Buffer.from('A'))
   *```
   */
  bufferToHex(value) {
    let withPrefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return _Base.bufferToHex(value, withPrefix);
  }
  /**
   * bufferToHex
   * @desc Returns a hex string with 0x prefix for given buffer.
   * @param {Buffer} value
   * @return {String}
   * @example
   *```js
   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))
   *```
   */
  static bufferToHex(value) {
    let withPrefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return `${withPrefix ? "0x" : ""}${(value || import_buffer.Buffer.alloc(0)).toString("hex")}`;
  }
  /**
   * bufferify
   * @desc Returns a buffer type for the given value.
   * @param {String|Number|Object|Buffer} value
   * @return {Buffer}
   *
   * @example
   * ```js
   *const buf = tree.bufferify('0x1234')
   *```
   */
  bufferify(value) {
    return _Base.bufferify(value);
  }
  /**
   * bufferifyFn
   * @desc Returns a function that will bufferify the return value.
   * @param {Function}
   * @return {Function}
   *
   * @example
   * ```js
   *const fn = tree.bufferifyFn((value) => sha256(value))
   *```
   */
  bufferifyFn(f) {
    return (value) => {
      const v = f(value);
      if (import_buffer.Buffer.isBuffer(v)) {
        return v;
      }
      if (this.isHexString(v)) {
        return import_buffer.Buffer.from(v.replace("0x", ""), "hex");
      }
      if (typeof v === "string") {
        return import_buffer.Buffer.from(v);
      }
      if (typeof v === "bigint") {
        return import_buffer.Buffer.from(value.toString(16), "hex");
      }
      if (ArrayBuffer.isView(v)) {
        return import_buffer.Buffer.from(v.buffer, v.byteOffset, v.byteLength);
      }
      const arrayBuffer = hexStringToArrayBuffer(value.toString("hex"));
      const processedBuffer = f(arrayBuffer);
      const hexResult = arrayBufferToHexString(processedBuffer);
      return import_buffer.Buffer.from(hexResult, "hex");
    };
  }
  /**
   * isHexString
   * @desc Returns true if value is a hex string.
   * @param {String} value
   * @return {Boolean}
   *
   * @example
   * ```js
   *console.log(MerkleTree.isHexString('0x1234'))
   *```
   */
  isHexString(value) {
    return _Base.isHexString(value);
  }
  /**
   * log2
   * @desc Returns the log2 of number.
   * @param {Number} value
   * @return {Number}
   */
  log2(n) {
    return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);
  }
  /**
   * zip
   * @desc Returns true if value is a hex string.
   * @param {String[]|Number[]|Buffer[]} a - first array
   * @param {String[]|Number[]|Buffer[]} b -  second array
   * @return {String[][]|Number[][]|Buffer[][]}
   *
   * @example
   * ```js
   *const zipped = tree.zip(['a', 'b'],['A', 'B'])
   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]
   *```
   */
  zip(a, b) {
    return a.map((e, i) => [e, b[i]]);
  }
  static hexZeroPad(hexStr, length) {
    return "0x" + hexStr.replace("0x", "").padStart(length, "0");
  }
};
var Base$1 = Base;
function convertWordsToBuffer(value) {
  const wordArray = value.words;
  const arrayBuffer = new ArrayBuffer(wordArray.length * 4);
  const uint8View = new Uint8Array(arrayBuffer);
  for (let i = 0; i < wordArray.length; i++) {
    uint8View[i * 4] = wordArray[i] >> 24 & 255;
    uint8View[i * 4 + 1] = wordArray[i] >> 16 & 255;
    uint8View[i * 4 + 2] = wordArray[i] >> 8 & 255;
    uint8View[i * 4 + 3] = wordArray[i] & 255;
  }
  return arrayBuffer;
}
function hexStringToArrayBuffer(hexString) {
  const buffer = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    buffer[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return buffer.buffer;
}
function arrayBufferToHexString(arrayBuffer) {
  const uint8View = new Uint8Array(arrayBuffer);
  return Array.from(uint8View).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
function uint8ArrayToBigInt(u8a) {
  const hex = Array.from(u8a).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return BigInt(`0x${hex}`);
}
var MerkleTree = class _MerkleTree extends Base$1 {
  /**
   * @desc Constructs a Merkle Tree.
   * All nodes and leaves are stored as Buffers.
   * Lonely leaf nodes are promoted to the next level up without being hashed again.
   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.
   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes
   * @param {Object} options - Additional options
   * @example
   *```js
   *const MerkleTree = require('merkletreejs')
   *const crypto = require('crypto')
   *
   *function sha256(data) {
   *  // returns Buffer
   *  return crypto.createHash('sha256').update(data).digest()
   *}
   *
   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))
   *
   *const tree = new MerkleTree(leaves, sha256)
   *```
   */
  constructor(leaves, hashFn) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super();
    __publicField(this, "duplicateOdd", false);
    __publicField(this, "concatenator", import_buffer.Buffer.concat);
    __publicField(this, "hashLeaves", false);
    __publicField(this, "isBitcoinTree", false);
    __publicField(this, "leaves", []);
    __publicField(this, "layers", []);
    __publicField(this, "sortLeaves", false);
    __publicField(this, "sortPairs", false);
    __publicField(this, "sort", false);
    __publicField(this, "fillDefaultHash", null);
    __publicField(this, "complete", false);
    if (options.complete) {
      if (options.isBitcoinTree) {
        throw new Error('option "complete" is incompatible with "isBitcoinTree"');
      }
      if (options.duplicateOdd) {
        throw new Error('option "complete" is incompatible with "duplicateOdd"');
      }
    }
    this.isBitcoinTree = !!options.isBitcoinTree;
    this.hashLeaves = !!options.hashLeaves;
    this.sortLeaves = !!options.sortLeaves;
    this.sortPairs = !!options.sortPairs;
    this.complete = !!options.complete;
    if (options.fillDefaultHash) {
      if (typeof options.fillDefaultHash === "function") {
        this.fillDefaultHash = options.fillDefaultHash;
      } else if (import_buffer.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === "string") {
        this.fillDefaultHash = (idx, hashFn2) => options.fillDefaultHash;
      } else {
        throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
      }
    }
    this.sort = !!options.sort;
    if (this.sort) {
      this.sortLeaves = true;
      this.sortPairs = true;
    }
    this.duplicateOdd = !!options.duplicateOdd;
    if (options.concatenator) {
      this.concatenator = options.concatenator;
    }
    this.hashFn = this.bufferifyFn(hashFn);
    this.processLeaves(leaves);
  }
  getOptions() {
    var _a;
    return {
      complete: this.complete,
      isBitcoinTree: this.isBitcoinTree,
      hashLeaves: this.hashLeaves,
      sortLeaves: this.sortLeaves,
      sortPairs: this.sortPairs,
      sort: this.sort,
      fillDefaultHash: ((_a = this.fillDefaultHash) == null ? void 0 : _a.toString()) ?? null,
      duplicateOdd: this.duplicateOdd
    };
  }
  processLeaves(leaves) {
    if (this.hashLeaves) {
      leaves = leaves.map(this.hashFn);
    }
    this.leaves = leaves.map(this.bufferify);
    if (this.sortLeaves) {
      this.leaves = this.leaves.sort(import_buffer.Buffer.compare);
    }
    if (this.fillDefaultHash) {
      for (let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {
        this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));
      }
    }
    this.createHashes(this.leaves);
  }
  createHashes(nodes) {
    this.layers = [nodes];
    while (nodes.length > 1) {
      const layerIndex = this.layers.length;
      this.layers.push([]);
      const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - 2 ** Math.ceil(Math.log2(nodes.length)) : nodes.length;
      for (let i = 0; i < nodes.length; i += 2) {
        if (i >= layerLimit) {
          this.layers[layerIndex].push(...nodes.slice(layerLimit));
          break;
        } else if (i + 1 === nodes.length) {
          if (nodes.length % 2 === 1) {
            const data = nodes[nodes.length - 1];
            let hash2 = data;
            if (this.isBitcoinTree) {
              hash2 = this.hashFn(this.concatenator([(0, import_buffer_reverse.default)(data), (0, import_buffer_reverse.default)(data)]));
              hash2 = (0, import_buffer_reverse.default)(this.hashFn(hash2));
              this.layers[layerIndex].push(hash2);
              continue;
            } else {
              if (this.duplicateOdd)
                ;
              else {
                this.layers[layerIndex].push(nodes[i]);
                continue;
              }
            }
          }
        }
        const left = nodes[i];
        const right = i + 1 === nodes.length ? left : nodes[i + 1];
        let combined = null;
        if (this.isBitcoinTree) {
          combined = [(0, import_buffer_reverse.default)(left), (0, import_buffer_reverse.default)(right)];
        } else {
          combined = [left, right];
        }
        if (this.sortPairs) {
          combined.sort(import_buffer.Buffer.compare);
        }
        let hash = this.hashFn(this.concatenator(combined));
        if (this.isBitcoinTree) {
          hash = (0, import_buffer_reverse.default)(this.hashFn(hash));
        }
        this.layers[layerIndex].push(hash);
      }
      nodes = this.layers[layerIndex];
    }
  }
  /**
   * addLeaf
   * @desc Adds a leaf to the tree and re-calculates layers.
   * @param {String|Buffer} - Leaf
   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.
   * @example
   *```js
   *tree.addLeaf(newLeaf)
   *```
   */
  addLeaf(leaf) {
    let shouldHash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (shouldHash) {
      leaf = this.hashFn(leaf);
    }
    this.processLeaves(this.leaves.concat(leaf));
  }
  /**
   * addLeaves
   * @desc Adds multiple leaves to the tree and re-calculates layers.
   * @param {String[]|Buffer[]} - Array of leaves
   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.
   * @example
   *```js
   *tree.addLeaves(newLeaves)
   *```
   */
  addLeaves(leaves) {
    let shouldHash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (shouldHash) {
      leaves = leaves.map(this.hashFn);
    }
    this.processLeaves(this.leaves.concat(leaves));
  }
  /**
   * getLeaves
   * @desc Returns array of leaves of Merkle Tree.
   * @return {Buffer[]}
   * @example
   *```js
   *const leaves = tree.getLeaves()
   *```
   */
  getLeaves(values) {
    if (Array.isArray(values)) {
      if (this.hashLeaves) {
        values = values.map(this.hashFn);
        if (this.sortLeaves) {
          values = values.sort(import_buffer.Buffer.compare);
        }
      }
      return this.leaves.filter(
        // @ts-expect-error - issue from original code
        (leaf) => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1
      );
    }
    return this.leaves;
  }
  /**
   * getLeaf
   * @desc Returns the leaf at the given index.
   * @param {Number} - Index number
   * @return {Buffer}
   * @example
   *```js
   *const leaf = tree.getLeaf(1)
   *```
   */
  getLeaf(index) {
    if (index < 0 || index > this.leaves.length - 1) {
      return import_buffer.Buffer.from([]);
    }
    return this.leaves[index];
  }
  /**
   * getLeafIndex
   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.
   * @param {String|Buffer} - Target leaf
   * @return {number}
   * @example
   *```js
   *const leaf = Buffer.from('abc')
   *const index = tree.getLeafIndex(leaf)
   *```
   */
  getLeafIndex(target) {
    target = this.bufferify(target);
    const leaves = this.getLeaves();
    for (let i = 0; i < leaves.length; i++) {
      const leaf = leaves[i];
      if (leaf.equals(target)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * getLeafCount
   * @desc Returns the total number of leaves.
   * @return {number}
   * @example
   *```js
   *const count = tree.getLeafCount()
   *```
   */
  getLeafCount() {
    return this.leaves.length;
  }
  /**
   * getHexLeaves
   * @desc Returns array of leaves of Merkle Tree as hex strings.
   * @return {String[]}
   * @example
   *```js
   *const leaves = tree.getHexLeaves()
   *```
   */
  getHexLeaves() {
    return this.leaves.map((leaf) => this.bufferToHex(leaf));
  }
  /**
   * marshalLeaves
   * @desc Returns array of leaves of Merkle Tree as a JSON string.
   * @param {String[]|Buffer[]} - Merkle tree leaves
   * @return {String} - List of leaves as JSON string
   * @example
   *```js
   *const jsonStr = MerkleTree.marshalLeaves(leaves)
   *```
   */
  static marshalLeaves(leaves) {
    return JSON.stringify(leaves.map((leaf) => _MerkleTree.bufferToHex(leaf)), null, 2);
  }
  /**
   * unmarshalLeaves
   * @desc Returns array of leaves of Merkle Tree as a Buffers.
   * @param {String|Object} - JSON stringified leaves
   * @return {Buffer[]} - Unmarshalled list of leaves
   * @example
   *```js
   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)
   *```
   */
  static unmarshalLeaves(jsonStr) {
    let parsed = null;
    if (typeof jsonStr === "string") {
      parsed = JSON.parse(jsonStr);
    } else if (jsonStr instanceof Object) {
      parsed = jsonStr;
    } else {
      throw new Error("Expected type of string or object");
    }
    if (!parsed) {
      return [];
    }
    if (!Array.isArray(parsed)) {
      throw new Error("Expected JSON string to be array");
    }
    return parsed.map(_MerkleTree.bufferify);
  }
  /**
   * getLayers
   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.
   * @return {Buffer[][]}
   * @example
   *```js
   *const layers = tree.getLayers()
   *```
   */
  getLayers() {
    return this.layers;
  }
  /**
   * getHexLayers
   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.
   * @return {String[][]}
   * @example
   *```js
   *const layers = tree.getHexLayers()
   *```
   */
  getHexLayers() {
    return this.layers.reduce((acc, item) => {
      if (Array.isArray(item)) {
        acc.push(item.map((layer) => this.bufferToHex(layer)));
      } else {
        acc.push(item);
      }
      return acc;
    }, []);
  }
  /**
   * getLayersFlat
   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.
   * @return {Buffer[]}
   * @example
   *```js
   *const layers = tree.getLayersFlat()
   *```
   */
  getLayersFlat() {
    const layers = this.layers.reduce((acc, item) => {
      if (Array.isArray(item)) {
        acc.unshift(...item);
      } else {
        acc.unshift(item);
      }
      return acc;
    }, []);
    layers.unshift(import_buffer.Buffer.from([0]));
    return layers;
  }
  /**
   * getHexLayersFlat
   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.
   * @return {String[]}
   * @example
   *```js
   *const layers = tree.getHexLayersFlat()
   *```
   */
  getHexLayersFlat() {
    return this.getLayersFlat().map((layer) => this.bufferToHex(layer));
  }
  /**
   * getLayerCount
   * @desc Returns the total number of layers.
   * @return {number}
   * @example
   *```js
   *const count = tree.getLayerCount()
   *```
   */
  getLayerCount() {
    return this.getLayers().length;
  }
  /**
   * getRoot
   * @desc Returns the Merkle root hash as a Buffer.
   * @return {Buffer}
   * @example
   *```js
   *const root = tree.getRoot()
   *```
   */
  getRoot() {
    if (this.layers.length === 0) {
      return import_buffer.Buffer.from([]);
    }
    return this.layers[this.layers.length - 1][0] || import_buffer.Buffer.from([]);
  }
  /**
   * getHexRoot
   * @desc Returns the Merkle root hash as a hex string.
   * @return {String}
   * @example
   *```js
   *const root = tree.getHexRoot()
   *```
   */
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  /**
   * getProof
   * @desc Returns the proof for a target leaf.
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {Object[]} - Array of objects containing a position property of type string
   * with values of 'left' or 'right' and a data property of type Buffer.
   * @example
   * ```js
   *const proof = tree.getProof(leaves[2])
   *```
   *
   * @example
   *```js
   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
   *const tree = new MerkleTree(leaves, keccak)
   *const proof = tree.getProof(leaves[2], 2)
   *```
   */
  getProof(leaf, index) {
    if (typeof leaf === "undefined") {
      throw new Error("leaf is required");
    }
    leaf = this.bufferify(leaf);
    const proof = [];
    if (!Number.isInteger(index)) {
      index = -1;
      for (let i = 0; i < this.leaves.length; i++) {
        if (import_buffer.Buffer.compare(leaf, this.leaves[i]) === 0) {
          index = i;
        }
      }
    }
    if (index <= -1) {
      return [];
    }
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      const isRightNode = index % 2;
      const pairIndex = isRightNode ? (
        // @ts-expect-error - issue from original code
        index - 1
      ) : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? (
        // Proof Generation for Bitcoin Trees
        index
      ) : (
        // Proof Generation for Non-Bitcoin Trees
        // @ts-expect-error - issue from original code
        index + 1
      );
      if (pairIndex < layer.length) {
        proof.push({
          position: isRightNode ? "left" : "right",
          data: layer[pairIndex]
        });
      }
      index = index / 2 | 0;
    }
    return proof;
  }
  /**
   * getHexProof
   * @desc Returns the proof for a target leaf as hex strings.
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {String[]} - Proof array as hex strings.
   * @example
   * ```js
   *const proof = tree.getHexProof(leaves[2])
   *```
   */
  getHexProof(leaf, index) {
    return this.getProof(leaf, index).map((item) => this.bufferToHex(item.data));
  }
  /**
   * getProofs
   * @desc Returns the proofs for all leaves.
   * @return {Object[]} - Array of objects containing a position property of type string
   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.
   * @example
   * ```js
   *const proofs = tree.getProofs()
   *```
   *
   * @example
   *```js
   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
   *const tree = new MerkleTree(leaves, keccak)
   *const proofs = tree.getProofs()
   *```
   */
  getProofs() {
    const proof = [];
    const proofs = [];
    this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);
    return proofs;
  }
  /**
   * getProofsDFS
   * @desc Get all proofs through single traverse
   * @param {Number} currentLayer - Current layer index in traverse.
   * @param {Number} index - Current tarvese node index in traverse.
   * @param {Object[]} proof - Proof chain for single leaf.
   * @param {Object[]} proofs - Proofs for all leaves
   * @example
   * ```js
   *const layers = tree.getLayers()
   *const index = 0;
   *let proof = [];
   *let proofs = [];
   *const proof = tree.getProofsDFS(layers, index, proof, proofs)
   *```
   */
  // @ts-expect-error - issue from original code
  getProofsDFS(currentLayer, index, proof, proofs) {
    const isRightNode = index % 2;
    if (currentLayer === -1) {
      if (!isRightNode) {
        proofs.push([...proof].reverse());
      }
      return;
    }
    if (index >= this.layers[currentLayer].length) {
      return;
    }
    const layer = this.layers[currentLayer];
    const pairIndex = isRightNode ? index - 1 : index + 1;
    let pushed = false;
    if (pairIndex < layer.length) {
      pushed = true;
      proof.push({
        position: isRightNode ? "left" : "right",
        data: layer[pairIndex]
      });
    }
    const leftchildIndex = index * 2;
    const rightchildIndex = index * 2 + 1;
    this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);
    this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);
    if (pushed) {
      proof.splice(proof.length - 1, 1);
    }
  }
  /**
   * getHexProofs
   * @desc Returns the proofs for all leaves as hex strings.
   * @return {String[]} - Proofs array as hex strings.
   * @example
   * ```js
   *const proofs = tree.getHexProofs()
   *```
   */
  getHexProofs() {
    return this.getProofs().map((item) => this.bufferToHex(item.data));
  }
  /**
   * getPositionalHexProof
   * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {(string | number)[][]} - Proof array as hex strings. position at index 0
   * @example
   * ```js
   *const proof = tree.getPositionalHexProof(leaves[2])
   *```
   */
  getPositionalHexProof(leaf, index) {
    return this.getProof(leaf, index).map((item) => {
      return [item.position === "left" ? 0 : 1, this.bufferToHex(item.data)];
    });
  }
  /**
   * getProofIndices
   * @desc Returns the proof indices for given tree indices.
   * @param {Number[]} treeIndices - Tree indices
   * @param {Number} depth - Tree depth; number of layers.
   * @return {Number[]} - Proof indices
   * @example
   * ```js
   *const proofIndices = tree.getProofIndices([2,5,6], 4)
   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]
   *```
   */
  getProofIndices(treeIndices, depth) {
    const leafCount = 2 ** depth;
    let maximalIndices = /* @__PURE__ */ new Set();
    for (const index of treeIndices) {
      let x = leafCount + index;
      while (x > 1) {
        maximalIndices.add(x ^ 1);
        x = x / 2 | 0;
      }
    }
    const a = treeIndices.map((index) => leafCount + index);
    const b = Array.from(maximalIndices).sort((x, y) => x - y).reverse();
    maximalIndices = a.concat(b);
    const redundantIndices = /* @__PURE__ */ new Set();
    const proof = [];
    for (let index of maximalIndices) {
      if (!redundantIndices.has(index)) {
        proof.push(index);
        while (index > 1) {
          redundantIndices.add(index);
          if (!redundantIndices.has(index ^ 1)) {
            break;
          }
          index = index / 2 | 0;
        }
      }
    }
    return proof.filter((index) => {
      return !treeIndices.includes(index - leafCount);
    });
  }
  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
    const depth = Math.ceil(Math.log2(leavesCount));
    const unevenLayers = [];
    for (let index = 0; index < depth; index++) {
      const unevenLayer = leavesCount % 2 !== 0;
      if (unevenLayer) {
        unevenLayers.push({
          index,
          leavesCount
        });
      }
      leavesCount = Math.ceil(leavesCount / 2);
    }
    const proofIndices = [];
    let layerNodes = sortedLeafIndices;
    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {
      const siblingIndices = layerNodes.map((index) => {
        if (index % 2 === 0) {
          return index + 1;
        }
        return index - 1;
      });
      let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));
      const unevenLayer = unevenLayers.find((_ref) => {
        let {
          index
        } = _ref;
        return index === layerIndex;
      });
      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
        proofNodeIndices = proofNodeIndices.slice(0, -1);
      }
      proofIndices.push(proofNodeIndices);
      layerNodes = [...new Set(layerNodes.map((index) => {
        if (index % 2 === 0) {
          return index / 2;
        }
        if (index % 2 === 0) {
          return (index + 1) / 2;
        }
        return (index - 1) / 2;
      }))];
    }
    return proofIndices;
  }
  /**
   * getMultiProof
   * @desc Returns the multiproof for given tree indices.
   * @param {Number[]} indices - Tree indices.
   * @return {Buffer[]} - Multiproofs
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getMultiProof(indices)
   *```
   */
  getMultiProof(tree, indices) {
    if (!this.complete) {
      console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true");
    }
    if (!indices) {
      indices = tree;
      tree = this.getLayersFlat();
    }
    const isUneven = this.isUnevenTree();
    if (isUneven) {
      if (indices.every(Number.isInteger)) {
        return this.getMultiProofForUnevenTree(indices);
      }
    }
    if (!indices.every(Number.isInteger)) {
      let els = indices;
      if (this.sortPairs) {
        els = els.sort(import_buffer.Buffer.compare);
      }
      let ids = els.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
      if (!ids.every((idx) => idx !== -1)) {
        throw new Error("Element does not exist in Merkle tree");
      }
      const hashes = [];
      const proof = [];
      let nextIds = [];
      for (let i = 0; i < this.layers.length; i++) {
        const layer = this.layers[i];
        for (let j = 0; j < ids.length; j++) {
          const idx = ids[j];
          const pairElement = this.getPairNode(layer, idx);
          hashes.push(layer[idx]);
          if (pairElement) {
            proof.push(pairElement);
          }
          nextIds.push(idx / 2 | 0);
        }
        ids = nextIds.filter((value, j, self) => self.indexOf(value) === j);
        nextIds = [];
      }
      return proof.filter((value) => !hashes.includes(value));
    }
    return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(
      // @ts-expect-error - issue from original code
      (index) => tree[index]
    );
  }
  getMultiProofForUnevenTree(tree, indices) {
    if (!indices) {
      indices = tree;
      tree = this.getLayers();
    }
    let proofHashes = [];
    let currentLayerIndices = indices;
    for (const treeLayer of tree) {
      const siblings = [];
      for (const index of currentLayerIndices) {
        if (index % 2 === 0) {
          const idx2 = index + 1;
          if (!currentLayerIndices.includes(idx2)) {
            if (treeLayer[idx2]) {
              siblings.push(treeLayer[idx2]);
              continue;
            }
          }
        }
        const idx = index - 1;
        if (!currentLayerIndices.includes(idx)) {
          if (treeLayer[idx]) {
            siblings.push(treeLayer[idx]);
            continue;
          }
        }
      }
      proofHashes = proofHashes.concat(siblings);
      const uniqueIndices = /* @__PURE__ */ new Set();
      for (const index of currentLayerIndices) {
        if (index % 2 === 0) {
          uniqueIndices.add(index / 2);
          continue;
        }
        if (index % 2 === 0) {
          uniqueIndices.add((index + 1) / 2);
          continue;
        }
        uniqueIndices.add((index - 1) / 2);
      }
      currentLayerIndices = Array.from(uniqueIndices);
    }
    return proofHashes;
  }
  /**
   * getHexMultiProof
   * @desc Returns the multiproof for given tree indices as hex strings.
   * @param {Number[]} indices - Tree indices.
   * @return {String[]} - Multiproofs as hex strings.
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getHexMultiProof(indices)
   *```
   */
  getHexMultiProof(tree, indices) {
    return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));
  }
  /**
   * getProofFlags
   * @desc Returns list of booleans where proofs should be used instead of hashing.
   * Proof flags are used in the Solidity multiproof verifiers.
   * @param {Number[]|Buffer[]} leaves
   * @param {Buffer[]} proofs
   * @return {Boolean[]} - Boolean flags
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getMultiProof(indices)
   *const proofFlags = tree.getProofFlags(leaves, proof)
   *```
   */
  getProofFlags(leaves, proofs) {
    if (!Array.isArray(leaves) || leaves.length <= 0) {
      throw new Error("Invalid Inputs!");
    }
    let ids;
    if (leaves.every(Number.isInteger)) {
      ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
    } else {
      ids = leaves.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
    }
    if (!ids.every((idx) => idx !== -1)) {
      throw new Error("Element does not exist in Merkle tree");
    }
    const _proofs = proofs.map((item) => this.bufferify(item));
    const tested = [];
    const flags = [];
    for (let index = 0; index < this.layers.length; index++) {
      const layer = this.layers[index];
      ids = ids.reduce((ids_, idx) => {
        const skipped = tested.includes(layer[idx]);
        if (!skipped) {
          const pairElement = this.getPairNode(layer, idx);
          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
          pairElement && flags.push(!proofUsed);
          tested.push(layer[idx]);
          tested.push(pairElement);
        }
        ids_.push(idx / 2 | 0);
        return ids_;
      }, []);
    }
    return flags;
  }
  /**
   * verify
   * @desc Returns true if the proof path (array of hashes) can connect the target node
   * to the Merkle root.
   * @param {Object[]} proof - Array of proof objects that should connect
   * target node to Merkle root.
   * @param {Buffer} targetNode - Target node Buffer
   * @param {Buffer} root - Merkle root Buffer
   * @return {Boolean}
   * @example
   *```js
   *const root = tree.getRoot()
   *const proof = tree.getProof(leaves[2])
   *const verified = tree.verify(proof, leaves[2], root)
   *```
   */
  verify(proof, targetNode, root) {
    let hash = this.bufferify(targetNode);
    root = this.bufferify(root);
    if (!Array.isArray(proof) || !targetNode || !root) {
      return false;
    }
    for (let i = 0; i < proof.length; i++) {
      const node = proof[i];
      let data = null;
      let isLeftNode = null;
      if (typeof node === "string") {
        data = this.bufferify(node);
        isLeftNode = true;
      } else if (Array.isArray(node)) {
        isLeftNode = node[0] === 0;
        data = this.bufferify(node[1]);
      } else if (import_buffer.Buffer.isBuffer(node)) {
        data = node;
        isLeftNode = true;
      } else if (node instanceof Object) {
        data = this.bufferify(node.data);
        isLeftNode = node.position === "left";
      } else {
        throw new Error("Expected node to be of type string or object");
      }
      const buffers = [];
      if (this.isBitcoinTree) {
        buffers.push((0, import_buffer_reverse.default)(hash));
        buffers[isLeftNode ? "unshift" : "push"]((0, import_buffer_reverse.default)(data));
        hash = this.hashFn(this.concatenator(buffers));
        hash = (0, import_buffer_reverse.default)(this.hashFn(hash));
      } else {
        if (this.sortPairs) {
          if (import_buffer.Buffer.compare(hash, data) === -1) {
            buffers.push(hash, data);
            hash = this.hashFn(this.concatenator(buffers));
          } else {
            buffers.push(data, hash);
            hash = this.hashFn(this.concatenator(buffers));
          }
        } else {
          buffers.push(hash);
          buffers[isLeftNode ? "unshift" : "push"](data);
          hash = this.hashFn(this.concatenator(buffers));
        }
      }
    }
    return import_buffer.Buffer.compare(hash, root) === 0;
  }
  /**
   * verifyMultiProof
   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.
   * @param {Buffer} root - Merkle tree root
   * @param {Number[]} proofIndices - Leave indices for proof
   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof
   * @param {Number} leavesCount - Count of original leaves
   * @param {Buffer[]} proof - Multiproofs given indices
   * @return {Boolean}
   * @example
   *```js
   *const leaves = tree.getLeaves()
   *const root = tree.getRoot()
   *const treeFlat = tree.getLayersFlat()
   *const leavesCount = leaves.length
   *const proofIndices = [2, 5, 6]
   *const proofLeaves = proofIndices.map(i => leaves[i])
   *const proof = tree.getMultiProof(treeFlat, indices)
   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)
   *```
   */
  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
    const isUneven = this.isUnevenTree();
    if (isUneven) {
      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
    }
    const depth = Math.ceil(Math.log2(leavesCount));
    root = this.bufferify(root);
    proofLeaves = proofLeaves.map((leaf) => this.bufferify(leaf));
    proof = proof.map((leaf) => this.bufferify(leaf));
    const tree = {};
    for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {
      tree[2 ** depth + index] = leaf;
    }
    for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {
      tree[index] = proofitem;
    }
    let indexqueue = Object.keys(tree).map((value) => Number(value)).sort((a, b) => a - b);
    indexqueue = indexqueue.slice(0, indexqueue.length - 1);
    let i = 0;
    while (i < indexqueue.length) {
      const index = indexqueue[i];
      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {
        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];
        if (this.sortPairs) {
          pair = pair.sort(import_buffer.Buffer.compare);
        }
        const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];
        tree[index / 2 | 0] = hash;
        indexqueue.push(index / 2 | 0);
      }
      i += 1;
    }
    return !proofIndices.length || // @ts-expect-error - issue from original code
    {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);
  }
  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
    root = this.bufferify(root);
    leaves = leaves.map(this.bufferify);
    proofs = proofs.map(this.bufferify);
    const leavesLen = leaves.length;
    const totalHashes = proofFlag.length;
    const hashes = [];
    let leafPos = 0;
    let hashPos = 0;
    let proofPos = 0;
    for (let i = 0; i < totalHashes; i++) {
      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
      const buffers = [bufA, bufB].sort(import_buffer.Buffer.compare);
      hashes[i] = this.hashFn(this.concatenator(buffers));
    }
    return import_buffer.Buffer.compare(hashes[totalHashes - 1], root) === 0;
  }
  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
    root = this.bufferify(root);
    leaves = leaves.map((leaf) => this.bufferify(leaf));
    proof = proof.map((leaf) => this.bufferify(leaf));
    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
    return root.equals(computedRoot);
  }
  /**
   * getDepth
   * @desc Returns the tree depth (number of layers)
   * @return {Number}
   * @example
   *```js
   *const depth = tree.getDepth()
   *```
   */
  getDepth() {
    return this.getLayers().length - 1;
  }
  /**
   * getLayersAsObject
   * @desc Returns the layers as nested objects instead of an array.
   * @example
   *```js
   *const layersObj = tree.getLayersAsObject()
   *```
   */
  getLayersAsObject() {
    const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));
    const objs = [];
    for (let i = 0; i < layers.length; i++) {
      const arr = [];
      for (let j = 0; j < layers[i].length; j++) {
        const obj = {
          [layers[i][j]]: null
        };
        if (objs.length) {
          obj[layers[i][j]] = {};
          const a = objs.shift();
          const akey = Object.keys(a)[0];
          obj[layers[i][j]][akey] = a[akey];
          if (objs.length) {
            const b = objs.shift();
            const bkey = Object.keys(b)[0];
            obj[layers[i][j]][bkey] = b[bkey];
          }
        }
        arr.push(obj);
      }
      objs.push(...arr);
    }
    return objs[0];
  }
  /**
   * resetTree
   * @desc Resets the tree by clearing the leaves and layers.
   * @example
   *```js
   *tree.resetTree()
   *```
   */
  resetTree() {
    this.leaves = [];
    this.layers = [];
  }
  /**
   * getPairNode
   * @desc Returns the node at the index for given layer.
   * @param {Buffer[]} layer - Tree layer
   * @param {Number} index - Index at layer.
   * @return {Buffer} - Node
   *
   *@example
   * ```js
   *const node = tree.getPairNode(layer, index)
   *```
   */
  getPairNode(layer, idx) {
    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
    if (pairIdx < layer.length) {
      return layer[pairIdx];
    } else {
      return null;
    }
  }
  /**
   * toTreeString
   * @desc Returns a visual representation of the merkle tree as a string.
   * @return {String}
   * @example
   *```js
   *console.log(tree.toTreeString())
   *```
   */
  toTreeString() {
    const obj = this.getLayersAsObject();
    return (0, import_treeify.asTree)(obj, true, false);
  }
  /**
   * toString
   * @desc Returns a visual representation of the merkle tree as a string.
   * @example
   *```js
   *console.log(tree.toString())
   *```
   */
  toString() {
    return this.toTreeString();
  }
  isUnevenTree(treeLayers) {
    const depth = (treeLayers == null ? void 0 : treeLayers.length) || this.getDepth();
    return !this.isPowOf2(depth);
  }
  isPowOf2(v) {
    return v && !(v & v - 1);
  }
  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
    const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {
      let [indexA] = _ref2;
      let [indexB] = _ref3;
      return indexA - indexB;
    });
    const leafTupleIndices = leafTuples.map((_ref4) => {
      let [index] = _ref4;
      return index;
    });
    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
    let nextSliceStart = 0;
    const proofTuplesByLayers = [];
    for (let i = 0; i < proofIndices.length; i++) {
      const indices = proofIndices[i];
      const sliceStart = nextSliceStart;
      nextSliceStart += indices.length;
      proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
    }
    const tree = [leafTuples];
    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {
      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort((_ref5, _ref6) => {
        let [indexA] = _ref5;
        let [indexB] = _ref6;
        return indexA - indexB;
      }).map((_ref7) => {
        let [, hash] = _ref7;
        return hash;
      });
      const s = tree[layerIndex].map((_ref8) => {
        let [layerIndex_] = _ref8;
        return layerIndex_;
      });
      const parentIndices = [...new Set(s.map((index) => {
        if (index % 2 === 0) {
          return index / 2;
        }
        if (index % 2 === 0) {
          return (index + 1) / 2;
        }
        return (index - 1) / 2;
      }))];
      const parentLayer = [];
      for (let i = 0; i < parentIndices.length; i++) {
        const parentNodeTreeIndex = parentIndices[i];
        const bufA = currentLayer[i * 2];
        const bufB = currentLayer[i * 2 + 1];
        const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;
        parentLayer.push([parentNodeTreeIndex, hash]);
      }
      tree.push(parentLayer);
    }
    return tree[tree.length - 1][0][1];
  }
};

// node_modules/@thirdweb-dev/sdk/dist/signature-61410b74.browser.esm.js
init_lib();
function abstractContractModelToLegacy(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerTransaction: model.maxClaimablePerWallet,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0
  };
}
function abstractContractModelToNew(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerWallet: model.maxClaimablePerWallet,
    metadata: model.metadata || ""
  };
}
function convertQuantityToBigNumber(quantity, tokenDecimals) {
  if (quantity === "unlimited") {
    return lib_exports.MaxUint256;
  } else {
    return utils_exports.parseUnits(quantity, tokenDecimals);
  }
}
async function parseSnapshotInputs(inputs) {
  const chunkSize = 25e3;
  const chunks = Array.from({
    length: Math.ceil(inputs.length / chunkSize)
  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));
  const results = [];
  const parsedChunks = await Promise.all(chunks.map((chunk) => SnapshotInputSchema.parseAsync(chunk)));
  for (const chunk of parsedChunks) {
    results.push(...chunk);
  }
  return results;
}
var SHARD_NYBBLES = 2;
var SnapshotFormatVersion = function(SnapshotFormatVersion2) {
  SnapshotFormatVersion2[SnapshotFormatVersion2["V1"] = 1] = "V1";
  SnapshotFormatVersion2[SnapshotFormatVersion2["V2"] = 2] = "V2";
  return SnapshotFormatVersion2;
}({});
var ShardedMerkleTree = class _ShardedMerkleTree {
  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {
    this.storage = storage;
    this.shardNybbles = shardNybbles;
    this.baseUri = baseUri;
    this.originalEntriesUri = originalEntriesUri;
    this.tokenDecimals = tokenDecimals;
    this.shards = {};
    this.trees = {};
  }
  static async fromUri(uri, storage) {
    try {
      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);
      if (shardedMerkleTreeInfo.isShardedMerkleTree) {
        return _ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);
      }
    } catch (e) {
      return void 0;
    }
  }
  static async fromShardedMerkleTreeInfo(info, storage) {
    return new _ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);
  }
  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {
    switch (snapshotFormatVersion) {
      case SnapshotFormatVersion.V1:
        return utils_exports.solidityKeccak256(["address", "uint256"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);
      case SnapshotFormatVersion.V2:
        return utils_exports.solidityKeccak256(["address", "uint256", "uint256", "address"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || "unlimited", currencyDecimals), entry.currencyAddress || lib_exports.AddressZero]);
    }
  }
  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {
    if (!currencyAddress) {
      return 18;
    }
    let currencyDecimals = cache[currencyAddress];
    if (currencyDecimals === void 0) {
      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);
      currencyDecimals = currencyMetadata.decimals;
      cache[currencyAddress] = currencyDecimals;
    }
    return currencyDecimals;
  }
  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {
    let shardNybbles = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : SHARD_NYBBLES;
    const inputs = await parseSnapshotInputs(snapshotInput);
    const shards = {};
    for (const snapshotEntry of inputs) {
      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
      if (shards[shard] === void 0) {
        shards[shard] = [];
      }
      shards[shard].push(snapshotEntry);
    }
    const currencyDecimalMap = {};
    const subTrees = await Promise.all(Object.entries(shards).map(async (_ref) => {
      let [shard, entries] = _ref;
      return [shard, new MerkleTree(await Promise.all(entries.map(async (entry) => {
        const currencyDecimals = await _ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
        return _ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);
      })), utils_exports.keccak256, {
        sort: true
      }).getHexRoot()];
    }));
    const roots = Object.fromEntries(subTrees);
    const tree = new MerkleTree(Object.values(roots), utils_exports.keccak256, {
      sort: true
    });
    const shardsToUpload = [];
    for (const [shardId, entries] of Object.entries(shards)) {
      const data = {
        proofs: tree.getProof(roots[shardId]).map((value) => "0x" + value.data.toString("hex")),
        entries
      };
      shardsToUpload.push({
        data: JSON.stringify(data),
        name: `${shardId}.json`
      });
    }
    const uris = await storage.uploadBatch(shardsToUpload);
    const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
    const originalEntriesUri = await storage.upload(inputs);
    const shardedMerkleInfo = {
      merkleRoot: tree.getHexRoot(),
      baseUri,
      originalEntriesUri,
      shardNybbles,
      tokenDecimals,
      isShardedMerkleTree: true
    };
    const masterUri = await storage.upload(shardedMerkleInfo);
    return {
      shardedMerkleInfo,
      uri: masterUri
    };
  }
  async getProof(address, provider, snapshotFormatVersion) {
    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();
    let shard = this.shards[shardId];
    const currencyDecimalMap = {};
    if (shard === void 0) {
      try {
        const uri = this.baseUri.endsWith("/") ? this.baseUri : `${this.baseUri}/`;
        shard = this.shards[shardId] = await this.storage.downloadJSON(`${uri}${shardId}.json`);
        const hashedEntries = await Promise.all(shard.entries.map(async (entry2) => {
          const currencyDecimals2 = await _ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry2.currencyAddress);
          return _ShardedMerkleTree.hashEntry(entry2, this.tokenDecimals, currencyDecimals2, snapshotFormatVersion);
        }));
        this.trees[shardId] = new MerkleTree(hashedEntries, utils_exports.keccak256, {
          sort: true
        });
      } catch (e) {
        return null;
      }
    }
    const entry = shard.entries.find((i) => i.address.toLowerCase() === address.toLowerCase());
    if (!entry) {
      return null;
    }
    const currencyDecimals = await _ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
    const leaf = _ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);
    const proof = this.trees[shardId].getProof(leaf).map((i) => "0x" + i.data.toString("hex"));
    return SnapshotEntryWithProofSchema.parseAsync({
      ...entry,
      proof: proof.concat(shard.proofs)
    });
  }
  async getAllEntries() {
    try {
      return await this.storage.downloadJSON(this.originalEntriesUri);
    } catch (e) {
      console.warn("Could not fetch original snapshot entries", e);
      return [];
    }
  }
};
async function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw = await storage.downloadJSON(snapshotUri);
    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);
      return await merkleTree.getProof(address, provider, snapshotFormatVersion);
    }
    const snapshotData = await SnapshotSchema.parseAsync(raw);
    if (merkleRoot === snapshotData.merkleRoot) {
      return snapshotData.claims.find((c) => c.address.toLowerCase() === address.toLowerCase()) || null;
    }
  }
  return null;
}
function legacyContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims
  };
}
function newContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerWallet,
    waitTimeInSecondsBetweenClaims: 0,
    metadata: model.metadata
  };
}
async function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {
  const signer = contractToApprove.getSigner();
  const provider = contractToApprove.getProvider();
  const ERC20Abi = (await import("./IERC20-2MDIK7BU.js")).default;
  const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.address;
  const allowance = await erc20.read("allowance", [owner, spender]);
  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils_exports.parseUnits("1", tokenDecimals));
  if (allowance.lt(totalPrice)) {
    await erc20.sendTransaction("approve", [spender, allowance.add(totalPrice)]);
  }
}
async function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {
  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);
  let proofs = [utils_exports.hexZeroPad([0], 32)];
  let priceInProof = activeClaimCondition.price;
  let currencyAddressInProof = activeClaimCondition.currencyAddress;
  try {
    if (!activeClaimCondition.merkleRootHash.toString().startsWith(lib_exports.AddressZero)) {
      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);
      if (snapshotEntry) {
        proofs = snapshotEntry.proof;
        maxClaimable = snapshotEntry.maxClaimable === "unlimited" ? lib_exports.MaxUint256 : utils_exports.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);
        priceInProof = snapshotEntry.price === void 0 || snapshotEntry.price === "unlimited" ? lib_exports.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || lib_exports.AddressZero);
        currencyAddressInProof = snapshotEntry.currencyAddress || lib_exports.AddressZero;
      } else {
        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {
          throw new Error("No claim found for this address");
        }
      }
    }
  } catch (e) {
    if ((e == null ? void 0 : e.message) === "No claim found for this address") {
      throw e;
    }
    console.warn("failed to check claim condition merkle root hash, continuing anyways", e);
  }
  const overrides = await contractWrapper.getCallOverrides() || {};
  const pricePerToken = priceInProof.toString() !== lib_exports.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;
  const currencyAddress = currencyAddressInProof !== lib_exports.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;
  if (pricePerToken.gt(0)) {
    if (isNativeToken(currencyAddress)) {
      overrides["value"] = BigNumber.from(pricePerToken).mul(quantity).div(utils_exports.parseUnits("1", tokenDecimals));
    } else if (checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);
    }
  }
  return {
    overrides,
    proofs,
    maxClaimable,
    price: pricePerToken,
    currencyAddress,
    priceInProof,
    currencyAddressInProof
  };
}
var CurrencySchema = (() => z.object({
  name: z.string(),
  symbol: z.string(),
  decimals: z.number()
}))();
var CurrencyValueSchema = (() => CurrencySchema.extend({
  value: BigNumberSchema,
  displayValue: z.string()
}))();
var ClaimConditionMetadataSchema = (() => z.object({
  name: z.string().optional()
}).catchall(z.unknown()))();
var ClaimConditionInputSchema = (() => z.object({
  startTime: StartDateSchema,
  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),
  price: AmountSchema.default(0),
  maxClaimableSupply: QuantitySchema,
  maxClaimablePerWallet: QuantitySchema,
  waitInSeconds: BigNumberishSchema.default(0),
  merkleRootHash: BytesLikeSchema.default(utils_exports.hexZeroPad([0], 32)),
  snapshot: z.optional(SnapshotInputSchema).nullable(),
  metadata: ClaimConditionMetadataSchema.optional()
}))();
var ClaimConditionInputArray = (() => z.array(ClaimConditionInputSchema))();
var PartialClaimConditionInputSchema = (() => ClaimConditionInputSchema.partial())();
var ClaimConditionOutputSchema = (() => ClaimConditionInputSchema.extend({
  availableSupply: QuantitySchema,
  currentMintSupply: QuantitySchema,
  currencyMetadata: CurrencyValueSchema.default({
    value: BigNumber.from("0"),
    displayValue: "0",
    symbol: "",
    decimals: 18,
    name: ""
  }),
  price: BigNumberSchema,
  waitInSeconds: BigNumberSchema,
  startTime: BigNumberSchema.transform((n) => new Date(n.toNumber() * 1e3)),
  snapshot: SnapshotInputSchema.optional().nullable()
}))();
async function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {
  const input = await parseSnapshotInputs(snapshotInput);
  const addresses = input.map((i) => i.address);
  const hasDuplicates = new Set(addresses).size < addresses.length;
  if (hasDuplicates) {
    throw new DuplicateLeafsError();
  }
  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);
  return {
    merkleRoot: tree.shardedMerkleInfo.merkleRoot,
    snapshotUri: tree.uri
  };
}
async function createMerkleTreeFromAllowList(snapshotInput) {
  let tokenDecimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 18;
  let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SnapshotFormatVersion.V1;
  const input = await parseSnapshotInputs(snapshotInput);
  const addresses = input.map((i) => i.address);
  const hasDuplicates = new Set(addresses).size < addresses.length;
  if (hasDuplicates) {
    throw new DuplicateLeafsError();
  }
  const leaves = input.map((i) => {
    return hashAllowListEntry(i, tokenDecimals, version);
  });
  const tree = new MerkleTree(leaves, utils_exports.keccak256, {
    sort: true
  });
  return tree;
}
async function getProofsForAllowListEntry(merkleTree, snapshotEntry) {
  let tokenDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 18;
  let version = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : SnapshotFormatVersion.V1;
  return merkleTree.getProof(hashAllowListEntry(snapshotEntry, tokenDecimals, version));
}
function hashAllowListEntry(snapshotEntry) {
  let tokenDecimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 18;
  let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SnapshotFormatVersion.V1;
  return ShardedMerkleTree.hashEntry(snapshotEntry, tokenDecimals, tokenDecimals, version);
}
function compare(a, b) {
  const left = BigNumber.from(a);
  const right = BigNumber.from(b);
  if (left.eq(right)) {
    return 0;
  } else if (left.gt(right)) {
    return 1;
  } else {
    return -1;
  }
}
async function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {
  const snapshotInfos = [];
  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async (conditionInput) => {
    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {
      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);
      snapshotInfos.push(snapshotInfo);
      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;
    } else {
      conditionInput.merkleRootHash = utils_exports.hexZeroPad([0], 32);
    }
    return conditionInput;
  }));
  return {
    inputsWithSnapshots,
    snapshotInfos
  };
}
async function convertToContractModel(c, tokenDecimals, provider, storage) {
  const currency = c.currencyAddress === lib_exports.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;
  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);
  let metadataOrUri;
  if (c.metadata) {
    if (typeof c.metadata === "string") {
      metadataOrUri = c.metadata;
    } else {
      metadataOrUri = await storage.upload(c.metadata);
    }
  }
  return {
    startTimestamp: c.startTime,
    maxClaimableSupply,
    supplyClaimed: 0,
    maxClaimablePerWallet,
    pricePerToken: await normalizePriceValue(provider, c.price, currency),
    currency,
    merkleRoot: c.merkleRootHash.toString(),
    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,
    metadata: metadataOrUri
  };
}
async function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {
  const {
    inputsWithSnapshots,
    snapshotInfos
  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);
  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);
  const sortedConditions = (await Promise.all(parsedInputs.map((c) => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {
    return compare(a.startTimestamp, b.startTimestamp);
  });
  return {
    snapshotInfos,
    sortedConditions
  };
}
async function fetchSnapshot(merkleRoot, merkleMetadata, storage) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw = await storage.downloadJSON(snapshotUri);
    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);
      return (smt == null ? void 0 : smt.getAllEntries()) || null;
    } else {
      const snapshotData = await SnapshotSchema.parseAsync(raw);
      if (merkleRoot === snapshotData.merkleRoot) {
        return snapshotData.claims.map((claim) => ({
          address: claim.address,
          maxClaimable: claim.maxClaimable,
          price: claim.price,
          currencyAddress: claim.currencyAddress
        }));
      }
    }
  }
  return null;
}
function convertToReadableQuantity(bn, tokenDecimals) {
  if (bn.toString() === lib_exports.MaxUint256.toString()) {
    return "unlimited";
  } else {
    return utils_exports.formatUnits(bn, tokenDecimals);
  }
}
async function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {
  var _a;
  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);
  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);
  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);
  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);
  let resolvedMetadata;
  if (pm.metadata) {
    resolvedMetadata = await storage.downloadJSON(pm.metadata);
  }
  return ClaimConditionOutputSchema.parseAsync({
    startTime: pm.startTimestamp,
    maxClaimableSupply,
    maxClaimablePerWallet,
    currentMintSupply,
    availableSupply,
    waitInSeconds: (_a = pm.waitTimeInSecondsBetweenClaims) == null ? void 0 : _a.toString(),
    price: BigNumber.from(pm.pricePerToken),
    currency: pm.currency,
    currencyAddress: pm.currency,
    currencyMetadata: cv,
    merkleRootHash: pm.merkleRoot,
    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : void 0,
    metadata: resolvedMetadata
  });
}
async function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {
  if (index >= existingConditions.length) {
    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);
  }
  const priceDecimals = existingConditions[index].currencyMetadata.decimals;
  const priceInWei = existingConditions[index].price;
  const priceInTokens = utils_exports.formatUnits(priceInWei, priceDecimals);
  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({
    ...existingConditions[index],
    price: priceInTokens,
    ...claimConditionInput
  });
  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({
    ...newConditionParsed,
    price: priceInWei
  });
  return existingConditions.map((existingOutput, i) => {
    let newConditionAtIndex;
    if (i === index) {
      newConditionAtIndex = mergedConditionOutput;
    } else {
      newConditionAtIndex = existingOutput;
    }
    const formattedPrice = utils_exports.formatUnits(newConditionAtIndex.price, priceDecimals);
    return {
      ...newConditionAtIndex,
      price: formattedPrice
      // manually transform back to input price type
    };
  });
}
var ClaimEligibility = function(ClaimEligibility2) {
  ClaimEligibility2["NotEnoughSupply"] = "There is not enough supply to claim.";
  ClaimEligibility2["AddressNotAllowed"] = "This address is not on the allowlist.";
  ClaimEligibility2["WaitBeforeNextClaimTransaction"] = "Not enough time since last claim transaction. Please wait.";
  ClaimEligibility2["ClaimPhaseNotStarted"] = "Claim phase has not started yet.";
  ClaimEligibility2["AlreadyClaimed"] = "You have already claimed the token.";
  ClaimEligibility2["WrongPriceOrCurrency"] = "Incorrect price or currency.";
  ClaimEligibility2["OverMaxClaimablePerWallet"] = "Cannot claim more than maximum allowed quantity.";
  ClaimEligibility2["NotEnoughTokens"] = "There are not enough tokens in the wallet to pay for the claim.";
  ClaimEligibility2["NoActiveClaimPhase"] = "There is no active claim phase at the moment. Please check back in later.";
  ClaimEligibility2["NoClaimConditionSet"] = "There is no claim condition set.";
  ClaimEligibility2["NoWallet"] = "No wallet connected.";
  ClaimEligibility2["Unknown"] = "No claim conditions found.";
  return ClaimEligibility2;
}({});
function resolveOrGenerateId(requestUId) {
  if (requestUId === void 0) {
    const buffer = Buffer.alloc(16);
    v4_default({}, buffer);
    return utils_exports.hexlify(utils_exports.toUtf8Bytes(buffer.toString("hex")));
  } else {
    return utils_exports.hexlify(requestUId);
  }
}
var BaseSignaturePayloadInput = (() => z.object({
  to: AddressOrEnsSchema.refine((address) => address.toLowerCase() !== lib_exports.AddressZero, {
    message: "Cannot create payload to mint to zero address"
  }),
  price: AmountSchema.default(0),
  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),
  mintStartTime: StartDateSchema,
  mintEndTime: EndDateSchema,
  uid: z.string().optional().transform((arg) => resolveOrGenerateId(arg)),
  primarySaleRecipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var Signature20PayloadInput = (() => BaseSignaturePayloadInput.extend({
  quantity: AmountSchema
}))();
var Signature20PayloadOutput = (() => Signature20PayloadInput.extend({
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
}))();
var Signature721PayloadInput = (() => BaseSignaturePayloadInput.extend({
  metadata: NFTInputOrUriSchema,
  royaltyRecipient: z.string().default(lib_exports.AddressZero),
  royaltyBps: BasisPointsSchema.default(0)
}))();
var Signature721PayloadOutput = (() => Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  uri: z.string(),
  royaltyBps: BigNumberSchema,
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
}))();
var Signature1155PayloadInput = (() => Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberishSchema
}))();
var Signature1155PayloadInputWithTokenId = (() => Signature1155PayloadInput.extend({
  tokenId: BigNumberishSchema
}))();
var Signature1155PayloadOutput = (() => Signature721PayloadOutput.extend({
  tokenId: BigNumberSchema,
  quantity: BigNumberSchema
}))();
var Signature721WithQuantityInput = (() => Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberSchema.default(1)
}))();
var Signature721WithQuantityOutput = (() => Signature721PayloadOutput.extend({
  quantity: BigNumberSchema.default(1)
}))();
var MintRequest20 = [{
  name: "to",
  type: "address"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest721 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest1155 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "tokenId",
  type: "uint256"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest721withQuantity = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var GenericRequest = [{
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}, {
  name: "data",
  type: "bytes"
}];

export {
  abstractContractModelToLegacy,
  abstractContractModelToNew,
  convertQuantityToBigNumber,
  SnapshotFormatVersion,
  fetchSnapshotEntryForAddress,
  legacyContractModelToAbstract,
  newContractModelToAbstract,
  approveErc20Allowance,
  prepareClaim,
  CurrencySchema,
  CurrencyValueSchema,
  ClaimConditionMetadataSchema,
  ClaimConditionInputSchema,
  ClaimConditionInputArray,
  PartialClaimConditionInputSchema,
  ClaimConditionOutputSchema,
  createSnapshot,
  createMerkleTreeFromAllowList,
  getProofsForAllowListEntry,
  hashAllowListEntry,
  processClaimConditionInputs,
  convertToReadableQuantity,
  transformResultToClaimCondition,
  updateExistingClaimConditions,
  ClaimEligibility,
  resolveOrGenerateId,
  BaseSignaturePayloadInput,
  Signature20PayloadInput,
  Signature20PayloadOutput,
  Signature721PayloadInput,
  Signature721PayloadOutput,
  Signature1155PayloadInput,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput,
  MintRequest20,
  MintRequest721,
  MintRequest1155,
  MintRequest721withQuantity,
  GenericRequest
};
//# sourceMappingURL=chunk-EG3CND37.js.map
