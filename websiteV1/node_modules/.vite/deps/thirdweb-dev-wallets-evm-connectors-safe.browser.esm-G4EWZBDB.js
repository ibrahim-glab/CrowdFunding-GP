import {
  require_js,
  require_readable_browser,
  require_satisfies,
  require_sha,
  require_string_decoder
} from "./chunk-SAKNM6JN.js";
import {
  require_safe_buffer
} from "./chunk-P3UYPI43.js";
import {
  require_assert,
  require_http,
  require_https,
  require_zlib
} from "./chunk-SIOUFKDP.js";
import {
  require_stream,
  require_util
} from "./chunk-FBLZXRPC.js";
import {
  require_url
} from "./chunk-S4HIJLSF.js";
import "./chunk-Y7WACQDY.js";
import {
  Connector
} from "./chunk-7ZKPRNKP.js";
import {
  _defineProperty
} from "./chunk-YUOLCEGR.js";
import "./chunk-LYEG5PGG.js";
import {
  require_crypto
} from "./chunk-Y2LWIENH.js";
import {
  require_events
} from "./chunk-GPX5XOM5.js";
import {
  require_buffer as require_buffer2
} from "./chunk-OP3MHZRI.js";
import {
  ethers_exports,
  init_lib as init_lib9,
  lib_exports as lib_exports9
} from "./chunk-I3BLH5LU.js";
import "./chunk-MFKPCOBF.js";
import {
  require_utils
} from "./chunk-VZ6GM6HX.js";
import {
  init_lib as init_lib5,
  init_lib6 as init_lib8,
  lib_exports as lib_exports5,
  lib_exports5 as lib_exports8
} from "./chunk-QDKWUOME.js";
import {
  init_lib11 as init_lib4,
  init_lib13 as init_lib6,
  init_lib19 as init_lib7,
  init_lib2 as init_lib,
  init_lib3 as init_lib2,
  init_lib7 as init_lib3,
  lib_exports11 as lib_exports4,
  lib_exports12 as lib_exports6,
  lib_exports18 as lib_exports7,
  lib_exports2 as lib_exports,
  lib_exports3 as lib_exports2,
  lib_exports7 as lib_exports3,
  require_hash,
  require_minimalistic_assert,
  require_sha3
} from "./chunk-3JDV7GMI.js";
import {
  require_bn,
  require_buffer
} from "./chunk-JVFNGTH2.js";
import {
  require_inherits_browser
} from "./chunk-UFR7PFM3.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = /* @__PURE__ */ function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = /* @__PURE__ */ function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/axios/lib/core/AxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module.exports = AxiosError;
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/axios/lib/helpers/toFormData.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module.exports = toFormData;
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var AxiosError = require_AxiosError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/axios/lib/cancel/CanceledError.js"(exports, module) {
    "use strict";
    var AxiosError = require_AxiosError();
    var utils = require_utils2();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module.exports = CanceledError;
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/axios/lib/helpers/parseProtocol.js"(exports, module) {
    "use strict";
    module.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/helpers/null.js
var require_null = __commonJS({
  "node_modules/axios/lib/helpers/null.js"(exports, module) {
    module.exports = null;
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_null()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.CanceledError = require_CanceledError();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.toFormData = require_toFormData();
    axios.AxiosError = require_AxiosError();
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/service.js
var require_service = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/service.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeService = void 0;
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var axios_1 = __importDefault(require_axios2());
    var SafeService2 = class {
      constructor(serviceUrl, network) {
        this.serviceUrl = serviceUrl;
        this.network = network !== null && network !== void 0 ? network : axios_1.default;
      }
      /**
       * Estimates a Safe transaction
       *
       * @param safe - Address of the Safe for which this transaction should be estimated
       * @param safeTx - Safe transaction that should be estimated for execution
       * @returns A big number representing the safeTxGas for the passed Safe transaction
       */
      async estimateSafeTx(safe, safeTx) {
        const url = `${this.serviceUrl}/api/v1/safes/${safe}/multisig-transactions/estimations/`;
        const resp = await this.network.post(url, safeTx);
        return bignumber_1.BigNumber.from(resp.data.safeTxGas);
      }
      /**
       * Load details for a Safe transaction
       *
       * @param safeTxHash - Hash of the Safe transaction
       * @returns A `SafeTxDetails` object that contains the details of a Safe transaction
       */
      async getSafeTxDetails(safeTxHash) {
        const url = `${this.serviceUrl}/api/v1/multisig-transactions/${safeTxHash}`;
        const resp = await this.network.get(url);
        return resp.data;
      }
      /**
       * Propose a new Safe transaction to the service
       *
       * @param safeAddress - Address of the Safe for which this transaction should be proposed
       * @param safeTxHash - Hash of the Safe transaction
       * @param safeTx - Safe transaction that should be proposed
       * @param signature - Signature of an owner or a delegate of an owner of the specified Safe to authorize the proposal
       * @returns The hash of the Safe transaction that has been proposed
       */
      async proposeTx(safeAddress, safeTxHash, safeTx, signature) {
        const url = `${this.serviceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/`;
        const data = {
          ...safeTx.data,
          contractTransactionHash: safeTxHash,
          sender: signature.signer,
          signature: signature.data
        };
        const resp = await this.network.post(url, data);
        return resp.data;
      }
    };
    exports.SafeService = SafeService2;
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CompatibilityFallbackHandlerContract.js
var require_CompatibilityFallbackHandlerContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CompatibilityFallbackHandlerContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CreateCallContract.js
var require_CreateCallContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CreateCallContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeContract.js
var require_GnosisSafeContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeProxyFactoryContract.js
var require_GnosisSafeProxyFactoryContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeProxyFactoryContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendCallOnlyContract.js
var require_MultiSendCallOnlyContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendCallOnlyContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendContract.js
var require_MultiSendContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/SignMessageLibContract.js
var require_SignMessageLibContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/SignMessageLibContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/ethereumLibs/EthAdapter.js
var require_EthAdapter = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/ethereumLibs/EthAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/types.js
var require_types = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperationType = void 0;
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["Call"] = 0] = "Call";
      OperationType2[OperationType2["DelegateCall"] = 1] = "DelegateCall";
    })(OperationType = exports.OperationType || (exports.OperationType = {}));
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CompatibilityFallbackHandlerContract(), exports);
    __exportStar(require_CreateCallContract(), exports);
    __exportStar(require_GnosisSafeContract(), exports);
    __exportStar(require_GnosisSafeProxyFactoryContract(), exports);
    __exportStar(require_MultiSendCallOnlyContract(), exports);
    __exportStar(require_MultiSendContract(), exports);
    __exportStar(require_SignMessageLibContract(), exports);
    __exportStar(require_EthAdapter(), exports);
    __exportStar(require_types(), exports);
  }
});

// node_modules/@safe-global/safe-deployments/dist/types.js
var require_types2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_l2.json
var require_safe_l2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_l2.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
      released: true,
      contractName: "SafeL2",
      version: "1.4.1",
      networkAddresses: {
        "1": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "5": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "10": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "56": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "71": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "97": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "100": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "137": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "1030": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "1101": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "1442": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "4337": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "8192": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "8194": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "8453": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "10243": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "11235": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "13337": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "17000": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "42161": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "42220": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "54211": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "80001": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "84531": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "84532": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
        "11155111": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "SafeModuleTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "additionalInfo",
              type: "bytes"
            }
          ],
          name: "SafeMultiSigTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe.json
var require_safe = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x41675C099F32341bf84BFc5382aF534df5C7461a",
      released: true,
      contractName: "Safe",
      version: "1.4.1",
      networkAddresses: {
        "1": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "5": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "10": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "56": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "71": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "97": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "100": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "137": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "1030": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "1101": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "1442": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "4337": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "8192": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "8194": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "8453": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "10243": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "11235": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "13337": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "17000": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "42161": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "42220": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "54211": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "80001": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "84531": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "84532": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
        "11155111": "0x41675C099F32341bf84BFc5382aF534df5C7461a"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe_l2.json
var require_gnosis_safe_l2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe_l2.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
      released: true,
      contractName: "GnosisSafeL2",
      version: "1.3.0",
      networkAddresses: {
        "1": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "3": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "4": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "5": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "10": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "11": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "12": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "18": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "25": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "28": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "30": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "31": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "39": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "40": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "41": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "42": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "44": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "46": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "50": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "51": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "56": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "57": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "61": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "63": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "69": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "71": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "81": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "82": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "83": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "97": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "100": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "106": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "108": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "109": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "111": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "122": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "123": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "137": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "148": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "155": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "169": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "204": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "246": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "250": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "255": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "280": "0x1727c2c531cf966f902E5927b98490fDFb3b2b70",
        "288": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "291": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "300": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "321": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "322": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "324": "0x1727c2c531cf966f902E5927b98490fDFb3b2b70",
        "336": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "338": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "420": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "424": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "570": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "588": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "592": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "595": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "599": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "686": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "787": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "919": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1030": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1088": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1101": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1111": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1112": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1115": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1116": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1230": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1231": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1284": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1285": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1287": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1294": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1442": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1559": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1663": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1807": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1890": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1891": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1984": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1998": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2001": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2002": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2019": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2020": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2021": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2221": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2222": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "2358": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "3737": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "4002": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "4337": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "4460": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "4689": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "4918": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "4919": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "5000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "5001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "5003": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "5700": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "6102": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "7001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "7332": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "7341": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "7700": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "8192": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "8194": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "8217": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "8453": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "9000": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "9001": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "9728": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "10000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "10001": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "10081": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "10200": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "10243": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "11235": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "11437": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "11891": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "12357": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "13337": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "17000": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "17172": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "18231": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "23294": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "23295": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "34443": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "42161": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "42170": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "42220": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "43113": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "43114": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "43288": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "44787": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "45000": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "47805": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "54211": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "56288": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "57000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "58008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "59140": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "59144": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "71401": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "71402": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "73799": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "80001": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "80085": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "84531": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "84532": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "167008": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "200101": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "200202": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "333999": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "421611": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "421613": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "421614": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "534351": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "534352": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "534353": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "622277": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "713715": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "7777777": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "11155111": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "11155420": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "222000222": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "245022926": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "245022934": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "333000333": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "999999999": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1313161554": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1313161555": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "1666600000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "1666700000": "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
        "11297108099": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
        "11297108109": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "SafeModuleTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "additionalInfo",
              type: "bytes"
            }
          ],
          name: "SafeMultiSigTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe.json
var require_gnosis_safe = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
      released: true,
      contractName: "GnosisSafe",
      version: "1.3.0",
      networkAddresses: {
        "1": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "3": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "4": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "5": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "10": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "11": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "12": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "18": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "25": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "28": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "30": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "31": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "39": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "40": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "41": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "42": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "44": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "46": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "50": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "51": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "56": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "57": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "61": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "63": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "69": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "71": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "81": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "82": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "83": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "97": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "100": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "106": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "108": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "109": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "111": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "122": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "123": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "137": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "148": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "155": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "169": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "204": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "246": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "250": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "255": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "280": "0xB00ce5CCcdEf57e539ddcEd01DF43a13855d9910",
        "288": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "291": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "300": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "321": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "322": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "324": "0xB00ce5CCcdEf57e539ddcEd01DF43a13855d9910",
        "336": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "338": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "420": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "424": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "570": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "588": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "592": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "595": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "599": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "686": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "787": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "919": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1030": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1088": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1101": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1111": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1112": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1115": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1116": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1230": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1231": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1284": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1285": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1287": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1294": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1442": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1559": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1663": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1807": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1890": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1891": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1984": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1998": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2001": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2002": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2019": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2020": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2021": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2221": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2222": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "2358": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "3737": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "4002": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "4337": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "4460": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "4689": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "4918": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "4919": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "5000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "5001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "5003": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "5700": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "6102": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "7001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "7332": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "7341": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "7700": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "8192": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "8194": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "8217": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "8453": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "9000": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "9001": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "9728": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "10000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "10001": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "10081": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "10200": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "10243": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "11235": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "11437": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "11891": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "12357": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "13337": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "17000": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "17172": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "18231": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "23294": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "23295": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "34443": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "42161": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "42170": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "42220": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "43113": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "43114": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "43288": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "44787": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "45000": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "47805": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "54211": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "56288": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "57000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "58008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "59140": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "59144": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "71401": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "71402": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "73799": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "80001": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "80085": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "84531": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "84532": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "167008": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "200101": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "200202": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "333999": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "421611": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "421613": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "421614": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "534351": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "534352": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "534353": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "622277": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "713715": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "7777777": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "11155111": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "11155420": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "222000222": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "245022926": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "245022934": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "333000333": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "999999999": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1313161554": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1313161555": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "1666600000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "1666700000": "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
        "11297108099": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        "11297108109": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.2.0/gnosis_safe.json
var require_gnosis_safe2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.2.0/gnosis_safe.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
      released: true,
      contractName: "GnosisSafe",
      version: "1.2.0",
      networkAddresses: {
        "1": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "4": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "5": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "42": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "88": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "100": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "246": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
        "73799": "0x6851D6fDFAfD08c0295C392436245E5bc78B0185"
      },
      abi: [
        {
          inputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "masterCopy",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          payable: true,
          stateMutability: "payable",
          type: "fallback"
        },
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_masterCopy",
              type: "address"
            }
          ],
          name: "changeMasterCopy",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: true,
          stateMutability: "payable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/gnosis_safe.json
var require_gnosis_safe3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/gnosis_safe.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
      released: true,
      contractName: "GnosisSafe",
      version: "1.1.1",
      networkAddresses: {
        "1": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "4": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "5": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "42": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "88": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "100": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "246": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        "73799": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F"
      },
      abi: [
        {
          inputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "masterCopy",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          payable: true,
          stateMutability: "payable",
          type: "fallback"
        },
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_masterCopy",
              type: "address"
            }
          ],
          name: "changeMasterCopy",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/gnosis_safe.json
var require_gnosis_safe4 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/gnosis_safe.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
      released: true,
      contractName: "GnosisSafe",
      version: "1.0.0",
      networkAddresses: {
        "1": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
        "4": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
        "5": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
        "42": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
        "100": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A"
      },
      abi: [
        {
          constant: false,
          inputs: [
            { name: "owner", type: "address" },
            { name: "_threshold", type: "uint256" }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "DOMAIN_SEPARATOR_TYPEHASH",
          outputs: [{ name: "", type: "bytes32" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [{ name: "owner", type: "address" }],
          name: "isOwner",
          outputs: [{ name: "", type: "bool" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "to", type: "address" },
            { name: "value", type: "uint256" },
            { name: "data", type: "bytes" },
            { name: "operation", type: "uint8" }
          ],
          name: "execTransactionFromModule",
          outputs: [{ name: "success", type: "bool" }],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [{ name: "", type: "bytes32" }],
          name: "signedMessages",
          outputs: [{ name: "", type: "uint256" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [{ name: "module", type: "address" }],
          name: "enableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [{ name: "_threshold", type: "uint256" }],
          name: "changeThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            { name: "", type: "address" },
            { name: "", type: "bytes32" }
          ],
          name: "approvedHashes",
          outputs: [{ name: "", type: "uint256" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [{ name: "_masterCopy", type: "address" }],
          name: "changeMasterCopy",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SENTINEL_MODULES",
          outputs: [{ name: "", type: "address" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SENTINEL_OWNERS",
          outputs: [{ name: "", type: "address" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getOwners",
          outputs: [{ name: "", type: "address[]" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [{ name: "", type: "string" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "nonce",
          outputs: [{ name: "", type: "uint256" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getModules",
          outputs: [{ name: "", type: "address[]" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SAFE_MSG_TYPEHASH",
          outputs: [{ name: "", type: "bytes32" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SAFE_TX_TYPEHASH",
          outputs: [{ name: "", type: "bytes32" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "prevModule", type: "address" },
            { name: "module", type: "address" }
          ],
          name: "disableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "prevOwner", type: "address" },
            { name: "oldOwner", type: "address" },
            { name: "newOwner", type: "address" }
          ],
          name: "swapOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getThreshold",
          outputs: [{ name: "", type: "uint256" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "domainSeparator",
          outputs: [{ name: "", type: "bytes32" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "prevOwner", type: "address" },
            { name: "owner", type: "address" },
            { name: "_threshold", type: "uint256" }
          ],
          name: "removeOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [{ name: "", type: "string" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        { payable: true, stateMutability: "payable", type: "fallback" },
        {
          anonymous: false,
          inputs: [{ indexed: false, name: "txHash", type: "bytes32" }],
          name: "ExecutionFailed",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [{ indexed: false, name: "owner", type: "address" }],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [{ indexed: false, name: "owner", type: "address" }],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [{ indexed: false, name: "threshold", type: "uint256" }],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [{ indexed: false, name: "module", type: "address" }],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [{ indexed: false, name: "module", type: "address" }],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            { indexed: false, name: "newContract", type: "address" }
          ],
          name: "ContractCreation",
          type: "event"
        },
        {
          constant: false,
          inputs: [
            { name: "_owners", type: "address[]" },
            { name: "_threshold", type: "uint256" },
            { name: "to", type: "address" },
            { name: "data", type: "bytes" },
            { name: "paymentToken", type: "address" },
            { name: "payment", type: "uint256" },
            { name: "paymentReceiver", type: "address" }
          ],
          name: "setup",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "to", type: "address" },
            { name: "value", type: "uint256" },
            { name: "data", type: "bytes" },
            { name: "operation", type: "uint8" },
            { name: "safeTxGas", type: "uint256" },
            { name: "baseGas", type: "uint256" },
            { name: "gasPrice", type: "uint256" },
            { name: "gasToken", type: "address" },
            { name: "refundReceiver", type: "address" },
            { name: "signatures", type: "bytes" }
          ],
          name: "execTransaction",
          outputs: [{ name: "success", type: "bool" }],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "to", type: "address" },
            { name: "value", type: "uint256" },
            { name: "data", type: "bytes" },
            { name: "operation", type: "uint8" }
          ],
          name: "requiredTxGas",
          outputs: [{ name: "", type: "uint256" }],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [{ name: "hashToApprove", type: "bytes32" }],
          name: "approveHash",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [{ name: "_data", type: "bytes" }],
          name: "signMessage",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            { name: "_data", type: "bytes" },
            { name: "_signature", type: "bytes" }
          ],
          name: "isValidSignature",
          outputs: [{ name: "", type: "bytes4" }],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [{ name: "message", type: "bytes" }],
          name: "getMessageHash",
          outputs: [{ name: "", type: "bytes32" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            { name: "to", type: "address" },
            { name: "value", type: "uint256" },
            { name: "data", type: "bytes" },
            { name: "operation", type: "uint8" },
            { name: "safeTxGas", type: "uint256" },
            { name: "baseGas", type: "uint256" },
            { name: "gasPrice", type: "uint256" },
            { name: "gasToken", type: "address" },
            { name: "refundReceiver", type: "address" },
            { name: "_nonce", type: "uint256" }
          ],
          name: "encodeTransactionData",
          outputs: [{ name: "", type: "bytes" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            { name: "to", type: "address" },
            { name: "value", type: "uint256" },
            { name: "data", type: "bytes" },
            { name: "operation", type: "uint8" },
            { name: "safeTxGas", type: "uint256" },
            { name: "baseGas", type: "uint256" },
            { name: "gasPrice", type: "uint256" },
            { name: "gasToken", type: "address" },
            { name: "refundReceiver", type: "address" },
            { name: "_nonce", type: "uint256" }
          ],
          name: "getTransactionHash",
          outputs: [{ name: "", type: "bytes32" }],
          payable: false,
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findDeployment = void 0;
    var satisfies_1 = __importDefault(require_satisfies());
    var DEFAULT_FILTER = { released: true };
    var findDeployment = (criteria = DEFAULT_FILTER, deployments) => {
      const criteriaWithDefaults = Object.assign(Object.assign({}, DEFAULT_FILTER), criteria);
      return deployments.find((deployment) => {
        if (typeof criteriaWithDefaults.version !== "undefined" && !(0, satisfies_1.default)(deployment.version, criteriaWithDefaults.version))
          return false;
        if (typeof criteriaWithDefaults.released === "boolean" && deployment.released != criteriaWithDefaults.released)
          return false;
        if (criteriaWithDefaults.network && !deployment.networkAddresses[criteriaWithDefaults.network])
          return false;
        return true;
      });
    };
    exports.findDeployment = findDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/safes.js
var require_safes = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/safes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSafeL2SingletonDeployment = exports._safeL2Deployments = exports.getSafeSingletonDeployment = exports._safeDeployments = void 0;
    var safe_l2_json_1 = __importDefault(require_safe_l2());
    var safe_json_1 = __importDefault(require_safe());
    var gnosis_safe_l2_json_1 = __importDefault(require_gnosis_safe_l2());
    var gnosis_safe_json_1 = __importDefault(require_gnosis_safe());
    var gnosis_safe_json_2 = __importDefault(require_gnosis_safe2());
    var gnosis_safe_json_3 = __importDefault(require_gnosis_safe3());
    var gnosis_safe_json_4 = __importDefault(require_gnosis_safe4());
    var utils_1 = require_utils3();
    exports._safeDeployments = [
      safe_json_1.default,
      gnosis_safe_json_1.default,
      gnosis_safe_json_2.default,
      gnosis_safe_json_3.default,
      gnosis_safe_json_4.default
    ];
    var getSafeSingletonDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, exports._safeDeployments);
    };
    exports.getSafeSingletonDeployment = getSafeSingletonDeployment;
    exports._safeL2Deployments = [
      safe_l2_json_1.default,
      gnosis_safe_l2_json_1.default
    ];
    var getSafeL2SingletonDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, exports._safeL2Deployments);
    };
    exports.getSafeL2SingletonDeployment = getSafeL2SingletonDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/proxy_factory.json
var require_proxy_factory = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/proxy_factory.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
      released: true,
      contractName: "ProxyFactory",
      version: "1.0.0",
      networkAddresses: {
        "1": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
        "4": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
        "5": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
        "42": "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
        "100": "0x12302fE9c02ff50939BaAaaf415fc226C078613C"
      },
      abi: [
        {
          constant: false,
          inputs: [
            {
              name: "_mastercopy",
              type: "address"
            },
            {
              name: "initializer",
              type: "bytes"
            },
            {
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "masterCopy",
              type: "address"
            },
            {
              name: "data",
              type: "bytes"
            }
          ],
          name: "createProxy",
          outputs: [
            {
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyRuntimeCode",
          outputs: [
            {
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "proxy",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/proxy_factory.json
var require_proxy_factory2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/proxy_factory.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
      released: true,
      contractName: "ProxyFactory",
      version: "1.1.1",
      networkAddresses: {
        "1": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "4": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "5": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "42": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "88": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "100": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "246": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "73799": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "masterCopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          name: "createProxy",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyRuntimeCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_mastercopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_mastercopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            },
            {
              internalType: "contract IProxyCreationCallback",
              name: "callback",
              type: "address"
            }
          ],
          name: "createProxyWithCallback",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_mastercopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "calculateCreateProxyWithNonceAddress",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/proxy_factory.json
var require_proxy_factory3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/proxy_factory.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
      released: true,
      contractName: "GnosisSafeProxyFactory",
      version: "1.3.0",
      networkAddresses: {
        "1": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "3": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "4": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "5": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "10": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "11": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "12": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "18": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "25": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "28": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "30": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "31": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "39": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "40": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "41": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "42": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "44": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "46": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "50": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "51": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "56": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "57": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "61": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "63": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "69": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "71": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "81": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "82": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "83": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "97": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "100": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "106": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "108": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "109": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "111": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "122": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "123": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "137": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "148": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "155": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "169": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "204": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "246": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "250": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "255": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "280": "0xDAec33641865E4651fB43181C6DB6f7232Ee91c2",
        "288": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "291": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "300": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "321": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "322": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "324": "0xDAec33641865E4651fB43181C6DB6f7232Ee91c2",
        "336": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "338": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "420": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "424": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "570": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "588": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "592": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "595": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "599": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "686": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "787": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "919": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1030": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1088": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1101": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1111": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1112": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1115": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1116": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1230": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1231": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1284": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1285": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1287": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1294": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1442": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1559": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1663": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1807": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1890": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1891": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1984": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1998": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2001": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2002": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2019": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2020": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2021": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2221": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2222": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "2358": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "3737": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "4002": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "4337": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "4460": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "4689": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "4918": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "4919": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "5000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "5001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "5003": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "5700": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "6102": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "7001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "7332": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "7341": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "7700": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "8192": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "8194": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "8217": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "8453": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "9000": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "9001": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "9728": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "10000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "10001": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "10081": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "10200": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "10243": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "11235": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "11437": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "11891": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "12357": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "13337": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "17000": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "17172": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "18231": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "23294": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "23295": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "34443": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "42161": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "42170": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "42220": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "43113": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "43114": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "43288": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "44787": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "45000": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "47805": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "54211": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "56288": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "57000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "58008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "59140": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "59144": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "71401": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "71402": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "73799": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "80001": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "80085": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "84531": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "84532": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "167008": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "200101": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "200202": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "333999": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "421611": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "421613": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "421614": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "534351": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "534352": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "534353": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "622277": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "713715": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "7777777": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "11155111": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "11155420": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "222000222": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "245022926": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "245022934": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "333000333": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "999999999": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1313161554": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1313161555": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "1666600000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "1666700000": "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
        "11297108099": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
        "11297108109": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "calculateCreateProxyWithNonceAddress",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          name: "createProxy",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            },
            {
              internalType: "contract IProxyCreationCallback",
              name: "callback",
              type: "address"
            }
          ],
          name: "createProxyWithCallback",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [],
          name: "proxyRuntimeCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_proxy_factory.json
var require_safe_proxy_factory = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_proxy_factory.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
      contractName: "SafeProxyFactory",
      version: "1.4.1",
      released: true,
      networkAddresses: {
        "1": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "5": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "10": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "56": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "71": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "97": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "100": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "137": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "1030": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "1101": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "1442": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "4337": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "8192": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "8194": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "8453": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "10243": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "11235": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "13337": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "17000": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "42161": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "42220": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "54211": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "80001": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "84531": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "84532": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
        "11155111": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createChainSpecificProxyWithNonce",
          outputs: [
            {
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            },
            {
              internalType: "contract IProxyCreationCallback",
              name: "callback",
              type: "address"
            }
          ],
          name: "createProxyWithCallback",
          outputs: [
            {
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/factories.js
var require_factories = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/factories.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProxyFactoryDeployment = void 0;
    var proxy_factory_json_1 = __importDefault(require_proxy_factory());
    var proxy_factory_json_2 = __importDefault(require_proxy_factory2());
    var proxy_factory_json_3 = __importDefault(require_proxy_factory3());
    var safe_proxy_factory_json_1 = __importDefault(require_safe_proxy_factory());
    var utils_1 = require_utils3();
    var factoryDeployments = [
      safe_proxy_factory_json_1.default,
      proxy_factory_json_3.default,
      proxy_factory_json_2.default,
      proxy_factory_json_1.default
    ];
    var getProxyFactoryDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, factoryDeployments);
    };
    exports.getProxyFactoryDeployment = getProxyFactoryDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/create_call.json
var require_create_call = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/create_call.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
      released: true,
      contractName: "CreateCall",
      version: "1.3.0",
      networkAddresses: {
        "1": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "3": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "4": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "5": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "10": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "11": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "12": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "18": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "25": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "28": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "30": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "31": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "39": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "40": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "41": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "42": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "44": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "46": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "50": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "51": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "56": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "57": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "61": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "63": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "69": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "71": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "81": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "82": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "83": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "97": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "100": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "106": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "108": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "109": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "111": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "122": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "123": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "137": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "148": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "155": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "169": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "204": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "246": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "250": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "255": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "280": "0xcB8e5E438c5c2b45FbE17B02Ca9aF91509a8ad56",
        "288": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "291": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "300": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "321": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "322": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "324": "0xcB8e5E438c5c2b45FbE17B02Ca9aF91509a8ad56",
        "336": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "338": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "420": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "424": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "570": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "588": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "592": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "595": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "599": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "686": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "787": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "919": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1030": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1088": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1101": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1111": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1112": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1115": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1116": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1230": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1231": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1284": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1285": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1287": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1294": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1442": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1559": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1663": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1807": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1890": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1891": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1984": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1998": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2001": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2002": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2019": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2020": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2021": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2221": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2222": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "2358": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "3737": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "4002": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "4337": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "4460": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "4689": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "4918": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "4919": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "5000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "5001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "5003": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "5700": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "6102": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "7001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "7332": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "7341": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "7700": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "8192": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "8194": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "8217": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "8453": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "9000": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "9001": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "9728": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "10000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "10001": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "10081": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "10200": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "10243": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "11235": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "11437": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "11891": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "12357": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "13337": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "17000": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "17172": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "18231": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "23294": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "23295": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "34443": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "42161": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "42170": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "42220": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "43113": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "43114": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "43288": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "44787": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "45000": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "47805": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "54211": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "56288": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "57000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "58008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "59140": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "59144": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "71401": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "71402": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "73799": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "80001": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "80085": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "84531": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "84532": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "167008": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "200101": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "200202": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "333999": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "421611": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "421613": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "421614": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "534351": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "534352": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "534353": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "622277": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "713715": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "7777777": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "11155111": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "11155420": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "222000222": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "245022926": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "245022934": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "333000333": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "999999999": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1313161554": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1313161555": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "1666600000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "1666700000": "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
        "11297108099": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
        "11297108109": "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          name: "ContractCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            }
          ],
          name: "performCreate",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            },
            {
              internalType: "bytes32",
              name: "salt",
              type: "bytes32"
            }
          ],
          name: "performCreate2",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/create_call.json
var require_create_call2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/create_call.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
      released: true,
      contractName: "CreateCall",
      version: "1.4.1",
      networkAddresses: {
        "1": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "5": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "10": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "56": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "71": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "97": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "100": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "137": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "1030": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "1101": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "1442": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "4337": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "8192": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "8194": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "8453": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "10243": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "11235": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "13337": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "17000": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "42161": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "42220": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "54211": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "80001": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "84531": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "84532": "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
        "11155111": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          name: "ContractCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            }
          ],
          name: "performCreate",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            },
            {
              internalType: "bytes32",
              name: "salt",
              type: "bytes32"
            }
          ],
          name: "performCreate2",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/multi_send.json
var require_multi_send = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/multi_send.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
      released: true,
      contractName: "MultiSend",
      version: "1.1.1",
      networkAddresses: {
        "1": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "4": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "5": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "42": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "88": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "100": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "246": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        "73799": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD"
      },
      abi: [
        {
          inputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send.json
var require_multi_send2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
      released: true,
      contractName: "MultiSend",
      version: "1.3.0",
      networkAddresses: {
        "1": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "3": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "4": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "5": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "10": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "11": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "12": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "18": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "25": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "28": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "30": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "31": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "39": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "40": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "41": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "42": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "44": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "46": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "50": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "51": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "56": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "57": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "61": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "63": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "69": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "71": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "81": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "82": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "83": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "97": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "100": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "106": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "108": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "109": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "111": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "122": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "123": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "137": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "148": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "155": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "169": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "204": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "246": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "250": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "255": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "280": "0x0dFcccB95225ffB03c6FBB2559B530C2B7C8A912",
        "288": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "291": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "300": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "321": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "322": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "324": "0x0dFcccB95225ffB03c6FBB2559B530C2B7C8A912",
        "336": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "338": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "420": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "424": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "570": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "588": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "592": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "595": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "599": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "686": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "787": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "919": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1030": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1088": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1101": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1111": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1112": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1115": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1116": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1230": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1231": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1284": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1285": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1287": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1294": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1442": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1559": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1663": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1807": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1890": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1891": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1984": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1998": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2001": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2002": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2019": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2020": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2021": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2221": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2222": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "2358": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "3737": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "4002": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "4337": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "4460": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "4689": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "4918": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "4919": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "5000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "5001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "5003": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "5700": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "6102": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "7001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "7332": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "7341": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "7700": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "8192": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "8194": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "8217": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "8453": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "9000": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "9001": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "9728": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "10000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "10001": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "10081": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "10200": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "10243": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "11235": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "11437": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "11891": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "12357": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "13337": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "17000": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "17172": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "18231": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "23294": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "23295": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "34443": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "42161": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "42170": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "42220": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "43113": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "43114": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "43288": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "44787": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "45000": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "47805": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "54211": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "56288": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "57000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "58008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "59140": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "59144": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "71401": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "71402": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "73799": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "80001": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "80085": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "84531": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "84532": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "167008": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "200101": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "200202": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "333999": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "421611": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "421613": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "421614": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "534351": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "534352": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "534353": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "622277": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "713715": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "7777777": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "11155111": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "11155420": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "222000222": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "245022926": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "245022934": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "333000333": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "999999999": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1313161554": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1313161555": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "1666600000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "1666700000": "0x998739BFdAAdde7C933B942a68053933098f9EDa",
        "11297108099": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
        "11297108109": "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send.json
var require_multi_send3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
      released: true,
      contractName: "MultiSend",
      version: "1.4.1",
      networkAddresses: {
        "1": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "5": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "10": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "56": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "71": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "97": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "100": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "137": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "1030": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "1101": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "1442": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "4337": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "8192": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "8194": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "8453": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "10243": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "11235": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "13337": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "17000": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "42161": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "42220": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "54211": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "80001": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "84531": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "84532": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
        "11155111": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send_call_only.json
var require_multi_send_call_only = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send_call_only.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
      released: true,
      contractName: "MultiSendCallOnly",
      version: "1.3.0",
      networkAddresses: {
        "1": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "3": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "4": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "5": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "10": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "11": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "12": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "18": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "25": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "28": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "30": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "31": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "39": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "40": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "41": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "42": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "44": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "46": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "50": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "51": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "56": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "57": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "61": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "63": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "69": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "71": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "81": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "82": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "83": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "97": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "100": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "106": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "108": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "109": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "111": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "122": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "123": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "137": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "148": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "155": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "169": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "204": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "246": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "250": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "255": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "280": "0xf220D3b4DFb23C4ade8C88E526C1353AbAcbC38F",
        "288": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "291": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "300": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "321": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "322": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "324": "0xf220D3b4DFb23C4ade8C88E526C1353AbAcbC38F",
        "336": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "338": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "420": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "424": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "570": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "588": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "592": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "595": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "599": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "686": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "787": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "919": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1030": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1088": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1101": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1111": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1112": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1115": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1116": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1230": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1231": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1284": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1285": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1287": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1294": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1442": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1559": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1663": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1807": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1890": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1891": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1984": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1998": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2001": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2002": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2019": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2020": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2021": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2221": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2222": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "2358": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "3737": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "4002": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "4337": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "4460": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "4689": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "4918": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "4919": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "5000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "5001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "5003": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "5700": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "6102": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "7001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "7332": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "7341": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "7700": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "8192": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "8194": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "8217": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "8453": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "9000": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "9001": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "9728": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "10000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "10001": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "10081": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "10200": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "10243": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "11235": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "11437": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "11891": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "12357": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "13337": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "17000": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "17172": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "18231": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "23294": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "23295": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "34443": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "42161": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "42170": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "42220": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "43113": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "43114": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "43288": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "44787": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "45000": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "47805": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "54211": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "56288": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "57000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "58008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "59140": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "59144": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "71401": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "71402": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "73799": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "80001": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "80085": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "84531": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "84532": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "167008": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "200101": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "200202": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "333999": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "421611": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "421613": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "421614": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "534351": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "534352": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "534353": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "622277": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "713715": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "7777777": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "11155111": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "11155420": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "222000222": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "245022926": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "245022934": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "333000333": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "999999999": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1313161554": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1313161555": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "1666600000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "1666700000": "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
        "11297108099": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
        "11297108109": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send_call_only.json
var require_multi_send_call_only2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send_call_only.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
      released: true,
      contractName: "MultiSendCallOnly",
      version: "1.4.1",
      networkAddresses: {
        "1": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "5": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "10": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "56": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "71": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "97": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "100": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "137": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "1030": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "1101": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "1442": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "4337": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "8192": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "8194": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "8453": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "10243": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "11235": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "13337": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "17000": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "42161": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "42220": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "54211": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "80001": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "84531": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "84532": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
        "11155111": "0x9641d764fc13c8B624c04430C7356C1C7C8102e2"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/sign_message_lib.json
var require_sign_message_lib = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/sign_message_lib.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
      contractName: "SignMessageLib",
      version: "1.3.0",
      released: true,
      networkAddresses: {
        "1": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "3": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "4": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "5": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "10": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "11": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "12": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "18": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "25": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "28": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "30": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "31": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "39": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "40": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "41": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "42": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "44": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "46": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "50": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "51": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "56": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "57": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "61": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "63": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "69": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "71": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "81": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "82": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "83": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "97": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "100": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "106": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "108": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "109": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "111": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "122": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "123": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "137": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "148": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "155": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "169": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "204": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "246": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "250": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "255": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "280": "0x357147caf9C0cCa67DfA0CF5369318d8193c8407",
        "288": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "291": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "300": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "321": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "322": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "324": "0x357147caf9C0cCa67DfA0CF5369318d8193c8407",
        "336": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "338": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "420": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "424": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "570": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "588": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "592": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "595": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "599": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "686": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "787": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "919": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1030": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1088": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1101": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1111": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1112": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1115": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1116": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1230": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1231": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1284": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1285": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1287": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1294": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1442": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1559": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1663": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1807": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1890": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1891": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1984": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1998": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2001": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2002": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2019": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2020": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2021": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2221": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2222": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "2358": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "3737": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "4002": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "4337": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "4460": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "4689": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "4918": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "4919": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "5000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "5001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "5003": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "5700": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "6102": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "7001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "7332": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "7341": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "7700": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "8192": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "8194": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "8217": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "8453": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "9000": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "9001": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "9728": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "10000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "10001": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "10081": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "10200": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "10243": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "11235": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "11437": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "11891": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "12357": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "13337": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "17000": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "17172": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "18231": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "23294": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "23295": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "34443": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "42161": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "42170": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "42220": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "43113": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "43114": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "43288": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "44787": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "45000": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "47805": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "54211": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "56288": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "57000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "58008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "59140": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "59144": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "71401": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "71402": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "73799": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "80001": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "80085": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "84531": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "84532": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "167008": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "200101": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "200202": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "333999": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "421611": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "421613": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "421614": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "534351": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "534352": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "534353": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "622277": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "713715": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "7777777": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "11155111": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "11155420": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "222000222": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "245022926": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "245022934": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "333000333": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "999999999": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1313161554": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1313161555": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "1666600000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "1666700000": "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
        "11297108099": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
        "11297108109": "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/sign_message_lib.json
var require_sign_message_lib2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/sign_message_lib.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
      contractName: "SignMessageLib",
      version: "1.4.1",
      released: true,
      networkAddresses: {
        "1": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "5": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "10": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "56": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "71": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "97": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "100": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "137": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "1030": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "1101": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "1442": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "4337": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "8192": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "8194": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "8453": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "10243": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "11235": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "13337": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "17000": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "42161": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "42220": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "54211": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "80001": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "84531": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "84532": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
        "11155111": "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/libs.js
var require_libs = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/libs.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSignMessageLibDeployment = exports.getCreateCallDeployment = exports.getMultiSendCallOnlyDeployment = exports.getMultiSendDeployment = void 0;
    var create_call_json_1 = __importDefault(require_create_call());
    var create_call_json_2 = __importDefault(require_create_call2());
    var multi_send_json_1 = __importDefault(require_multi_send());
    var multi_send_json_2 = __importDefault(require_multi_send2());
    var multi_send_json_3 = __importDefault(require_multi_send3());
    var multi_send_call_only_json_1 = __importDefault(require_multi_send_call_only());
    var multi_send_call_only_json_2 = __importDefault(require_multi_send_call_only2());
    var sign_message_lib_json_1 = __importDefault(require_sign_message_lib());
    var sign_message_lib_json_2 = __importDefault(require_sign_message_lib2());
    var utils_1 = require_utils3();
    var multiSendDeployments = [
      multi_send_json_3.default,
      multi_send_json_2.default,
      multi_send_json_1.default
    ];
    var getMultiSendDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, multiSendDeployments);
    };
    exports.getMultiSendDeployment = getMultiSendDeployment;
    var multiSendCallOnlyDeployments = [
      multi_send_call_only_json_2.default,
      multi_send_call_only_json_1.default
    ];
    var getMultiSendCallOnlyDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, multiSendCallOnlyDeployments);
    };
    exports.getMultiSendCallOnlyDeployment = getMultiSendCallOnlyDeployment;
    var createCallDeployments = [
      create_call_json_2.default,
      create_call_json_1.default
    ];
    var getCreateCallDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, createCallDeployments);
    };
    exports.getCreateCallDeployment = getCreateCallDeployment;
    var signMessageLibDeployments = [
      sign_message_lib_json_2.default,
      sign_message_lib_json_1.default
    ];
    var getSignMessageLibDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, signMessageLibDeployments);
    };
    exports.getSignMessageLibDeployment = getSignMessageLibDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/default_callback_handler.json
var require_default_callback_handler = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/default_callback_handler.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
      released: true,
      contractName: "DefaultCallbackHandler",
      version: "1.1.1",
      networkAddresses: {
        "1": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "4": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "5": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "42": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "88": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "100": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "246": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
        "73799": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44"
      },
      abi: [
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155BatchReceived",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC721Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "tokensReceived",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/compatibility_fallback_handler.json
var require_compatibility_fallback_handler = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/compatibility_fallback_handler.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
      released: true,
      contractName: "CompatibilityFallbackHandler",
      version: "1.3.0",
      networkAddresses: {
        "1": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "3": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "4": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "5": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "10": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "11": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "12": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "18": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "25": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "28": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "30": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "31": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "39": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "40": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "41": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "42": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "44": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "46": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "50": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "51": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "56": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "57": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "61": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "63": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "69": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "71": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "81": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "82": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "83": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "97": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "100": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "106": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "108": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "109": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "111": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "122": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "123": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "137": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "148": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "155": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "169": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "204": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "246": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "250": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "255": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "280": "0x2f870a80647BbC554F3a0EBD093f11B4d2a7492A",
        "288": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "291": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "300": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "321": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "322": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "324": "0x2f870a80647BbC554F3a0EBD093f11B4d2a7492A",
        "336": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "338": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "420": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "424": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "570": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "588": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "592": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "595": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "599": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "686": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "787": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "919": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1030": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1088": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1101": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1111": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1112": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1115": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1116": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1230": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1231": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1284": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1285": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1287": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1294": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1442": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1559": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1663": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1807": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1890": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1891": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1984": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1998": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2001": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2002": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2019": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2020": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2021": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2221": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2222": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "2358": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "3737": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "4002": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "4337": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "4460": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "4689": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "4918": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "4919": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "5000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "5001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "5003": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "5700": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "6102": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "7001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "7332": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "7341": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "7700": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "8192": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "8194": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "8217": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "8453": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "9000": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "9001": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "9728": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "10000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "10001": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "10081": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "10200": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "10243": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "11235": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "11437": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "11891": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "12357": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "13337": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "17000": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "17172": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "18231": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "23294": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "23295": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "34443": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "42161": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "42170": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "42220": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "43113": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "43114": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "43288": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "44787": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "45000": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "47805": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "54211": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "56288": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "57000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "58008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "59140": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "59144": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "71401": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "71402": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "73799": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "80001": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "80085": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "84531": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "84532": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "167008": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "200101": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "200202": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "333999": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "421611": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "421613": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "421614": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "534351": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "534352": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "534353": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "622277": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "713715": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "7777777": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "11155111": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "11155420": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "222000222": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "245022926": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "245022934": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "333000333": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "999999999": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1313161554": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1313161555": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "1666600000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "1666700000": "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
        "11297108099": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
        "11297108109": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4"
      },
      abi: [
        {
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "contract GnosisSafe",
              name: "safe",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHashForSafe",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155BatchReceived",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC721Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "bytes",
              name: "response",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "interfaceId",
              type: "bytes4"
            }
          ],
          name: "supportsInterface",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "tokensReceived",
          outputs: [],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/compatibility_fallback_handler.json
var require_compatibility_fallback_handler2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/compatibility_fallback_handler.json"(exports, module) {
    module.exports = {
      defaultAddress: "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
      released: true,
      contractName: "CompatibilityFallbackHandler",
      version: "1.4.1",
      networkAddresses: {
        "1": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "5": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "10": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "56": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "71": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "97": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "100": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "137": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "1030": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "1101": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "1442": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "4337": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "8192": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "8194": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "8453": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "10243": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "11235": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "13337": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "17000": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "42161": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "42220": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "54211": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "80001": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "84531": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "84532": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
        "11155111": "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "contract Safe",
              name: "safe",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "encodeMessageDataForSafe",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "contract Safe",
              name: "safe",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHashForSafe",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155BatchReceived",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC721Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "bytes",
              name: "response",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "interfaceId",
              type: "bytes4"
            }
          ],
          name: "supportsInterface",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "tokensReceived",
          outputs: [],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/handler.js
var require_handler = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/handler.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFallbackHandlerDeployment = exports.getCompatibilityFallbackHandlerDeployment = exports.getDefaultCallbackHandlerDeployment = void 0;
    var default_callback_handler_json_1 = __importDefault(require_default_callback_handler());
    var compatibility_fallback_handler_json_1 = __importDefault(require_compatibility_fallback_handler());
    var compatibility_fallback_handler_json_2 = __importDefault(require_compatibility_fallback_handler2());
    var utils_1 = require_utils3();
    var defaultCallbackHandlerDeployments = [
      default_callback_handler_json_1.default
    ];
    var getDefaultCallbackHandlerDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, defaultCallbackHandlerDeployments);
    };
    exports.getDefaultCallbackHandlerDeployment = getDefaultCallbackHandlerDeployment;
    var compatFallbackHandlerDeployments = [
      compatibility_fallback_handler_json_2.default,
      compatibility_fallback_handler_json_1.default
    ];
    var getCompatibilityFallbackHandlerDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, compatFallbackHandlerDeployments);
    };
    exports.getCompatibilityFallbackHandlerDeployment = getCompatibilityFallbackHandlerDeployment;
    var fallbackHandlerDeployments = [
      compatibility_fallback_handler_json_2.default,
      compatibility_fallback_handler_json_1.default,
      default_callback_handler_json_1.default
    ];
    var getFallbackHandlerDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, fallbackHandlerDeployments);
    };
    exports.getFallbackHandlerDeployment = getFallbackHandlerDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/simulate_tx_accessor.json
var require_simulate_tx_accessor = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/simulate_tx_accessor.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
      released: true,
      contractName: "SimulateTxAccessor",
      version: "1.3.0",
      networkAddresses: {
        "1": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "3": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "4": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "5": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "10": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "11": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "12": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "18": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "25": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "28": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "30": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "31": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "39": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "40": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "41": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "42": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "44": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "46": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "50": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "51": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "56": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "57": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "61": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "63": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "69": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "71": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "81": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "82": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "83": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "97": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "100": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "106": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "108": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "109": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "111": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "122": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "123": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "137": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "148": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "155": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "169": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "204": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "246": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "250": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "255": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "280": "0x4191E2e12E8BC5002424CE0c51f9947b02675a44",
        "288": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "291": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "300": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "321": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "322": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "324": "0x4191E2e12E8BC5002424CE0c51f9947b02675a44",
        "336": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "338": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "420": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "424": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "570": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "588": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "592": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "595": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "599": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "686": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "787": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "919": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1030": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1088": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1101": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1111": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1112": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1115": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1116": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1230": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1231": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1284": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1285": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1287": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1294": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1442": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1559": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1663": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1807": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1890": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1891": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1984": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1998": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2001": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2002": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2019": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2020": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2021": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2221": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2222": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "2358": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "3737": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "4002": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "4337": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "4460": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "4689": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "4918": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "4919": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "5000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "5001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "5003": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "5700": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "6102": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "7001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "7332": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "7341": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "7700": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "8192": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "8194": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "8217": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "8453": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "9000": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "9001": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "9728": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "10000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "10001": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "10081": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "10200": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "10243": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "11235": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "11437": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "11891": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "12357": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "13337": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "17000": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "17172": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "18231": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "23294": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "23295": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "34443": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "42161": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "42170": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "42220": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "43113": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "43114": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "43288": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "44787": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "45000": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "47805": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "54211": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "56288": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "57000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "58008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "59140": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "59144": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "71401": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "71402": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "73799": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "80001": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "80085": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "84531": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "84532": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "167008": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "200101": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "200202": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "333999": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "421611": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "421613": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "421614": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "534351": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "534352": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "534353": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "622277": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "713715": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "7777777": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "11155111": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "11155420": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "222000222": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "245022926": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "245022934": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "333000333": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "999999999": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1313161554": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1313161555": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "1666600000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "1666700000": "0x727a77a074D1E6c4530e814F89E618a3298FC044",
        "11297108099": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
        "11297108109": "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "uint256",
              name: "estimate",
              type: "uint256"
            },
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/simulate_tx_accessor.json
var require_simulate_tx_accessor2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/simulate_tx_accessor.json"(exports, module) {
    module.exports = {
      defaultAddress: "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
      released: true,
      contractName: "SimulateTxAccessor",
      version: "1.4.1",
      networkAddresses: {
        "1": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "5": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "10": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "56": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "71": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "97": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "100": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "137": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "1030": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "1101": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "1442": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "4337": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "8192": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "8194": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "8453": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "10243": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "11235": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "13337": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "17000": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "42161": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "42220": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "54211": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "80001": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "84531": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "84532": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
        "11155111": "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "uint256",
              name: "estimate",
              type: "uint256"
            },
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/accessors.js
var require_accessors = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/accessors.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSimulateTxAccessorDeployment = void 0;
    var simulate_tx_accessor_json_1 = __importDefault(require_simulate_tx_accessor());
    var simulate_tx_accessor_json_2 = __importDefault(require_simulate_tx_accessor2());
    var utils_1 = require_utils3();
    var accessorDeployments = [
      simulate_tx_accessor_json_2.default,
      simulate_tx_accessor_json_1.default
    ];
    var getSimulateTxAccessorDeployment = (filter) => {
      return (0, utils_1.findDeployment)(filter, accessorDeployments);
    };
    exports.getSimulateTxAccessorDeployment = getSimulateTxAccessorDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/index.js
var require_dist = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types2(), exports);
    __exportStar(require_safes(), exports);
    __exportStar(require_factories(), exports);
    __exportStar(require_libs(), exports);
    __exportStar(require_handler(), exports);
    __exportStar(require_accessors(), exports);
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/utils.js
var require_utils4 = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapReceipt = exports.createLibInterface = exports.createLibAddress = exports.createLibDeployment = void 0;
    var abi_1 = (init_lib5(), __toCommonJS(lib_exports5));
    var address_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var safe_deployments_1 = require_dist();
    exports.createLibDeployment = (0, safe_deployments_1.getCreateCallDeployment)();
    exports.createLibAddress = exports.createLibDeployment.defaultAddress;
    exports.createLibInterface = new abi_1.Interface(exports.createLibDeployment.abi);
    var mapStatus = (receipt) => {
      const success = receipt.logs.find((log) => log.topics[0] === "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e");
      return !!success ? 1 : 0;
    };
    var mapContractAddress = (receipt, safeTx) => {
      if (safeTx.to.toLowerCase() === exports.createLibAddress.toLowerCase()) {
        const creationLog = receipt.logs.find((log) => log.topics[0] === "0x4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511");
        if (creationLog)
          return (0, address_1.getAddress)("0x" + creationLog.data.slice(creationLog.data.length - 40));
      }
      return receipt.contractAddress;
    };
    var mapReceipt = (receipt, safeTx) => {
      receipt.status = mapStatus(receipt);
      receipt.contractAddress = mapContractAddress(receipt, safeTx);
      return receipt;
    };
    exports.mapReceipt = mapReceipt;
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/signer.js
var require_signer = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeEthersSigner = void 0;
    var abstract_signer_1 = (init_lib6(), __toCommonJS(lib_exports6));
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_types_1 = require_src();
    var utils_1 = require_utils4();
    var sleep = (duration) => new Promise((resolve) => setTimeout(resolve, duration));
    var SafeEthersSigner2 = class extends abstract_signer_1.VoidSigner {
      /**
       * Creates an instance of the SafeEthersSigner.
       * @param safe - Safe that should be used
       * @param service - Services to which the transactions should be proposed to
       * @param provider - (Optional) Provider that should be used for blockchain interactions. By default the provider from the signer is used.
       * @param options - (Optional) Additional options (e.g. polling delay when waiting for a transaction to be mined)
       * @returns The SafeEthersSigner instance
       */
      constructor(safe, service, provider, options) {
        super(safe.getAddress(), provider);
        this.service = service;
        this.safe = safe;
        this.options = options;
      }
      async buildTransactionResponse(safeTxHash, safeTx) {
        const connectedSafe = await this.safe;
        const connectedService = this.service;
        return {
          to: safeTx.to,
          value: bignumber_1.BigNumber.from(safeTx.value),
          data: safeTx.data,
          operation: safeTx.operation,
          gasLimit: bignumber_1.BigNumber.from(safeTx.safeTxGas),
          gasPrice: bignumber_1.BigNumber.from(0),
          nonce: safeTx.nonce,
          chainId: await connectedSafe.getChainId(),
          hash: safeTxHash,
          from: this.address,
          confirmations: 0,
          wait: async (confirmations) => {
            var _a, _b;
            while (true) {
              try {
                const txDetails = await connectedService.getSafeTxDetails(safeTxHash);
                if (txDetails.transactionHash) {
                  this._checkProvider("sendTransaction");
                  const receipt = await this.provider.waitForTransaction(txDetails.transactionHash, confirmations);
                  return (0, utils_1.mapReceipt)(receipt, safeTx);
                }
              } catch (e) {
              }
              await sleep((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.pollingDelay) !== null && _b !== void 0 ? _b : 5e3);
            }
          }
        };
      }
      /**
       * Populates all fields in a transaction, signs it and sends it to the Safe transaction service
       *
       * @param transaction - The transaction what should be send
       * @returns A promise that resolves to a SafeTransactionReponse, that contains all the information of the transaction.
       */
      async sendTransaction(transaction) {
        var _a, _b, _c;
        const tx = await transaction;
        let operation = safe_core_sdk_types_1.OperationType.Call;
        let to = await tx.to;
        let data = (_b = (_a = await tx.data) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "0x";
        let value = bignumber_1.BigNumber.from((_c = await tx.value) !== null && _c !== void 0 ? _c : 0);
        if (!to) {
          to = utils_1.createLibAddress;
          data = utils_1.createLibInterface.encodeFunctionData("performCreate", [value, data]);
          value = bignumber_1.BigNumber.from(0);
          operation = safe_core_sdk_types_1.OperationType.DelegateCall;
        }
        const baseTx = {
          to,
          data,
          value: value.toString(),
          operation
        };
        const safeTxGas = await this.service.estimateSafeTx(this.address, baseTx);
        const connectedSafe = await this.safe;
        const safeTransactionData = {
          ...baseTx,
          safeTxGas: safeTxGas.toNumber()
        };
        const safeTx = await connectedSafe.createTransaction({ safeTransactionData });
        const safeTxHash = await connectedSafe.getTransactionHash(safeTx);
        const signature = await connectedSafe.signTransactionHash(safeTxHash);
        await this.service.proposeTx(this.address, safeTxHash, safeTx, signature);
        return this.buildTransactionResponse(safeTxHash, safeTx.data);
      }
    };
    exports.SafeEthersSigner = SafeEthersSigner2;
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_service(), exports);
    __exportStar(require_signer(), exports);
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/contracts/config.js
var require_config = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/contracts/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeDeploymentsL1ChainIds = exports.safeDeploymentsVersions = exports.SAFE_BASE_VERSION = exports.DEFAULT_SAFE_VERSION = void 0;
    exports.DEFAULT_SAFE_VERSION = "1.3.0";
    exports.SAFE_BASE_VERSION = "1.0.0";
    exports.safeDeploymentsVersions = {
      "1.4.1": {
        safeMasterCopyVersion: "1.4.1",
        safeMasterCopyL2Version: "1.4.1",
        safeProxyFactoryVersion: "1.4.1",
        compatibilityFallbackHandler: "1.4.1",
        multiSendVersion: "1.4.1",
        multiSendCallOnlyVersion: "1.4.1",
        signMessageLibVersion: "1.4.1",
        createCallVersion: "1.4.1"
      },
      "1.3.0": {
        safeMasterCopyVersion: "1.3.0",
        safeMasterCopyL2Version: "1.3.0",
        safeProxyFactoryVersion: "1.3.0",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.3.0",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      },
      "1.2.0": {
        safeMasterCopyVersion: "1.2.0",
        safeMasterCopyL2Version: void 0,
        safeProxyFactoryVersion: "1.1.1",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.1.1",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      },
      "1.1.1": {
        safeMasterCopyVersion: "1.1.1",
        safeMasterCopyL2Version: void 0,
        safeProxyFactoryVersion: "1.1.1",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.1.1",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      },
      "1.0.0": {
        safeMasterCopyVersion: "1.0.0",
        safeMasterCopyL2Version: void 0,
        safeProxyFactoryVersion: "1.0.0",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.1.1",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      }
    };
    exports.safeDeploymentsL1ChainIds = [
      1
      // Ethereum Mainnet
    ];
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/constants.js
var require_constants = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SENTINEL_ADDRESS = exports.EMPTY_DATA = exports.ZERO_ADDRESS = void 0;
    exports.ZERO_ADDRESS = `0x${"0".repeat(40)}`;
    exports.EMPTY_DATA = "0x";
    exports.SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/memoized.js
var require_memoized = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/memoized.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMemoizedFunction = void 0;
    function createMemoizedFunction(callback, cache = {}) {
      return (...args) => {
        const key = JSON.stringify(args);
        cache[key] = cache[key] || callback(...args);
        return cache[key];
      };
    }
    exports.createMemoizedFunction = createMemoizedFunction;
  }
});

// node_modules/rlp/dist.browser/index.js
var require_dist2 = __commonJS({
  "node_modules/rlp/dist.browser/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLength = exports.decode = exports.encode = void 0;
    var bn_js_1 = __importDefault(require_bn());
    function encode(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
          output.push(encode(input[i]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
      } else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
      }
    }
    exports.encode = encode;
    function safeParseInt(v, base) {
      if (v[0] === "0" && v[1] === "0") {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseInt(v, base);
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Buffer.from([len + offset]);
      } else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, "hex");
      }
    }
    function decode(input, stream) {
      if (stream === void 0) {
        stream = false;
      }
      if (!input || input.length === 0) {
        return Buffer.from([]);
      }
      var inputBuffer = toBuffer(input);
      var decoded = _decode(inputBuffer);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid remainder");
      }
      return decoded.data;
    }
    exports.decode = decode;
    function getLength(input) {
      if (!input || input.length === 0) {
        return Buffer.from([]);
      }
      var inputBuffer = toBuffer(input);
      var firstByte = inputBuffer[0];
      if (firstByte <= 127) {
        return inputBuffer.length;
      } else if (firstByte <= 183) {
        return firstByte - 127;
      } else if (firstByte <= 191) {
        return firstByte - 182;
      } else if (firstByte <= 247) {
        return firstByte - 191;
      } else {
        var llength = firstByte - 246;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
        return llength + length_1;
      }
    }
    exports.getLength = getLength;
    function _decode(input) {
      var length, llength, data, innerRemainder, d;
      var decoded = [];
      var firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Buffer.from([]);
        } else {
          data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid rlp encoding: byte must be less 0x80");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
          throw new Error("invalid RLP: not enough bytes for string");
        }
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid rlp: total length is larger than the data");
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
          throw new Error("invalid rlp, List has a invalid length");
        }
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    function isHexPrefixed(str) {
      return str.slice(0, 2) === "0x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function intToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      var hex = integer.toString(16);
      return hex.length % 2 ? "0" + hex : hex;
    }
    function padToEven(a) {
      return a.length % 2 ? "0" + a : a;
    }
    function intToBuffer(integer) {
      var hex = intToHex(integer);
      return Buffer.from(hex, "hex");
    }
    function toBuffer(v) {
      if (!Buffer.isBuffer(v)) {
        if (typeof v === "string") {
          if (isHexPrefixed(v)) {
            return Buffer.from(padToEven(stripHexPrefix(v)), "hex");
          } else {
            return Buffer.from(v);
          }
        } else if (typeof v === "number" || typeof v === "bigint") {
          if (!v) {
            return Buffer.from([]);
          } else {
            return intToBuffer(v);
          }
        } else if (v === null || v === void 0) {
          return Buffer.from([]);
        } else if (v instanceof Uint8Array) {
          return Buffer.from(v);
        } else if (bn_js_1.default.isBN(v)) {
          return Buffer.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    }
  }
});

// node_modules/ethereumjs-util/dist.browser/externals.js
var require_externals = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/externals.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlp = exports.BN = void 0;
    var bn_js_1 = __importDefault(require_bn());
    exports.BN = bn_js_1.default;
    var rlp = __importStar(require_dist2());
    exports.rlp = rlp;
  }
});

// node_modules/ethereumjs-util/dist.browser/constants.js
var require_constants2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
    var buffer_1 = require_buffer2();
    var externals_1 = require_externals();
    exports.MAX_UINT64 = new externals_1.BN("ffffffffffffffff", 16);
    exports.MAX_INTEGER = new externals_1.BN("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new externals_1.BN("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, "hex");
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports, module) {
    var errors = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name, value, length) {
      assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
      if (length !== void 0) {
        if (Array.isArray(length)) {
          const numbers = length.join(", ");
          const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
          assert(length.includes(value.length), msg);
        } else {
          const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
          assert(value.length === length, msg);
        }
      }
    }
    function isCompressed(value) {
      assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
      if (typeof output === "function")
        output = output(length);
      isUint8Array("output", output, length);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SECKEY_INVALID);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors.SIGN);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.RECOVER);
            case 3:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils6 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils5();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r;
    module.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto = require_crypto();
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils6();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils6();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils6();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils6();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils6();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var utils = require_utils5();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils6();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils6();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils6();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils6();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils6();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils6();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils6();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports, module) {
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    var BN = ecparams.n.constructor;
    function loadCompressedPublicKey(first, xbuf) {
      let x = new BN(xbuf);
      if (x.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
      if (first === 3 !== y.isOdd())
        y = y.redNeg();
      return ec.keyPair({ pub: { x, y } });
    }
    function loadUncompressedPublicKey(first, xbuf, ybuf) {
      let x = new BN(xbuf);
      let y = new BN(ybuf);
      if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      y = y.toRed(ecparams.red);
      if ((first === 6 || first === 7) && y.isOdd() !== (first === 7))
        return null;
      const x3 = x.redSqr().redIMul(x);
      if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x, y } });
    }
    function loadPublicKey(pubkey) {
      const first = pubkey[0];
      switch (first) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i = 0; i < output.length; ++i)
        output[i] = pubkey[i];
    }
    module.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0)
          return 1;
        bn.iadd(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn.isub(ecparams.n);
        if (bn.isZero())
          return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        bn.imul(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        const point = ec.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i = 0; i < pubkeys.length; ++i) {
          pairs[i] = loadPublicKey(pubkeys[i]);
          if (pairs[i] === null)
            return 1;
        }
        let point = pairs[0].getPublic();
        for (let i = 1; i < pairs.length; ++i)
          point = point.add(pairs[i].pub);
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r = new BN(sig.subarray(0, 32));
        const s = new BN(sig.subarray(32, 64));
        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0)
          return 1;
        if (s.cmp(ec.nh) === 1) {
          sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj;
        let r = output.subarray(4, 4 + 33);
        r[0] = 0;
        r.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR)
          ;
        r = r.subarray(posR);
        if (r[0] & 128)
          return 1;
        if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
          return 1;
        let s = output.subarray(6 + 33, 6 + 33 + 33);
        s[0] = 0;
        s.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS)
          ;
        s = s.subarray(posS);
        if (s[0] & 128)
          return 1;
        if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
          return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r.length;
        output.set(r, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s.length;
        output.set(s, 6 + lenR);
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r = new BN(sigR);
        if (r.cmp(ecparams.n) >= 0)
          r = new BN(0);
        let s = new BN(sig.subarray(6 + lenR));
        if (s.cmp(ecparams.n) >= 0)
          s = new BN(0);
        output.set(r.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN(nonce);
          };
        }
        const d = new BN(seckey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero())
          return 1;
        let sig;
        try {
          sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point = pair.getPublic();
        const isValid = ec.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point;
        try {
          point = ec.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha256 = ec.hash().update(data2).digest();
          for (let i = 0; i < 32; ++i)
            output[i] = sha256[i];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x = point.getX().toArray("be", 32);
          for (let i = 0; i < 32; ++i)
            xbuf[i] = x[i];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y = point.getY().toArray("be", 32);
          for (let i = 0; i < 32; ++i)
            ybuf[i] = y[i];
          const hash = hashfn(xbuf, ybuf, data);
          const isValid = hash instanceof Uint8Array && hash.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports, module) {
    module.exports = require_lib()(require_elliptic2());
  }
});

// node_modules/randombytes/browser.js
var require_browser = __commonJS({
  "node_modules/randombytes/browser.js"(exports, module) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = global.crypto || global.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module.exports = randomBytes;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/ethereum-cryptography/random.js
var require_random = __commonJS({
  "node_modules/ethereum-cryptography/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var randombytes = require_browser();
    function getRandomBytes(bytes) {
      return new Promise(function(resolve, reject) {
        randombytes(bytes, function(err, resp) {
          if (err) {
            reject(err);
            return;
          }
          resolve(resp);
        });
      });
    }
    exports.getRandomBytes = getRandomBytes;
    function getRandomBytesSync(bytes) {
      return randombytes(bytes);
    }
    exports.getRandomBytesSync = getRandomBytesSync;
  }
});

// node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var secp256k1_1 = require_elliptic3();
    var random_1 = require_random();
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter(this, void 0, void 0, function() {
        var pk;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (false)
                return [3, 2];
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a.sent();
              if (secp256k1_1.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports.createPrivateKeySync = createPrivateKeySync;
    __export(require_elliptic3());
  }
});

// node_modules/ethereumjs-util/dist.browser/internal.js
var require_internal = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[isHexPrefixed] input must be type 'string', received type ".concat(typeof str));
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix = function(str) {
      if (typeof str !== "string")
        throw new Error("[stripHexPrefix] input must be type 'string', received ".concat(typeof str));
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports.stripHexPrefix = stripHexPrefix;
    function padToEven(value) {
      var a = value;
      if (typeof a !== "string") {
        throw new Error("[padToEven] value must be type 'string', received ".concat(typeof a));
      }
      if (a.length % 2)
        a = "0".concat(a);
      return a;
    }
    exports.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[getBinarySize] method requires input type 'string', recieved ".concat(typeof str));
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[arrayContainsArray] method requires input 'superset' to be an array, got type '".concat(typeof superset, "'"));
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[arrayContainsArray] method requires input 'subset' to be an array, got type '".concat(typeof subset, "'"));
      }
      return subset[some ? "some" : "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    exports.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      var str = "";
      var i = 0;
      var l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i = 2;
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports.toAscii = toAscii;
    function fromUtf8(stringValue) {
      var str = Buffer.from(stringValue, "utf8");
      return "0x".concat(padToEven(str.toString("hex")).replace(/^0+|0+$/g, ""));
    }
    exports.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      var hex = "";
      for (var i = 0; i < stringValue.length; i++) {
        var code = stringValue.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0".concat(n) : n;
      }
      return "0x".concat(hex);
    }
    exports.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[getKeys] method expects input 'params' to be an array, got ".concat(typeof params));
      }
      if (typeof key !== "string") {
        throw new Error("[getKeys] method expects input 'key' to be type 'string', got ".concat(typeof params));
      }
      var result = [];
      for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi - expected type 'string', received ".concat(typeof value));
        }
        result.push(value);
      }
      return result;
    }
    exports.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (length && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports.isHexString = isHexString;
  }
});

// node_modules/ethereumjs-util/dist.browser/helpers.js
var require_helpers = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;
    var internal_1 = require_internal();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        var msg = "This method only supports 0x-prefixed hex strings but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        var msg = "This method only supports Buffer but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        var msg = "This method only supports number arrays but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        var msg = "This method only supports strings but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsString = assertIsString;
  }
});

// node_modules/ethereumjs-util/dist.browser/bytes.js
var require_bytes = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/bytes.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
    var externals_1 = require_externals();
    var internal_1 = require_internal();
    var helpers_1 = require_helpers();
    var intToHex = function(i) {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error("Received an invalid integer type: ".concat(i));
      }
      return "0x".concat(i.toString(16));
    };
    exports.intToHex = intToHex;
    var intToBuffer = function(i) {
      var hex = (0, exports.intToHex)(i);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.zeros = zeros;
    var setLength = function(msg, length, right) {
      var buf = (0, exports.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return stripZeros(a);
    };
    exports.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ".concat(v));
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports.intToBuffer)(v);
      }
      if (externals_1.BN.isBN(v)) {
        if (v.isNeg()) {
          throw new Error("Cannot convert negative BN to buffer. Given: ".concat(v));
        }
        return v.toArrayLike(Buffer);
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports.toBuffer = toBuffer;
    var bufferToInt = function(buf) {
      return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();
    };
    exports.bufferToInt = bufferToInt;
    var bufferToHex = function(buf) {
      buf = (0, exports.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports.bufferToHex = bufferToHex;
    var fromSigned = function(num) {
      return new externals_1.BN(num).fromTwos(256);
    };
    exports.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return Buffer.from(num.toTwos(256).toArray());
    };
    exports.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports.addHexPrefix = addHexPrefix;
    var toUtf8 = function(hex) {
      var zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      var bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return "0x".concat(ba.toString("hex"));
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push((0, exports.baToJSON)(ba[i]));
        }
        return array;
      }
    };
    exports.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      var e_1, _a;
      try {
        for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
          if (v !== void 0 && v.length > 0 && v[0] === 0) {
            throw new Error("".concat(k, " cannot have leading zeroes, received: ").concat(v.toString("hex")));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map(function(a) {
        return arrToBufArr(a);
      });
    }
    exports.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);
      }
      return arr.map(function(a) {
        return bufArrToArr(a);
      });
    }
    exports.bufArrToArr = bufArrToArr;
  }
});

// node_modules/ethereum-cryptography/hash-utils.js
var require_hash_utils = __commonJS({
  "node_modules/ethereum-cryptography/hash-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createHashFunction(hashConstructor) {
      return function(msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
      };
    }
    exports.createHashFunction = createHashFunction;
  }
});

// node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_utils_1 = require_hash_utils();
    var createKeccakHash = require_js();
    exports.keccak224 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak224");
    });
    exports.keccak256 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak256");
    });
    exports.keccak384 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak384");
    });
    exports.keccak512 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak512");
    });
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_readable_browser().Transform;
    var inherits = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer2.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer2.isBuffer(data))
        data = Buffer2.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; )
          block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0)
          this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i)
        this._length[i] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i)
        M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/ripemd160/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_buffer2().Buffer;
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j = 0; j < 16; ++j)
        words[j] = this._block.readInt32LE(j * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i = 0; i < 80; i += 1) {
        var tl;
        var tr;
        if (i < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
      }
      var t = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fn1(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b, c, d, e, m, k, s) {
      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    module.exports = RIPEMD160;
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream().Transform;
    var StringDecoder = require_string_decoder().StringDecoder;
    var inherits = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer2.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser2 = __commonJS({
  "node_modules/create-hash/browser.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha();
    var Base = require_cipher_base();
    function Hash(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD160();
      return new Hash(sha(alg));
    };
  }
});

// node_modules/ethereumjs-util/dist.browser/hash.js
var require_hash2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;
    var keccak_1 = require_keccak();
    var createHash = require_browser2();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var helpers_1 = require_helpers();
    var keccak = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsBuffer)(a);
      switch (bits) {
        case 224: {
          return (0, keccak_1.keccak224)(a);
        }
        case 256: {
          return (0, keccak_1.keccak256)(a);
        }
        case 384: {
          return (0, keccak_1.keccak384)(a);
        }
        case 512: {
          return (0, keccak_1.keccak512)(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak".concat(bits));
        }
      }
    };
    exports.keccak = keccak;
    var keccak256 = function(a) {
      return (0, exports.keccak)(a);
    };
    exports.keccak256 = keccak256;
    var keccakFromString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsString)(a);
      var buf = Buffer.from(a, "utf8");
      return (0, exports.keccak)(buf, bits);
    };
    exports.keccakFromString = keccakFromString;
    var keccakFromHexString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsHexString)(a);
      return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
    };
    exports.keccakFromHexString = keccakFromHexString;
    var keccakFromArray = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsArray)(a);
      return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
    };
    exports.keccakFromArray = keccakFromArray;
    var _sha256 = function(a) {
      a = (0, bytes_1.toBuffer)(a);
      return createHash("sha256").update(a).digest();
    };
    var sha256 = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return _sha256(a);
    };
    exports.sha256 = sha256;
    var sha256FromString = function(a) {
      (0, helpers_1.assertIsString)(a);
      return _sha256(a);
    };
    exports.sha256FromString = sha256FromString;
    var sha256FromArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return _sha256(a);
    };
    exports.sha256FromArray = sha256FromArray;
    var _ripemd160 = function(a, padded) {
      a = (0, bytes_1.toBuffer)(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return (0, bytes_1.setLengthLeft)(hash, 32);
      } else {
        return hash;
      }
    };
    var ripemd160 = function(a, padded) {
      (0, helpers_1.assertIsBuffer)(a);
      return _ripemd160(a, padded);
    };
    exports.ripemd160 = ripemd160;
    var ripemd160FromString = function(a, padded) {
      (0, helpers_1.assertIsString)(a);
      return _ripemd160(a, padded);
    };
    exports.ripemd160FromString = ripemd160FromString;
    var ripemd160FromArray = function(a, padded) {
      (0, helpers_1.assertIsArray)(a);
      return _ripemd160(a, padded);
    };
    exports.ripemd160FromArray = ripemd160FromArray;
    var rlphash = function(a) {
      return (0, exports.keccak)(externals_1.rlp.encode(a));
    };
    exports.rlphash = rlphash;
  }
});

// node_modules/ethereumjs-util/dist.browser/types.js
var require_types3 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;
    var externals_1 = require_externals();
    var internal_1 = require_internal();
    var bytes_1 = require_bytes();
    function bnToHex(value) {
      return "0x".concat(value.toString(16));
    }
    exports.bnToHex = bnToHex;
    function bnToUnpaddedBuffer(value) {
      return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));
    }
    exports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
    function bnToRlp(value) {
      return bnToUnpaddedBuffer(value);
    }
    exports.bnToRlp = bnToRlp;
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BN"] = 1] = "BN";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error("A string must be provided with a 0x-prefix, given: ".concat(input));
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      var output = (0, bytes_1.toBuffer)(input);
      if (outputType === TypeOutput.Buffer) {
        return output;
      } else if (outputType === TypeOutput.BN) {
        return new externals_1.BN(output);
      } else if (outputType === TypeOutput.Number) {
        var bn = new externals_1.BN(output);
        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());
        if (bn.gt(max)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        }
        return bn.toNumber();
      } else {
        return "0x".concat(output.toString("hex"));
      }
    }
    exports.toType = toType;
  }
});

// node_modules/ethereumjs-util/dist.browser/account.js
var require_account = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/account.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
    var assert_1 = __importDefault(require_assert());
    var externals_1 = require_externals();
    var secp256k1_1 = require_secp256k12();
    var internal_1 = require_internal();
    var constants_1 = require_constants2();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash2();
    var helpers_1 = require_helpers();
    var types_1 = require_types3();
    var Account = (
      /** @class */
      function() {
        function Account2(nonce, balance, stateRoot, codeHash) {
          if (nonce === void 0) {
            nonce = new externals_1.BN(0);
          }
          if (balance === void 0) {
            balance = new externals_1.BN(0);
          }
          if (stateRoot === void 0) {
            stateRoot = constants_1.KECCAK256_RLP;
          }
          if (codeHash === void 0) {
            codeHash = constants_1.KECCAK256_NULL;
          }
          this.nonce = nonce;
          this.balance = balance;
          this.stateRoot = stateRoot;
          this.codeHash = codeHash;
          this._validate();
        }
        Account2.fromAccountData = function(accountData) {
          var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;
          return new Account2(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : void 0, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : void 0, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : void 0, codeHash ? (0, bytes_1.toBuffer)(codeHash) : void 0);
        };
        Account2.fromRlpSerializedAccount = function(serialized) {
          var values = externals_1.rlp.decode(serialized);
          if (!Array.isArray(values)) {
            throw new Error("Invalid serialized account input. Must be array");
          }
          return this.fromValuesArray(values);
        };
        Account2.fromValuesArray = function(values) {
          var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];
          return new Account2(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);
        };
        Account2.prototype._validate = function() {
          if (this.nonce.lt(new externals_1.BN(0))) {
            throw new Error("nonce must be greater than zero");
          }
          if (this.balance.lt(new externals_1.BN(0))) {
            throw new Error("balance must be greater than zero");
          }
          if (this.stateRoot.length !== 32) {
            throw new Error("stateRoot must have a length of 32");
          }
          if (this.codeHash.length !== 32) {
            throw new Error("codeHash must have a length of 32");
          }
        };
        Account2.prototype.raw = function() {
          return [
            (0, types_1.bnToUnpaddedBuffer)(this.nonce),
            (0, types_1.bnToUnpaddedBuffer)(this.balance),
            this.stateRoot,
            this.codeHash
          ];
        };
        Account2.prototype.serialize = function() {
          return externals_1.rlp.encode(this.raw());
        };
        Account2.prototype.isContract = function() {
          return !this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        Account2.prototype.isEmpty = function() {
          return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        return Account2;
      }()
    );
    exports.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      var prefix = "";
      if (eip1191ChainId) {
        var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);
        prefix = chainId.toString() + "0x";
      }
      var hash = (0, hash_1.keccakFromString)(prefix + address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      var nonceBN = new externals_1.BN(nonce);
      if (nonceBN.isZero()) {
        return (0, hash_1.rlphash)([from, null]).slice(-20);
      }
      return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);
    };
    exports.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      (0, assert_1.default)(from.length === 20);
      (0, assert_1.default)(salt.length === 32);
      var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, hash_1.keccak256)(initCode)]));
      return address.slice(-20);
    };
    exports.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return (0, secp256k1_1.privateKeyVerify)(privateKey);
    };
    exports.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return (0, secp256k1_1.publicKeyVerify)(publicKey);
    };
    exports.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));
      }
      (0, assert_1.default)(pubKey.length === 64);
      return (0, hash_1.keccak)(pubKey).slice(-20);
    };
    exports.pubToAddress = pubToAddress;
    exports.publicToAddress = exports.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);
    };
    exports.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
    };
    exports.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));
      }
      return publicKey;
    };
    exports.importPublic = importPublic;
    var zeroAddress = function() {
      var addressLength = 20;
      var addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      var zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports.isZeroAddress = isZeroAddress;
  }
});

// node_modules/ethereumjs-util/dist.browser/address.js
var require_address = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/address.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var assert_1 = __importDefault(require_assert());
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var account_1 = require_account();
    var Address = (
      /** @class */
      function() {
        function Address2(buf) {
          (0, assert_1.default)(buf.length === 20, "Invalid address length");
          this.buf = buf;
        }
        Address2.zero = function() {
          return new Address2((0, bytes_1.zeros)(20));
        };
        Address2.fromString = function(str) {
          (0, assert_1.default)((0, account_1.isValidAddress)(str), "Invalid address");
          return new Address2((0, bytes_1.toBuffer)(str));
        };
        Address2.fromPublicKey = function(pubKey) {
          (0, assert_1.default)(Buffer.isBuffer(pubKey), "Public key should be Buffer");
          var buf = (0, account_1.pubToAddress)(pubKey);
          return new Address2(buf);
        };
        Address2.fromPrivateKey = function(privateKey) {
          (0, assert_1.default)(Buffer.isBuffer(privateKey), "Private key should be Buffer");
          var buf = (0, account_1.privateToAddress)(privateKey);
          return new Address2(buf);
        };
        Address2.generate = function(from, nonce) {
          (0, assert_1.default)(externals_1.BN.isBN(nonce));
          return new Address2((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));
        };
        Address2.generate2 = function(from, salt, initCode) {
          (0, assert_1.default)(Buffer.isBuffer(salt));
          (0, assert_1.default)(Buffer.isBuffer(initCode));
          return new Address2((0, account_1.generateAddress2)(from.buf, salt, initCode));
        };
        Address2.prototype.equals = function(address) {
          return this.buf.equals(address.buf);
        };
        Address2.prototype.isZero = function() {
          return this.equals(Address2.zero());
        };
        Address2.prototype.isPrecompileOrSystemAddress = function() {
          var addressBN = new externals_1.BN(this.buf);
          var rangeMin = new externals_1.BN(0);
          var rangeMax = new externals_1.BN("ffff", "hex");
          return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
        };
        Address2.prototype.toString = function() {
          return "0x" + this.buf.toString("hex");
        };
        Address2.prototype.toBuffer = function() {
          return Buffer.from(this.buf);
        };
        return Address2;
      }()
    );
    exports.Address = Address;
  }
});

// node_modules/ethereumjs-util/dist.browser/signature.js
var require_signature3 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var secp256k1_1 = require_secp256k12();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash2();
    var helpers_1 = require_helpers();
    var types_1 = require_types3();
    function ecsign(msgHash, privateKey, chainId) {
      var _a = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey), signature = _a.signature, recovery = _a.recid;
      var r = Buffer.from(signature.slice(0, 32));
      var s = Buffer.from(signature.slice(32, 64));
      if (!chainId || typeof chainId === "number") {
        if (chainId && !Number.isSafeInteger(chainId)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
        }
        var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
        return { r, s, v: v_1 };
      }
      var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
      var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);
      return { r, s, v };
    }
    exports.ecsign = ecsign;
    function calculateSigRecovery(v, chainId) {
      var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);
      if (vBN.eqn(0) || vBN.eqn(1))
        return (0, types_1.toType)(v, types_1.TypeOutput.BN);
      if (!chainId) {
        return vBN.subn(27);
      }
      var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
      return vBN.sub(chainIdBN.muln(2).addn(35));
    }
    function isValidSigRecovery(recovery) {
      var rec = new externals_1.BN(recovery);
      return rec.eqn(0) || rec.eqn(1);
    }
    var ecrecover = function(msgHash, v, r, s, chainId) {
      var signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);
      return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));
    };
    exports.ecrecover = ecrecover;
    var toRpcSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);
      var ss = s;
      if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      var buf = (0, bytes_1.toBuffer)(sig);
      var r;
      var s;
      var v;
      if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r,
        s
      };
    };
    exports.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r, s, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new externals_1.BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new externals_1.BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      var rBN = new externals_1.BN(r);
      var sBN = new externals_1.BN(s);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.isValidSignature = isValidSignature;
    var hashPersonalMessage = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      var prefix = Buffer.from("Ethereum Signed Message:\n".concat(message.length), "utf-8");
      return (0, hash_1.keccak)(Buffer.concat([prefix, message]));
    };
    exports.hashPersonalMessage = hashPersonalMessage;
  }
});

// node_modules/ethereumjs-util/dist.browser/object.js
var require_object = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/object.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = void 0;
    var assert_1 = __importDefault(require_assert());
    var internal_1 = require_internal();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes();
    var defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self2._fields.forEach(function(field) {
            obj_1[field] = "0x".concat(self2[field].toString("hex"));
          });
          return obj_1;
        }
        return (0, bytes_1.baToJSON)(self2.raw);
      };
      self2.serialize = function serialize() {
        return externals_1.rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = (0, bytes_1.toBuffer)(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = (0, bytes_1.unpadBuffer)(v);
            (0, assert_1.default)(field.length >= v.length, "The field ".concat(field.name, " must not have more ").concat(field.length, " bytes"));
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            (0, assert_1.default)(field.length === v.length, "The field ".concat(field.name, " must have byte length of ").concat(field.length));
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer.from((0, internal_1.stripHexPrefix)(data), "hex");
        }
        if (Buffer.isBuffer(data)) {
          data = externals_1.rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = (0, bytes_1.toBuffer)(d);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
    exports.defineProperties = defineProperties;
  }
});

// node_modules/ethereumjs-util/dist.browser/index.js
var require_dist3 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    __exportStar(require_constants2(), exports);
    __exportStar(require_account(), exports);
    __exportStar(require_address(), exports);
    __exportStar(require_hash2(), exports);
    __exportStar(require_signature3(), exports);
    __exportStar(require_bytes(), exports);
    __exportStar(require_object(), exports);
    __exportStar(require_externals(), exports);
    __exportStar(require_types3(), exports);
    var internal_1 = require_internal();
    Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
  }
});

// node_modules/zksync-web3/build/src/types.js
var require_types4 = __commonJS({
  "node_modules/zksync-web3/build/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountNonceOrdering = exports.AccountAbstractionVersion = exports.TransactionStatus = exports.PriorityOpTree = exports.PriorityQueueType = exports.Network = void 0;
    var Network;
    (function(Network2) {
      Network2[Network2["Mainnet"] = 1] = "Mainnet";
      Network2[Network2["Ropsten"] = 3] = "Ropsten";
      Network2[Network2["Rinkeby"] = 4] = "Rinkeby";
      Network2[Network2["Goerli"] = 5] = "Goerli";
      Network2[Network2["Localhost"] = 9] = "Localhost";
    })(Network = exports.Network || (exports.Network = {}));
    var PriorityQueueType;
    (function(PriorityQueueType2) {
      PriorityQueueType2[PriorityQueueType2["Deque"] = 0] = "Deque";
      PriorityQueueType2[PriorityQueueType2["HeapBuffer"] = 1] = "HeapBuffer";
      PriorityQueueType2[PriorityQueueType2["Heap"] = 2] = "Heap";
    })(PriorityQueueType = exports.PriorityQueueType || (exports.PriorityQueueType = {}));
    var PriorityOpTree;
    (function(PriorityOpTree2) {
      PriorityOpTree2[PriorityOpTree2["Full"] = 0] = "Full";
      PriorityOpTree2[PriorityOpTree2["Rollup"] = 1] = "Rollup";
    })(PriorityOpTree = exports.PriorityOpTree || (exports.PriorityOpTree = {}));
    var TransactionStatus;
    (function(TransactionStatus2) {
      TransactionStatus2["NotFound"] = "not-found";
      TransactionStatus2["Processing"] = "processing";
      TransactionStatus2["Committed"] = "committed";
      TransactionStatus2["Finalized"] = "finalized";
    })(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
    var AccountAbstractionVersion;
    (function(AccountAbstractionVersion2) {
      AccountAbstractionVersion2[AccountAbstractionVersion2["None"] = 0] = "None";
      AccountAbstractionVersion2[AccountAbstractionVersion2["Version1"] = 1] = "Version1";
    })(AccountAbstractionVersion = exports.AccountAbstractionVersion || (exports.AccountAbstractionVersion = {}));
    var AccountNonceOrdering;
    (function(AccountNonceOrdering2) {
      AccountNonceOrdering2[AccountNonceOrdering2["Sequential"] = 0] = "Sequential";
      AccountNonceOrdering2[AccountNonceOrdering2["Arbitrary"] = 1] = "Arbitrary";
    })(AccountNonceOrdering = exports.AccountNonceOrdering || (exports.AccountNonceOrdering = {}));
  }
});

// node_modules/zksync-web3/build/typechain/IZkSyncFactory.js
var require_IZkSyncFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IZkSyncFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IZkSyncFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IZkSyncFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IZkSyncFactory = IZkSyncFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "commitment",
            type: "bytes32"
          }
        ],
        name: "BlockCommit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "commitment",
            type: "bytes32"
          }
        ],
        name: "BlockExecution",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "totalBlocksCommitted",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalBlocksVerified",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalBlocksExecuted",
            type: "uint256"
          }
        ],
        name: "BlocksRevert",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "previousLastVerifiedBlock",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "currentLastVerifiedBlock",
            type: "uint256"
          }
        ],
        name: "BlocksVerification",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          }
        ],
        name: "CancelUpgradeProposal",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "EthWithdrawalFinalized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "proposalSalt",
            type: "bytes32"
          }
        ],
        name: "ExecuteUpgrade",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "Freeze",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bool",
            name: "isPorterAvailable",
            type: "bool"
          }
        ],
        name: "IsPorterAvailableStatusUpdate",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldGovernor",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newGovernor",
            type: "address"
          }
        ],
        name: "NewGovernor",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousBytecodeHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "NewL2BootloaderBytecodeHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousBytecodeHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "NewL2DefaultAccountBytecodeHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldPendingGovernor",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newPendingGovernor",
            type: "address"
          }
        ],
        name: "NewPendingGovernor",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "txId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint64",
            name: "expirationTimestamp",
            type: "uint64"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "txType",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "from",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "to",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasPerPubdataByteLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymaster",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "value",
                type: "uint256"
              },
              {
                internalType: "uint256[4]",
                name: "reserved",
                type: "uint256[4]"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              },
              {
                internalType: "uint256[]",
                name: "factoryDeps",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "paymasterInput",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "reservedDynamic",
                type: "bytes"
              }
            ],
            indexed: false,
            internalType: "struct IMailbox.L2CanonicalTransaction",
            name: "transaction",
            type: "tuple"
          },
          {
            indexed: false,
            internalType: "bytes[]",
            name: "factoryDeps",
            type: "bytes[]"
          }
        ],
        name: "NewPriorityRequest",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "oldPriorityTxMaxGasLimit",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newPriorityTxMaxGasLimit",
            type: "uint256"
          }
        ],
        name: "NewPriorityTxMaxGasLimit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldVerifier",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newVerifier",
            type: "address"
          }
        ],
        name: "NewVerifier",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct VerifierParams",
            name: "oldVerifierParams",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct VerifierParams",
            name: "newVerifierParams",
            type: "tuple"
          }
        ],
        name: "NewVerifierParams",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          }
        ],
        name: "ProposeShadowUpgrade",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            indexed: false,
            internalType: "struct Diamond.DiamondCutData",
            name: "diamondCut",
            type: "tuple"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "proposalSalt",
            type: "bytes32"
          }
        ],
        name: "ProposeTransparentUpgrade",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          }
        ],
        name: "SecurityCouncilUpgradeApprove",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "Unfreeze",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "validatorAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "isActive",
            type: "bool"
          }
        ],
        name: "ValidatorStatusUpdate",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_proposedUpgradeHash",
            type: "bytes32"
          }
        ],
        name: "cancelUpgradeProposal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo",
            name: "_lastCommittedBlockData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "uint64",
                name: "timestamp",
                type: "uint64"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "newStateRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes",
                name: "initialStorageChanges",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "repeatedStorageChanges",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "l2Logs",
                type: "bytes"
              },
              {
                internalType: "bytes[]",
                name: "l2ArbitraryLengthMessages",
                type: "bytes[]"
              },
              {
                internalType: "bytes[]",
                name: "factoryDeps",
                type: "bytes[]"
              }
            ],
            internalType: "struct IExecutor.CommitBlockInfo[]",
            name: "_newBlocksData",
            type: "tuple[]"
          }
        ],
        name: "commitBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo[]",
            name: "_blocksData",
            type: "tuple[]"
          }
        ],
        name: "executeBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            internalType: "struct Diamond.DiamondCutData",
            name: "_diamondCut",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "_proposalSalt",
            type: "bytes32"
          }
        ],
        name: "executeUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facet",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facets",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "addr",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "selectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IGetters.Facet[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes",
            name: "_message",
            type: "bytes"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          }
        ],
        name: "finalizeEthWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "freezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getCurrentProposalId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getFirstUnprocessedPriorityTx",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getGovernor",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getL2BootloaderBytecodeHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getL2DefaultAccountBytecodeHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPendingGovernor",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPriorityQueueSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getProposedUpgradeHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getProposedUpgradeTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSecurityCouncil",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalBlocksCommitted",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalBlocksExecuted",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalBlocksVerified",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalPriorityTxs",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getUpgradeProposalState",
        outputs: [
          {
            internalType: "enum UpgradeState",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVerifier",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVerifierParams",
        outputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            internalType: "struct VerifierParams",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getpriorityTxMaxGasLimit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isApprovedBySecurityCouncil",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isDiamondStorageFrozen",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          }
        ],
        name: "isEthWithdrawalFinalized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "isFacetFreezable",
        outputs: [
          {
            internalType: "bool",
            name: "isFreezable",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "isFunctionFreezable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_address",
            type: "address"
          }
        ],
        name: "isValidator",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          }
        ],
        name: "l2LogsRootHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "hash",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_gasPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2GasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2GasPerPubdataByteLimit",
            type: "uint256"
          }
        ],
        name: "l2TransactionBaseCost",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "priorityQueueFrontOperation",
        outputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "canonicalTxHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "expirationTimestamp",
                type: "uint64"
              },
              {
                internalType: "uint192",
                name: "layer2Tip",
                type: "uint192"
              }
            ],
            internalType: "struct PriorityOperation",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_proposalHash",
            type: "bytes32"
          },
          {
            internalType: "uint40",
            name: "_proposalId",
            type: "uint40"
          }
        ],
        name: "proposeShadowUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            internalType: "struct Diamond.DiamondCutData",
            name: "_diamondCut",
            type: "tuple"
          },
          {
            internalType: "uint40",
            name: "_proposalId",
            type: "uint40"
          }
        ],
        name: "proposeTransparentUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo",
            name: "_prevBlock",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo[]",
            name: "_committedBlocks",
            type: "tuple[]"
          },
          {
            components: [
              {
                internalType: "uint256[]",
                name: "recursiveAggregationInput",
                type: "uint256[]"
              },
              {
                internalType: "uint256[]",
                name: "serializedProof",
                type: "uint256[]"
              }
            ],
            internalType: "struct IExecutor.ProofInput",
            name: "_proof",
            type: "tuple"
          }
        ],
        name: "proveBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_l2TxHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          },
          {
            internalType: "enum TxStatus",
            name: "_status",
            type: "uint8"
          }
        ],
        name: "proveL1ToL2TransactionStatus",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint8",
                name: "l2ShardId",
                type: "uint8"
              },
              {
                internalType: "bool",
                name: "isService",
                type: "bool"
              },
              {
                internalType: "uint16",
                name: "txNumberInBlock",
                type: "uint16"
              },
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bytes32",
                name: "key",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "value",
                type: "bytes32"
              }
            ],
            internalType: "struct L2Log",
            name: "_log",
            type: "tuple"
          },
          {
            internalType: "bytes32[]",
            name: "_proof",
            type: "bytes32[]"
          }
        ],
        name: "proveL2LogInclusion",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint16",
                name: "txNumberInBlock",
                type: "uint16"
              },
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              }
            ],
            internalType: "struct L2Message",
            name: "_message",
            type: "tuple"
          },
          {
            internalType: "bytes32[]",
            name: "_proof",
            type: "bytes32[]"
          }
        ],
        name: "proveL2MessageInclusion",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractL2",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_l2Value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "_l2GasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2GasPerPubdataByteLimit",
            type: "uint256"
          },
          {
            internalType: "bytes[]",
            name: "_factoryDeps",
            type: "bytes[]"
          },
          {
            internalType: "address",
            name: "_refundRecipient",
            type: "address"
          }
        ],
        name: "requestL2Transaction",
        outputs: [
          {
            internalType: "bytes32",
            name: "canonicalTxHash",
            type: "bytes32"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_newLastBlock",
            type: "uint256"
          }
        ],
        name: "revertBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_upgradeProposalHash",
            type: "bytes32"
          }
        ],
        name: "securityCouncilUpgradeApprove",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_l2BootloaderBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "setL2BootloaderBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_l2DefaultAccountBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "setL2DefaultAccountBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newPendingGovernor",
            type: "address"
          }
        ],
        name: "setPendingGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "_zkPorterIsAvailable",
            type: "bool"
          }
        ],
        name: "setPorterAvailability",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_newPriorityTxMaxGasLimit",
            type: "uint256"
          }
        ],
        name: "setPriorityTxMaxGasLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_validator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "_active",
            type: "bool"
          }
        ],
        name: "setValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract Verifier",
            name: "_newVerifier",
            type: "address"
          }
        ],
        name: "setVerifier",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            internalType: "struct VerifierParams",
            name: "_newVerifierParams",
            type: "tuple"
          }
        ],
        name: "setVerifierParams",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          }
        ],
        name: "storedBlockHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "unfreezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            internalType: "struct Diamond.DiamondCutData",
            name: "_diamondCut",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "_proposalId",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "_salt",
            type: "bytes32"
          }
        ],
        name: "upgradeProposalHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IERC20MetadataFactory.js
var require_IERC20MetadataFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IERC20MetadataFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IERC20MetadataFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IERC20MetadataFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IERC20MetadataFactory = IERC20MetadataFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IL1BridgeFactory.js
var require_IL1BridgeFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IL1BridgeFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IL1BridgeFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IL1BridgeFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IL1BridgeFactory = IL1BridgeFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "l1Token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "ClaimedFailedDeposit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "l1Token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "DepositInitiated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "l1Token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "WithdrawalFinalized",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_depositSender",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_l2TxHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          }
        ],
        name: "claimFailedDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l2Receiver",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2TxGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2TxGasPerPubdataByte",
            type: "uint256"
          }
        ],
        name: "deposit",
        outputs: [
          {
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes",
            name: "_message",
            type: "bytes"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          }
        ],
        name: "finalizeWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          }
        ],
        name: "isWithdrawalFinalized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          }
        ],
        name: "l2TokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IL2BridgeFactory.js
var require_IL2BridgeFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IL2BridgeFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IL2BridgeFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IL2BridgeFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IL2BridgeFactory = IL2BridgeFactory;
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l2Receiver",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "finalizeDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Bridge",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_l2TokenProxyBytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "_governor",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "l1Bridge",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l2Token",
            type: "address"
          }
        ],
        name: "l1TokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          }
        ],
        name: "l2TokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Receiver",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l2Token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IAllowListFactory.js
var require_IAllowListFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IAllowListFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IAllowListFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IAllowListFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IAllowListFactory = IAllowListFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            indexed: false,
            internalType: "enum IAllowList.AccessMode",
            name: "previousMode",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "enum IAllowList.AccessMode",
            name: "newMode",
            type: "uint8"
          }
        ],
        name: "UpdateAccessMode",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "caller",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            indexed: true,
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "status",
            type: "bool"
          }
        ],
        name: "UpdateCallPermission",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_caller",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "_functionSig",
            type: "bytes4"
          }
        ],
        name: "canCall",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_target",
            type: "address"
          }
        ],
        name: "getAccessMode",
        outputs: [
          {
            internalType: "enum IAllowList.AccessMode",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          }
        ],
        name: "getTokenDepositLimitData",
        outputs: [
          {
            components: [
              {
                internalType: "bool",
                name: "depositLimitation",
                type: "bool"
              },
              {
                internalType: "uint256",
                name: "depositCap",
                type: "uint256"
              }
            ],
            internalType: "struct IAllowList.Deposit",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_caller",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "_functionSig",
            type: "bytes4"
          }
        ],
        name: "hasSpecialAccessToCall",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "enum IAllowList.AccessMode",
            name: "_accessMode",
            type: "uint8"
          }
        ],
        name: "setAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_targets",
            type: "address[]"
          },
          {
            internalType: "enum IAllowList.AccessMode[]",
            name: "_accessMode",
            type: "uint8[]"
          }
        ],
        name: "setBatchAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_callers",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "_targets",
            type: "address[]"
          },
          {
            internalType: "bytes4[]",
            name: "_functionSigs",
            type: "bytes4[]"
          },
          {
            internalType: "bool[]",
            name: "_enables",
            type: "bool[]"
          }
        ],
        name: "setBatchPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "bool",
            name: "_depositLimitation",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "_depositCap",
            type: "uint256"
          }
        ],
        name: "setDepositLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_caller",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "_functionSig",
            type: "bytes4"
          },
          {
            internalType: "bool",
            name: "_enable",
            type: "bool"
          }
        ],
        name: "setPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IEthTokenFactory.js
var require_IEthTokenFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IEthTokenFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEthTokenFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IEthTokenFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IEthTokenFactory = IEthTokenFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Mint",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "_l1Receiver",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "Withdrawal",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_from",
            type: "address"
          },
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "transferFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Receiver",
            type: "address"
          }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/index.js
var require_typechain = __commonJS({
  "node_modules/zksync-web3/build/typechain/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEthTokenFactory = exports.IAllowListFactory = exports.IL2BridgeFactory = exports.IL1BridgeFactory = exports.IERC20MetadataFactory = exports.IZkSyncFactory = void 0;
    var IZkSyncFactory_1 = require_IZkSyncFactory();
    Object.defineProperty(exports, "IZkSyncFactory", { enumerable: true, get: function() {
      return IZkSyncFactory_1.IZkSyncFactory;
    } });
    var IERC20MetadataFactory_1 = require_IERC20MetadataFactory();
    Object.defineProperty(exports, "IERC20MetadataFactory", { enumerable: true, get: function() {
      return IERC20MetadataFactory_1.IERC20MetadataFactory;
    } });
    var IL1BridgeFactory_1 = require_IL1BridgeFactory();
    Object.defineProperty(exports, "IL1BridgeFactory", { enumerable: true, get: function() {
      return IL1BridgeFactory_1.IL1BridgeFactory;
    } });
    var IL2BridgeFactory_1 = require_IL2BridgeFactory();
    Object.defineProperty(exports, "IL2BridgeFactory", { enumerable: true, get: function() {
      return IL2BridgeFactory_1.IL2BridgeFactory;
    } });
    var IAllowListFactory_1 = require_IAllowListFactory();
    Object.defineProperty(exports, "IAllowListFactory", { enumerable: true, get: function() {
      return IAllowListFactory_1.IAllowListFactory;
    } });
    var IEthTokenFactory_1 = require_IEthTokenFactory();
    Object.defineProperty(exports, "IEthTokenFactory", { enumerable: true, get: function() {
      return IEthTokenFactory_1.IEthTokenFactory;
    } });
  }
});

// node_modules/zksync-web3/build/src/adapters.js
var require_adapters = __commonJS({
  "node_modules/zksync-web3/build/src/adapters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AdapterL2 = exports.AdapterL1 = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var typechain_1 = require_typechain();
    var utils_1 = require_utils7();
    function AdapterL1(Base) {
      return class Adapter extends Base {
        _providerL2() {
          throw new Error("Must be implemented by the derived class!");
        }
        _providerL1() {
          throw new Error("Must be implemented by the derived class!");
        }
        _signerL1() {
          throw new Error("Must be implemented by the derived class!");
        }
        async getMainContract() {
          const address = await this._providerL2().getMainContractAddress();
          return typechain_1.IZkSyncFactory.connect(address, this._signerL1());
        }
        async getL1BridgeContracts() {
          const addresses = await this._providerL2().getDefaultBridgeAddresses();
          return {
            erc20: typechain_1.IL1BridgeFactory.connect(addresses.erc20L1, this._signerL1())
          };
        }
        async getBalanceL1(token, blockTag) {
          token !== null && token !== void 0 ? token : token = utils_1.ETH_ADDRESS;
          if ((0, utils_1.isETH)(token)) {
            return await this._providerL1().getBalance(await this.getAddress(), blockTag);
          } else {
            const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._providerL1());
            return await erc20contract.balanceOf(await this.getAddress());
          }
        }
        async l2TokenAddress(token) {
          if (token == utils_1.ETH_ADDRESS) {
            return utils_1.ETH_ADDRESS;
          } else {
            const erc20Bridge = (await this.getL1BridgeContracts()).erc20;
            return await erc20Bridge.l2TokenAddress(token);
          }
        }
        async approveERC20(token, amount, overrides) {
          if ((0, utils_1.isETH)(token)) {
            throw new Error("ETH token can't be approved. The address of the token does not exist on L1.");
          }
          let bridgeAddress = overrides === null || overrides === void 0 ? void 0 : overrides.bridgeAddress;
          const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._signerL1());
          if (bridgeAddress == null) {
            bridgeAddress = (await this._providerL2().getDefaultBridgeAddresses()).erc20L1;
          } else {
            delete overrides.bridgeAddress;
          }
          return await erc20contract.approve(bridgeAddress, amount, overrides);
        }
        async getBaseCost(params) {
          var _a, _b;
          const zksyncContract = await this.getMainContract();
          const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
          (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : parameters.gasPrice = await this._providerL1().getGasPrice();
          (_b = parameters.gasPerPubdataByte) !== null && _b !== void 0 ? _b : parameters.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
          return ethers_1.BigNumber.from(await zksyncContract.l2TransactionBaseCost(parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte));
        }
        async deposit(transaction) {
          var _a;
          const depositTx = await this.getDepositTx(transaction);
          if (transaction.token == utils_1.ETH_ADDRESS) {
            return this.requestExecute(depositTx);
          } else {
            const bridgeContracts = await this.getL1BridgeContracts();
            if (transaction.approveERC20) {
              const approveTx = await this.approveERC20(transaction.token, transaction.amount, {
                bridgeAddress: (_a = transaction.bridgeAddress) !== null && _a !== void 0 ? _a : bridgeContracts.erc20.address,
                ...transaction.approveOverrides
              });
              await approveTx.wait();
            }
            return await this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(depositTx));
          }
        }
        async estimateGasDeposit(transaction) {
          const depositTx = await this.getDepositTx(transaction);
          if (transaction.token == utils_1.ETH_ADDRESS) {
            return await this.estimateGasRequestExecute(depositTx);
          } else {
            return await this._providerL1().estimateGas(depositTx);
          }
        }
        async getDepositTx(transaction) {
          var _a, _b, _c, _d, _e, _f, _g;
          const bridgeContracts = await this.getL1BridgeContracts();
          if (transaction.bridgeAddress) {
            bridgeContracts.erc20.attach(transaction.bridgeAddress);
          }
          const { ...tx } = transaction;
          (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = await this.getAddress();
          (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);
          (_c = tx.overrides) !== null && _c !== void 0 ? _c : tx.overrides = {};
          (_d = tx.gasPerPubdataByte) !== null && _d !== void 0 ? _d : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
          (_e = tx.l2GasLimit) !== null && _e !== void 0 ? _e : tx.l2GasLimit = await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._providerL1(), this._providerL2(), tx.token, tx.amount, tx.to, await this.getAddress(), tx.gasPerPubdataByte);
          const { to, token, amount, operatorTip, overrides } = tx;
          await insertGasPrice(this._providerL1(), overrides);
          const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
          const zksyncContract = await this.getMainContract();
          const baseCost = await zksyncContract.l2TransactionBaseCost(await gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte);
          if (token == utils_1.ETH_ADDRESS) {
            (_f = overrides.value) !== null && _f !== void 0 ? _f : overrides.value = baseCost.add(operatorTip).add(amount);
            return {
              contractAddress: to,
              calldata: "0x",
              l2Value: amount,
              // For some reason typescript can not deduce that we've already set the
              // tx.l2GasLimit
              l2GasLimit: tx.l2GasLimit,
              ...tx
            };
          } else {
            const args = [
              to,
              token,
              amount,
              tx.l2GasLimit,
              tx.gasPerPubdataByte
            ];
            (_g = overrides.value) !== null && _g !== void 0 ? _g : overrides.value = baseCost.add(operatorTip);
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return await bridgeContracts.erc20.populateTransaction.deposit(...args, overrides);
          }
        }
        async _getWithdrawalLog(withdrawalHash, index = 0) {
          const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
          const receipt = await this._providerL2().getTransactionReceipt(hash);
          const log = receipt.logs.filter((log2) => log2.address == utils_1.L1_MESSENGER_ADDRESS && log2.topics[0] == ethers_1.ethers.utils.id("L1MessageSent(address,bytes32,bytes)"))[index];
          return {
            log,
            l1BatchTxId: receipt.l1BatchTxIndex
          };
        }
        async _getWithdrawalL2ToL1Log(withdrawalHash, index = 0) {
          const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
          const receipt = await this._providerL2().getTransactionReceipt(hash);
          const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([_, log]) => log.sender == utils_1.L1_MESSENGER_ADDRESS);
          const [l2ToL1LogIndex, l2ToL1Log] = messages[index];
          return {
            l2ToL1LogIndex,
            l2ToL1Log
          };
        }
        async finalizeWithdrawalParams(withdrawalHash, index = 0) {
          const { log, l1BatchTxId } = await this._getWithdrawalLog(withdrawalHash, index);
          const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
          const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
          const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
          const message = ethers_1.ethers.utils.defaultAbiCoder.decode(["bytes"], log.data)[0];
          return {
            l1BatchNumber: log.l1BatchNumber,
            l2MessageIndex: proof.id,
            l2TxNumberInBlock: l1BatchTxId,
            message,
            sender,
            proof: proof.proof
          };
        }
        async finalizeWithdrawal(withdrawalHash, index = 0, overrides) {
          const { l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, sender, proof } = await this.finalizeWithdrawalParams(withdrawalHash, index);
          if ((0, utils_1.isETH)(sender)) {
            const contractAddress = await this._providerL2().getMainContractAddress();
            const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
            return await zksync.finalizeEthWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
          }
          const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
          const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._signerL1());
          return await l1Bridge.finalizeWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
        }
        async isWithdrawalFinalized(withdrawalHash, index = 0) {
          const { log } = await this._getWithdrawalLog(withdrawalHash, index);
          const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
          const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
          const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
          if ((0, utils_1.isETH)(sender)) {
            const contractAddress = await this._providerL2().getMainContractAddress();
            const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
            return await zksync.isEthWithdrawalFinalized(log.l1BatchNumber, proof.id);
          }
          const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
          const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._providerL1());
          return await l1Bridge.isWithdrawalFinalized(log.l1BatchNumber, proof.id);
        }
        async claimFailedDeposit(depositHash, overrides) {
          const receipt = await this._providerL2().getTransactionReceipt(ethers_1.ethers.utils.hexlify(depositHash));
          const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex((l2ToL1log) => l2ToL1log.sender == utils_1.BOOTLOADER_FORMAL_ADDRESS && l2ToL1log.key == depositHash);
          const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];
          if (successL2ToL1Log.value != ethers_1.ethers.constants.HashZero) {
            throw new Error("Cannot claim successful deposit");
          }
          const tx = await this._providerL2().getTransaction(ethers_1.ethers.utils.hexlify(depositHash));
          const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);
          const l2BridgeAddress = receipt.to;
          const l1Bridge = typechain_1.IL1BridgeFactory.connect(l1BridgeAddress, this._signerL1());
          const l2Bridge = typechain_1.IL2BridgeFactory.connect(l2BridgeAddress, this._providerL2());
          const calldata = l2Bridge.interface.decodeFunctionData("finalizeDeposit", tx.data);
          const proof = await this._providerL2().getLogProof(depositHash, successL2ToL1LogIndex);
          return await l1Bridge.claimFailedDeposit(calldata["_l1Sender"], calldata["_l1Token"], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof, overrides !== null && overrides !== void 0 ? overrides : {});
        }
        async requestExecute(transaction) {
          const requestExecuteTx = await this.getRequestExecuteTx(transaction);
          return this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(requestExecuteTx));
        }
        async estimateGasRequestExecute(transaction) {
          const requestExecuteTx = await this.getRequestExecuteTx(transaction);
          return this._providerL1().estimateGas(requestExecuteTx);
        }
        async getRequestExecuteTx(transaction) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const zksyncContract = await this.getMainContract();
          const { ...tx } = transaction;
          (_a = tx.l2Value) !== null && _a !== void 0 ? _a : tx.l2Value = ethers_1.BigNumber.from(0);
          (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);
          (_c = tx.factoryDeps) !== null && _c !== void 0 ? _c : tx.factoryDeps = [];
          (_d = tx.overrides) !== null && _d !== void 0 ? _d : tx.overrides = {};
          (_e = tx.gasPerPubdataByte) !== null && _e !== void 0 ? _e : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
          (_f = tx.refundRecipient) !== null && _f !== void 0 ? _f : tx.refundRecipient = await this.getAddress();
          (_g = tx.l2GasLimit) !== null && _g !== void 0 ? _g : tx.l2GasLimit = await this._providerL2().estimateL1ToL2Execute(transaction);
          const { contractAddress, l2Value, calldata, l2GasLimit, factoryDeps, operatorTip, overrides, gasPerPubdataByte, refundRecipient } = tx;
          await insertGasPrice(this._providerL1(), overrides);
          const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
          const baseCost = await this.getBaseCost({
            gasPrice: await gasPriceForEstimation,
            gasPerPubdataByte,
            gasLimit: l2GasLimit
          });
          (_h = overrides.value) !== null && _h !== void 0 ? _h : overrides.value = baseCost.add(operatorTip).add(l2Value);
          await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
          return await zksyncContract.populateTransaction.requestL2Transaction(contractAddress, l2Value, calldata, l2GasLimit, utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT, factoryDeps, refundRecipient, overrides);
        }
      };
    }
    exports.AdapterL1 = AdapterL1;
    function AdapterL2(Base) {
      return class Adapter extends Base {
        _providerL2() {
          throw new Error("Must be implemented by the derived class!");
        }
        _signerL2() {
          throw new Error("Must be implemented by the derived class!");
        }
        async getBalance(token, blockTag = "committed") {
          return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);
        }
        async getAllBalances() {
          return await this._providerL2().getAllAccountBalances(await this.getAddress());
        }
        async getL2BridgeContracts() {
          const addresses = await this._providerL2().getDefaultBridgeAddresses();
          return {
            erc20: typechain_1.IL2BridgeFactory.connect(addresses.erc20L2, this._signerL2())
          };
        }
        _fillCustomData(data) {
          var _a, _b;
          const customData = { ...data };
          (_a = customData.gasPerPubdata) !== null && _a !== void 0 ? _a : customData.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
          (_b = customData.factoryDeps) !== null && _b !== void 0 ? _b : customData.factoryDeps = [];
          return customData;
        }
        async withdraw(transaction) {
          const withdrawTx = await this._providerL2().getWithdrawTx({
            from: await this.getAddress(),
            ...transaction
          });
          const txResponse = await this.sendTransaction(withdrawTx);
          return this._providerL2()._wrapTransaction(txResponse);
        }
        async transfer(transaction) {
          const transferTx = await this._providerL2().getTransferTx({
            from: await this.getAddress(),
            ...transaction
          });
          const txResponse = await this.sendTransaction(transferTx);
          return this._providerL2()._wrapTransaction(txResponse);
        }
      };
    }
    exports.AdapterL2 = AdapterL2;
    async function insertGasPrice(l1Provider, overrides) {
      if (!overrides.gasPrice && !overrides.maxFeePerGas) {
        const l1FeeData = await l1Provider.getFeeData();
        const baseFee = l1FeeData.lastBaseFeePerGas || l1FeeData.gasPrice;
        const maxFeePerGas = baseFee.mul(3).div(2).add(l1FeeData.maxPriorityFeePerGas);
        overrides.maxFeePerGas = maxFeePerGas;
        overrides.maxPriorityFeePerGas = l1FeeData.maxPriorityFeePerGas;
      }
    }
  }
});

// node_modules/zksync-web3/build/src/signer.js
var require_signer2 = __commonJS({
  "node_modules/zksync-web3/build/src/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.eip712Types = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var utils_1 = require_utils7();
    var hash_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var adapters_1 = require_adapters();
    exports.eip712Types = {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    };
    var EIP712Signer = class _EIP712Signer {
      constructor(ethSigner, chainId) {
        this.ethSigner = ethSigner;
        this.eip712Domain = Promise.resolve(chainId).then((chainId2) => ({
          name: "zkSync",
          version: "2",
          chainId: chainId2
        }));
      }
      static getSignInput(transaction) {
        var _a, _b, _c, _d, _e, _f, _g;
        const maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice;
        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
        const gasPerPubdataByteLimit = ((_a = transaction.customData) === null || _a === void 0 ? void 0 : _a.gasPerPubdata) || utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        const signInput = {
          txType: transaction.type,
          from: transaction.from,
          to: transaction.to,
          gasLimit: transaction.gasLimit,
          gasPerPubdataByteLimit,
          maxFeePerGas,
          maxPriorityFeePerGas,
          paymaster: ((_c = (_b = transaction.customData) === null || _b === void 0 ? void 0 : _b.paymasterParams) === null || _c === void 0 ? void 0 : _c.paymaster) || ethers_1.ethers.constants.AddressZero,
          nonce: transaction.nonce,
          value: transaction.value,
          data: transaction.data,
          factoryDeps: ((_e = (_d = transaction.customData) === null || _d === void 0 ? void 0 : _d.factoryDeps) === null || _e === void 0 ? void 0 : _e.map((dep) => (0, utils_1.hashBytecode)(dep))) || [],
          paymasterInput: ((_g = (_f = transaction.customData) === null || _f === void 0 ? void 0 : _f.paymasterParams) === null || _g === void 0 ? void 0 : _g.paymasterInput) || "0x"
        };
        return signInput;
      }
      async sign(transaction) {
        return await this.ethSigner._signTypedData(await this.eip712Domain, exports.eip712Types, _EIP712Signer.getSignInput(transaction));
      }
      static getSignedDigest(transaction) {
        if (!transaction.chainId) {
          throw Error("Transaction chainId isn't set");
        }
        const domain = {
          name: "zkSync",
          version: "2",
          chainId: transaction.chainId
        };
        return hash_1._TypedDataEncoder.hash(domain, exports.eip712Types, _EIP712Signer.getSignInput(transaction));
      }
    };
    exports.EIP712Signer = EIP712Signer;
    var Signer = class _Signer extends (0, adapters_1.AdapterL2)(ethers_1.ethers.providers.JsonRpcSigner) {
      _signerL2() {
        return this;
      }
      _providerL2() {
        return this.provider;
      }
      static from(signer) {
        const newSigner = Object.setPrototypeOf(signer, _Signer.prototype);
        newSigner.eip712 = new EIP712Signer(newSigner, newSigner.getChainId());
        return newSigner;
      }
      // an alias with a better name
      async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
      }
      async sendTransaction(transaction) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (transaction.customData == null && transaction.type == null) {
          transaction.type = 0;
        }
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
          return await super.sendTransaction(transaction);
        } else {
          const address = await this.getAddress();
          (_a = transaction.from) !== null && _a !== void 0 ? _a : transaction.from = address;
          if (transaction.from.toLowerCase() != address.toLowerCase()) {
            throw new Error("Transaction `from` address mismatch");
          }
          transaction.type = utils_1.EIP712_TX_TYPE;
          (_b = transaction.value) !== null && _b !== void 0 ? _b : transaction.value = 0;
          (_c = transaction.data) !== null && _c !== void 0 ? _c : transaction.data = "0x";
          (_d = transaction.nonce) !== null && _d !== void 0 ? _d : transaction.nonce = await this.getNonce();
          transaction.customData = this._fillCustomData(transaction.customData);
          (_e = transaction.gasPrice) !== null && _e !== void 0 ? _e : transaction.gasPrice = await this.provider.getGasPrice();
          (_f = transaction.gasLimit) !== null && _f !== void 0 ? _f : transaction.gasLimit = await this.provider.estimateGas(transaction);
          (_g = transaction.chainId) !== null && _g !== void 0 ? _g : transaction.chainId = (await this.provider.getNetwork()).chainId;
          transaction.customData.customSignature = await this.eip712.sign(transaction);
          const txBytes = (0, utils_1.serialize)(transaction);
          return await this.provider.sendTransaction(txBytes);
        }
      }
    };
    exports.Signer = Signer;
    var L1Signer = class _L1Signer extends (0, adapters_1.AdapterL1)(ethers_1.ethers.providers.JsonRpcSigner) {
      _providerL2() {
        return this.providerL2;
      }
      _providerL1() {
        return this.provider;
      }
      _signerL1() {
        return this;
      }
      static from(signer, zksyncProvider) {
        const newSigner = Object.setPrototypeOf(signer, _L1Signer.prototype);
        newSigner.providerL2 = zksyncProvider;
        return newSigner;
      }
      connectToL2(provider) {
        this.providerL2 = provider;
        return this;
      }
    };
    exports.L1Signer = L1Signer;
  }
});

// node_modules/zksync-web3/abi/IPaymasterFlow.json
var require_IPaymasterFlow = __commonJS({
  "node_modules/zksync-web3/abi/IPaymasterFlow.json"(exports, module) {
    module.exports = {
      abi: [
        {
          inputs: [
            {
              internalType: "address",
              name: "_token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_minAllowance",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "_innerInput",
              type: "bytes"
            }
          ],
          name: "approvalBased",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "input",
              type: "bytes"
            }
          ],
          name: "general",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/build/src/paymaster-utils.js
var require_paymaster_utils = __commonJS({
  "node_modules/zksync-web3/build/src/paymaster-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPaymasterParams = exports.getGeneralPaymasterInput = exports.getApprovalBasedPaymasterInput = exports.IPaymasterFlow = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    exports.IPaymasterFlow = new ethers_1.ethers.utils.Interface(require_IPaymasterFlow().abi);
    function getApprovalBasedPaymasterInput(paymasterInput) {
      return exports.IPaymasterFlow.encodeFunctionData("approvalBased", [
        paymasterInput.token,
        paymasterInput.minimalAllowance,
        paymasterInput.innerInput
      ]);
    }
    exports.getApprovalBasedPaymasterInput = getApprovalBasedPaymasterInput;
    function getGeneralPaymasterInput(paymasterInput) {
      return exports.IPaymasterFlow.encodeFunctionData("general", [paymasterInput.innerInput]);
    }
    exports.getGeneralPaymasterInput = getGeneralPaymasterInput;
    function getPaymasterParams(paymasterAddress, paymasterInput) {
      if (paymasterInput.type == "General") {
        return {
          paymaster: paymasterAddress,
          paymasterInput: getGeneralPaymasterInput(paymasterInput)
        };
      } else {
        return {
          paymaster: paymasterAddress,
          paymasterInput: getApprovalBasedPaymasterInput(paymasterInput)
        };
      }
    }
    exports.getPaymasterParams = getPaymasterParams;
  }
});

// node_modules/zksync-web3/abi/IZkSync.json
var require_IZkSync = __commonJS({
  "node_modules/zksync-web3/abi/IZkSync.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "blockNumber",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "blockHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "commitment",
              type: "bytes32"
            }
          ],
          name: "BlockCommit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "blockNumber",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "blockHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "commitment",
              type: "bytes32"
            }
          ],
          name: "BlockExecution",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "totalBlocksCommitted",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "totalBlocksVerified",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "totalBlocksExecuted",
              type: "uint256"
            }
          ],
          name: "BlocksRevert",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "previousLastVerifiedBlock",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "uint256",
              name: "currentLastVerifiedBlock",
              type: "uint256"
            }
          ],
          name: "BlocksVerification",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            }
          ],
          name: "CancelUpgradeProposal",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "EthWithdrawalFinalized",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "bytes32",
              name: "proposalSalt",
              type: "bytes32"
            }
          ],
          name: "ExecuteUpgrade",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [],
          name: "Freeze",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bool",
              name: "isPorterAvailable",
              type: "bool"
            }
          ],
          name: "IsPorterAvailableStatusUpdate",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "oldGovernor",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "newGovernor",
              type: "address"
            }
          ],
          name: "NewGovernor",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "previousBytecodeHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "newBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "NewL2BootloaderBytecodeHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "previousBytecodeHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "newBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "NewL2DefaultAccountBytecodeHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "oldPendingGovernor",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "newPendingGovernor",
              type: "address"
            }
          ],
          name: "NewPendingGovernor",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "txId",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint64",
              name: "expirationTimestamp",
              type: "uint64"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "txType",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "from",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "to",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "gasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "gasPerPubdataByteLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "paymaster",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "uint256[4]",
                  name: "reserved",
                  type: "uint256[4]"
                },
                {
                  internalType: "bytes",
                  name: "data",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                },
                {
                  internalType: "uint256[]",
                  name: "factoryDeps",
                  type: "uint256[]"
                },
                {
                  internalType: "bytes",
                  name: "paymasterInput",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "reservedDynamic",
                  type: "bytes"
                }
              ],
              indexed: false,
              internalType: "struct IMailbox.L2CanonicalTransaction",
              name: "transaction",
              type: "tuple"
            },
            {
              indexed: false,
              internalType: "bytes[]",
              name: "factoryDeps",
              type: "bytes[]"
            }
          ],
          name: "NewPriorityRequest",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "oldPriorityTxMaxGasLimit",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "newPriorityTxMaxGasLimit",
              type: "uint256"
            }
          ],
          name: "NewPriorityTxMaxGasLimit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "oldVerifier",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "newVerifier",
              type: "address"
            }
          ],
          name: "NewVerifier",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              indexed: false,
              internalType: "struct VerifierParams",
              name: "oldVerifierParams",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              indexed: false,
              internalType: "struct VerifierParams",
              name: "newVerifierParams",
              type: "tuple"
            }
          ],
          name: "NewVerifierParams",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            }
          ],
          name: "ProposeShadowUpgrade",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              indexed: false,
              internalType: "struct Diamond.DiamondCutData",
              name: "diamondCut",
              type: "tuple"
            },
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes32",
              name: "proposalSalt",
              type: "bytes32"
            }
          ],
          name: "ProposeTransparentUpgrade",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            }
          ],
          name: "SecurityCouncilUpgradeApprove",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [],
          name: "Unfreeze",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "validatorAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bool",
              name: "isActive",
              type: "bool"
            }
          ],
          name: "ValidatorStatusUpdate",
          type: "event"
        },
        {
          inputs: [],
          name: "acceptGovernor",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_proposedUpgradeHash",
              type: "bytes32"
            }
          ],
          name: "cancelUpgradeProposal",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo",
              name: "_lastCommittedBlockData",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "uint64",
                  name: "timestamp",
                  type: "uint64"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "newStateRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes",
                  name: "initialStorageChanges",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "repeatedStorageChanges",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "l2Logs",
                  type: "bytes"
                },
                {
                  internalType: "bytes[]",
                  name: "l2ArbitraryLengthMessages",
                  type: "bytes[]"
                },
                {
                  internalType: "bytes[]",
                  name: "factoryDeps",
                  type: "bytes[]"
                }
              ],
              internalType: "struct IExecutor.CommitBlockInfo[]",
              name: "_newBlocksData",
              type: "tuple[]"
            }
          ],
          name: "commitBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo[]",
              name: "_blocksData",
              type: "tuple[]"
            }
          ],
          name: "executeBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              internalType: "struct Diamond.DiamondCutData",
              name: "_diamondCut",
              type: "tuple"
            },
            {
              internalType: "bytes32",
              name: "_proposalSalt",
              type: "bytes32"
            }
          ],
          name: "executeUpgrade",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "_selector",
              type: "bytes4"
            }
          ],
          name: "facetAddress",
          outputs: [
            {
              internalType: "address",
              name: "facet",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "facetAddresses",
          outputs: [
            {
              internalType: "address[]",
              name: "facets",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_facet",
              type: "address"
            }
          ],
          name: "facetFunctionSelectors",
          outputs: [
            {
              internalType: "bytes4[]",
              name: "",
              type: "bytes4[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "facets",
          outputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "addr",
                  type: "address"
                },
                {
                  internalType: "bytes4[]",
                  name: "selectors",
                  type: "bytes4[]"
                }
              ],
              internalType: "struct IGetters.Facet[]",
              name: "",
              type: "tuple[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            }
          ],
          name: "finalizeEthWithdrawal",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "freezeDiamond",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getCurrentProposalId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getFirstUnprocessedPriorityTx",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getGovernor",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getL2BootloaderBytecodeHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getL2DefaultAccountBytecodeHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getPendingGovernor",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getPriorityQueueSize",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getProposedUpgradeHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getProposedUpgradeTimestamp",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getSecurityCouncil",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalBlocksCommitted",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalBlocksExecuted",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalBlocksVerified",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalPriorityTxs",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getUpgradeProposalState",
          outputs: [
            {
              internalType: "enum UpgradeState",
              name: "",
              type: "uint8"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getVerifier",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getVerifierParams",
          outputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              internalType: "struct VerifierParams",
              name: "",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getpriorityTxMaxGasLimit",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "isApprovedBySecurityCouncil",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "isDiamondStorageFrozen",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            }
          ],
          name: "isEthWithdrawalFinalized",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_facet",
              type: "address"
            }
          ],
          name: "isFacetFreezable",
          outputs: [
            {
              internalType: "bool",
              name: "isFreezable",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "_selector",
              type: "bytes4"
            }
          ],
          name: "isFunctionFreezable",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_address",
              type: "address"
            }
          ],
          name: "isValidator",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            }
          ],
          name: "l2LogsRootHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "hash",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_gasPrice",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2GasLimit",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2GasPerPubdataByteLimit",
              type: "uint256"
            }
          ],
          name: "l2TransactionBaseCost",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "priorityQueueFrontOperation",
          outputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "canonicalTxHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "expirationTimestamp",
                  type: "uint64"
                },
                {
                  internalType: "uint192",
                  name: "layer2Tip",
                  type: "uint192"
                }
              ],
              internalType: "struct PriorityOperation",
              name: "",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_proposalHash",
              type: "bytes32"
            },
            {
              internalType: "uint40",
              name: "_proposalId",
              type: "uint40"
            }
          ],
          name: "proposeShadowUpgrade",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              internalType: "struct Diamond.DiamondCutData",
              name: "_diamondCut",
              type: "tuple"
            },
            {
              internalType: "uint40",
              name: "_proposalId",
              type: "uint40"
            }
          ],
          name: "proposeTransparentUpgrade",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo",
              name: "_prevBlock",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo[]",
              name: "_committedBlocks",
              type: "tuple[]"
            },
            {
              components: [
                {
                  internalType: "uint256[]",
                  name: "recursiveAggregationInput",
                  type: "uint256[]"
                },
                {
                  internalType: "uint256[]",
                  name: "serializedProof",
                  type: "uint256[]"
                }
              ],
              internalType: "struct IExecutor.ProofInput",
              name: "_proof",
              type: "tuple"
            }
          ],
          name: "proveBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_l2TxHash",
              type: "bytes32"
            },
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            },
            {
              internalType: "enum TxStatus",
              name: "_status",
              type: "uint8"
            }
          ],
          name: "proveL1ToL2TransactionStatus",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_index",
              type: "uint256"
            },
            {
              components: [
                {
                  internalType: "uint8",
                  name: "l2ShardId",
                  type: "uint8"
                },
                {
                  internalType: "bool",
                  name: "isService",
                  type: "bool"
                },
                {
                  internalType: "uint16",
                  name: "txNumberInBlock",
                  type: "uint16"
                },
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "bytes32",
                  name: "key",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "value",
                  type: "bytes32"
                }
              ],
              internalType: "struct L2Log",
              name: "_log",
              type: "tuple"
            },
            {
              internalType: "bytes32[]",
              name: "_proof",
              type: "bytes32[]"
            }
          ],
          name: "proveL2LogInclusion",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_index",
              type: "uint256"
            },
            {
              components: [
                {
                  internalType: "uint16",
                  name: "txNumberInBlock",
                  type: "uint16"
                },
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "data",
                  type: "bytes"
                }
              ],
              internalType: "struct L2Message",
              name: "_message",
              type: "tuple"
            },
            {
              internalType: "bytes32[]",
              name: "_proof",
              type: "bytes32[]"
            }
          ],
          name: "proveL2MessageInclusion",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_contractL2",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_l2Value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "_calldata",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "_l2GasLimit",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2GasPerPubdataByteLimit",
              type: "uint256"
            },
            {
              internalType: "bytes[]",
              name: "_factoryDeps",
              type: "bytes[]"
            },
            {
              internalType: "address",
              name: "_refundRecipient",
              type: "address"
            }
          ],
          name: "requestL2Transaction",
          outputs: [
            {
              internalType: "bytes32",
              name: "canonicalTxHash",
              type: "bytes32"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_newLastBlock",
              type: "uint256"
            }
          ],
          name: "revertBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_upgradeProposalHash",
              type: "bytes32"
            }
          ],
          name: "securityCouncilUpgradeApprove",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_l2BootloaderBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "setL2BootloaderBytecodeHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_l2DefaultAccountBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "setL2DefaultAccountBytecodeHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_newPendingGovernor",
              type: "address"
            }
          ],
          name: "setPendingGovernor",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bool",
              name: "_zkPorterIsAvailable",
              type: "bool"
            }
          ],
          name: "setPorterAvailability",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_newPriorityTxMaxGasLimit",
              type: "uint256"
            }
          ],
          name: "setPriorityTxMaxGasLimit",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_validator",
              type: "address"
            },
            {
              internalType: "bool",
              name: "_active",
              type: "bool"
            }
          ],
          name: "setValidator",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "contract Verifier",
              name: "_newVerifier",
              type: "address"
            }
          ],
          name: "setVerifier",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              internalType: "struct VerifierParams",
              name: "_newVerifierParams",
              type: "tuple"
            }
          ],
          name: "setVerifierParams",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            }
          ],
          name: "storedBlockHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "unfreezeDiamond",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              internalType: "struct Diamond.DiamondCutData",
              name: "_diamondCut",
              type: "tuple"
            },
            {
              internalType: "uint256",
              name: "_proposalId",
              type: "uint256"
            },
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            }
          ],
          name: "upgradeProposalHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/ContractDeployer.json
var require_ContractDeployer = __commonJS({
  "node_modules/zksync-web3/abi/ContractDeployer.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "accountAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "enum IContractDeployer.AccountNonceOrdering",
              name: "nonceOrdering",
              type: "uint8"
            }
          ],
          name: "AccountNonceOrderingUpdated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "accountAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "aaVersion",
              type: "uint8"
            }
          ],
          name: "AccountVersionUpdated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "deployerAddress",
              type: "address"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "bytecodeHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "contractAddress",
              type: "address"
            }
          ],
          name: "ContractDeployed",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            }
          ],
          name: "create",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            }
          ],
          name: "create2",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            },
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "_aaVersion",
              type: "uint8"
            }
          ],
          name: "create2Account",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            },
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "_aaVersion",
              type: "uint8"
            }
          ],
          name: "createAccount",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_address",
              type: "address"
            }
          ],
          name: "extendedAccountVersion",
          outputs: [
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "",
              type: "uint8"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "bytecodeHash",
                  type: "bytes32"
                },
                {
                  internalType: "address",
                  name: "newAddress",
                  type: "address"
                },
                {
                  internalType: "bool",
                  name: "callConstructor",
                  type: "bool"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "input",
                  type: "bytes"
                }
              ],
              internalType: "struct ContractDeployer.ForceDeployment",
              name: "_deployment",
              type: "tuple"
            },
            {
              internalType: "address",
              name: "_sender",
              type: "address"
            }
          ],
          name: "forceDeployOnAddress",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "bytecodeHash",
                  type: "bytes32"
                },
                {
                  internalType: "address",
                  name: "newAddress",
                  type: "address"
                },
                {
                  internalType: "bool",
                  name: "callConstructor",
                  type: "bool"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "input",
                  type: "bytes"
                }
              ],
              internalType: "struct ContractDeployer.ForceDeployment[]",
              name: "_deployments",
              type: "tuple[]"
            }
          ],
          name: "forceDeployOnAddresses",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_address",
              type: "address"
            }
          ],
          name: "getAccountInfo",
          outputs: [
            {
              components: [
                {
                  internalType: "enum IContractDeployer.AccountAbstractionVersion",
                  name: "supportedAAVersion",
                  type: "uint8"
                },
                {
                  internalType: "enum IContractDeployer.AccountNonceOrdering",
                  name: "nonceOrdering",
                  type: "uint8"
                }
              ],
              internalType: "struct IContractDeployer.AccountInfo",
              name: "info",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_sender",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_senderNonce",
              type: "uint256"
            }
          ],
          name: "getNewAddressCreate",
          outputs: [
            {
              internalType: "address",
              name: "newAddress",
              type: "address"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_sender",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            }
          ],
          name: "getNewAddressCreate2",
          outputs: [
            {
              internalType: "address",
              name: "newAddress",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "_version",
              type: "uint8"
            }
          ],
          name: "updateAccountVersion",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "enum IContractDeployer.AccountNonceOrdering",
              name: "_nonceOrdering",
              type: "uint8"
            }
          ],
          name: "updateNonceOrdering",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IL1Messenger.json
var require_IL1Messenger = __commonJS({
  "node_modules/zksync-web3/abi/IL1Messenger.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "_sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "_hash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            }
          ],
          name: "L1MessageSent",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            }
          ],
          name: "sendToL1",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IERC20.json
var require_IERC20 = __commonJS({
  "node_modules/zksync-web3/abi/IERC20.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "spender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "Approval",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "Transfer",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "address",
              name: "spender",
              type: "address"
            }
          ],
          name: "allowance",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "spender",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "approve",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            }
          ],
          name: "balanceOf",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "decimals",
          outputs: [
            {
              internalType: "uint8",
              name: "",
              type: "uint8"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "name",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "symbol",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "totalSupply",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transfer",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transferFrom",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IERC1271.json
var require_IERC1271 = __commonJS({
  "node_modules/zksync-web3/abi/IERC1271.json"(exports, module) {
    module.exports = {
      abi: [
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "magicValue",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IL1Bridge.json
var require_IL1Bridge = __commonJS({
  "node_modules/zksync-web3/abi/IL1Bridge.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "ClaimedFailedDeposit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "DepositInitiated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "WithdrawalFinalized",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_depositSender",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "_l2TxHash",
              type: "bytes32"
            },
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            }
          ],
          name: "claimFailedDeposit",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l2Receiver",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_amount",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2TxGasLimit",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2TxGasPerPubdataByte",
              type: "uint256"
            }
          ],
          name: "deposit",
          outputs: [
            {
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            }
          ],
          name: "finalizeWithdrawal",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            }
          ],
          name: "isWithdrawalFinalized",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            }
          ],
          name: "l2TokenAddress",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IL2Bridge.json
var require_IL2Bridge = __commonJS({
  "node_modules/zksync-web3/abi/IL2Bridge.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "l1Sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l2Receiver",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l2Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "FinalizeDeposit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "l2Sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Receiver",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l2Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "WithdrawalInitiated",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Sender",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l2Receiver",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_amount",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "finalizeDeposit",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "l1Bridge",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l2Token",
              type: "address"
            }
          ],
          name: "l1TokenAddress",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            }
          ],
          name: "l2TokenAddress",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Receiver",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l2Token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_amount",
              type: "uint256"
            }
          ],
          name: "withdraw",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/build/src/utils.js
var require_utils7 = __commonJS({
  "node_modules/zksync-web3/build/src/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.parseTransaction = exports.hashBytecode = exports.serialize = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = exports.MAX_BYTECODE_LEN_BYTES = exports.PRIORITY_OPERATION_L2_TX_TYPE = exports.EIP712_TX_TYPE = exports.EIP1271_MAGIC_VALUE = exports.L1_TO_L2_ALIAS_OFFSET = exports.L2_ETH_TOKEN_ADDRESS = exports.L1_MESSENGER_ADDRESS = exports.CONTRACT_DEPLOYER_ADDRESS = exports.BOOTLOADER_FORMAL_ADDRESS = exports.L2_BRIDGE_ABI = exports.L1_BRIDGE_ABI = exports.IERC1271 = exports.IERC20 = exports.L1_MESSENGER = exports.CONTRACT_DEPLOYER = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var types_1 = require_types4();
    var signer_1 = require_signer2();
    var typechain_1 = require_typechain();
    var utils_1 = require_utils();
    __exportStar(require_paymaster_utils(), exports);
    exports.ETH_ADDRESS = "0x0000000000000000000000000000000000000000";
    exports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(require_IZkSync().abi);
    exports.CONTRACT_DEPLOYER = new ethers_1.utils.Interface(require_ContractDeployer().abi);
    exports.L1_MESSENGER = new ethers_1.utils.Interface(require_IL1Messenger().abi);
    exports.IERC20 = new ethers_1.utils.Interface(require_IERC20().abi);
    exports.IERC1271 = new ethers_1.utils.Interface(require_IERC1271().abi);
    exports.L1_BRIDGE_ABI = new ethers_1.utils.Interface(require_IL1Bridge().abi);
    exports.L2_BRIDGE_ABI = new ethers_1.utils.Interface(require_IL2Bridge().abi);
    exports.BOOTLOADER_FORMAL_ADDRESS = "0x0000000000000000000000000000000000008001";
    exports.CONTRACT_DEPLOYER_ADDRESS = "0x0000000000000000000000000000000000008006";
    exports.L1_MESSENGER_ADDRESS = "0x0000000000000000000000000000000000008008";
    exports.L2_ETH_TOKEN_ADDRESS = "0x000000000000000000000000000000000000800a";
    exports.L1_TO_L2_ALIAS_OFFSET = "0x1111000000000000000000000000000000001111";
    exports.EIP1271_MAGIC_VALUE = "0x1626ba7e";
    exports.EIP712_TX_TYPE = 113;
    exports.PRIORITY_OPERATION_L2_TX_TYPE = 255;
    exports.MAX_BYTECODE_LEN_BYTES = ((1 << 16) - 1) * 32;
    exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = 5e4;
    exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = 800;
    function isETH(token) {
      return token.toLowerCase() == exports.ETH_ADDRESS || token.toLowerCase() == exports.L2_ETH_TOKEN_ADDRESS;
    }
    exports.isETH = isETH;
    function sleep(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports.sleep = sleep;
    function layer1TxDefaults() {
      return {
        queueType: types_1.PriorityQueueType.Deque,
        opTree: types_1.PriorityOpTree.Full
      };
    }
    exports.layer1TxDefaults = layer1TxDefaults;
    function getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {
      const encodedMsg = new Uint8Array([
        0,
        1,
        ...ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(txNumberInBlock), 2),
        ...ethers_1.ethers.utils.arrayify(exports.L1_MESSENGER_ADDRESS),
        ...ethers_1.ethers.utils.zeroPad(sender, 32),
        ...ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.keccak256(msg))
      ]);
      return ethers_1.ethers.utils.keccak256(encodedMsg);
    }
    exports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;
    function getDeployedContracts(receipt) {
      const addressBytesLen = 40;
      const deployedContracts = receipt.logs.filter((log) => log.topics[0] == ethers_1.utils.id("ContractDeployed(address,bytes32,address)") && log.address == exports.CONTRACT_DEPLOYER_ADDRESS).map((log) => {
        const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;
        const bytesCodehash = log.topics[2];
        const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;
        return {
          sender: ethers_1.utils.getAddress(sender),
          bytecodeHash: bytesCodehash,
          deployedAddress: ethers_1.utils.getAddress(address)
        };
      });
      return deployedContracts;
    }
    exports.getDeployedContracts = getDeployedContracts;
    function create2Address(sender, bytecodeHash, salt, input) {
      const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes("zksyncCreate2"));
      const inputHash = ethers_1.ethers.utils.keccak256(input);
      const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([prefix, ethers_1.ethers.utils.zeroPad(sender, 32), salt, bytecodeHash, inputHash])).slice(26);
      return ethers_1.ethers.utils.getAddress(addressBytes);
    }
    exports.create2Address = create2Address;
    function createAddress(sender, senderNonce) {
      const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes("zksyncCreate"));
      const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([
        prefix,
        ethers_1.ethers.utils.zeroPad(sender, 32),
        ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(senderNonce), 32)
      ])).slice(26);
      return ethers_1.ethers.utils.getAddress(addressBytes);
    }
    exports.createAddress = createAddress;
    async function checkBaseCost(baseCost, value) {
      if (baseCost.gt(await value)) {
        throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter for the transaction: baseCost: ${baseCost}, provided value: ${value}`);
      }
    }
    exports.checkBaseCost = checkBaseCost;
    function serialize(transaction, signature) {
      var _a;
      if (transaction.customData == null && transaction.type != exports.EIP712_TX_TYPE) {
        return ethers_1.utils.serializeTransaction(transaction, signature);
      }
      if (!transaction.chainId) {
        throw Error("Transaction chainId isn't set");
      }
      function formatNumber(value, name) {
        const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());
        if (result.length > 32) {
          throw new Error("invalid length for " + name);
        }
        return result;
      }
      if (!transaction.from) {
        throw new Error("Explicitly providing `from` field is reqiured for EIP712 transactions");
      }
      const from = transaction.from;
      const meta = transaction.customData;
      let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;
      let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
      const fields = [
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(maxPriorityFeePerGas, "maxPriorityFeePerGas"),
        formatNumber(maxFeePerGas, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x"
      ];
      if (signature) {
        const sig = ethers_1.utils.splitSignature(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push(ethers_1.utils.stripZeros(sig.r));
        fields.push(ethers_1.utils.stripZeros(sig.s));
      } else {
        fields.push(formatNumber(transaction.chainId, "chainId"));
        fields.push("0x");
        fields.push("0x");
      }
      fields.push(formatNumber(transaction.chainId, "chainId"));
      fields.push(ethers_1.utils.getAddress(from));
      fields.push(formatNumber(meta.gasPerPubdata || exports.DEFAULT_GAS_PER_PUBDATA_LIMIT, "gasPerPubdata"));
      fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map((dep) => ethers_1.utils.hexlify(dep)));
      if (meta.customSignature && ethers_1.ethers.utils.arrayify(meta.customSignature).length == 0) {
        throw new Error("Empty signatures are not supported");
      }
      fields.push(meta.customSignature || "0x");
      if (meta.paymasterParams) {
        fields.push([meta.paymasterParams.paymaster, ethers_1.ethers.utils.hexlify(meta.paymasterParams.paymasterInput)]);
      } else {
        fields.push([]);
      }
      return ethers_1.utils.hexConcat([[exports.EIP712_TX_TYPE], ethers_1.utils.RLP.encode(fields)]);
    }
    exports.serialize = serialize;
    function hashBytecode(bytecode) {
      const bytecodeAsArray = ethers_1.ethers.utils.arrayify(bytecode);
      if (bytecodeAsArray.length % 32 != 0) {
        throw new Error("The bytecode length in bytes must be divisible by 32");
      }
      if (bytecodeAsArray.length > exports.MAX_BYTECODE_LEN_BYTES) {
        throw new Error(`Bytecode can not be longer than ${exports.MAX_BYTECODE_LEN_BYTES} bytes`);
      }
      const hashStr = ethers_1.ethers.utils.sha256(bytecodeAsArray);
      const hash = ethers_1.ethers.utils.arrayify(hashStr);
      const bytecodeLengthInWords = bytecodeAsArray.length / 32;
      if (bytecodeLengthInWords % 2 == 0) {
        throw new Error("Bytecode length in 32-byte words must be odd");
      }
      const bytecodeLength = ethers_1.ethers.utils.arrayify(bytecodeLengthInWords);
      const bytecodeLengthPadded = ethers_1.ethers.utils.zeroPad(bytecodeLength, 2);
      const codeHashVersion = new Uint8Array([1, 0]);
      hash.set(codeHashVersion, 0);
      hash.set(bytecodeLengthPadded, 2);
      return hash;
    }
    exports.hashBytecode = hashBytecode;
    function parseTransaction(payload) {
      function handleAddress(value) {
        if (value === "0x") {
          return null;
        }
        return ethers_1.utils.getAddress(value);
      }
      function handleNumber(value) {
        if (value === "0x") {
          return ethers_1.BigNumber.from(0);
        }
        return ethers_1.BigNumber.from(value);
      }
      function arrayToPaymasterParams(arr) {
        if (arr.length == 0) {
          return void 0;
        }
        if (arr.length != 2) {
          throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`);
        }
        return {
          paymaster: ethers_1.utils.getAddress(arr[0]),
          paymasterInput: ethers_1.utils.arrayify(arr[1])
        };
      }
      const bytes = ethers_1.utils.arrayify(payload);
      if (bytes[0] != exports.EIP712_TX_TYPE) {
        return ethers_1.utils.parseTransaction(bytes);
      }
      const raw = ethers_1.utils.RLP.decode(bytes.slice(1));
      const transaction = {
        type: exports.EIP712_TX_TYPE,
        nonce: handleNumber(raw[0]).toNumber(),
        maxPriorityFeePerGas: handleNumber(raw[1]),
        maxFeePerGas: handleNumber(raw[2]),
        gasLimit: handleNumber(raw[3]),
        to: handleAddress(raw[4]),
        value: handleNumber(raw[5]),
        data: raw[6],
        chainId: handleNumber(raw[10]),
        from: handleAddress(raw[11]),
        customData: {
          gasPerPubdata: handleNumber(raw[12]),
          factoryDeps: raw[13],
          customSignature: raw[14],
          paymasterParams: arrayToPaymasterParams(raw[15])
        }
      };
      const ethSignature = {
        v: handleNumber(raw[7]).toNumber(),
        r: raw[8],
        s: raw[9]
      };
      if ((ethers_1.utils.hexlify(ethSignature.r) == "0x" || ethers_1.utils.hexlify(ethSignature.s) == "0x") && !transaction.customData.customSignature) {
        return transaction;
      }
      if (ethSignature.v !== 0 && ethSignature.v !== 1 && !transaction.customData.customSignature) {
        throw new Error("Failed to parse signature");
      }
      if (!transaction.customData.customSignature) {
        transaction.v = ethSignature.v;
        transaction.s = ethSignature.s;
        transaction.r = ethSignature.r;
      }
      transaction.hash = eip712TxHash(transaction, ethSignature);
      return transaction;
    }
    exports.parseTransaction = parseTransaction;
    function getSignature(transaction, ethSignature) {
      var _a;
      if (((_a = transaction === null || transaction === void 0 ? void 0 : transaction.customData) === null || _a === void 0 ? void 0 : _a.customSignature) && transaction.customData.customSignature.length) {
        return ethers_1.ethers.utils.arrayify(transaction.customData.customSignature);
      }
      if (!ethSignature) {
        throw new Error("No signature provided");
      }
      const r = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.r), 32);
      const s = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.s), 32);
      const v = ethSignature.v;
      return new Uint8Array([...r, ...s, v]);
    }
    function eip712TxHash(transaction, ethSignature) {
      const signedDigest = signer_1.EIP712Signer.getSignedDigest(transaction);
      const hashedSignature = ethers_1.ethers.utils.keccak256(getSignature(transaction, ethSignature));
      return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.hexConcat([signedDigest, hashedSignature]));
    }
    function getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {
      let txHash = null;
      for (const log of txReceipt.logs) {
        if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {
          continue;
        }
        try {
          const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);
          if (priorityQueueLog && priorityQueueLog.args.txHash != null) {
            txHash = priorityQueueLog.args.txHash;
          }
        } catch {
        }
      }
      if (!txHash) {
        throw new Error("Failed to parse tx logs");
      }
      return txHash;
    }
    exports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;
    var ADDRESS_MODULO = ethers_1.BigNumber.from(2).pow(160);
    function applyL1ToL2Alias(address) {
      return ethers_1.ethers.utils.hexlify(ethers_1.ethers.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET).mod(ADDRESS_MODULO));
    }
    exports.applyL1ToL2Alias = applyL1ToL2Alias;
    function undoL1ToL2Alias(address) {
      let result = ethers_1.ethers.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET);
      if (result.lt(ethers_1.BigNumber.from(0))) {
        result = result.add(ADDRESS_MODULO);
      }
      return ethers_1.ethers.utils.hexlify(result);
    }
    exports.undoL1ToL2Alias = undoL1ToL2Alias;
    async function getERC20GettersData(l1TokenAddress, provider) {
      const token = typechain_1.IERC20MetadataFactory.connect(l1TokenAddress, provider);
      const name = await token.name();
      const symbol = await token.symbol();
      const decimals = await token.decimals();
      const coder = new utils_1.AbiCoder();
      const nameBytes = coder.encode(["string"], [name]);
      const symbolBytes = coder.encode(["string"], [symbol]);
      const decimalsBytes = coder.encode(["uint256"], [decimals]);
      return coder.encode(["bytes", "bytes", "bytes"], [nameBytes, symbolBytes, decimalsBytes]);
    }
    async function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, provider) {
      const gettersData = await getERC20GettersData(l1TokenAddress, provider);
      return exports.L2_BRIDGE_ABI.encodeFunctionData("finalizeDeposit", [
        l1Sender,
        l2Receiver,
        l1TokenAddress,
        amount,
        gettersData
      ]);
    }
    exports.getERC20BridgeCalldata = getERC20BridgeCalldata;
    function isECDSASignatureCorrect(address, msgHash, signature) {
      try {
        return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);
      } catch {
        return false;
      }
    }
    async function isEIP1271SignatureCorrect(provider, address, msgHash, signature) {
      const accountContract = new ethers_1.ethers.Contract(address, exports.IERC1271, provider);
      const result = await accountContract.isValidSignature(msgHash, signature);
      return result == exports.EIP1271_MAGIC_VALUE;
    }
    async function isSignatureCorrect(provider, address, msgHash, signature) {
      let isContractAccount = false;
      const code = await provider.getCode(address);
      isContractAccount = ethers_1.ethers.utils.arrayify(code).length != 0;
      if (!isContractAccount) {
        return isECDSASignatureCorrect(address, msgHash, signature);
      } else {
        return await isEIP1271SignatureCorrect(provider, address, msgHash, signature);
      }
    }
    async function isMessageSignatureCorrect(provider, address, message, signature) {
      const msgHash = ethers_1.ethers.utils.hashMessage(message);
      return await isSignatureCorrect(provider, address, msgHash, signature);
    }
    exports.isMessageSignatureCorrect = isMessageSignatureCorrect;
    async function isTypedDataSignatureCorrect(provider, address, domain, types, value, signature) {
      const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);
      return await isSignatureCorrect(provider, address, msgHash, signature);
    }
    exports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;
    async function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {
      from !== null && from !== void 0 ? from : from = ethers_1.ethers.Wallet.createRandom().address;
      if (token == exports.ETH_ADDRESS) {
        return await providerL2.estimateL1ToL2Execute({
          contractAddress: to,
          gasPerPubdataByte,
          caller: from,
          calldata: "0x",
          l2Value: amount
        });
      } else {
        const l1ERC20BridgeAddresses = (await providerL2.getDefaultBridgeAddresses()).erc20L1;
        const erc20BridgeAddress = (await providerL2.getDefaultBridgeAddresses()).erc20L2;
        const calldata = await getERC20BridgeCalldata(token, from, to, amount, providerL1);
        return await providerL2.estimateL1ToL2Execute({
          caller: applyL1ToL2Alias(l1ERC20BridgeAddresses),
          contractAddress: erc20BridgeAddress,
          gasPerPubdataByte,
          calldata
        });
      }
    }
    exports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas;
  }
});

// node_modules/zksync-web3/build/src/wallet.js
var require_wallet = __commonJS({
  "node_modules/zksync-web3/build/src/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wallet = void 0;
    var signer_1 = require_signer2();
    var utils_1 = require_utils7();
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var adapters_1 = require_adapters();
    var Wallet = class _Wallet extends (0, adapters_1.AdapterL2)((0, adapters_1.AdapterL1)(ethers_1.ethers.Wallet)) {
      _providerL1() {
        if (this.providerL1 == null) {
          throw new Error("L1 provider missing: use `connectToL1` to specify");
        }
        return this.providerL1;
      }
      _providerL2() {
        return this.provider;
      }
      _signerL1() {
        return this.ethWallet();
      }
      _signerL2() {
        return this;
      }
      ethWallet() {
        return new ethers_1.ethers.Wallet(this._signingKey(), this._providerL1());
      }
      // an alias with a better name
      async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
      }
      connect(provider) {
        return new _Wallet(this._signingKey(), provider, this.providerL1);
      }
      connectToL1(provider) {
        return new _Wallet(this._signingKey(), this.provider, provider);
      }
      static fromMnemonic(mnemonic, path, wordlist) {
        const wallet = super.fromMnemonic(mnemonic, path, wordlist);
        return new _Wallet(wallet._signingKey());
      }
      static async fromEncryptedJson(json, password, callback) {
        const wallet = await super.fromEncryptedJson(json, password, callback);
        return new _Wallet(wallet._signingKey());
      }
      static fromEncryptedJsonSync(json, password) {
        const wallet = super.fromEncryptedJsonSync(json, password);
        return new _Wallet(wallet._signingKey());
      }
      static createRandom(options) {
        const wallet = super.createRandom(options);
        return new _Wallet(wallet._signingKey());
      }
      constructor(privateKey, providerL2, providerL1) {
        super(privateKey, providerL2);
        if (this.provider != null) {
          const chainId = this.getChainId();
          this.eip712 = new signer_1.EIP712Signer(this, chainId);
        }
        this.providerL1 = providerL1;
      }
      async populateTransaction(transaction) {
        var _a, _b;
        if (transaction.type == null && transaction.customData == null) {
          transaction.type = 0;
        }
        transaction = await super.populateTransaction(transaction);
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
          return transaction;
        }
        transaction.type = utils_1.EIP712_TX_TYPE;
        (_a = transaction.value) !== null && _a !== void 0 ? _a : transaction.value = 0;
        (_b = transaction.data) !== null && _b !== void 0 ? _b : transaction.data = "0x";
        transaction.customData = this._fillCustomData(transaction.customData);
        transaction.gasPrice = await this.provider.getGasPrice();
        return transaction;
      }
      async signTransaction(transaction) {
        var _a;
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
          if (transaction.type == 2 && transaction.maxFeePerGas == null) {
            transaction.maxFeePerGas = await this.provider.getGasPrice();
          }
          return await super.signTransaction(transaction);
        } else {
          (_a = transaction.from) !== null && _a !== void 0 ? _a : transaction.from = this.address;
          if (transaction.from.toLowerCase() != this.address.toLowerCase()) {
            throw new Error("Transaction `from` address mismatch");
          }
          transaction.customData.customSignature = await this.eip712.sign(transaction);
          return (0, utils_1.serialize)(transaction);
        }
      }
      async sendTransaction(transaction) {
        return await super.sendTransaction(transaction);
      }
    };
    exports.Wallet = Wallet;
  }
});

// node_modules/zksync-web3/build/src/provider.js
var require_provider = __commonJS({
  "node_modules/zksync-web3/build/src/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Provider = exports.Provider = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var Formatter = ethers_1.providers.Formatter;
    var web_1 = (init_lib7(), __toCommonJS(lib_exports7));
    var typechain_1 = require_typechain();
    var types_1 = require_types4();
    var utils_1 = require_utils7();
    var signer_1 = require_signer2();
    var defaultFormatter = null;
    var Provider = class _Provider extends ethers_1.ethers.providers.JsonRpcProvider {
      async getTransactionReceipt(transactionHash) {
        await this.getNetwork();
        transactionHash = await transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return (0, web_1.poll)(async () => {
          const result = await this.perform("getTransactionReceipt", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {
            return {
              ...this.formatter.receipt({
                ...result,
                confirmations: 1,
                blockNumber: 0,
                blockHash: ethers_1.ethers.constants.HashZero
              }),
              blockNumber: null,
              blockHash: null,
              l1BatchNumber: null,
              l1BatchTxIndex: null
            };
          }
          if (result.blockHash == null) {
            return void 0;
          } else {
            const receipt = this.formatter.receipt(result);
            if (receipt.blockNumber == null) {
              receipt.confirmations = 0;
            } else if (receipt.confirmations == null) {
              const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              let confirmations = blockNumber - receipt.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              receipt.confirmations = confirmations;
            }
            return receipt;
          }
        }, { oncePoll: this });
      }
      async getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
      }
      async getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
      }
      static getFormatter() {
        if (defaultFormatter == null) {
          defaultFormatter = new Formatter();
          const number = defaultFormatter.number.bind(defaultFormatter);
          const boolean = defaultFormatter.boolean.bind(defaultFormatter);
          const hash = defaultFormatter.hash.bind(defaultFormatter);
          const address = defaultFormatter.address.bind(defaultFormatter);
          defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.l2Tol1Log = {
            blockNumber: number,
            blockHash: hash,
            l1BatchNumber: Formatter.allowNull(number),
            transactionIndex: number,
            shardId: number,
            isService: boolean,
            sender: address,
            key: hash,
            value: hash,
            transactionHash: hash,
            logIndex: number
          };
          defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);
          defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf((value) => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));
          defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);
          defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);
          defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);
          defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);
        }
        return defaultFormatter;
      }
      async getBalance(address, blockTag, tokenAddress) {
        const tag = this.formatter.blockTag(blockTag);
        if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {
          return await super.getBalance(address, tag);
        } else {
          try {
            let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);
            return await token.balanceOf(address, { blockTag: tag });
          } catch {
            return ethers_1.BigNumber.from(0);
          }
        }
      }
      async l2TokenAddress(token) {
        if (token == utils_1.ETH_ADDRESS) {
          return utils_1.ETH_ADDRESS;
        } else {
          const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
          const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
          return await erc20Bridge.l2TokenAddress(token);
        }
      }
      async l1TokenAddress(token) {
        if (token == utils_1.ETH_ADDRESS) {
          return utils_1.ETH_ADDRESS;
        } else {
          const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
          const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
          return await erc20Bridge.l1TokenAddress(token);
        }
      }
      // This function is used when formatting requests for
      // eth_call and eth_estimateGas. We override it here
      // because we have extra stuff to serialize (customData).
      // This function is for internal use only.
      static hexlifyTransaction(transaction, allowExtra) {
        var _a;
        const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {
          ...allowExtra,
          customData: true,
          from: true
        });
        if (transaction.customData == null) {
          return result;
        }
        result.eip712Meta = {
          gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)
        };
        transaction.type = utils_1.EIP712_TX_TYPE;
        if (transaction.customData.factoryDeps) {
          result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep) => (
            // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.
            //  We should change deserialization there.
            Array.from(ethers_1.utils.arrayify(dep))
          ));
        }
        if (transaction.customData.paymasterParams) {
          result.eip712Meta.paymasterParams = {
            paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),
            paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))
          };
        }
        return result;
      }
      async estimateGas(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
          transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
          params.transaction.customData = transaction.customData;
        }
        const result = await this.perform("estimateGas", params);
        try {
          return ethers_1.BigNumber.from(result);
        } catch (error) {
          throw new Error(`bad result from backend (estimateGas): ${result}`);
        }
      }
      async estimateGasL1(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
          transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
          params.transaction.customData = transaction.customData;
        }
        const result = await this.send("zks_estimateGasL1ToL2", [
          _Provider.hexlifyTransaction(params.transaction, { from: true })
        ]);
        try {
          return ethers_1.BigNumber.from(result);
        } catch (error) {
          throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);
        }
      }
      async getGasPrice(token) {
        const params = token ? [token] : [];
        const price = await this.send("eth_gasPrice", params);
        return ethers_1.BigNumber.from(price);
      }
      constructor(url, network) {
        super(url, network);
        this.pollingInterval = 500;
        const blockTag = this.formatter.blockTag.bind(this.formatter);
        this.formatter.blockTag = (tag) => {
          if (tag == "committed" || tag == "finalized") {
            return tag;
          }
          return blockTag(tag);
        };
        this.contractAddresses = {};
        this.formatter.transaction = utils_1.parseTransaction;
      }
      async getMessageProof(blockNumber, sender, messageHash, logIndex) {
        return await this.send("zks_getL2ToL1MsgProof", [
          ethers_1.BigNumber.from(blockNumber).toNumber(),
          sender,
          ethers_1.ethers.utils.hexlify(messageHash),
          logIndex
        ]);
      }
      async getLogProof(txHash, index) {
        return await this.send("zks_getL2ToL1LogProof", [ethers_1.ethers.utils.hexlify(txHash), index]);
      }
      async getL1BatchBlockRange(l1BatchNumber) {
        const range = await this.send("zks_getL1BatchBlockRange", [l1BatchNumber]);
        if (range == null) {
          return null;
        }
        return [parseInt(range[0], 16), parseInt(range[1], 16)];
      }
      async getMainContractAddress() {
        if (!this.contractAddresses.mainContract) {
          this.contractAddresses.mainContract = await this.send("zks_getMainContract", []);
        }
        return this.contractAddresses.mainContract;
      }
      async getTestnetPaymasterAddress() {
        return await this.send("zks_getTestnetPaymaster", []);
      }
      async getDefaultBridgeAddresses() {
        if (!this.contractAddresses.erc20BridgeL1) {
          let addresses = await this.send("zks_getBridgeContracts", []);
          this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;
          this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;
        }
        return {
          erc20L1: this.contractAddresses.erc20BridgeL1,
          erc20L2: this.contractAddresses.erc20BridgeL2
        };
      }
      async getConfirmedTokens(start = 0, limit = 255) {
        const tokens = await this.send("zks_getConfirmedTokens", [start, limit]);
        return tokens.map((token) => ({ address: token.l2Address, ...token }));
      }
      async getTokenPrice(token) {
        return await this.send("zks_getTokenPrice", [token]);
      }
      async getAllAccountBalances(address) {
        let balances = await this.send("zks_getAllAccountBalances", [address]);
        for (let token in balances) {
          balances[token] = ethers_1.BigNumber.from(balances[token]);
        }
        return balances;
      }
      async l1ChainId() {
        const res = await this.send("zks_L1ChainId", []);
        return ethers_1.BigNumber.from(res).toNumber();
      }
      async getL1BatchNumber() {
        const number = await this.send("zks_L1BatchNumber", []);
        return ethers_1.BigNumber.from(number).toNumber();
      }
      async getL1BatchDetails(number) {
        return await this.send("zks_getL1BatchDetails", [number]);
      }
      async getBlockDetails(number) {
        return await this.send("zks_getBlockDetails", [number]);
      }
      async getTransactionDetails(txHash) {
        return await this.send("zks_getTransactionDetails", [txHash]);
      }
      async getWithdrawTx(transaction) {
        var _a, _b, _c;
        var _d;
        const { ...tx } = transaction;
        if (tx.to == null && tx.from == null) {
          throw new Error("withdrawal target address is undefined");
        }
        (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = tx.from;
        (_b = tx.overrides) !== null && _b !== void 0 ? _b : tx.overrides = {};
        (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : _d.from = tx.from;
        if ((0, utils_1.isETH)(tx.token)) {
          if (!tx.overrides.value) {
            tx.overrides.value = tx.amount;
          }
          const passedValue = ethers_1.BigNumber.from(tx.overrides.value);
          if (!passedValue.eq(tx.amount)) {
            throw new Error("The tx.value is not equal to the value withdrawn");
          }
          const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);
          return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);
        }
        if (tx.bridgeAddress == null) {
          const bridges = await this.getDefaultBridgeAddresses();
          tx.bridgeAddress = bridges.erc20L2;
        }
        const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);
        return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);
      }
      async estimateGasWithdraw(transaction) {
        const withdrawTx = await this.getWithdrawTx(transaction);
        return await this.estimateGas(withdrawTx);
      }
      async getTransferTx(transaction) {
        var _a, _b;
        var _c;
        const { ...tx } = transaction;
        (_a = tx.overrides) !== null && _a !== void 0 ? _a : tx.overrides = {};
        (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : _c.from = tx.from;
        if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {
          return {
            ...await ethers_1.ethers.utils.resolveProperties(tx.overrides),
            to: tx.to,
            value: tx.amount
          };
        } else {
          const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);
          return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);
        }
      }
      async estimateGasTransfer(transaction) {
        const transferTx = await this.getTransferTx(transaction);
        return await this.estimateGas(transferTx);
      }
      static getDefaultProvider() {
        return new _Provider(process.env.ZKSYNC_WEB3_API_URL || "http://localhost:3050");
      }
      async newFilter(filter) {
        filter = await filter;
        const id = await this.send("eth_newFilter", [this._prepareFilter(filter)]);
        return ethers_1.BigNumber.from(id);
      }
      async newBlockFilter() {
        const id = await this.send("eth_newBlockFilter", []);
        return ethers_1.BigNumber.from(id);
      }
      async newPendingTransactionsFilter() {
        const id = await this.send("eth_newPendingTransactionFilter", []);
        return ethers_1.BigNumber.from(id);
      }
      async getFilterChanges(idx) {
        const logs = await this.send("eth_getFilterChanges", [idx.toHexString()]);
        return typeof logs[0] === "string" ? logs : this._parseLogs(logs);
      }
      async getLogs(filter = {}) {
        filter = await filter;
        const logs = await this.send("eth_getLogs", [this._prepareFilter(filter)]);
        return this._parseLogs(logs);
      }
      _parseLogs(logs) {
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
      }
      _prepareFilter(filter) {
        return {
          ...filter,
          fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),
          toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)
        };
      }
      _wrapTransaction(tx, hash) {
        const response = super._wrapTransaction(tx, hash);
        response.waitFinalize = async () => {
          const receipt = await response.wait();
          while (true) {
            const block = await this.getBlock("finalized");
            if (receipt.blockNumber <= block.number) {
              return await this.getTransactionReceipt(receipt.transactionHash);
            } else {
              await (0, utils_1.sleep)(this.pollingInterval);
            }
          }
        };
        return response;
      }
      // This is inefficient. Status should probably be indicated in the transaction receipt.
      async getTransactionStatus(txHash) {
        const tx = await this.getTransaction(txHash);
        if (tx == null) {
          return types_1.TransactionStatus.NotFound;
        }
        if (tx.blockNumber == null) {
          return types_1.TransactionStatus.Processing;
        }
        const verifiedBlock = await this.getBlock("finalized");
        if (tx.blockNumber <= verifiedBlock.number) {
          return types_1.TransactionStatus.Finalized;
        }
        return types_1.TransactionStatus.Committed;
      }
      async getTransaction(hash) {
        hash = await hash;
        const tx = await super.getTransaction(hash);
        return tx ? this._wrapTransaction(tx, hash) : null;
      }
      async sendTransaction(transaction) {
        return await super.sendTransaction(transaction);
      }
      async getL2TransactionFromPriorityOp(l1TxResponse) {
        const receipt = await l1TxResponse.wait();
        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
        let status = null;
        do {
          status = await this.getTransactionStatus(l2Hash);
          await (0, utils_1.sleep)(this.pollingInterval);
        } while (status == types_1.TransactionStatus.NotFound);
        return await this.getTransaction(l2Hash);
      }
      async getPriorityOpResponse(l1TxResponse) {
        const l2Response = { ...l1TxResponse };
        l2Response.waitL1Commit = l2Response.wait;
        l2Response.wait = async () => {
          const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
          return await l2Tx.wait();
        };
        l2Response.waitFinalize = async () => {
          const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
          return await l2Tx.waitFinalize();
        };
        return l2Response;
      }
      async getContractAccountInfo(address) {
        const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);
        const data = await deployerContract.getAccountInfo(address);
        return {
          supportedAAVersion: data.supportedAAVersion,
          nonceOrdering: data.nonceOrdering
        };
      }
      // TODO (EVM-3): support refundRecipient for fee estimation
      async estimateL1ToL2Execute(transaction) {
        var _a, _b;
        (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
        (_b = transaction.caller) !== null && _b !== void 0 ? _b : transaction.caller = ethers_1.ethers.Wallet.createRandom().address;
        const customData = {
          gasPerPubdataByte: transaction.gasPerPubdataByte
        };
        if (transaction.factoryDeps) {
          Object.assign(customData, { factoryDeps: transaction.factoryDeps });
        }
        const fee = await this.estimateGasL1({
          from: transaction.caller,
          data: transaction.calldata,
          to: transaction.contractAddress,
          value: transaction.l2Value,
          customData
        });
        return fee;
      }
    };
    exports.Provider = Provider;
    var Web3Provider = class extends Provider {
      constructor(provider, network) {
        if (provider == null) {
          throw new Error("missing provider");
        }
        if (!provider.request) {
          throw new Error("provider must implement eip-1193");
        }
        let path = provider.host || provider.path || (provider.isMetaMask ? "metamask" : "eip-1193:");
        super(path, network);
        this.provider = provider;
      }
      async send(method, params) {
        params !== null && params !== void 0 ? params : params = [];
        if (method == "eth_sign" && (this.provider.isMetaMask || this.provider.isStatus)) {
          method = "personal_sign";
          params = [params[1], params[0]];
        }
        return await this.provider.request({ method, params });
      }
      getSigner(addressOrIndex) {
        return signer_1.Signer.from(super.getSigner(addressOrIndex));
      }
      async estimateGas(transaction) {
        const gas = await super.estimateGas(transaction);
        const metamaskMinimum = ethers_1.BigNumber.from(21e3);
        const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;
        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;
      }
    };
    exports.Web3Provider = Web3Provider;
  }
});

// node_modules/zksync-web3/build/src/contract.js
var require_contract = __commonJS({
  "node_modules/zksync-web3/build/src/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractFactory = exports.Contract = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var utils_1 = require_utils7();
    var types_1 = require_types4();
    var ethers_2 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return ethers_2.Contract;
    } });
    var ContractFactory = class extends ethers_1.ethers.ContractFactory {
      constructor(abi, bytecode, signer, deploymentType) {
        super(abi, bytecode, signer);
        this.deploymentType = deploymentType || "create";
      }
      encodeCalldata(salt, bytecodeHash, constructorCalldata) {
        if (this.deploymentType == "create") {
          return utils_1.CONTRACT_DEPLOYER.encodeFunctionData("create", [salt, bytecodeHash, constructorCalldata]);
        } else if (this.deploymentType == "createAccount") {
          return utils_1.CONTRACT_DEPLOYER.encodeFunctionData("createAccount", [
            salt,
            bytecodeHash,
            constructorCalldata,
            types_1.AccountAbstractionVersion.Version1
          ]);
        } else {
          throw new Error(`Unsupported deployment type ${this.deploymentType}`);
        }
      }
      getDeployTransaction(...args) {
        var _a, _b, _c;
        var _d, _e;
        let salt = "0x0000000000000000000000000000000000000000000000000000000000000000";
        const txRequest = super.getDeployTransaction(...args);
        if (this.interface.deploy.inputs.length + 1 == args.length) {
          args.pop();
        }
        const bytecodeHash = (0, utils_1.hashBytecode)(this.bytecode);
        const constructorCalldata = ethers_1.utils.arrayify(this.interface.encodeDeploy(args));
        const deployCalldata = this.encodeCalldata(salt, bytecodeHash, constructorCalldata);
        txRequest.type = utils_1.EIP712_TX_TYPE;
        txRequest.to = utils_1.CONTRACT_DEPLOYER_ADDRESS;
        txRequest.data = deployCalldata;
        (_a = txRequest.customData) !== null && _a !== void 0 ? _a : txRequest.customData = {};
        (_b = (_d = txRequest.customData).factoryDeps) !== null && _b !== void 0 ? _b : _d.factoryDeps = [];
        (_c = (_e = txRequest.customData).gasPerPubdata) !== null && _c !== void 0 ? _c : _e.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        if (!txRequest.customData.factoryDeps.includes(this.bytecode)) {
          txRequest.customData.factoryDeps.push(this.bytecode);
        }
        return txRequest;
      }
      async deploy(...args) {
        const contract = await super.deploy(...args);
        const deployTxReceipt = await contract.deployTransaction.wait();
        const deployedAddresses = (0, utils_1.getDeployedContracts)(deployTxReceipt).map((info) => info.deployedAddress);
        const contractWithCorrectAddress = new ethers_1.ethers.Contract(deployedAddresses[deployedAddresses.length - 1], contract.interface, contract.signer);
        ethers_1.utils.defineReadOnly(contractWithCorrectAddress, "deployTransaction", contract.deployTransaction);
        return contractWithCorrectAddress;
      }
    };
    exports.ContractFactory = ContractFactory;
  }
});

// node_modules/zksync-web3/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/zksync-web3/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = exports.ContractFactory = exports.Provider = exports.Web3Provider = exports.Wallet = exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.types = exports.utils = void 0;
    exports.utils = __importStar(require_utils7());
    exports.types = __importStar(require_types4());
    var signer_1 = require_signer2();
    Object.defineProperty(exports, "EIP712Signer", { enumerable: true, get: function() {
      return signer_1.EIP712Signer;
    } });
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return signer_1.Signer;
    } });
    Object.defineProperty(exports, "L1Signer", { enumerable: true, get: function() {
      return signer_1.L1Signer;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return wallet_1.Wallet;
    } });
    var provider_1 = require_provider();
    Object.defineProperty(exports, "Web3Provider", { enumerable: true, get: function() {
      return provider_1.Web3Provider;
    } });
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return provider_1.Provider;
    } });
    var contract_1 = require_contract();
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return contract_1.ContractFactory;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contract_1.Contract;
    } });
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/contracts/safeDeploymentContracts.js
var require_safeDeploymentContracts = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/contracts/safeDeploymentContracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSimulateTxAccessorContract = exports.getCreateCallContract = exports.getSignMessageLibContract = exports.getMultiSendCallOnlyContract = exports.getMultiSendContract = exports.getCompatibilityFallbackHandlerContract = exports.getProxyFactoryContract = exports.getSafeContract = exports.getSimulateTxAccessorContractDeployment = exports.getCreateCallContractDeployment = exports.getSignMessageLibContractDeployment = exports.getSafeProxyFactoryContractDeployment = exports.getMultiSendContractDeployment = exports.getMultiSendCallOnlyContractDeployment = exports.getCompatibilityFallbackHandlerContractDeployment = exports.getSafeContractDeployment = void 0;
    var safe_deployments_1 = require_dist();
    var config_1 = require_config();
    function getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy = false) {
      const version = config_1.safeDeploymentsVersions[safeVersion].safeMasterCopyVersion;
      const filters = { version, network: chainId.toString(), released: true };
      if (config_1.safeDeploymentsL1ChainIds.includes(chainId) || isL1SafeMasterCopy) {
        return (0, safe_deployments_1.getSafeSingletonDeployment)(filters);
      }
      return (0, safe_deployments_1.getSafeL2SingletonDeployment)(filters);
    }
    exports.getSafeContractDeployment = getSafeContractDeployment;
    function getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].compatibilityFallbackHandler;
      return (0, safe_deployments_1.getCompatibilityFallbackHandlerDeployment)({
        version,
        network: chainId.toString(),
        released: true
      });
    }
    exports.getCompatibilityFallbackHandlerContractDeployment = getCompatibilityFallbackHandlerContractDeployment;
    function getMultiSendCallOnlyContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].multiSendCallOnlyVersion;
      return (0, safe_deployments_1.getMultiSendCallOnlyDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getMultiSendCallOnlyContractDeployment = getMultiSendCallOnlyContractDeployment;
    function getMultiSendContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].multiSendVersion;
      return (0, safe_deployments_1.getMultiSendDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getMultiSendContractDeployment = getMultiSendContractDeployment;
    function getSafeProxyFactoryContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].safeProxyFactoryVersion;
      return (0, safe_deployments_1.getProxyFactoryDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getSafeProxyFactoryContractDeployment = getSafeProxyFactoryContractDeployment;
    function getSignMessageLibContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].signMessageLibVersion;
      return (0, safe_deployments_1.getSignMessageLibDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getSignMessageLibContractDeployment = getSignMessageLibContractDeployment;
    function getCreateCallContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].createCallVersion;
      return (0, safe_deployments_1.getCreateCallDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getCreateCallContractDeployment = getCreateCallContractDeployment;
    function getSimulateTxAccessorContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].createCallVersion;
      return (0, safe_deployments_1.getSimulateTxAccessorDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getSimulateTxAccessorContractDeployment = getSimulateTxAccessorContractDeployment;
    async function getSafeContract({ ethAdapter, safeVersion, customSafeAddress, isL1SafeMasterCopy, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const singletonDeployment = getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy);
      const safeContract = await ethAdapter.getSafeContract({
        safeVersion,
        singletonDeployment,
        customContractAddress: customSafeAddress ?? (customContracts == null ? void 0 : customContracts.safeMasterCopyAddress),
        customContractAbi: customContracts == null ? void 0 : customContracts.safeMasterCopyAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(safeContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SafeProxy contract is not deployed on the current network");
      }
      return safeContract;
    }
    exports.getSafeContract = getSafeContract;
    async function getProxyFactoryContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const proxyFactoryDeployment = getSafeProxyFactoryContractDeployment(safeVersion, chainId);
      const safeProxyFactoryContract = await ethAdapter.getSafeProxyFactoryContract({
        safeVersion,
        singletonDeployment: proxyFactoryDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.safeProxyFactoryAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.safeProxyFactoryAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(safeProxyFactoryContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SafeProxyFactory contract is not deployed on the current network");
      }
      return safeProxyFactoryContract;
    }
    exports.getProxyFactoryContract = getProxyFactoryContract;
    async function getCompatibilityFallbackHandlerContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const fallbackHandlerDeployment = getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId);
      const fallbackHandlerContract = await ethAdapter.getCompatibilityFallbackHandlerContract({
        safeVersion,
        singletonDeployment: fallbackHandlerDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.fallbackHandlerAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.fallbackHandlerAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(fallbackHandlerContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("CompatibilityFallbackHandler contract is not deployed on the current network");
      }
      return fallbackHandlerContract;
    }
    exports.getCompatibilityFallbackHandlerContract = getCompatibilityFallbackHandlerContract;
    async function getMultiSendContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const multiSendDeployment = getMultiSendContractDeployment(safeVersion, chainId);
      const multiSendContract = await ethAdapter.getMultiSendContract({
        safeVersion,
        singletonDeployment: multiSendDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.multiSendAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.multiSendAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(multiSendContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("MultiSend contract is not deployed on the current network");
      }
      return multiSendContract;
    }
    exports.getMultiSendContract = getMultiSendContract;
    async function getMultiSendCallOnlyContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const multiSendCallOnlyDeployment = getMultiSendCallOnlyContractDeployment(safeVersion, chainId);
      const multiSendCallOnlyContract = await ethAdapter.getMultiSendCallOnlyContract({
        safeVersion,
        singletonDeployment: multiSendCallOnlyDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.multiSendCallOnlyAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.multiSendCallOnlyAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(multiSendCallOnlyContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("MultiSendCallOnly contract is not deployed on the current network");
      }
      return multiSendCallOnlyContract;
    }
    exports.getMultiSendCallOnlyContract = getMultiSendCallOnlyContract;
    async function getSignMessageLibContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const signMessageLibDeployment = getSignMessageLibContractDeployment(safeVersion, chainId);
      const signMessageLibContract = await ethAdapter.getSignMessageLibContract({
        safeVersion,
        singletonDeployment: signMessageLibDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.signMessageLibAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.signMessageLibAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(signMessageLibContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SignMessageLib contract is not deployed on the current network");
      }
      return signMessageLibContract;
    }
    exports.getSignMessageLibContract = getSignMessageLibContract;
    async function getCreateCallContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const createCallDeployment = getCreateCallContractDeployment(safeVersion, chainId);
      const createCallContract = await ethAdapter.getCreateCallContract({
        safeVersion,
        singletonDeployment: createCallDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.createCallAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.createCallAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(createCallContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("CreateCall contract is not deployed on the current network");
      }
      return createCallContract;
    }
    exports.getCreateCallContract = getCreateCallContract;
    async function getSimulateTxAccessorContract({ ethAdapter, safeVersion, customContracts }) {
      const chainId = await ethAdapter.getChainId();
      const simulateTxAccessorDeployment = getSimulateTxAccessorContractDeployment(safeVersion, chainId);
      const simulateTxAccessorContract = await ethAdapter.getSimulateTxAccessorContract({
        safeVersion,
        singletonDeployment: simulateTxAccessorDeployment,
        customContractAddress: customContracts == null ? void 0 : customContracts.simulateTxAccessorAddress,
        customContractAbi: customContracts == null ? void 0 : customContracts.simulateTxAccessorAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(simulateTxAccessorContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SimulateTxAccessor contract is not deployed on the current network");
      }
      return simulateTxAccessorContract;
    }
    exports.getSimulateTxAccessorContract = getSimulateTxAccessorContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/contracts/utils.js
var require_utils8 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/contracts/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSafeDeploymentConfig = exports.validateSafeAccountConfig = exports.predictSafeAddress = exports.encodeSetupCallData = exports.encodeCreateProxyWithNonce = exports.PREDETERMINED_SALT_NONCE = void 0;
    var address_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var config_1 = require_config();
    var constants_1 = require_constants();
    var memoized_1 = require_memoized();
    var ethereumjs_util_1 = require_dist3();
    var satisfies_1 = __importDefault(require_satisfies());
    var zksync_web3_1 = require_src3();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    exports.PREDETERMINED_SALT_NONCE = "0xb1073742015cbcf5a3a4d9d1ae33ecf619439710b89475f92e2abd2117e90f90";
    var ZKSYNC_MAINNET = 324;
    var ZKSYNC_TESTNET = 280;
    var ZKSYNC_SAFE_PROXY_DEPLOYED_BYTECODE = {
      "1.3.0": {
        deployedBytecodeHash: "0x0100004124426fb9ebb25e27d670c068e52f9ba631bd383279a188be47e3f86d"
      }
    };
    function encodeCreateProxyWithNonce(safeProxyFactoryContract, safeSingletonAddress, initializer) {
      return safeProxyFactoryContract.encode("createProxyWithNonce", [
        safeSingletonAddress,
        initializer,
        exports.PREDETERMINED_SALT_NONCE
      ]);
    }
    exports.encodeCreateProxyWithNonce = encodeCreateProxyWithNonce;
    var memoizedGetCompatibilityFallbackHandlerContract = (0, memoized_1.createMemoizedFunction)(safeDeploymentContracts_1.getCompatibilityFallbackHandlerContract);
    async function encodeSetupCallData({ ethAdapter, safeAccountConfig, safeContract, customContracts, customSafeVersion }) {
      const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = safeAccountConfig;
      const safeVersion = customSafeVersion || await safeContract.getVersion();
      if ((0, satisfies_1.default)(safeVersion, "<=1.0.0")) {
        return safeContract.encode("setup", [
          owners,
          threshold,
          to,
          data,
          paymentToken,
          payment,
          paymentReceiver
        ]);
      }
      let fallbackHandlerAddress = fallbackHandler;
      const isValidAddress = fallbackHandlerAddress !== void 0 && (0, address_1.isAddress)(fallbackHandlerAddress);
      if (!isValidAddress) {
        const fallbackHandlerContract = await memoizedGetCompatibilityFallbackHandlerContract({
          ethAdapter,
          safeVersion,
          customContracts
        });
        fallbackHandlerAddress = fallbackHandlerContract.getAddress();
      }
      return safeContract.encode("setup", [
        owners,
        threshold,
        to,
        data,
        fallbackHandlerAddress,
        paymentToken,
        payment,
        paymentReceiver
      ]);
    }
    exports.encodeSetupCallData = encodeSetupCallData;
    var memoizedGetProxyFactoryContract = (0, memoized_1.createMemoizedFunction)(safeDeploymentContracts_1.getProxyFactoryContract);
    var memoizedGetSafeContract = (0, memoized_1.createMemoizedFunction)(safeDeploymentContracts_1.getSafeContract);
    var memoizedGetProxyCreationCode = (0, memoized_1.createMemoizedFunction)(async ({ ethAdapter, safeVersion, customContracts }) => {
      const safeProxyFactoryContract = await memoizedGetProxyFactoryContract({
        ethAdapter,
        safeVersion,
        customContracts
      });
      return safeProxyFactoryContract.proxyCreationCode();
    });
    async function predictSafeAddress({ ethAdapter, safeAccountConfig, safeDeploymentConfig = {}, isL1SafeMasterCopy = false, customContracts }) {
      (0, exports.validateSafeAccountConfig)(safeAccountConfig);
      (0, exports.validateSafeDeploymentConfig)(safeDeploymentConfig);
      const { safeVersion = config_1.DEFAULT_SAFE_VERSION, saltNonce = exports.PREDETERMINED_SALT_NONCE } = safeDeploymentConfig;
      const safeProxyFactoryContract = await memoizedGetProxyFactoryContract({
        ethAdapter,
        safeVersion,
        customContracts
      });
      const proxyCreationCode = await memoizedGetProxyCreationCode({
        ethAdapter,
        safeVersion,
        customContracts
      });
      const safeContract = await memoizedGetSafeContract({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
      });
      const initializer = await encodeSetupCallData({
        ethAdapter,
        safeAccountConfig,
        safeContract,
        customContracts,
        customSafeVersion: safeVersion
        // it is more efficient if we provide the safeVersion manually
      });
      const encodedNonce = (0, ethereumjs_util_1.toBuffer)(ethAdapter.encodeParameters(["uint256"], [saltNonce])).toString("hex");
      const salt = (0, ethereumjs_util_1.keccak256)((0, ethereumjs_util_1.toBuffer)("0x" + (0, ethereumjs_util_1.keccak256)((0, ethereumjs_util_1.toBuffer)(initializer)).toString("hex") + encodedNonce));
      const input = ethAdapter.encodeParameters(["address"], [safeContract.getAddress()]);
      const chainId = await ethAdapter.getChainId();
      if ([ZKSYNC_MAINNET, ZKSYNC_TESTNET].includes(chainId)) {
        const bytecodeHash = ZKSYNC_SAFE_PROXY_DEPLOYED_BYTECODE[safeVersion].deployedBytecodeHash;
        return zksync_web3_1.utils.create2Address(safeProxyFactoryContract.getAddress(), bytecodeHash, salt, input);
      }
      const constructorData = (0, ethereumjs_util_1.toBuffer)(input).toString("hex");
      const initCode = proxyCreationCode + constructorData;
      const proxyAddress = "0x" + (0, ethereumjs_util_1.generateAddress2)((0, ethereumjs_util_1.toBuffer)(safeProxyFactoryContract.getAddress()), (0, ethereumjs_util_1.toBuffer)(salt), (0, ethereumjs_util_1.toBuffer)(initCode)).toString("hex");
      return ethAdapter.getChecksummedAddress(proxyAddress);
    }
    exports.predictSafeAddress = predictSafeAddress;
    var validateSafeAccountConfig = ({ owners, threshold }) => {
      if (owners.length <= 0)
        throw new Error("Owner list must have at least one owner");
      if (threshold <= 0)
        throw new Error("Threshold must be greater than or equal to 1");
      if (threshold > owners.length)
        throw new Error("Threshold must be lower than or equal to owners length");
    };
    exports.validateSafeAccountConfig = validateSafeAccountConfig;
    var validateSafeDeploymentConfig = ({ saltNonce }) => {
      if (saltNonce && bignumber_1.BigNumber.from(saltNonce).lt(0))
        throw new Error("saltNonce must be greater than or equal to 0");
    };
    exports.validateSafeDeploymentConfig = validateSafeDeploymentConfig;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/types.js
var require_types5 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSafeConfigWithPredictedSafe = void 0;
    function isSafeConfigWithPredictedSafe(config) {
      return config.predictedSafe !== void 0;
    }
    exports.isSafeConfigWithPredictedSafe = isSafeConfigWithPredictedSafe;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/managers/contractManager.js
var require_contractManager = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/managers/contractManager.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ContractManager_contractNetworks;
    var _ContractManager_isL1SafeMasterCopy;
    var _ContractManager_safeContract;
    var _ContractManager_multiSendContract;
    var _ContractManager_multiSendCallOnlyContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var config_1 = require_config();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    var types_1 = require_types5();
    var ContractManager = class _ContractManager {
      constructor() {
        _ContractManager_contractNetworks.set(this, void 0);
        _ContractManager_isL1SafeMasterCopy.set(this, void 0);
        _ContractManager_safeContract.set(this, void 0);
        _ContractManager_multiSendContract.set(this, void 0);
        _ContractManager_multiSendCallOnlyContract.set(this, void 0);
      }
      static async create(config) {
        const contractManager = new _ContractManager();
        await contractManager.init(config);
        return contractManager;
      }
      async init(config) {
        var _a;
        const { ethAdapter, isL1SafeMasterCopy, contractNetworks, predictedSafe, safeAddress } = config;
        const chainId = await ethAdapter.getChainId();
        const customContracts = contractNetworks == null ? void 0 : contractNetworks[chainId];
        __classPrivateFieldSet(this, _ContractManager_contractNetworks, contractNetworks, "f");
        __classPrivateFieldSet(this, _ContractManager_isL1SafeMasterCopy, isL1SafeMasterCopy, "f");
        let safeVersion;
        if ((0, types_1.isSafeConfigWithPredictedSafe)(config)) {
          safeVersion = ((_a = predictedSafe == null ? void 0 : predictedSafe.safeDeploymentConfig) == null ? void 0 : _a.safeVersion) ?? config_1.DEFAULT_SAFE_VERSION;
        } else {
          const defaultSafeContractInstance = await (0, safeDeploymentContracts_1.getSafeContract)({
            ethAdapter,
            safeVersion: config_1.DEFAULT_SAFE_VERSION,
            isL1SafeMasterCopy,
            customSafeAddress: safeAddress,
            customContracts
          });
          safeVersion = await defaultSafeContractInstance.getVersion();
          const isTheDefaultSafeVersion = safeVersion === config_1.DEFAULT_SAFE_VERSION;
          __classPrivateFieldSet(this, _ContractManager_safeContract, isTheDefaultSafeVersion ? defaultSafeContractInstance : await (0, safeDeploymentContracts_1.getSafeContract)({
            ethAdapter,
            safeVersion,
            isL1SafeMasterCopy,
            customSafeAddress: safeAddress,
            customContracts
          }), "f");
        }
        __classPrivateFieldSet(this, _ContractManager_multiSendContract, await (0, safeDeploymentContracts_1.getMultiSendContract)({
          ethAdapter,
          safeVersion,
          customContracts
        }), "f");
        __classPrivateFieldSet(this, _ContractManager_multiSendCallOnlyContract, await (0, safeDeploymentContracts_1.getMultiSendCallOnlyContract)({
          ethAdapter,
          safeVersion,
          customContracts
        }), "f");
      }
      get contractNetworks() {
        return __classPrivateFieldGet(this, _ContractManager_contractNetworks, "f");
      }
      get isL1SafeMasterCopy() {
        return __classPrivateFieldGet(this, _ContractManager_isL1SafeMasterCopy, "f");
      }
      get safeContract() {
        return __classPrivateFieldGet(this, _ContractManager_safeContract, "f");
      }
      get multiSendContract() {
        return __classPrivateFieldGet(this, _ContractManager_multiSendContract, "f");
      }
      get multiSendCallOnlyContract() {
        return __classPrivateFieldGet(this, _ContractManager_multiSendCallOnlyContract, "f");
      }
    };
    _ContractManager_contractNetworks = /* @__PURE__ */ new WeakMap(), _ContractManager_isL1SafeMasterCopy = /* @__PURE__ */ new WeakMap(), _ContractManager_safeContract = /* @__PURE__ */ new WeakMap(), _ContractManager_multiSendContract = /* @__PURE__ */ new WeakMap(), _ContractManager_multiSendCallOnlyContract = /* @__PURE__ */ new WeakMap();
    exports.default = ContractManager;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/address.js
var require_address2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isRestrictedAddress = exports.isZeroAddress = exports.sameString = void 0;
    var constants_1 = require_constants();
    function sameString(str1, str2) {
      return str1.toLowerCase() === str2.toLowerCase();
    }
    exports.sameString = sameString;
    function isZeroAddress(address) {
      return sameString(address, constants_1.ZERO_ADDRESS);
    }
    exports.isZeroAddress = isZeroAddress;
    function isSentinelAddress(address) {
      return sameString(address, constants_1.SENTINEL_ADDRESS);
    }
    function isRestrictedAddress(address) {
      return isZeroAddress(address) || isSentinelAddress(address);
    }
    exports.isRestrictedAddress = isRestrictedAddress;
  }
});

// node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer2().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/number-to-bn/node_modules/bn.js/lib/bn.js
var require_bn4 = __commonJS({
  "node_modules/number-to-bn/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer2().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src4 = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src5 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    var isHexPrefixed = require_src4();
    module.exports = function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/number-to-bn/src/index.js
var require_src6 = __commonJS({
  "node_modules/number-to-bn/src/index.js"(exports, module) {
    var BN = require_bn4();
    var stripHexPrefix = require_src5();
    module.exports = function numberToBN(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        var multiplier = new BN(1);
        var formattedString = String(arg).toLowerCase().trim();
        var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
        var stringArg = stripHexPrefix(formattedString);
        if (stringArg.substr(0, 1) === "-") {
          stringArg = stripHexPrefix(stringArg.slice(1));
          multiplier = new BN(-1, 10);
        }
        stringArg = stringArg === "" ? "0" : stringArg;
        if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) {
          return new BN(stringArg, 16).mul(multiplier);
        }
        if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) {
          return new BN(stringArg, 10).mul(multiplier);
        }
      } else if (typeof arg === "object" && arg.toString && (!arg.pop && !arg.push)) {
        if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
          return new BN(arg.toString(10), 10);
        }
      }
      throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
    };
  }
});

// node_modules/ethjs-unit/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ethjs-unit/lib/index.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var numberToBN = require_src6();
    var zero = new BN(0);
    var negative1 = new BN(-1);
    var unitMap = {
      "noether": "0",
      // eslint-disable-line
      "wei": "1",
      // eslint-disable-line
      "kwei": "1000",
      // eslint-disable-line
      "Kwei": "1000",
      // eslint-disable-line
      "babbage": "1000",
      // eslint-disable-line
      "femtoether": "1000",
      // eslint-disable-line
      "mwei": "1000000",
      // eslint-disable-line
      "Mwei": "1000000",
      // eslint-disable-line
      "lovelace": "1000000",
      // eslint-disable-line
      "picoether": "1000000",
      // eslint-disable-line
      "gwei": "1000000000",
      // eslint-disable-line
      "Gwei": "1000000000",
      // eslint-disable-line
      "shannon": "1000000000",
      // eslint-disable-line
      "nanoether": "1000000000",
      // eslint-disable-line
      "nano": "1000000000",
      // eslint-disable-line
      "szabo": "1000000000000",
      // eslint-disable-line
      "microether": "1000000000000",
      // eslint-disable-line
      "micro": "1000000000000",
      // eslint-disable-line
      "finney": "1000000000000000",
      // eslint-disable-line
      "milliether": "1000000000000000",
      // eslint-disable-line
      "milli": "1000000000000000",
      // eslint-disable-line
      "ether": "1000000000000000000",
      // eslint-disable-line
      "kether": "1000000000000000000000",
      // eslint-disable-line
      "grand": "1000000000000000000000",
      // eslint-disable-line
      "mether": "1000000000000000000000000",
      // eslint-disable-line
      "gether": "1000000000000000000000000000",
      // eslint-disable-line
      "tether": "1000000000000000000000000000000"
    };
    function getValueOfUnit(unitInput) {
      var unit = unitInput ? unitInput.toLowerCase() : "ether";
      var unitValue = unitMap[unit];
      if (typeof unitValue !== "string") {
        throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
      }
      return new BN(unitValue, 10);
    }
    function numberToString(arg) {
      if (typeof arg === "string") {
        if (!arg.match(/^-?[0-9.]+$/)) {
          throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
        }
        return arg;
      } else if (typeof arg === "number") {
        return String(arg);
      } else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
        if (arg.toPrecision) {
          return String(arg.toPrecision());
        } else {
          return arg.toString(10);
        }
      }
      throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
    }
    function fromWei(weiInput, unit, optionsInput) {
      var wei = numberToBN(weiInput);
      var negative = wei.lt(zero);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var options = optionsInput || {};
      if (negative) {
        wei = wei.mul(negative1);
      }
      var fraction = wei.mod(base).toString(10);
      while (fraction.length < baseLength) {
        fraction = "0" + fraction;
      }
      if (!options.pad) {
        fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      }
      var whole = wei.div(base).toString(10);
      if (options.commify) {
        whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      var value = "" + whole + (fraction == "0" ? "" : "." + fraction);
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    function toWei(etherInput, unit) {
      var ether = numberToString(etherInput);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var negative = ether.substring(0, 1) === "-";
      if (negative) {
        ether = ether.substring(1);
      }
      if (ether === ".") {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
      }
      var comps = ether.split(".");
      if (comps.length > 2) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      if (fraction.length > baseLength) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
      }
      while (fraction.length < baseLength) {
        fraction += "0";
      }
      whole = new BN(whole);
      fraction = new BN(fraction);
      var wei = whole.mul(base).add(fraction);
      if (negative) {
        wei = wei.mul(negative1);
      }
      return new BN(wei.toString(10), 10);
    }
    module.exports = {
      unitMap,
      numberToString,
      getValueOfUnit,
      fromWei,
      toWei
    };
  }
});

// node_modules/utf8/utf8.js
var require_utf8 = __commonJS({
  "node_modules/utf8/utf8.js"(exports) {
    (function(root) {
      var stringFromCharCode = String.fromCharCode;
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = "";
        while (++index < length) {
          value = array[index];
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }
      function checkScalarValue(codePoint) {
        if (codePoint >= 55296 && codePoint <= 57343) {
          throw Error(
            "Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value"
          );
        }
      }
      function createByte(codePoint, shift) {
        return stringFromCharCode(codePoint >> shift & 63 | 128);
      }
      function encodeCodePoint(codePoint) {
        if ((codePoint & 4294967168) == 0) {
          return stringFromCharCode(codePoint);
        }
        var symbol = "";
        if ((codePoint & 4294965248) == 0) {
          symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
        } else if ((codePoint & 4294901760) == 0) {
          checkScalarValue(codePoint);
          symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
          symbol += createByte(codePoint, 6);
        } else if ((codePoint & 4292870144) == 0) {
          symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode(codePoint & 63 | 128);
        return symbol;
      }
      function utf8encode(string) {
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = "";
        while (++index < length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint);
        }
        return byteString;
      }
      function readContinuationByte() {
        if (byteIndex >= byteCount) {
          throw Error("Invalid byte index");
        }
        var continuationByte = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((continuationByte & 192) == 128) {
          return continuationByte & 63;
        }
        throw Error("Invalid continuation byte");
      }
      function decodeSymbol() {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;
        if (byteIndex > byteCount) {
          throw Error("Invalid byte index");
        }
        if (byteIndex == byteCount) {
          return false;
        }
        byte1 = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((byte1 & 128) == 0) {
          return byte1;
        }
        if ((byte1 & 224) == 192) {
          byte2 = readContinuationByte();
          codePoint = (byte1 & 31) << 6 | byte2;
          if (codePoint >= 128) {
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 240) == 224) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
          if (codePoint >= 2048) {
            checkScalarValue(codePoint);
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 248) == 240) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (codePoint >= 65536 && codePoint <= 1114111) {
            return codePoint;
          }
        }
        throw Error("Invalid UTF-8 detected");
      }
      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString) {
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol()) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }
      root.version = "3.0.0";
      root.encode = utf8encode;
      root.decode = utf8decode;
    })(typeof exports === "undefined" ? exports.utf8 = {} : exports);
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils9 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!isBytes(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!isBytes(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
          throw new Error("Uint8Array expected");
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils9();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils9();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils10 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.isBytes = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!isBytes(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!isBytes(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
          throw new Error("Uint8Array expected");
        sum += a.length;
      }
      let res = new Uint8Array(sum);
      let pad = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils10();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports.mapHashToField = mapHashToField;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve2 = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils10();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils10();
    var utils_js_1 = require_utils10();
    var curve_js_1 = require_curve2();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!ut.isBytes(data))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils10();
    function validateDST(dst) {
      if ((0, utils_js_1.isBytes)(dst))
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function abytes(item) {
      if (!(0, utils_js_1.isBytes)(item))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      abytes(msg);
      abytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      abytes(msg);
      abytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      abytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    exports.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils9();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils9();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k13 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils9();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils10();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k14 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = void 0;
    var secp256k1_1 = require_secp256k13();
    Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.secp256k1;
    } });
  }
});

// node_modules/@ethereumjs/util/dist/constants.js
var require_constants3 = __commonJS({
  "node_modules/@ethereumjs/util/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
    var buffer_1 = require_buffer2();
    var secp256k1_1 = require_secp256k14();
    exports.MAX_UINT64 = BigInt("0xffffffffffffffff");
    exports.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    exports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;
    exports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);
    exports.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, "hex");
    exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([128]);
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
  }
});

// node_modules/@ethereumjs/util/dist/units.js
var require_units = __commonJS({
  "node_modules/@ethereumjs/util/dist/units.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GWEI_TO_WEI = void 0;
    exports.GWEI_TO_WEI = BigInt(1e9);
  }
});

// node_modules/@ethereumjs/rlp/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@ethereumjs/rlp/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RLP = exports.utils = exports.decode = exports.encode = void 0;
    function encode(input) {
      if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i = 0; i < input.length; i++) {
          const encoded = encode(input[i]);
          output.push(encoded);
          outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
      }
      const inputBuf = toBytes(input);
      if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
      }
      return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
    }
    exports.encode = encode;
    function safeSlice(input, start, end) {
      if (end > input.length) {
        throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
      }
      return input.slice(start, end);
    }
    function decodeLength(v) {
      if (v[0] === 0) {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseHexByte(bytesToHex(v));
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Uint8Array.from([len + offset]);
      }
      const hexLength = numberToHex(len);
      const lLength = hexLength.length / 2;
      const firstByte = numberToHex(offset + 55 + lLength);
      return Uint8Array.from(hexToBytes(firstByte + hexLength));
    }
    function decode(input, stream = false) {
      if (typeof input === "undefined" || input === null || input.length === 0) {
        return Uint8Array.from([]);
      }
      const inputBytes = toBytes(input);
      const decoded = _decode(inputBytes);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid RLP: remainder must be zero");
      }
      return decoded.data;
    }
    exports.decode = decode;
    function _decode(input) {
      let length, llength, data, innerRemainder, d;
      const decoded = [];
      const firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Uint8Array.from([]);
        } else {
          data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = safeSlice(input, llength, length + llength);
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
          throw new Error("invalid RLP: encoded list too short");
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid RLP: total length is larger than the data");
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
      }
      return hex;
    }
    function parseHexByte(hexByte) {
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte))
        throw new Error("Invalid byte sequence");
      return byte;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
      }
      return array;
    }
    function concatBytes(...arrays) {
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    function utf8ToBytes(utf) {
      return new TextEncoder().encode(utf);
    }
    function numberToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      const hex = integer.toString(16);
      return hex.length % 2 ? `0${hex}` : hex;
    }
    function padToEven(a) {
      return a.length % 2 ? `0${a}` : a;
    }
    function isHexPrefixed(str) {
      return str.length >= 2 && str[0] === "0" && str[1] === "x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function toBytes(v) {
      if (v instanceof Uint8Array) {
        return v;
      }
      if (typeof v === "string") {
        if (isHexPrefixed(v)) {
          return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
      }
      if (typeof v === "number" || typeof v === "bigint") {
        if (!v) {
          return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
      }
      if (v === null || v === void 0) {
        return Uint8Array.from([]);
      }
      throw new Error("toBytes: received unsupported type " + typeof v);
    }
    exports.utils = {
      bytesToHex,
      concatBytes,
      hexToBytes,
      utf8ToBytes
    };
    exports.RLP = { encode, decode };
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha32 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils9();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js
var require_utils11 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    var _assert_1 = __importDefault(require_assert2());
    var utils_1 = require_utils9();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils9();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    exports.bytesToUtf8 = bytesToUtf8;
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    exports.hexToBytes = hexToBytes;
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.equalsBytes = equalsBytes;
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.wrapHash = wrapHash;
    exports.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha32();
    var utils_js_1 = require_utils11();
    exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/@ethereumjs/util/dist/internal.js
var require_internal2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix = (str) => {
      if (typeof str !== "string")
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports.stripHexPrefix = stripHexPrefix;
    function padToEven(value) {
      let a = value;
      if (typeof a !== "string") {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
      }
      if (a.length % 2)
        a = `0${a}`;
      return a;
    }
    exports.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
      }
      if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
      }
      return subset[some === true ? "some" : "every"]((value) => superset.indexOf(value) >= 0);
    }
    exports.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      let str = "";
      let i = 0;
      const l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i = 2;
      for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports.toAscii = toAscii;
    function fromUtf8(stringValue) {
      const str = Buffer.from(stringValue, "utf8");
      return `0x${padToEven(str.toString("hex")).replace(/^0+|0+$/g, "")}`;
    }
    exports.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      let hex = "";
      for (let i = 0; i < stringValue.length; i++) {
        const code = stringValue.charCodeAt(i);
        const n = code.toString(16);
        hex += n.length < 2 ? `0${n}` : n;
      }
      return `0x${hex}`;
    }
    exports.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
      }
      if (typeof key !== "string") {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
      }
      const result = [];
      for (let i = 0; i < params.length; i++) {
        let value = params[i][key];
        if (allowEmpty === true && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
        }
        result.push(value);
      }
      return result;
    }
    exports.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports.isHexString = isHexString;
  }
});

// node_modules/@ethereumjs/util/dist/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;
    var internal_1 = require_internal2();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsString = assertIsString;
  }
});

// node_modules/@ethereumjs/util/dist/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
    var helpers_1 = require_helpers2();
    var internal_1 = require_internal2();
    var intToHex = function(i) {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error(`Received an invalid integer type: ${i}`);
      }
      return `0x${i.toString(16)}`;
    };
    exports.intToHex = intToHex;
    var intToBuffer = function(i) {
      const hex = (0, exports.intToHex)(i);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.zeros = zeros;
    var setLength = function(msg, length, right) {
      const buf = (0, exports.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      let first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return "0x" + stripZeros(a);
    };
    exports.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports.intToBuffer)(v);
      }
      if (typeof v === "bigint") {
        if (v < BigInt(0)) {
          throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);
        }
        let n = v.toString(16);
        if (n.length % 2)
          n = "0" + n;
        return Buffer.from(n, "hex");
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports.toBuffer = toBuffer;
    var bufferToHex = function(buf) {
      buf = (0, exports.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports.bufferToHex = bufferToHex;
    function bufferToBigInt(buf) {
      const hex = (0, exports.bufferToHex)(buf);
      if (hex === "0x") {
        return BigInt(0);
      }
      return BigInt(hex);
    }
    exports.bufferToBigInt = bufferToBigInt;
    function bigIntToBuffer(num) {
      return (0, exports.toBuffer)("0x" + num.toString(16));
    }
    exports.bigIntToBuffer = bigIntToBuffer;
    var bufferToInt = function(buf) {
      const res = Number(bufferToBigInt(buf));
      if (!Number.isSafeInteger(res))
        throw new Error("Number exceeds 53 bits");
      return res;
    };
    exports.bufferToInt = bufferToInt;
    var fromSigned = function(num) {
      return BigInt.asIntN(256, bufferToBigInt(num));
    };
    exports.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return bigIntToBuffer(BigInt.asUintN(256, num));
    };
    exports.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports.addHexPrefix = addHexPrefix;
    function short(buffer, maxLength = 50) {
      const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString("hex") : buffer;
      if (bufferStr.length <= maxLength) {
        return bufferStr;
      }
      return bufferStr.slice(0, maxLength) + "";
    }
    exports.short = short;
    var toUtf8 = function(hex) {
      const zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      const bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return `0x${ba.toString("hex")}`;
      } else if (ba instanceof Array) {
        const array = [];
        for (let i = 0; i < ba.length; i++) {
          array.push((0, exports.baToJSON)(ba[i]));
        }
        return array;
      }
    };
    exports.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      for (const [k, v] of Object.entries(values)) {
        if (v !== void 0 && v.length > 0 && v[0] === 0) {
          throw new Error(`${k} cannot have leading zeroes, received: ${v.toString("hex")}`);
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map((a) => arrToBufArr(a));
    }
    exports.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr ?? []);
      }
      return arr.map((a) => bufArrToArr(a));
    }
    exports.bufArrToArr = bufArrToArr;
    var bigIntToHex = (num) => {
      return "0x" + num.toString(16);
    };
    exports.bigIntToHex = bigIntToHex;
    function bigIntToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)(bigIntToBuffer(value));
    }
    exports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;
    function intToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));
    }
    exports.intToUnpaddedBuffer = intToUnpaddedBuffer;
  }
});

// node_modules/@ethereumjs/util/dist/account.js
var require_account2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
    var rlp_1 = require_dist4();
    var keccak_1 = require_keccak2();
    var secp256k1_1 = require_secp256k14();
    var utils_1 = require_utils11();
    var bytes_1 = require_bytes2();
    var constants_1 = require_constants3();
    var helpers_1 = require_helpers2();
    var internal_1 = require_internal2();
    var _0n = BigInt(0);
    var Account = class _Account {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating an Account from varying data types.
       */
      constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
        this.nonce = nonce;
        this.balance = balance;
        this.storageRoot = storageRoot;
        this.codeHash = codeHash;
        this._validate();
      }
      static fromAccountData(accountData) {
        const { nonce, balance, storageRoot, codeHash } = accountData;
        return new _Account(nonce !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : void 0, balance !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : void 0, storageRoot !== void 0 ? (0, bytes_1.toBuffer)(storageRoot) : void 0, codeHash !== void 0 ? (0, bytes_1.toBuffer)(codeHash) : void 0);
      }
      static fromRlpSerializedAccount(serialized) {
        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized account input. Must be array");
        }
        return this.fromValuesArray(values);
      }
      static fromValuesArray(values) {
        const [nonce, balance, storageRoot, codeHash] = values;
        return new _Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);
      }
      _validate() {
        if (this.nonce < _0n) {
          throw new Error("nonce must be greater than zero");
        }
        if (this.balance < _0n) {
          throw new Error("balance must be greater than zero");
        }
        if (this.storageRoot.length !== 32) {
          throw new Error("storageRoot must have a length of 32");
        }
        if (this.codeHash.length !== 32) {
          throw new Error("codeHash must have a length of 32");
        }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */
      raw() {
        return [
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
          this.storageRoot,
          this.codeHash
        ];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */
      isContract() {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */
      isEmpty() {
        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
    };
    exports.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      let prefix = "";
      if (eip1191ChainId !== void 0) {
        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
        prefix = chainId.toString() + "0x";
      }
      const buf = Buffer.from(prefix + address, "utf8");
      const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
      let ret = "0x";
      for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
      }
      return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
    };
    exports.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      if (from.length !== 20) {
        throw new Error("Expected from to be of length 20");
      }
      if (salt.length !== 32) {
        throw new Error("Expected salt to be of length 32");
      }
      const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, keccak_1.keccak256)(initCode)]));
      return (0, bytes_1.toBuffer)(address).slice(-20);
    };
    exports.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);
    };
    exports.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        try {
          secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));
          return true;
        } catch (e) {
          return false;
        }
      }
      if (!sanitize) {
        return false;
      }
      try {
        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
        return true;
      } catch (e) {
        return false;
      }
    };
    exports.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));
      }
      if (pubKey.length !== 64) {
        throw new Error("Expected pubKey to be of length 64");
      }
      return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
    };
    exports.pubToAddress = pubToAddress;
    exports.publicToAddress = exports.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
    };
    exports.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
    };
    exports.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));
      }
      return publicKey;
    };
    exports.importPublic = importPublic;
    var zeroAddress = function() {
      const addressLength = 20;
      const addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      const zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports.isZeroAddress = isZeroAddress;
    function accountBodyFromSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash
      ];
    }
    exports.accountBodyFromSlim = accountBodyFromSlim;
    var emptyUint8Arr = new Uint8Array(0);
    function accountBodyToSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash
      ];
    }
    exports.accountBodyToSlim = accountBodyToSlim;
    function accountBodyToRLP(body, couldBeSlim = true) {
      const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
      return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));
    }
    exports.accountBodyToRLP = accountBodyToRLP;
  }
});

// node_modules/@ethereumjs/util/dist/address.js
var require_address3 = __commonJS({
  "node_modules/@ethereumjs/util/dist/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var account_1 = require_account2();
    var bytes_1 = require_bytes2();
    var Address = class _Address {
      constructor(buf) {
        if (buf.length !== 20) {
          throw new Error("Invalid address length");
        }
        this.buf = buf;
      }
      /**
       * Returns the zero address.
       */
      static zero() {
        return new _Address((0, bytes_1.zeros)(20));
      }
      /**
       * Returns an Address object from a hex-encoded string.
       * @param str - Hex-encoded address
       */
      static fromString(str) {
        if (!(0, account_1.isValidAddress)(str)) {
          throw new Error("Invalid address");
        }
        return new _Address((0, bytes_1.toBuffer)(str));
      }
      /**
       * Returns an address for a given public key.
       * @param pubKey The two points of an uncompressed key
       */
      static fromPublicKey(pubKey) {
        if (!Buffer.isBuffer(pubKey)) {
          throw new Error("Public key should be Buffer");
        }
        const buf = (0, account_1.pubToAddress)(pubKey);
        return new _Address(buf);
      }
      /**
       * Returns an address for a given private key.
       * @param privateKey A private key must be 256 bits wide
       */
      static fromPrivateKey(privateKey) {
        if (!Buffer.isBuffer(privateKey)) {
          throw new Error("Private key should be Buffer");
        }
        const buf = (0, account_1.privateToAddress)(privateKey);
        return new _Address(buf);
      }
      /**
       * Generates an address for a newly created contract.
       * @param from The address which is creating this new address
       * @param nonce The nonce of the from account
       */
      static generate(from, nonce) {
        if (typeof nonce !== "bigint") {
          throw new Error("Expected nonce to be a bigint");
        }
        return new _Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));
      }
      /**
       * Generates an address for a contract created using CREATE2.
       * @param from The address which is creating this new address
       * @param salt A salt
       * @param initCode The init code of the contract being created
       */
      static generate2(from, salt, initCode) {
        if (!Buffer.isBuffer(salt)) {
          throw new Error("Expected salt to be a Buffer");
        }
        if (!Buffer.isBuffer(initCode)) {
          throw new Error("Expected initCode to be a Buffer");
        }
        return new _Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
      }
      /**
       * Is address equal to another.
       */
      equals(address) {
        return this.buf.equals(address.buf);
      }
      /**
       * Is address zero.
       */
      isZero() {
        return this.equals(_Address.zero());
      }
      /**
       * True if address is in the address range defined
       * by EIP-1352
       */
      isPrecompileOrSystemAddress() {
        const address = (0, bytes_1.bufferToBigInt)(this.buf);
        const rangeMin = BigInt(0);
        const rangeMax = BigInt("0xffff");
        return address >= rangeMin && address <= rangeMax;
      }
      /**
       * Returns hex encoding of address.
       */
      toString() {
        return "0x" + this.buf.toString("hex");
      }
      /**
       * Returns Buffer representation of address.
       */
      toBuffer() {
        return Buffer.from(this.buf);
      }
    };
    exports.Address = Address;
  }
});

// node_modules/@ethereumjs/util/dist/types.js
var require_types6 = __commonJS({
  "node_modules/@ethereumjs/util/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toType = exports.TypeOutput = void 0;
    var bytes_1 = require_bytes2();
    var internal_1 = require_internal2();
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      const output = (0, bytes_1.toBuffer)(input);
      switch (outputType) {
        case TypeOutput.Buffer:
          return output;
        case TypeOutput.BigInt:
          return (0, bytes_1.bufferToBigInt)(output);
        case TypeOutput.Number: {
          const bigInt = (0, bytes_1.bufferToBigInt)(output);
          if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
          }
          return Number(bigInt);
        }
        case TypeOutput.PrefixedHexString:
          return (0, bytes_1.bufferToHex)(output);
        default:
          throw new Error("unknown outputType");
      }
    }
    exports.toType = toType;
  }
});

// node_modules/@ethereumjs/util/dist/withdrawal.js
var require_withdrawal = __commonJS({
  "node_modules/@ethereumjs/util/dist/withdrawal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Withdrawal = void 0;
    var address_1 = require_address3();
    var bytes_1 = require_bytes2();
    var types_1 = require_types6();
    var Withdrawal = class _Withdrawal {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
       * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
       */
      constructor(index, validatorIndex, address, amount) {
        this.index = index;
        this.validatorIndex = validatorIndex;
        this.address = address;
        this.amount = amount;
      }
      static fromWithdrawalData(withdrawalData) {
        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;
        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);
        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);
        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));
        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);
        return new _Withdrawal(index, validatorIndex, address, amount);
      }
      static fromValuesArray(withdrawalArray) {
        if (withdrawalArray.length !== 4) {
          throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
        }
        const [index, validatorIndex, address, amount] = withdrawalArray;
        return _Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });
      }
      /**
       * Convert a withdrawal to a buffer array
       * @param withdrawal the withdrawal to convert
       * @returns buffer array of the withdrawal
       */
      static toBufferArray(withdrawal) {
        const { index, validatorIndex, address, amount } = withdrawal;
        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);
        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);
        let addressBuffer;
        if (address instanceof address_1.Address) {
          addressBuffer = address.buf;
        } else {
          addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);
        }
        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);
        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];
      }
      raw() {
        return _Withdrawal.toBufferArray(this);
      }
      toValue() {
        return {
          index: this.index,
          validatorIndex: this.validatorIndex,
          address: this.address.buf,
          amount: this.amount
        };
      }
      toJSON() {
        return {
          index: (0, bytes_1.bigIntToHex)(this.index),
          validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),
          address: "0x" + this.address.buf.toString("hex"),
          amount: (0, bytes_1.bigIntToHex)(this.amount)
        };
      }
    };
    exports.Withdrawal = Withdrawal;
  }
});

// node_modules/@ethereumjs/util/dist/signature.js
var require_signature4 = __commonJS({
  "node_modules/@ethereumjs/util/dist/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var keccak_1 = require_keccak2();
    var secp256k1_1 = require_secp256k14();
    var bytes_1 = require_bytes2();
    var constants_1 = require_constants3();
    var helpers_1 = require_helpers2();
    function ecsign(msgHash, privateKey, chainId) {
      const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);
      const buf = sig.toCompactRawBytes();
      const r = Buffer.from(buf.slice(0, 32));
      const s = Buffer.from(buf.slice(32, 64));
      const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
      return { r, s, v };
    }
    exports.ecsign = ecsign;
    function calculateSigRecovery(v, chainId) {
      if (v === BigInt(0) || v === BigInt(1))
        return v;
      if (chainId === void 0) {
        return v - BigInt(27);
      }
      return v - (chainId * BigInt(2) + BigInt(35));
    }
    function isValidSigRecovery(recovery) {
      return recovery === BigInt(0) || recovery === BigInt(1);
    }
    var ecrecover = function(msgHash, v, r, s, chainId) {
      const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
      const senderPubKey = sig.recoverPublicKey(msgHash);
      return Buffer.from(senderPubKey.toRawBytes(false).slice(1));
    };
    exports.ecrecover = ecrecover;
    var toRpcSig = function(v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      let ss = s;
      if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      const buf = (0, bytes_1.toBuffer)(sig);
      let r;
      let s;
      let v;
      if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v = v + BigInt(27);
      }
      return {
        v,
        r,
        s
      };
    };
    exports.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      const rBigInt = (0, bytes_1.bufferToBigInt)(r);
      const sBigInt = (0, bytes_1.bufferToBigInt)(s);
      if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {
        return false;
      }
      if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {
        return false;
      }
      return true;
    };
    exports.isValidSignature = isValidSignature;
    var hashPersonalMessage = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      const prefix = Buffer.from(`Ethereum Signed Message:
${message.length}`, "utf-8");
      return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));
    };
    exports.hashPersonalMessage = hashPersonalMessage;
  }
});

// node_modules/@ethereumjs/util/dist/encoding.js
var require_encoding = __commonJS({
  "node_modules/@ethereumjs/util/dist/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;
    var hasTerminator = (nibbles) => {
      return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;
    };
    exports.hasTerminator = hasTerminator;
    var nibblesToBytes = (nibbles, bytes) => {
      for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {
        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];
      }
    };
    exports.nibblesToBytes = nibblesToBytes;
    var nibblesToCompactBytes = (nibbles) => {
      let terminator = 0;
      if ((0, exports.hasTerminator)(nibbles)) {
        terminator = 1;
        nibbles = nibbles.subarray(0, nibbles.length - 1);
      }
      const buf = new Uint8Array(nibbles.length / 2 + 1);
      buf[0] = terminator << 5;
      if ((nibbles.length & 1) === 1) {
        buf[0] |= 1 << 4;
        buf[0] |= nibbles[0];
        nibbles = nibbles.subarray(1);
      }
      (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));
      return buf;
    };
    exports.nibblesToCompactBytes = nibblesToCompactBytes;
    var bytesToNibbles = (str) => {
      const l = str.length * 2 + 1;
      const nibbles = new Uint8Array(l);
      for (let i = 0; i < str.length; i++) {
        const b = str[i];
        nibbles[i * 2] = b / 16;
        nibbles[i * 2 + 1] = b % 16;
      }
      nibbles[l - 1] = 16;
      return nibbles;
    };
    exports.bytesToNibbles = bytesToNibbles;
    var compactBytesToNibbles = (compact) => {
      if (compact.length === 0) {
        return compact;
      }
      let base = (0, exports.bytesToNibbles)(compact);
      if (base[0] < 2) {
        base = base.subarray(0, base.length - 1);
      }
      const chop = 2 - (base[0] & 1);
      return base.subarray(chop);
    };
    exports.compactBytesToNibbles = compactBytesToNibbles;
  }
});

// node_modules/@ethereumjs/util/dist/asyncEventEmitter.js
var require_asyncEventEmitter = __commonJS({
  "node_modules/@ethereumjs/util/dist/asyncEventEmitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncEventEmitter = void 0;
    var events_1 = require_events();
    async function runInSeries(context, tasks, data) {
      let error;
      for await (const task of tasks) {
        try {
          if (task.length < 2) {
            task.call(context, data);
          } else {
            await new Promise((resolve, reject) => {
              task.call(context, data, (error2) => {
                if (error2) {
                  reject(error2);
                } else {
                  resolve();
                }
              });
            });
          }
        } catch (e) {
          error = e;
        }
      }
      if (error) {
        throw error;
      }
    }
    var AsyncEventEmitter = class extends events_1.EventEmitter {
      emit(event, ...args) {
        let [data, callback] = args;
        const self2 = this;
        let listeners = self2._events[event] ?? [];
        if (callback === void 0 && typeof data === "function") {
          callback = data;
          data = void 0;
        }
        if (event === "newListener" || event === "removeListener") {
          data = {
            event: data,
            fn: callback
          };
          callback = void 0;
        }
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        runInSeries(self2, listeners.slice(), data).then(callback).catch(callback);
        return self2.listenerCount(event) > 0;
      }
      once(event, listener) {
        const self2 = this;
        let g;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (listener.length >= 2) {
          g = function(e, next) {
            self2.removeListener(event, g);
            void listener(e, next);
          };
        } else {
          g = function(e) {
            self2.removeListener(event, g);
            void listener(e, g);
          };
        }
        self2.on(event, g);
        return self2;
      }
      first(event, listener) {
        let listeners = this._events[event] ?? [];
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        listeners.unshift(listener);
        return this;
      }
      before(event, target, listener) {
        return this.beforeOrAfter(event, target, listener);
      }
      after(event, target, listener) {
        return this.beforeOrAfter(event, target, listener, "after");
      }
      beforeOrAfter(event, target, listener, beforeOrAfter) {
        let listeners = this._events[event] ?? [];
        let i;
        let index;
        const add = beforeOrAfter === "after" ? 1 : 0;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (typeof target !== "function") {
          throw new TypeError("target must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        index = listeners.length;
        for (i = listeners.length; i--; ) {
          if (listeners[i] === target) {
            index = i + add;
            break;
          }
        }
        listeners.splice(index, 0, listener);
        return this;
      }
      on(event, listener) {
        return super.on(event, listener);
      }
      addListener(event, listener) {
        return super.addListener(event, listener);
      }
      prependListener(event, listener) {
        return super.prependListener(event, listener);
      }
      prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
      }
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
      eventNames() {
        return super.eventNames();
      }
      listeners(event) {
        return super.listeners(event);
      }
      listenerCount(event) {
        return super.listenerCount(event);
      }
      getMaxListeners() {
        return super.getMaxListeners();
      }
      setMaxListeners(maxListeners) {
        return super.setMaxListeners(maxListeners);
      }
    };
    exports.AsyncEventEmitter = AsyncEventEmitter;
  }
});

// node_modules/@ethereumjs/util/dist/lock.js
var require_lock = __commonJS({
  "node_modules/@ethereumjs/util/dist/lock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lock = void 0;
    var Lock = class {
      constructor() {
        this.permits = 1;
        this.promiseResolverQueue = [];
      }
      /**
       * Returns a promise used to wait for a permit to become available. This method should be awaited on.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      async acquire() {
        if (this.permits > 0) {
          this.permits -= 1;
          return Promise.resolve(true);
        }
        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
      }
      /**
       * Increases the number of permits by one. If there are other functions waiting, one of them will
       * continue to execute in a future iteration of the event loop.
       */
      release() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
          console.warn("Lock.permits should never be > 0 when there is someone waiting.");
        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
          this.permits -= 1;
          const nextResolver = this.promiseResolverQueue.shift();
          if (nextResolver) {
            nextResolver(true);
          }
        }
      }
    };
    exports.Lock = Lock;
  }
});

// node_modules/micro-ftch/index.js
var require_micro_ftch = __commonJS({
  "node_modules/micro-ftch/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStatusCodeError = exports.InvalidCertError = void 0;
    var DEFAULT_OPT = Object.freeze({
      redirect: true,
      expectStatusCode: 200,
      headers: {},
      full: false,
      keepAlive: true,
      cors: false,
      referrer: false,
      sslAllowSelfSigned: false,
      _redirectCount: 0
    });
    var InvalidCertError = class extends Error {
      constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
      }
    };
    exports.InvalidCertError = InvalidCertError;
    var InvalidStatusCodeError = class extends Error {
      constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
      }
    };
    exports.InvalidStatusCodeError = InvalidStatusCodeError;
    function detectType(b, type) {
      if (!type || type === "text" || type === "json") {
        try {
          let text = new TextDecoder("utf8", { fatal: true }).decode(b);
          if (type === "text")
            return text;
          try {
            return JSON.parse(text);
          } catch (err) {
            if (type === "json")
              throw err;
            return text;
          }
        } catch (err) {
          if (type === "text" || type === "json")
            throw err;
        }
      }
      return b;
    }
    var agents = {};
    function fetchNode(url, _options) {
      var _a;
      let options = { ...DEFAULT_OPT, ..._options };
      const http = require_http();
      const https = require_https();
      const zlib = require_zlib();
      const { promisify } = require_util();
      const { resolve: urlResolve } = require_url();
      const isSecure = !!/^https/.test(url);
      let opts = {
        method: options.method || "GET",
        headers: { "Accept-Encoding": "gzip, deflate, br" }
      };
      const compactFP = (s) => s.replace(/:| /g, "").toLowerCase();
      if (options.keepAlive) {
        const agentOpt = {
          keepAlive: true,
          keepAliveMsecs: 30 * 1e3,
          maxFreeSockets: 1024,
          maxCachedSessions: 1024
        };
        const agentKey = [
          isSecure,
          isSecure && ((_a = options.sslPinnedCertificates) == null ? void 0 : _a.map((i) => compactFP(i)).sort())
        ].join();
        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
      }
      if (options.type === "json")
        opts.headers["Content-Type"] = "application/json";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      opts.headers = { ...opts.headers, ...options.headers };
      if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
      const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers["location"]) {
          if (options._redirectCount == 10)
            throw new Error("Request failed. Too much redirects.");
          options._redirectCount += 1;
          return await fetchNode(urlResolve(url, res.headers["location"]), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
          res.resume();
          throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
          buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers["content-encoding"];
        if (encoding === "br")
          bytes = await promisify(zlib.brotliDecompress)(bytes);
        if (encoding === "gzip" || encoding === "deflate")
          bytes = await promisify(zlib.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
          return { headers: res.headers, status, body };
        return body;
      };
      return new Promise((resolve, reject) => {
        var _a2;
        const handleError = async (err) => {
          if (err && err.code === "DEPTH_ZERO_SELF_SIGNED_CERT") {
            try {
              await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
            } catch (e) {
              if (e && e.fingerprint256) {
                err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);
              }
            }
          }
          reject(err);
        };
        const req = (isSecure ? https : http).request(url, opts, (res) => {
          res.on("error", handleError);
          (async () => {
            try {
              resolve(await handleRes(res));
            } catch (error) {
              reject(error);
            }
          })();
        });
        req.on("error", handleError);
        const pinned = (_a2 = options.sslPinnedCertificates) == null ? void 0 : _a2.map((i) => compactFP(i));
        const mfetchSecureConnect = (socket) => {
          var _a3;
          const fp256 = compactFP(((_a3 = socket.getPeerCertificate()) == null ? void 0 : _a3.fingerprint256) || "");
          if (!fp256 && socket.isSessionReused())
            return;
          if (pinned.includes(fp256))
            return;
          req.emit("error", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
          return req.abort();
        };
        if (options.sslPinnedCertificates) {
          req.on("socket", (socket) => {
            const hasListeners = socket.listeners("secureConnect").map((i) => (i.name || "").replace("bound ", "")).includes("mfetchSecureConnect");
            if (hasListeners)
              return;
            socket.on("secureConnect", mfetchSecureConnect.bind(null, socket));
          });
        }
        if (options.keepAlive)
          req.setNoDelay(true);
        if (opts.body)
          req.write(opts.body);
        req.end();
      });
    }
    var SAFE_HEADERS = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((i) => i.toLowerCase()));
    var FORBIDDEN_HEADERS = new Set([
      "Accept-Charset",
      "Accept-Encoding",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Connection",
      "Content-Length",
      "Cookie",
      "Cookie2",
      "Date",
      "DNT",
      "Expect",
      "Host",
      "Keep-Alive",
      "Origin",
      "Referer",
      "TE",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Via"
    ].map((i) => i.toLowerCase()));
    async function fetchBrowser(url, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const headers = new Headers();
      if (options.type === "json")
        headers.set("Content-Type", "application/json");
      let parsed = new URL(url);
      if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set("Authorization", `Basic ${auth}`);
        parsed.username = "";
        parsed.password = "";
      }
      url = "" + parsed;
      for (let k in options.headers) {
        const name = k.toLowerCase();
        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name))
          headers.set(k, options.headers[k]);
      }
      let opts = { headers, redirect: options.redirect ? "follow" : "manual" };
      if (!options.referrer)
        opts.referrerPolicy = "no-referrer";
      if (options.cors)
        opts.mode = "cors";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      const res = await fetch(url, opts);
      if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
      const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
      if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
      return body;
    }
    var IS_NODE = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
    function fetchUrl(url, options) {
      const fn = IS_NODE ? fetchNode : fetchBrowser;
      return fn(url, options);
    }
    exports.default = fetchUrl;
  }
});

// node_modules/@ethereumjs/util/dist/provider.js
var require_provider2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProvider = exports.fetchFromProvider = void 0;
    var micro_ftch_1 = require_micro_ftch();
    var fetchFromProvider = async (url, params) => {
      const res = await (0, micro_ftch_1.default)(url, {
        headers: {
          "content-type": "application/json"
        },
        type: "json",
        data: {
          method: params.method,
          params: params.params,
          jsonrpc: "2.0",
          id: 1
        }
      });
      return res.result;
    };
    exports.fetchFromProvider = fetchFromProvider;
    var getProvider = (provider) => {
      var _a;
      if (typeof provider === "string") {
        return provider;
      } else if (((_a = provider == null ? void 0 : provider.connection) == null ? void 0 : _a.url) !== void 0) {
        return provider.connection.url;
      } else {
        throw new Error("Must provide valid provider URL or Web3Provider");
      }
    };
    exports.getProvider = getProvider;
  }
});

// node_modules/@ethereumjs/util/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@ethereumjs/util/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;
    __exportStar(require_constants3(), exports);
    __exportStar(require_units(), exports);
    __exportStar(require_account2(), exports);
    __exportStar(require_address3(), exports);
    __exportStar(require_withdrawal(), exports);
    __exportStar(require_signature4(), exports);
    __exportStar(require_bytes2(), exports);
    __exportStar(require_types6(), exports);
    __exportStar(require_encoding(), exports);
    __exportStar(require_asyncEventEmitter(), exports);
    var internal_1 = require_internal2();
    Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
    Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    __exportStar(require_lock(), exports);
    __exportStar(require_provider2(), exports);
  }
});

// node_modules/ethereum-bloom-filters/dist/utils.js
var require_utils12 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha3 = require_sha3();
    function keccak256(data) {
      return "0x" + sha3.keccak_256(toByteArray(data));
    }
    exports.keccak256 = keccak256;
    exports.padLeft = (value, chars) => {
      const hasPrefix = /^0x/i.test(value) || typeof value === "number";
      value = value.toString().replace(/^0x/i, "");
      const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join("0") + value;
    };
    function bytesToHex(bytes) {
      const hex = [];
      for (let i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return `0x${hex.join("").replace(/^0+/, "")}`;
    }
    exports.bytesToHex = bytesToHex;
    function toByteArray(value) {
      if (value == null) {
        throw new Error("cannot convert null value to array");
      }
      if (typeof value === "string") {
        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!match) {
          throw new Error("invalid hexidecimal string");
        }
        if (match[1] !== "0x") {
          throw new Error("hex string must have 0x prefix");
        }
        value = value.substring(2);
        if (value.length % 2) {
          value = "0" + value;
        }
        const result = [];
        for (let i = 0; i < value.length; i += 2) {
          result.push(parseInt(value.substr(i, 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isByteArray(value)) {
        return addSlice(new Uint8Array(value));
      }
      throw new Error("invalid arrayify value");
    }
    exports.toByteArray = toByteArray;
    function isByteArray(value) {
      if (!value || // tslint:disable-next-line: radix
      parseInt(String(value.length)) != value.length || typeof value === "string") {
        return false;
      }
      for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
          return false;
        }
      }
      return true;
    }
    function addSlice(array) {
      if (array.slice !== void 0) {
        return array;
      }
      array.slice = () => {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
  }
});

// node_modules/ethereum-bloom-filters/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils12();
    function isBloom(bloom) {
      if (typeof bloom !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
      }
      if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
      }
      return false;
    }
    exports.isBloom = isBloom;
    function isInBloom(bloom, value) {
      if (typeof value === "object" && value.constructor === Uint8Array) {
        value = utils_1.bytesToHex(value);
      }
      const hash = utils_1.keccak256(value).replace("0x", "");
      for (let i = 0; i < 12; i += 4) {
        const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;
        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
        const offset = 1 << bitpos % 4;
        if ((code & offset) !== offset) {
          return false;
        }
      }
      return true;
    }
    exports.isInBloom = isInBloom;
    function codePointToInt(codePoint) {
      if (codePoint >= 48 && codePoint <= 57) {
        return codePoint - 48;
      }
      if (codePoint >= 65 && codePoint <= 70) {
        return codePoint - 55;
      }
      if (codePoint >= 97 && codePoint <= 102) {
        return codePoint - 87;
      }
      throw new Error("invalid bloom");
    }
    function isUserEthereumAddressInBloom(bloom, ethereumAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(ethereumAddress)) {
        throw new Error(`Invalid ethereum address given: "${ethereumAddress}"`);
      }
      const address = utils_1.padLeft(ethereumAddress, 64);
      return isInBloom(bloom, address);
    }
    exports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;
    function isContractAddressInBloom(bloom, contractAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address given: "${contractAddress}"`);
      }
      return isInBloom(bloom, contractAddress);
    }
    exports.isContractAddressInBloom = isContractAddressInBloom;
    function isTopicInBloom(bloom, topic) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isTopic(topic)) {
        throw new Error("Invalid topic");
      }
      return isInBloom(bloom, topic);
    }
    exports.isTopicInBloom = isTopicInBloom;
    function isTopic(topic) {
      if (typeof topic !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
      }
      return false;
    }
    exports.isTopic = isTopic;
    function isAddress(address) {
      if (typeof address !== "string") {
        return false;
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        return true;
      }
      if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        return true;
      }
      return false;
    }
    exports.isAddress = isAddress;
  }
});

// node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js
var require_utils13 = __commonJS({
  "node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    var _assert_1 = __importDefault(require_assert2());
    var utils_1 = require_utils9();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils9();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    exports.bytesToUtf8 = bytesToUtf8;
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    exports.hexToBytes = hexToBytes;
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.equalsBytes = equalsBytes;
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.wrapHash = wrapHash;
    exports.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha32();
    var utils_js_1 = require_utils13();
    exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/web3-utils/lib/utils.js
var require_utils14 = __commonJS({
  "node_modules/web3-utils/lib/utils.js"(exports, module) {
    var BN = require_bn();
    var numberToBN = require_src6();
    var utf8 = require_utf8();
    var ethereumjsUtil = require_dist5();
    var ethereumBloomFilters = require_dist6();
    var { keccak256 } = require_keccak3();
    var isBN = function(object) {
      return BN.isBN(object);
    };
    var isBigNumber = function(object) {
      return object && object.constructor && object.constructor.name === "BigNumber";
    };
    var toBN = function(number) {
      try {
        return numberToBN.apply(null, arguments);
      } catch (e) {
        throw new Error(e + ' Given value: "' + number + '"');
      }
    };
    var toTwosComplement = function(number) {
      return "0x" + toBN(number).toTwos(256).toString(16, 64);
    };
    var isAddress = function(address) {
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return checkAddressChecksum(address);
      }
    };
    var checkAddressChecksum = function(address) {
      address = address.replace(/^0x/i, "");
      var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, "");
      for (var i = 0; i < 40; i++) {
        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
          return false;
        }
      }
      return true;
    };
    var leftPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join(sign ? sign : "0") + string;
    };
    var rightPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + string + new Array(padding).join(sign ? sign : "0");
    };
    var utf8ToHex = function(str) {
      str = utf8.encode(str);
      var hex = "";
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var hexToUtf8 = function(hex) {
      if (!isHexStrict(hex))
        throw new Error('The parameter "' + hex + '" must be a valid HEX string.');
      var str = "";
      var code = 0;
      hex = hex.replace(/^0x/i, "");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      var l = hex.length;
      for (var i = 0; i < l; i += 2) {
        code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
      }
      return utf8.decode(str);
    };
    var hexToNumber = function(value, bigIntOnOverflow = false) {
      if (!value) {
        return value;
      }
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      const n = toBN(value);
      if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {
        return BigInt(n);
      }
      return n.toNumber();
    };
    var hexToNumberString = function(value) {
      if (!value)
        return value;
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      return toBN(value).toString(10);
    };
    var numberToHex = function(value) {
      if (value === null || value === void 0) {
        return value;
      }
      if (!isFinite(value) && !isHexStrict(value)) {
        throw new Error('Given input "' + value + '" is not a number.');
      }
      var number = toBN(value);
      var result = number.toString(16);
      return number.lt(new BN(0)) ? "-0x" + result.slice(1) : "0x" + result;
    };
    var bytesToHex = function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return "0x" + hex.join("");
    };
    var hexToBytes = function(hex) {
      hex = hex.toString(16);
      if (!isHexStrict(hex)) {
        throw new Error('Given value "' + hex + '" is not a valid hex string.');
      }
      hex = hex.replace(/^0x/i, "");
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.slice(c, c + 2), 16));
      return bytes;
    };
    var toHex = function(value, returnType) {
      if (isAddress(value)) {
        return returnType ? "address" : "0x" + value.toLowerCase().replace(/^0x/i, "");
      }
      if (typeof value === "boolean") {
        return returnType ? "bool" : value ? "0x01" : "0x00";
      }
      if (Buffer.isBuffer(value)) {
        return "0x" + value.toString("hex");
      }
      if (typeof value === "object" && !!value && !isBigNumber(value) && !isBN(value)) {
        return returnType ? "string" : utf8ToHex(JSON.stringify(value));
      }
      if (typeof value === "string") {
        if (value.indexOf("-0x") === 0 || value.indexOf("-0X") === 0) {
          return returnType ? "int256" : numberToHex(value);
        } else if (value.indexOf("0x") === 0 || value.indexOf("0X") === 0) {
          return returnType ? "bytes" : value;
        } else if (!isFinite(value)) {
          return returnType ? "string" : utf8ToHex(value);
        }
      }
      return returnType ? value < 0 ? "int256" : "uint256" : numberToHex(value);
    };
    var isHexStrict = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
    };
    var isHex = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);
    };
    var stripHexPrefix = function(str) {
      if (str !== 0 && isHex(str))
        return str.replace(/^(-)?0x/i, "$1");
      return str;
    };
    var isBloom = function(bloom) {
      return ethereumBloomFilters.isBloom(bloom);
    };
    var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {
      return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);
    };
    var isContractAddressInBloom = function(bloom, contractAddress) {
      return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);
    };
    var isTopic = function(topic) {
      return ethereumBloomFilters.isTopic(topic);
    };
    var isTopicInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isTopicInBloom(bloom, topic);
    };
    var isInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isInBloom(bloom, topic);
    };
    var SHA3_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    var sha3 = function(value) {
      if (isBN(value)) {
        value = value.toString();
      }
      if (isHexStrict(value) && /^0x/i.test(value.toString())) {
        value = ethereumjsUtil.toBuffer(value);
      } else if (typeof value === "string") {
        value = Buffer.from(value, "utf-8");
      }
      var returnValue = ethereumjsUtil.bufferToHex(keccak256(value));
      if (returnValue === SHA3_NULL_S) {
        return null;
      } else {
        return returnValue;
      }
    };
    sha3._Hash = keccak256;
    var sha3Raw = function(value) {
      value = sha3(value);
      if (value === null) {
        return SHA3_NULL_S;
      }
      return value;
    };
    var toNumber = function(value, bigIntOnOverflow = false) {
      return typeof value === "number" ? value : hexToNumber(toHex(value), bigIntOnOverflow);
    };
    var BNwrapped = function(value) {
      if (typeof value == "string" && value.includes("0x")) {
        const [negative, hexValue] = value.toLocaleLowerCase().startsWith("-") ? ["-", value.slice(3)] : ["", value.slice(2)];
        return new BN(negative + hexValue, 16);
      } else {
        return new BN(value);
      }
    };
    Object.setPrototypeOf(BNwrapped, BN);
    Object.setPrototypeOf(BNwrapped.prototype, BN.prototype);
    module.exports = {
      BN: BNwrapped,
      isBN,
      isBigNumber,
      toBN,
      isAddress,
      isBloom,
      isUserEthereumAddressInBloom,
      isContractAddressInBloom,
      isTopic,
      isTopicInBloom,
      isInBloom,
      checkAddressChecksum,
      utf8ToHex,
      hexToUtf8,
      hexToNumber,
      hexToNumberString,
      numberToHex,
      toHex,
      hexToBytes,
      bytesToHex,
      isHex,
      isHexStrict,
      stripHexPrefix,
      leftPad,
      rightPad,
      toTwosComplement,
      sha3,
      sha3Raw,
      toNumber
    };
  }
});

// node_modules/web3-utils/lib/soliditySha3.js
var require_soliditySha3 = __commonJS({
  "node_modules/web3-utils/lib/soliditySha3.js"(exports, module) {
    var BN = require_bn();
    var utils = require_utils14();
    var _elementaryName = function(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    };
    var _parseTypeN = function(type) {
      var typesize = /^\D+(\d+).*$/.exec(type);
      return typesize ? parseInt(typesize[1], 10) : null;
    };
    var _parseTypeNArray = function(type) {
      var arraySize = /^\D+\d*\[(\d+)\]$/.exec(type);
      return arraySize ? parseInt(arraySize[1], 10) : null;
    };
    var _parseNumber = function(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (utils.isHexStrict(arg)) {
          return new BN(arg.replace(/0x/i, ""), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (utils.isBigNumber(arg)) {
        return new BN(arg.toString(10));
      } else if (utils.isBN(arg)) {
        return arg;
      } else {
        throw new Error(arg + " is not a number");
      }
    };
    var _solidityPack = function(type, value, arraySize) {
      var size, num;
      type = _elementaryName(type);
      if (type === "bytes") {
        if (value.replace(/^0x/i, "").length % 2 !== 0) {
          throw new Error("Invalid bytes characters " + value.length);
        }
        return value;
      } else if (type === "string") {
        return utils.utf8ToHex(value);
      } else if (type === "bool") {
        return value ? "01" : "00";
      } else if (type.startsWith("address")) {
        if (arraySize) {
          size = 64;
        } else {
          size = 40;
        }
        if (!utils.isAddress(value)) {
          throw new Error(value + " is not a valid address, or the checksum is invalid.");
        }
        return utils.leftPad(value.toLowerCase(), size);
      }
      size = _parseTypeN(type);
      if (type.startsWith("bytes")) {
        if (!size) {
          throw new Error("bytes[] not yet supported in solidity");
        }
        if (arraySize) {
          size = 32;
        }
        if (size < 1 || size > 32 || size < value.replace(/^0x/i, "").length / 2) {
          throw new Error("Invalid bytes" + size + " for " + value);
        }
        return utils.rightPad(value, size * 2);
      } else if (type.startsWith("uint")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          throw new Error("Supplied uint " + num.toString() + " is negative");
        }
        return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
      } else if (type.startsWith("int")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          return num.toTwos(size).toString("hex");
        } else {
          return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
        }
      } else {
        throw new Error("Unsupported or invalid type: " + type);
      }
    };
    var _processSolidityEncodePackedArgs = function(arg) {
      if (Array.isArray(arg)) {
        throw new Error("Autodetection of array types is not supported.");
      }
      var type, value = "";
      var hexArg, arraySize;
      if (!!arg && typeof arg === "object" && (arg.hasOwnProperty("v") || arg.hasOwnProperty("t") || arg.hasOwnProperty("value") || arg.hasOwnProperty("type"))) {
        type = arg.hasOwnProperty("t") ? arg.t : arg.type;
        value = arg.hasOwnProperty("v") ? arg.v : arg.value;
      } else {
        type = utils.toHex(arg, true);
        value = utils.toHex(arg);
        if (!type.startsWith("int") && !type.startsWith("uint")) {
          type = "bytes";
        }
      }
      if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
        value = new BN(value);
      }
      if (Array.isArray(value)) {
        arraySize = _parseTypeNArray(type);
        if (arraySize && value.length !== arraySize) {
          throw new Error(type + " is not matching the given array " + JSON.stringify(value));
        } else {
          arraySize = value.length;
        }
      }
      if (Array.isArray(value)) {
        hexArg = value.map(function(val) {
          return _solidityPack(type, val, arraySize).toString("hex").replace("0x", "");
        });
        return hexArg.join("");
      } else {
        hexArg = _solidityPack(type, value, arraySize);
        return hexArg.toString("hex").replace("0x", "");
      }
    };
    var soliditySha3 = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return utils.sha3("0x" + hexArgs.join(""));
    };
    var soliditySha3Raw = function() {
      return utils.sha3Raw("0x" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(""));
    };
    var encodePacked = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return "0x" + hexArgs.join("").toLowerCase();
    };
    module.exports = {
      soliditySha3,
      soliditySha3Raw,
      encodePacked
    };
  }
});

// node_modules/web3-utils/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/web3-utils/lib/index.js"(exports, module) {
    var ethjsUnit = require_lib2();
    var utils = require_utils14();
    var soliditySha3 = require_soliditySha3();
    var randombytes = require_browser();
    var BN = require_bn();
    var _fireError = function(error, emitter, reject, callback, optionalData) {
      if (!!error && typeof error === "object" && !(error instanceof Error) && error.data) {
        if (!!error.data && typeof error.data === "object" || Array.isArray(error.data)) {
          error.data = JSON.stringify(error.data, null, 2);
        }
        error = error.message + "\n" + error.data;
      }
      if (typeof error === "string") {
        error = new Error(error);
      }
      if (typeof callback === "function") {
        callback(error, optionalData);
      }
      if (typeof reject === "function") {
        if (emitter && (typeof emitter.listeners === "function" && emitter.listeners("error").length) || typeof callback === "function") {
          emitter.catch(function() {
          });
        }
        setTimeout(function() {
          reject(error);
        }, 1);
      }
      if (emitter && typeof emitter.emit === "function") {
        setTimeout(function() {
          emitter.emit("error", error, optionalData);
          emitter.removeAllListeners();
        }, 1);
      }
      return emitter;
    };
    var _jsonInterfaceMethodToString = function(json) {
      if (!!json && typeof json === "object" && json.name && json.name.indexOf("(") !== -1) {
        return json.name;
      }
      return json.name + "(" + _flattenTypes(false, json.inputs).join(",") + ")";
    };
    var _flattenTypes = function(includeTuple, puts) {
      var types = [];
      puts.forEach(function(param) {
        if (typeof param.components === "object") {
          if (param.type.substring(0, 5) !== "tuple") {
            throw new Error("components found but type is not tuple; report on GitHub");
          }
          var suffix = "";
          var arrayBracket = param.type.indexOf("[");
          if (arrayBracket >= 0) {
            suffix = param.type.substring(arrayBracket);
          }
          var result = _flattenTypes(includeTuple, param.components);
          if (Array.isArray(result) && includeTuple) {
            types.push("tuple(" + result.join(",") + ")" + suffix);
          } else if (!includeTuple) {
            types.push("(" + result.join(",") + ")" + suffix);
          } else {
            types.push("(" + result + ")");
          }
        } else {
          types.push(param.type);
        }
      });
      return types;
    };
    var randomHex = function(size) {
      return "0x" + randombytes(size).toString("hex");
    };
    var hexToAscii = function(hex) {
      if (!utils.isHexStrict(hex))
        throw new Error("The parameter must be a valid HEX string.");
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    };
    var asciiToHex = function(str) {
      if (!str)
        return "0x00";
      var hex = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var getUnitValue = function(unit) {
      unit = unit ? unit.toLowerCase() : "ether";
      if (!ethjsUnit.unitMap[unit]) {
        throw new Error('This unit "' + unit + `" doesn't exist, please use the one of the following units` + JSON.stringify(ethjsUnit.unitMap, null, 2));
      }
      return unit;
    };
    var fromWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);
    };
    var toWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);
    };
    var toChecksumAddress = function(address) {
      if (typeof address === "undefined")
        return "";
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address))
        throw new Error('Given address "' + address + '" is not a valid Ethereum address.');
      address = address.toLowerCase().replace(/^0x/i, "");
      var addressHash = utils.sha3(address).replace(/^0x/i, "");
      var checksumAddress = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
          checksumAddress += address[i];
        }
      }
      return checksumAddress;
    };
    var compareBlockNumbers = function(a, b) {
      if (a === b) {
        return 0;
      } else if (("genesis" === a || "earliest" === a || 0 === a) && ("genesis" === b || "earliest" === b || 0 === b)) {
        return 0;
      } else if ("genesis" === a || "earliest" === a || a === 0) {
        return -1;
      } else if ("genesis" === b || "earliest" === b || b === 0) {
        return 1;
      } else if (a === "latest" || a === "finalized") {
        if (b === "pending") {
          return -1;
        } else {
          return 1;
        }
      } else if (b === "latest" || b === "finalized") {
        if (a === "pending") {
          return 1;
        } else {
          return -1;
        }
      } else if (a === "pending") {
        return 1;
      } else if (b === "pending") {
        return -1;
      } else if (a === "safe" || b === "safe") {
        return void 0;
      } else {
        let bnA = new BN(a);
        let bnB = new BN(b);
        if (bnA.lt(bnB)) {
          return -1;
        } else if (bnA.eq(bnB)) {
          return 0;
        } else {
          return 1;
        }
      }
    };
    module.exports = {
      _fireError,
      _jsonInterfaceMethodToString,
      _flattenTypes,
      // extractDisplayName: extractDisplayName,
      // extractTypeName: extractTypeName,
      randomHex,
      BN: utils.BN,
      isBN: utils.isBN,
      isBigNumber: utils.isBigNumber,
      isHex: utils.isHex,
      isHexStrict: utils.isHexStrict,
      sha3: utils.sha3,
      sha3Raw: utils.sha3Raw,
      keccak256: utils.sha3,
      soliditySha3: soliditySha3.soliditySha3,
      soliditySha3Raw: soliditySha3.soliditySha3Raw,
      encodePacked: soliditySha3.encodePacked,
      isAddress: utils.isAddress,
      checkAddressChecksum: utils.checkAddressChecksum,
      toChecksumAddress,
      toHex: utils.toHex,
      toBN: utils.toBN,
      bytesToHex: utils.bytesToHex,
      hexToBytes: utils.hexToBytes,
      hexToNumberString: utils.hexToNumberString,
      hexToNumber: utils.hexToNumber,
      toDecimal: utils.hexToNumber,
      numberToHex: utils.numberToHex,
      fromDecimal: utils.numberToHex,
      hexToUtf8: utils.hexToUtf8,
      hexToString: utils.hexToUtf8,
      toUtf8: utils.hexToUtf8,
      stripHexPrefix: utils.stripHexPrefix,
      utf8ToHex: utils.utf8ToHex,
      stringToHex: utils.utf8ToHex,
      fromUtf8: utils.utf8ToHex,
      hexToAscii,
      toAscii: hexToAscii,
      asciiToHex,
      fromAscii: asciiToHex,
      unitMap: ethjsUnit.unitMap,
      toWei,
      fromWei,
      padLeft: utils.leftPad,
      leftPad: utils.leftPad,
      padRight: utils.rightPad,
      rightPad: utils.rightPad,
      toTwosComplement: utils.toTwosComplement,
      isBloom: utils.isBloom,
      isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,
      isContractAddressInBloom: utils.isContractAddressInBloom,
      isTopic: utils.isTopic,
      isTopicInBloom: utils.isTopicInBloom,
      isInBloom: utils.isInBloom,
      compareBlockNumbers,
      toNumber: utils.toNumber
    };
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/eip-3770/config.js
var require_config2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/eip-3770/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.networks = void 0;
    exports.networks = [
      { chainId: 1, shortName: "eth" },
      { chainId: 3, shortName: "rop" },
      { chainId: 4, shortName: "rin" },
      { chainId: 5, shortName: "gor" },
      { chainId: 10, shortName: "oeth" },
      { chainId: 11, shortName: "meta" },
      { chainId: 12, shortName: "kal" },
      { chainId: 18, shortName: "tst" },
      { chainId: 25, shortName: "cro" },
      { chainId: 28, shortName: "bobarinkeby" },
      { chainId: 39, shortName: "u2u" },
      { chainId: 40, shortName: "telosevm" },
      { chainId: 41, shortName: "telosevmtestnet" },
      { chainId: 42, shortName: "kov" },
      { chainId: 44, shortName: "crab" },
      { chainId: 46, shortName: "darwinia" },
      { chainId: 50, shortName: "xdc" },
      { chainId: 51, shortName: "txdc" },
      { chainId: 56, shortName: "bnb" },
      { chainId: 57, shortName: "sys" },
      { chainId: 61, shortName: "etc" },
      { chainId: 63, shortName: "metc" },
      { chainId: 69, shortName: "okov" },
      { chainId: 82, shortName: "meter" },
      { chainId: 83, shortName: "meter-test" },
      { chainId: 97, shortName: "bnbt" },
      { chainId: 100, shortName: "gno" },
      { chainId: 106, shortName: "vlx" },
      { chainId: 108, shortName: "tt" },
      { chainId: 111, shortName: "etl" },
      { chainId: 122, shortName: "fuse" },
      { chainId: 123, shortName: "spark" },
      { chainId: 137, shortName: "matic" },
      { chainId: 155, shortName: "tenet-testnet" },
      { chainId: 246, shortName: "ewt" },
      { chainId: 250, shortName: "ftm" },
      { chainId: 280, shortName: "zksync-goerli" },
      { chainId: 288, shortName: "boba" },
      { chainId: 300, shortName: "ogn" },
      { chainId: 321, shortName: "kcs" },
      { chainId: 322, shortName: "kcst" },
      { chainId: 324, shortName: "zksync" },
      { chainId: 336, shortName: "sdn" },
      { chainId: 338, shortName: "tcro" },
      { chainId: 420, shortName: "ogor" },
      { chainId: 570, shortName: "sys-rollux" },
      { chainId: 588, shortName: "metis-stardust" },
      { chainId: 592, shortName: "astr" },
      { chainId: 595, shortName: "maca" },
      { chainId: 599, shortName: "metis-goerli" },
      { chainId: 686, shortName: "kar" },
      { chainId: 787, shortName: "aca" },
      { chainId: 1001, shortName: "baobab" },
      { chainId: 1008, shortName: "eun" },
      { chainId: 1088, shortName: "metis-andromeda" },
      { chainId: 1101, shortName: "zkevm" },
      { chainId: 1111, shortName: "wemix" },
      { chainId: 1112, shortName: "twemix" },
      { chainId: 1115, shortName: "tcore" },
      { chainId: 1116, shortName: "core" },
      { chainId: 1284, shortName: "mbeam" },
      { chainId: 1285, shortName: "mriver" },
      { chainId: 1287, shortName: "mbase" },
      { chainId: 1294, shortName: "bobabeam" },
      { chainId: 1559, shortName: "tenet" },
      { chainId: 1807, shortName: "rana" },
      { chainId: 1984, shortName: "euntest" },
      { chainId: 2001, shortName: "milkada" },
      { chainId: 2002, shortName: "milkalgo" },
      { chainId: 2008, shortName: "cloudwalk_testnet" },
      { chainId: 2019, shortName: "pmint_test" },
      { chainId: 2020, shortName: "pmint" },
      { chainId: 2221, shortName: "tkava" },
      { chainId: 2222, shortName: "kava" },
      { chainId: 3737, shortName: "csb" },
      { chainId: 4002, shortName: "tftm" },
      { chainId: 4689, shortName: "iotex-mainnet" },
      { chainId: 4918, shortName: "txvm" },
      { chainId: 4919, shortName: "xvm" },
      { chainId: 5e3, shortName: "mantle" },
      { chainId: 5001, shortName: "mantle-testnet" },
      { chainId: 5700, shortName: "tsys" },
      { chainId: 7341, shortName: "shyft" },
      { chainId: 7700, shortName: "canto" },
      { chainId: 8217, shortName: "cypress" },
      { chainId: 8453, shortName: "base" },
      { chainId: 9e3, shortName: "evmos-testnet" },
      { chainId: 9001, shortName: "evmos" },
      { chainId: 9728, shortName: "boba-testnet" },
      { chainId: 1e4, shortName: "smartbch" },
      { chainId: 10001, shortName: "smartbchtest" },
      { chainId: 10200, shortName: "chi" },
      { chainId: 11235, shortName: "islm" },
      { chainId: 11437, shortName: "shyftt" },
      { chainId: 12357, shortName: "rei-testnet" },
      { chainId: 23294, shortName: "sapphire" },
      { chainId: 23295, shortName: "sapphire-testnet" },
      { chainId: 42161, shortName: "arb1" },
      { chainId: 42170, shortName: "arb-nova" },
      { chainId: 42220, shortName: "celo" },
      { chainId: 43113, shortName: "fuji" },
      { chainId: 43114, shortName: "avax" },
      { chainId: 43288, shortName: "boba-avax" },
      { chainId: 44787, shortName: "alfa" },
      { chainId: 45e3, shortName: "autobahnnetwork" },
      { chainId: 47805, shortName: "rei" },
      { chainId: 54211, shortName: "islmt" },
      { chainId: 56288, shortName: "boba-bnb" },
      { chainId: 57e3, shortName: "tsys-rollux" },
      { chainId: 59140, shortName: "linea-testnet" },
      { chainId: 71401, shortName: "gw-testnet-v1" },
      { chainId: 71402, shortName: "gw-mainnet-v1" },
      { chainId: 73799, shortName: "vt" },
      { chainId: 80001, shortName: "maticmum" },
      { chainId: 84531, shortName: "base-gor" },
      { chainId: 200101, shortName: "milktada" },
      { chainId: 200202, shortName: "milktalgo" },
      { chainId: 333999, shortName: "olympus" },
      { chainId: 421611, shortName: "arb-rinkeby" },
      { chainId: 421613, shortName: "arb-goerli" },
      { chainId: 534353, shortName: "scr-alpha" },
      { chainId: 7777777, shortName: "zora" },
      { chainId: 11155111, shortName: "sep" },
      { chainId: 245022926, shortName: "neonevm-devnet" },
      { chainId: 1313161554, shortName: "aurora" },
      { chainId: 1313161555, shortName: "aurora-testnet" },
      { chainId: 16666e5, shortName: "hmy-s0" },
      { chainId: 16667e5, shortName: "hmy-b-s0" },
      { chainId: 11297108099, shortName: "tpalm" },
      { chainId: 11297108109, shortName: "palm" }
    ];
    if (process.env.TEST_NETWORK === "hardhat") {
      exports.networks.push({ shortName: "local", chainId: 31337 });
    } else if (process.env.TEST_NETWORK === "ganache") {
      exports.networks.push({ shortName: "local", chainId: 1337 });
    }
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/eip-3770/index.js
var require_eip_3770 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/eip-3770/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEip3770Address = exports.validateEthereumAddress = exports.validateEip3770NetworkPrefix = exports.isValidEip3770NetworkPrefix = exports.getEip3770NetworkPrefixFromChainId = exports.parseEip3770Address = void 0;
    var web3_utils_1 = require_lib3();
    var config_1 = require_config2();
    function parseEip3770Address(fullAddress) {
      const parts = fullAddress.split(":");
      const address = parts.length > 1 ? parts[1] : parts[0];
      const prefix = parts.length > 1 ? parts[0] : "";
      return { prefix, address };
    }
    exports.parseEip3770Address = parseEip3770Address;
    function getEip3770NetworkPrefixFromChainId(chainId) {
      const network = config_1.networks.find((network2) => chainId === network2.chainId);
      if (!network) {
        throw new Error("No network prefix supported for the current chainId");
      }
      return network.shortName;
    }
    exports.getEip3770NetworkPrefixFromChainId = getEip3770NetworkPrefixFromChainId;
    function isValidEip3770NetworkPrefix(prefix) {
      return config_1.networks.some(({ shortName }) => shortName === prefix);
    }
    exports.isValidEip3770NetworkPrefix = isValidEip3770NetworkPrefix;
    function validateEip3770NetworkPrefix(prefix, currentChainId) {
      const isCurrentNetworkPrefix = prefix === getEip3770NetworkPrefixFromChainId(currentChainId);
      if (!isValidEip3770NetworkPrefix(prefix) || !isCurrentNetworkPrefix) {
        throw new Error("The network prefix must match the current network");
      }
    }
    exports.validateEip3770NetworkPrefix = validateEip3770NetworkPrefix;
    function validateEthereumAddress(address) {
      const isValidAddress = (0, web3_utils_1.isHexStrict)(address) && (0, web3_utils_1.isAddress)(address);
      if (!isValidAddress) {
        throw new Error(`Invalid Ethereum address ${address}`);
      }
    }
    exports.validateEthereumAddress = validateEthereumAddress;
    function validateEip3770Address(fullAddress, currentChainId) {
      const { address, prefix } = parseEip3770Address(fullAddress);
      validateEthereumAddress(address);
      if (prefix) {
        validateEip3770NetworkPrefix(prefix, currentChainId);
      }
      return { address, prefix };
    }
    exports.validateEip3770Address = validateEip3770Address;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/eip-712/index.js
var require_eip_712 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/eip-712/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateTypedData = exports.getEip712MessageTypes = exports.EIP712_DOMAIN = exports.EIP712_DOMAIN_BEFORE_V130 = void 0;
    var satisfies_1 = __importDefault(require_satisfies());
    var EQ_OR_GT_1_3_0 = ">=1.3.0";
    exports.EIP712_DOMAIN_BEFORE_V130 = [
      {
        type: "address",
        name: "verifyingContract"
      }
    ];
    exports.EIP712_DOMAIN = [
      {
        type: "uint256",
        name: "chainId"
      },
      {
        type: "address",
        name: "verifyingContract"
      }
    ];
    function getEip712MessageTypes(safeVersion) {
      const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
      return {
        EIP712Domain: eip712WithChainId ? exports.EIP712_DOMAIN : exports.EIP712_DOMAIN_BEFORE_V130,
        SafeTx: [
          { type: "address", name: "to" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "data" },
          { type: "uint8", name: "operation" },
          { type: "uint256", name: "safeTxGas" },
          { type: "uint256", name: "baseGas" },
          { type: "uint256", name: "gasPrice" },
          { type: "address", name: "gasToken" },
          { type: "address", name: "refundReceiver" },
          { type: "uint256", name: "nonce" }
        ]
      };
    }
    exports.getEip712MessageTypes = getEip712MessageTypes;
    function generateTypedData({ safeAddress, safeVersion, chainId, safeTransactionData }) {
      const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
      const typedData = {
        types: getEip712MessageTypes(safeVersion),
        domain: {
          verifyingContract: safeAddress
        },
        primaryType: "SafeTx",
        message: {
          ...safeTransactionData,
          value: safeTransactionData.value,
          safeTxGas: safeTransactionData.safeTxGas,
          baseGas: safeTransactionData.baseGas,
          gasPrice: safeTransactionData.gasPrice,
          nonce: safeTransactionData.nonce
        }
      };
      if (eip712WithChainId) {
        typedData.domain.chainId = chainId;
      }
      return typedData;
    }
    exports.generateTypedData = generateTypedData;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/safeVersions.js
var require_safeVersions = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/safeVersions.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasSafeFeature = exports.SAFE_FEATURES = void 0;
    var satisfies_1 = __importDefault(require_satisfies());
    var SAFE_FEATURES;
    (function(SAFE_FEATURES2) {
      SAFE_FEATURES2["SAFE_TX_GAS_OPTIONAL"] = "SAFE_TX_GAS_OPTIONAL";
      SAFE_FEATURES2["SAFE_TX_GUARDS"] = "SAFE_TX_GUARDS";
      SAFE_FEATURES2["SAFE_FALLBACK_HANDLER"] = "SAFE_FALLBACK_HANDLER";
      SAFE_FEATURES2["ETH_SIGN"] = "ETH_SIGN";
      SAFE_FEATURES2["ACCOUNT_ABSTRACTION"] = "ACCOUNT_ABSTRACTION";
    })(SAFE_FEATURES = exports.SAFE_FEATURES || (exports.SAFE_FEATURES = {}));
    var SAFE_FEATURES_BY_VERSION = {
      [SAFE_FEATURES.SAFE_TX_GAS_OPTIONAL]: ">=1.3.0",
      [SAFE_FEATURES.SAFE_TX_GUARDS]: ">=1.3.0",
      [SAFE_FEATURES.SAFE_FALLBACK_HANDLER]: ">=1.1.1",
      [SAFE_FEATURES.ETH_SIGN]: ">=1.1.0",
      [SAFE_FEATURES.ACCOUNT_ABSTRACTION]: ">=1.3.0"
    };
    var hasSafeFeature = (feature, version) => {
      if (!(feature in SAFE_FEATURES_BY_VERSION)) {
        return false;
      }
      return (0, satisfies_1.default)(version, SAFE_FEATURES_BY_VERSION[feature]);
    };
    exports.hasSafeFeature = hasSafeFeature;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/signatures/SafeSignature.js
var require_SafeSignature = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/signatures/SafeSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthSafeSignature = void 0;
    var EthSafeSignature = class {
      /**
       * Creates an instance of a Safe signature.
       *
       * @param signer - Ethers signer
       * @param signature - The Safe signature
       * @returns The Safe signature instance
       */
      constructor(signer, signature) {
        this.signer = signer;
        this.data = signature;
      }
      /**
       * Returns the static part of the Safe signature.
       *
       * @returns The static part of the Safe signature
       */
      staticPart() {
        return this.data;
      }
      /**
       * Returns the dynamic part of the Safe signature.
       *
       * @returns The dynamic part of the Safe signature
       */
      dynamicPart() {
        return "";
      }
    };
    exports.EthSafeSignature = EthSafeSignature;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/signatures/utils.js
var require_utils15 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/signatures/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;
    var ethereumjs_util_1 = require_dist3();
    var address_1 = require_address2();
    var SafeSignature_1 = require_SafeSignature();
    function generatePreValidatedSignature(ownerAddress) {
      const signature = "0x000000000000000000000000" + ownerAddress.slice(2) + "000000000000000000000000000000000000000000000000000000000000000001";
      return new SafeSignature_1.EthSafeSignature(ownerAddress, signature);
    }
    exports.generatePreValidatedSignature = generatePreValidatedSignature;
    function isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {
      let hasPrefix;
      try {
        const rsvSig = {
          r: Buffer.from(signature.slice(2, 66), "hex"),
          s: Buffer.from(signature.slice(66, 130), "hex"),
          v: parseInt(signature.slice(130, 132), 16)
        };
        const recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), "hex"), rsvSig.v, rsvSig.r, rsvSig.s);
        const recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));
        hasPrefix = !(0, address_1.sameString)(recoveredAddress, ownerAddress);
      } catch (e) {
        hasPrefix = true;
      }
      return hasPrefix;
    }
    exports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;
    var adjustVInSignature = (signingMethod, signature, safeTxHash, signerAddress) => {
      const ETHEREUM_V_VALUES = [0, 1, 27, 28];
      const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;
      let signatureV = parseInt(signature.slice(-2), 16);
      if (!ETHEREUM_V_VALUES.includes(signatureV)) {
        throw new Error("Invalid signature");
      }
      if (signingMethod === "eth_sign") {
        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
          signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
        }
        const adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);
        const signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);
        if (signatureHasPrefix) {
          signatureV += 4;
        }
      }
      if (signingMethod === "eth_signTypedData") {
        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
          signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
        }
      }
      signature = signature.slice(0, -2) + signatureV.toString(16);
      return signature;
    };
    exports.adjustVInSignature = adjustVInSignature;
    async function generateSignature(ethAdapter, hash) {
      const signerAddress = await ethAdapter.getSignerAddress();
      if (!signerAddress) {
        throw new Error("EthAdapter must be initialized with a signer to use this method");
      }
      let signature = await ethAdapter.signMessage(hash);
      signature = (0, exports.adjustVInSignature)("eth_sign", signature, hash, signerAddress);
      return new SafeSignature_1.EthSafeSignature(signerAddress, signature);
    }
    exports.generateSignature = generateSignature;
    async function generateEIP712Signature(ethAdapter, safeTransactionEIP712Args, methodVersion) {
      const signerAddress = await ethAdapter.getSignerAddress();
      if (!signerAddress) {
        throw new Error("EthAdapter must be initialized with a signer to use this method");
      }
      let signature = await ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);
      signature = (0, exports.adjustVInSignature)("eth_signTypedData", signature);
      return new SafeSignature_1.EthSafeSignature(signerAddress, signature);
    }
    exports.generateEIP712Signature = generateEIP712Signature;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/signatures/index.js
var require_signatures = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/signatures/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SafeSignature(), exports);
    __exportStar(require_utils15(), exports);
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/gas.js
var require_gas = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/gas.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateSafeDeploymentGas = exports.estimateSafeTxGas = exports.estimateTxBaseGas = exports.estimateTxGas = exports.estimateGas = void 0;
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_types_1 = require_src();
    var satisfies_1 = __importDefault(require_satisfies());
    var constants_1 = require_constants();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    var CALL_DATA_ZERO_BYTE_GAS_COST = 4;
    var CALL_DATA_BYTE_GAS_COST = 16;
    var INITIZATION_GAS_COST = 2e4;
    var INCREMENT_NONCE_GAS_COST = 5e3;
    var HASH_GENERATION_GAS_COST = 1500;
    var ECRECOVER_GAS_COST = 6e3;
    var TRANSAFER_GAS_COST = 32e3;
    var GAS_COST_PER_SIGNATURE = 1 * CALL_DATA_BYTE_GAS_COST + 2 * 32 * CALL_DATA_BYTE_GAS_COST + ECRECOVER_GAS_COST;
    function estimateDataGasCosts(data) {
      const bytes = data.match(/.{2}/g);
      return bytes.reduce((gasCost, currentByte) => {
        if (currentByte === "0x") {
          return gasCost + 0;
        }
        if (currentByte === "00") {
          return gasCost + CALL_DATA_ZERO_BYTE_GAS_COST;
        }
        return gasCost + CALL_DATA_BYTE_GAS_COST;
      }, 0);
    }
    async function estimateGas(safeVersion, safeContract, ethAdapter, to, valueInWei, data, operation, customContracts) {
      const chainId = await ethAdapter.getChainId();
      const simulateTxAccessorContract = await (0, safeDeploymentContracts_1.getSimulateTxAccessorContract)({
        ethAdapter,
        safeVersion,
        customContracts: customContracts == null ? void 0 : customContracts[chainId]
      });
      const transactionDataToEstimate = simulateTxAccessorContract.encode("simulate", [
        to,
        valueInWei,
        data,
        operation
      ]);
      const safeFunctionToEstimate = safeContract.encode("simulateAndRevert", [
        await simulateTxAccessorContract.getAddress(),
        transactionDataToEstimate
      ]);
      const safeAddress = safeContract.getAddress();
      const transactionToEstimateGas = {
        to: safeAddress,
        value: "0",
        data: safeFunctionToEstimate,
        from: safeAddress
      };
      try {
        const encodedResponse = await ethAdapter.call(transactionToEstimateGas);
        return Number("0x" + encodedResponse.slice(184).slice(0, 10)).toString();
      } catch (error) {
        return parseSafeTxGasErrorResponse(error);
      }
    }
    exports.estimateGas = estimateGas;
    async function estimateTxGas(safeContract, ethAdapter, to, valueInWei, data, operation) {
      let txGasEstimation = bignumber_1.BigNumber.from(0);
      const safeAddress = safeContract.getAddress();
      const estimateData = safeContract.encode("requiredTxGas", [
        to,
        valueInWei,
        data,
        operation
      ]);
      try {
        const estimateResponse = await ethAdapter.estimateGas({
          to: safeAddress,
          from: safeAddress,
          data: estimateData
        });
        txGasEstimation = bignumber_1.BigNumber.from("0x" + estimateResponse.substring(138)).add(1e4);
      } catch (error) {
      }
      if (txGasEstimation.gt(0)) {
        const dataGasEstimation = estimateDataGasCosts(estimateData);
        let additionalGas = 1e4;
        for (let i = 0; i < 10; i++) {
          try {
            const estimateResponse = await ethAdapter.call({
              to: safeAddress,
              from: safeAddress,
              data: estimateData,
              gasPrice: "0",
              gasLimit: txGasEstimation.add(dataGasEstimation).add(additionalGas).toString()
            });
            if (estimateResponse !== "0x") {
              break;
            }
          } catch (error) {
          }
          txGasEstimation = txGasEstimation.add(additionalGas);
          additionalGas *= 2;
        }
        return txGasEstimation.add(additionalGas).toString();
      }
      try {
        const estimateGas2 = await ethAdapter.estimateGas({
          to,
          from: safeAddress,
          value: valueInWei,
          data
        });
        return estimateGas2;
      } catch (error) {
        if (operation === safe_core_sdk_types_1.OperationType.DelegateCall) {
          return "0";
        }
        return Promise.reject(error);
      }
    }
    exports.estimateTxGas = estimateTxGas;
    async function estimateTxBaseGas(safe, safeTransaction) {
      var _a;
      const safeTransactionData = safeTransaction.data;
      const { to, value, data, operation, safeTxGas, gasToken, refundReceiver } = safeTransactionData;
      const safeThreshold = await safe.getThreshold();
      const safeNonce = await safe.getNonce();
      const signaturesGasCost = safeThreshold * GAS_COST_PER_SIGNATURE;
      const encodeSafeTxGas = safeTxGas || 0;
      const encodeBaseGas = 0;
      const gasPrice = 1;
      const encodeGasToken = gasToken || constants_1.ZERO_ADDRESS;
      const encodeRefundReceiver = refundReceiver || constants_1.ZERO_ADDRESS;
      const signatures = "0x";
      const safeVersion = await safe.getContractVersion();
      const ethAdapter = safe.getEthAdapter();
      const isL1SafeMasterCopy = safe.getContractManager().isL1SafeMasterCopy;
      const chainId = await safe.getChainId();
      const customContracts = (_a = safe.getContractManager().contractNetworks) == null ? void 0 : _a[chainId];
      const safeSingletonContract = await (0, safeDeploymentContracts_1.getSafeContract)({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
      });
      const execTransactionData = safeSingletonContract.encode("execTransaction", [
        to,
        value,
        data,
        operation,
        encodeSafeTxGas,
        encodeBaseGas,
        gasPrice,
        encodeGasToken,
        encodeRefundReceiver,
        signatures
      ]);
      const isSafeInitialized = safeNonce !== 0;
      const incrementNonceGasCost = isSafeInitialized ? INCREMENT_NONCE_GAS_COST : INITIZATION_GAS_COST;
      let baseGas = signaturesGasCost + estimateDataGasCosts(execTransactionData) + incrementNonceGasCost + HASH_GENERATION_GAS_COST;
      baseGas > 65536 ? baseGas += 64 : baseGas += 128;
      baseGas += TRANSAFER_GAS_COST;
      return baseGas.toString();
    }
    exports.estimateTxBaseGas = estimateTxBaseGas;
    async function estimateSafeTxGas(safe, safeTransaction) {
      const safeVersion = await safe.getContractVersion();
      if ((0, satisfies_1.default)(safeVersion, ">=1.3.0")) {
        const safeTxGas2 = await estimateSafeTxGasWithSimulate(safe, safeTransaction);
        return addExtraGasForSafety(safeTxGas2);
      }
      const safeTxGas = await estimateSafeTxGasWithRequiredTxGas(safe, safeTransaction);
      return addExtraGasForSafety(safeTxGas);
    }
    exports.estimateSafeTxGas = estimateSafeTxGas;
    function addExtraGasForSafety(safeTxGas) {
      const INCREASE_GAS_FACTOR = 1.05;
      return Math.round(Number(safeTxGas) * INCREASE_GAS_FACTOR).toString();
    }
    async function estimateSafeTxGasWithRequiredTxGas(safe, safeTransaction) {
      var _a;
      const isSafeDeployed = await safe.isSafeDeployed();
      const safeAddress = await safe.getAddress();
      const safeVersion = await safe.getContractVersion();
      const ethAdapter = safe.getEthAdapter();
      const isL1SafeMasterCopy = safe.getContractManager().isL1SafeMasterCopy;
      const chainId = await safe.getChainId();
      const customContracts = (_a = safe.getContractManager().contractNetworks) == null ? void 0 : _a[chainId];
      const safeSingletonContract = await (0, safeDeploymentContracts_1.getSafeContract)({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
      });
      const transactionDataToEstimate = safeSingletonContract.encode("requiredTxGas", [
        safeTransaction.data.to,
        safeTransaction.data.value,
        safeTransaction.data.data,
        safeTransaction.data.operation
      ]);
      const to = isSafeDeployed ? safeAddress : safeSingletonContract.getAddress();
      const transactionToEstimateGas = {
        to,
        value: "0",
        data: transactionDataToEstimate,
        from: safeAddress
      };
      try {
        const encodedResponse = await ethAdapter.call(transactionToEstimateGas);
        const safeTxGas = "0x" + encodedResponse.slice(-32);
        return safeTxGas;
      } catch (error) {
        try {
          const revertData = JSON.parse(error.error.body).error.data;
          if (revertData && revertData.startsWith("Reverted ")) {
            const [, safeTxGas] = revertData.split("Reverted ");
            return Number(safeTxGas).toString();
          }
        } catch {
          return "0";
        }
      }
      return "0";
    }
    function decodeSafeTxGas(encodedSafeTxGas) {
      return Number("0x" + encodedSafeTxGas.slice(184).slice(0, 10)).toString();
    }
    function parseSafeTxGasErrorResponse(error) {
      var _a;
      if ((_a = error == null ? void 0 : error.error) == null ? void 0 : _a.body) {
        const revertData = JSON.parse(error.error.body).error.data;
        if (revertData && revertData.startsWith("Reverted ")) {
          const [, encodedResponse2] = revertData.split("Reverted ");
          const safeTxGas2 = decodeSafeTxGas(encodedResponse2);
          return safeTxGas2;
        }
      }
      const [, encodedResponse] = error.message.split("return data: ");
      const safeTxGas = decodeSafeTxGas(encodedResponse);
      return safeTxGas;
    }
    async function estimateSafeTxGasWithSimulate(safe, safeTransaction) {
      var _a;
      const isSafeDeployed = await safe.isSafeDeployed();
      const safeAddress = await safe.getAddress();
      const safeVersion = await safe.getContractVersion();
      const ethAdapter = safe.getEthAdapter();
      const chainId = await safe.getChainId();
      const customContracts = (_a = safe.getContractManager().contractNetworks) == null ? void 0 : _a[chainId];
      const isL1SafeMasterCopy = safe.getContractManager().isL1SafeMasterCopy;
      const safeSingletonContract = await (0, safeDeploymentContracts_1.getSafeContract)({
        ethAdapter,
        safeVersion,
        isL1SafeMasterCopy,
        customContracts
      });
      const simulateTxAccessorContract = await (0, safeDeploymentContracts_1.getSimulateTxAccessorContract)({
        ethAdapter,
        safeVersion,
        customContracts
      });
      const transactionDataToEstimate = simulateTxAccessorContract.encode("simulate", [
        safeTransaction.data.to,
        safeTransaction.data.value,
        safeTransaction.data.data,
        safeTransaction.data.operation
      ]);
      const to = isSafeDeployed ? safeAddress : safeSingletonContract.getAddress();
      const safeFunctionToEstimate = safeSingletonContract.encode("simulateAndRevert", [
        await simulateTxAccessorContract.getAddress(),
        transactionDataToEstimate
      ]);
      const transactionToEstimateGas = {
        to,
        value: "0",
        data: safeFunctionToEstimate,
        from: safeAddress
      };
      try {
        const encodedResponse = await ethAdapter.call(transactionToEstimateGas);
        const safeTxGas = decodeSafeTxGas(encodedResponse);
        return safeTxGas;
      } catch (error) {
        return parseSafeTxGasErrorResponse(error);
      }
      return "0";
    }
    async function estimateSafeDeploymentGas(safe) {
      const isSafeDeployed = await safe.isSafeDeployed();
      if (isSafeDeployed) {
        return "0";
      }
      const ethAdapter = safe.getEthAdapter();
      const safeDeploymentTransaction = await safe.createSafeDeploymentTransaction();
      const estimation = await ethAdapter.estimateGas({
        ...safeDeploymentTransaction,
        from: constants_1.ZERO_ADDRESS
        // if we use the Safe address the estimation always fails due to CREATE2
      });
      return estimation;
    }
    exports.estimateSafeDeploymentGas = estimateSafeDeploymentGas;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/SafeTransaction.js
var require_SafeTransaction = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/SafeTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EthSafeTransaction = class {
      constructor(data) {
        this.signatures = /* @__PURE__ */ new Map();
        this.data = data;
      }
      addSignature(signature) {
        this.signatures.set(signature.signer.toLowerCase(), signature);
      }
      encodedSignatures() {
        const signers = Array.from(this.signatures.keys()).sort();
        const baseOffset = signers.length * 65;
        let staticParts = "";
        let dynamicParts = "";
        signers.forEach((signerAddress) => {
          const signature = this.signatures.get(signerAddress);
          staticParts += signature == null ? void 0 : signature.staticPart().slice(2);
          dynamicParts += signature == null ? void 0 : signature.dynamicPart();
        });
        return "0x" + staticParts + dynamicParts;
      }
    };
    exports.default = EthSafeTransaction;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/types.js
var require_types7 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/utils.js
var require_utils16 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSafeMultisigTransactionResponse = exports.isMetaTransactionArray = exports.decodeMultiSendData = exports.encodeMultiSendData = exports.standardizeSafeTransactionData = exports.standardizeMetaTransactionData = void 0;
    var abi_1 = (init_lib5(), __toCommonJS(lib_exports5));
    var bytes_1 = (init_lib(), __toCommonJS(lib_exports));
    var solidity_1 = (init_lib8(), __toCommonJS(lib_exports8));
    var config_1 = require_config();
    var utils_1 = require_utils17();
    var constants_1 = require_constants();
    var safe_core_sdk_types_1 = require_src();
    var satisfies_1 = __importDefault(require_satisfies());
    var web3_utils_1 = require_lib3();
    var gas_1 = require_gas();
    function standardizeMetaTransactionData(tx) {
      const standardizedTxs = {
        ...tx,
        operation: tx.operation ?? safe_core_sdk_types_1.OperationType.Call
      };
      return standardizedTxs;
    }
    exports.standardizeMetaTransactionData = standardizeMetaTransactionData;
    async function standardizeSafeTransactionData({ safeContract, predictedSafe, ethAdapter, tx, contractNetworks }) {
      var _a;
      const standardizedTxs = {
        to: tx.to,
        value: tx.value,
        data: tx.data,
        operation: tx.operation ?? safe_core_sdk_types_1.OperationType.Call,
        baseGas: tx.baseGas ?? "0",
        gasPrice: tx.gasPrice ?? "0",
        gasToken: tx.gasToken || constants_1.ZERO_ADDRESS,
        refundReceiver: tx.refundReceiver || constants_1.ZERO_ADDRESS,
        nonce: tx.nonce ?? (safeContract ? await safeContract.getNonce() : 0)
      };
      if (typeof tx.safeTxGas !== "undefined") {
        return {
          ...standardizedTxs,
          safeTxGas: tx.safeTxGas
        };
      }
      let safeVersion;
      if (predictedSafe) {
        safeVersion = ((_a = predictedSafe == null ? void 0 : predictedSafe.safeDeploymentConfig) == null ? void 0 : _a.safeVersion) || config_1.DEFAULT_SAFE_VERSION;
      } else {
        if (!safeContract) {
          throw new Error("Safe is not deployed");
        }
        safeVersion = await safeContract.getVersion();
      }
      const hasSafeTxGasOptional = (0, utils_1.hasSafeFeature)(utils_1.SAFE_FEATURES.SAFE_TX_GAS_OPTIONAL, safeVersion);
      if (hasSafeTxGasOptional && standardizedTxs.gasPrice === "0" || hasSafeTxGasOptional && predictedSafe) {
        return {
          ...standardizedTxs,
          safeTxGas: "0"
        };
      }
      if (!safeContract) {
        throw new Error("Safe is not deployed");
      }
      let safeTxGas;
      if ((0, satisfies_1.default)(safeVersion, ">=1.3.0")) {
        safeTxGas = await (0, gas_1.estimateGas)(safeVersion, safeContract, ethAdapter, standardizedTxs.to, standardizedTxs.value, standardizedTxs.data, standardizedTxs.operation, contractNetworks);
      } else {
        safeTxGas = await (0, gas_1.estimateTxGas)(safeContract, ethAdapter, standardizedTxs.to, standardizedTxs.value, standardizedTxs.data, standardizedTxs.operation);
      }
      return {
        ...standardizedTxs,
        safeTxGas
      };
    }
    exports.standardizeSafeTransactionData = standardizeSafeTransactionData;
    function encodeMetaTransaction(tx) {
      const data = (0, bytes_1.arrayify)(tx.data);
      const encoded = (0, solidity_1.pack)(["uint8", "address", "uint256", "uint256", "bytes"], [tx.operation, tx.to, tx.value, data.length, data]);
      return encoded.slice(2);
    }
    function encodeMultiSendData(txs) {
      return "0x" + txs.map((tx) => encodeMetaTransaction(tx)).join("");
    }
    exports.encodeMultiSendData = encodeMultiSendData;
    function decodeMultiSendData(encodedData) {
      const multiSendInterface = new abi_1.Interface([
        "function multiSend(bytes memory transactions) public payable"
      ]);
      const [decodedData] = multiSendInterface.decodeFunctionData("multiSend", encodedData);
      const txs = [];
      let index = 2;
      while (index < decodedData.length) {
        const operation = `0x${decodedData.slice(index, index += 2)}`;
        const to = `0x${decodedData.slice(index, index += 40)}`;
        const value = `0x${decodedData.slice(index, index += 64)}`;
        const dataLength = parseInt(decodedData.slice(index, index += 64), 16) * 2;
        const data = `0x${decodedData.slice(index, index += dataLength)}`;
        txs.push({
          operation: (0, web3_utils_1.hexToNumber)(operation),
          to: (0, web3_utils_1.toChecksumAddress)(to),
          value: (0, web3_utils_1.hexToNumberString)(value),
          data
        });
      }
      return txs;
    }
    exports.decodeMultiSendData = decodeMultiSendData;
    function isMetaTransactionArray(safeTransactions) {
      return (safeTransactions == null ? void 0 : safeTransactions.length) !== void 0;
    }
    exports.isMetaTransactionArray = isMetaTransactionArray;
    function isSafeMultisigTransactionResponse(safeTransaction) {
      return safeTransaction.isExecuted !== void 0;
    }
    exports.isSafeMultisigTransactionResponse = isSafeMultisigTransactionResponse;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/transactions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_gas(), exports);
    __exportStar(require_SafeTransaction(), exports);
    __exportStar(require_types7(), exports);
    __exportStar(require_utils16(), exports);
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/index.js
var require_utils17 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_address2(), exports);
    __exportStar(require_eip_3770(), exports);
    __exportStar(require_eip_712(), exports);
    __exportStar(require_safeVersions(), exports);
    __exportStar(require_signatures(), exports);
    __exportStar(require_transactions(), exports);
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/managers/fallbackHandlerManager.js
var require_fallbackHandlerManager = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/managers/fallbackHandlerManager.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _FallbackHandlerManager_ethAdapter;
    var _FallbackHandlerManager_safeContract;
    var _FallbackHandlerManager_slot;
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils17();
    var constants_1 = require_constants();
    var FallbackHandlerManager = class {
      constructor(ethAdapter, safeContract) {
        _FallbackHandlerManager_ethAdapter.set(this, void 0);
        _FallbackHandlerManager_safeContract.set(this, void 0);
        _FallbackHandlerManager_slot.set(this, "0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5");
        __classPrivateFieldSet(this, _FallbackHandlerManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _FallbackHandlerManager_safeContract, safeContract, "f");
      }
      validateFallbackHandlerAddress(fallbackHandlerAddress) {
        const isValidAddress = __classPrivateFieldGet(this, _FallbackHandlerManager_ethAdapter, "f").isAddress(fallbackHandlerAddress);
        if (!isValidAddress || (0, utils_1.isZeroAddress)(fallbackHandlerAddress)) {
          throw new Error("Invalid fallback handler address provided");
        }
      }
      validateFallbackHandlerIsNotEnabled(currentFallbackHandler, newFallbackHandlerAddress) {
        if ((0, utils_1.sameString)(currentFallbackHandler, newFallbackHandlerAddress)) {
          throw new Error("Fallback handler provided is already enabled");
        }
      }
      validateFallbackHandlerIsEnabled(fallbackHandlerAddress) {
        if ((0, utils_1.isZeroAddress)(fallbackHandlerAddress)) {
          throw new Error("There is no fallback handler enabled yet");
        }
      }
      async getFallbackHandler() {
        if (!__classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        const safeVersion = await __classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").getVersion();
        if ((0, utils_1.hasSafeFeature)(utils_1.SAFE_FEATURES.SAFE_FALLBACK_HANDLER, safeVersion)) {
          return __classPrivateFieldGet(this, _FallbackHandlerManager_ethAdapter, "f").getStorageAt(__classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").getAddress(), __classPrivateFieldGet(this, _FallbackHandlerManager_slot, "f"));
        } else {
          throw new Error("Current version of the Safe does not support the fallback handler functionality");
        }
      }
      async encodeEnableFallbackHandlerData(fallbackHandlerAddress) {
        if (!__classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateFallbackHandlerAddress(fallbackHandlerAddress);
        const currentFallbackHandler = await this.getFallbackHandler();
        this.validateFallbackHandlerIsNotEnabled(currentFallbackHandler, fallbackHandlerAddress);
        return __classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").encode("setFallbackHandler", [fallbackHandlerAddress]);
      }
      async encodeDisableFallbackHandlerData() {
        if (!__classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        const currentFallbackHandler = await this.getFallbackHandler();
        this.validateFallbackHandlerIsEnabled(currentFallbackHandler);
        return __classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").encode("setFallbackHandler", [constants_1.ZERO_ADDRESS]);
      }
    };
    _FallbackHandlerManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _FallbackHandlerManager_safeContract = /* @__PURE__ */ new WeakMap(), _FallbackHandlerManager_slot = /* @__PURE__ */ new WeakMap();
    exports.default = FallbackHandlerManager;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/managers/guardManager.js
var require_guardManager = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/managers/guardManager.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _GuardManager_ethAdapter;
    var _GuardManager_safeContract;
    var _GuardManager_slot;
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils17();
    var constants_1 = require_constants();
    var GuardManager = class {
      constructor(ethAdapter, safeContract) {
        _GuardManager_ethAdapter.set(this, void 0);
        _GuardManager_safeContract.set(this, void 0);
        _GuardManager_slot.set(this, "0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8");
        __classPrivateFieldSet(this, _GuardManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _GuardManager_safeContract, safeContract, "f");
      }
      validateGuardAddress(guardAddress) {
        const isValidAddress = __classPrivateFieldGet(this, _GuardManager_ethAdapter, "f").isAddress(guardAddress);
        if (!isValidAddress || (0, utils_1.isZeroAddress)(guardAddress)) {
          throw new Error("Invalid guard address provided");
        }
      }
      validateGuardIsNotEnabled(currentGuard, newGuardAddress) {
        if ((0, utils_1.sameString)(currentGuard, newGuardAddress)) {
          throw new Error("Guard provided is already enabled");
        }
      }
      validateGuardIsEnabled(guardAddress) {
        if ((0, utils_1.isZeroAddress)(guardAddress)) {
          throw new Error("There is no guard enabled yet");
        }
      }
      async getGuard() {
        if (!__classPrivateFieldGet(this, _GuardManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        const safeVersion = await __classPrivateFieldGet(this, _GuardManager_safeContract, "f").getVersion();
        if ((0, utils_1.hasSafeFeature)(utils_1.SAFE_FEATURES.SAFE_TX_GUARDS, safeVersion)) {
          return __classPrivateFieldGet(this, _GuardManager_ethAdapter, "f").getStorageAt(__classPrivateFieldGet(this, _GuardManager_safeContract, "f").getAddress(), __classPrivateFieldGet(this, _GuardManager_slot, "f"));
        } else {
          throw new Error("Current version of the Safe does not support Safe transaction guards functionality");
        }
      }
      async encodeEnableGuardData(guardAddress) {
        if (!__classPrivateFieldGet(this, _GuardManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateGuardAddress(guardAddress);
        const currentGuard = await this.getGuard();
        this.validateGuardIsNotEnabled(currentGuard, guardAddress);
        return __classPrivateFieldGet(this, _GuardManager_safeContract, "f").encode("setGuard", [guardAddress]);
      }
      async encodeDisableGuardData() {
        if (!__classPrivateFieldGet(this, _GuardManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        const currentGuard = await this.getGuard();
        this.validateGuardIsEnabled(currentGuard);
        return __classPrivateFieldGet(this, _GuardManager_safeContract, "f").encode("setGuard", [constants_1.ZERO_ADDRESS]);
      }
    };
    _GuardManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _GuardManager_safeContract = /* @__PURE__ */ new WeakMap(), _GuardManager_slot = /* @__PURE__ */ new WeakMap();
    exports.default = GuardManager;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/managers/moduleManager.js
var require_moduleManager = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/managers/moduleManager.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ModuleManager_ethAdapter;
    var _ModuleManager_safeContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var address_1 = require_address2();
    var constants_1 = require_constants();
    var ModuleManager = class {
      constructor(ethAdapter, safeContract) {
        _ModuleManager_ethAdapter.set(this, void 0);
        _ModuleManager_safeContract.set(this, void 0);
        __classPrivateFieldSet(this, _ModuleManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _ModuleManager_safeContract, safeContract, "f");
      }
      validateModuleAddress(moduleAddress) {
        const isValidAddress = __classPrivateFieldGet(this, _ModuleManager_ethAdapter, "f").isAddress(moduleAddress);
        if (!isValidAddress || (0, address_1.isRestrictedAddress)(moduleAddress)) {
          throw new Error("Invalid module address provided");
        }
      }
      validateModuleIsNotEnabled(moduleAddress, modules) {
        const moduleIndex = modules.findIndex((module2) => (0, address_1.sameString)(module2, moduleAddress));
        const isEnabled = moduleIndex >= 0;
        if (isEnabled) {
          throw new Error("Module provided is already enabled");
        }
      }
      validateModuleIsEnabled(moduleAddress, modules) {
        const moduleIndex = modules.findIndex((module2) => (0, address_1.sameString)(module2, moduleAddress));
        const isEnabled = moduleIndex >= 0;
        if (!isEnabled) {
          throw new Error("Module provided is not enabled yet");
        }
        return moduleIndex;
      }
      async getModules() {
        if (!__classPrivateFieldGet(this, _ModuleManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").getModules();
      }
      async isModuleEnabled(moduleAddress) {
        if (!__classPrivateFieldGet(this, _ModuleManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").isModuleEnabled(moduleAddress);
      }
      async encodeEnableModuleData(moduleAddress) {
        if (!__classPrivateFieldGet(this, _ModuleManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateModuleAddress(moduleAddress);
        const modules = await this.getModules();
        this.validateModuleIsNotEnabled(moduleAddress, modules);
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").encode("enableModule", [moduleAddress]);
      }
      async encodeDisableModuleData(moduleAddress) {
        if (!__classPrivateFieldGet(this, _ModuleManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateModuleAddress(moduleAddress);
        const modules = await this.getModules();
        const moduleIndex = this.validateModuleIsEnabled(moduleAddress, modules);
        const prevModuleAddress = moduleIndex === 0 ? constants_1.SENTINEL_ADDRESS : modules[moduleIndex - 1];
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").encode("disableModule", [prevModuleAddress, moduleAddress]);
      }
    };
    _ModuleManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _ModuleManager_safeContract = /* @__PURE__ */ new WeakMap();
    exports.default = ModuleManager;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/managers/ownerManager.js
var require_ownerManager = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/managers/ownerManager.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _OwnerManager_ethAdapter;
    var _OwnerManager_safeContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var address_1 = require_address2();
    var constants_1 = require_constants();
    var OwnerManager = class {
      constructor(ethAdapter, safeContract) {
        _OwnerManager_ethAdapter.set(this, void 0);
        _OwnerManager_safeContract.set(this, void 0);
        __classPrivateFieldSet(this, _OwnerManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _OwnerManager_safeContract, safeContract, "f");
      }
      validateOwnerAddress(ownerAddress, errorMessage) {
        const isValidAddress = __classPrivateFieldGet(this, _OwnerManager_ethAdapter, "f").isAddress(ownerAddress);
        if (!isValidAddress || (0, address_1.isRestrictedAddress)(ownerAddress)) {
          throw new Error(errorMessage || "Invalid owner address provided");
        }
      }
      validateThreshold(threshold, numOwners) {
        if (threshold <= 0) {
          throw new Error("Threshold needs to be greater than 0");
        }
        if (threshold > numOwners) {
          throw new Error("Threshold cannot exceed owner count");
        }
      }
      validateAddressIsNotOwner(ownerAddress, owners, errorMessage) {
        const ownerIndex = owners.findIndex((owner) => (0, address_1.sameString)(owner, ownerAddress));
        const isOwner = ownerIndex >= 0;
        if (isOwner) {
          throw new Error(errorMessage || "Address provided is already an owner");
        }
      }
      validateAddressIsOwner(ownerAddress, owners, errorMessage) {
        const ownerIndex = owners.findIndex((owner) => (0, address_1.sameString)(owner, ownerAddress));
        const isOwner = ownerIndex >= 0;
        if (!isOwner) {
          throw new Error(errorMessage || "Address provided is not an owner");
        }
        return ownerIndex;
      }
      async getOwners() {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        const owners = await __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").getOwners();
        return [...owners];
      }
      async getThreshold() {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").getThreshold();
      }
      async isOwner(ownerAddress) {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").isOwner(ownerAddress);
      }
      async encodeAddOwnerWithThresholdData(ownerAddress, threshold) {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateOwnerAddress(ownerAddress);
        const owners = await this.getOwners();
        this.validateAddressIsNotOwner(ownerAddress, owners);
        const newThreshold = threshold ?? await this.getThreshold();
        this.validateThreshold(newThreshold, owners.length + 1);
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("addOwnerWithThreshold", [ownerAddress, newThreshold]);
      }
      async encodeRemoveOwnerData(ownerAddress, threshold) {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateOwnerAddress(ownerAddress);
        const owners = await this.getOwners();
        const ownerIndex = this.validateAddressIsOwner(ownerAddress, owners);
        const newThreshold = threshold ?? await this.getThreshold() - 1;
        this.validateThreshold(newThreshold, owners.length - 1);
        const prevOwnerAddress = ownerIndex === 0 ? constants_1.SENTINEL_ADDRESS : owners[ownerIndex - 1];
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("removeOwner", [prevOwnerAddress, ownerAddress, newThreshold]);
      }
      async encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress) {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        this.validateOwnerAddress(newOwnerAddress, "Invalid new owner address provided");
        this.validateOwnerAddress(oldOwnerAddress, "Invalid old owner address provided");
        const owners = await this.getOwners();
        this.validateAddressIsNotOwner(newOwnerAddress, owners, "New address provided is already an owner");
        const oldOwnerIndex = this.validateAddressIsOwner(oldOwnerAddress, owners, "Old address provided is not an owner");
        const prevOwnerAddress = oldOwnerIndex === 0 ? constants_1.SENTINEL_ADDRESS : owners[oldOwnerIndex - 1];
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("swapOwner", [
          prevOwnerAddress,
          oldOwnerAddress,
          newOwnerAddress
        ]);
      }
      async encodeChangeThresholdData(threshold) {
        if (!__classPrivateFieldGet(this, _OwnerManager_safeContract, "f")) {
          throw new Error("Safe is not deployed");
        }
        const owners = await this.getOwners();
        this.validateThreshold(threshold, owners.length);
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("changeThreshold", [threshold]);
      }
    };
    _OwnerManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _OwnerManager_safeContract = /* @__PURE__ */ new WeakMap();
    exports.default = OwnerManager;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/Safe.js
var require_Safe = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/Safe.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Safe_predictedSafe;
    var _Safe_ethAdapter;
    var _Safe_contractManager;
    var _Safe_ownerManager;
    var _Safe_moduleManager;
    var _Safe_guardManager;
    var _Safe_fallbackHandlerManager;
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_types_1 = require_src();
    var utils_1 = require_utils8();
    var config_1 = require_config();
    var contractManager_1 = __importDefault(require_contractManager());
    var fallbackHandlerManager_1 = __importDefault(require_fallbackHandlerManager());
    var guardManager_1 = __importDefault(require_guardManager());
    var moduleManager_1 = __importDefault(require_moduleManager());
    var ownerManager_1 = __importDefault(require_ownerManager());
    var utils_2 = require_utils17();
    var utils_3 = require_utils15();
    var SafeTransaction_1 = __importDefault(require_SafeTransaction());
    var utils_4 = require_utils16();
    var types_1 = require_types5();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    var Safe = class _Safe {
      constructor() {
        _Safe_predictedSafe.set(this, void 0);
        _Safe_ethAdapter.set(this, void 0);
        _Safe_contractManager.set(this, void 0);
        _Safe_ownerManager.set(this, void 0);
        _Safe_moduleManager.set(this, void 0);
        _Safe_guardManager.set(this, void 0);
        _Safe_fallbackHandlerManager.set(this, void 0);
      }
      /**
       * Creates an instance of the Safe Core SDK.
       * @param config - Ethers Safe configuration
       * @returns The Safe Core SDK instance
       * @throws "The SDK must be initialized with a safeAddress or a predictedSafe"
       * @throws "SafeProxy contract is not deployed on the current network"
       * @throws "MultiSend contract is not deployed on the current network"
       * @throws "MultiSendCallOnly contract is not deployed on the current network"
       */
      static async create(config) {
        const safeSdk = new _Safe();
        await safeSdk.init(config);
        return safeSdk;
      }
      /**
       * Initializes the Safe Core SDK instance.
       * @param config - Safe configuration
       * @throws "Signer must be connected to a provider"
       * @throws "SafeProxy contract is not deployed on the current network"
       * @throws "MultiSend contract is not deployed on the current network"
       * @throws "MultiSendCallOnly contract is not deployed on the current network"
       */
      async init(config) {
        const { ethAdapter, isL1SafeMasterCopy, contractNetworks } = config;
        __classPrivateFieldSet(this, _Safe_ethAdapter, ethAdapter, "f");
        if ((0, types_1.isSafeConfigWithPredictedSafe)(config)) {
          __classPrivateFieldSet(this, _Safe_predictedSafe, config.predictedSafe, "f");
          __classPrivateFieldSet(this, _Safe_contractManager, await contractManager_1.default.create({
            ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
            predictedSafe: __classPrivateFieldGet(this, _Safe_predictedSafe, "f"),
            isL1SafeMasterCopy,
            contractNetworks
          }), "f");
        } else {
          __classPrivateFieldSet(this, _Safe_contractManager, await contractManager_1.default.create({
            ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
            safeAddress: config.safeAddress,
            isL1SafeMasterCopy,
            contractNetworks
          }), "f");
        }
        __classPrivateFieldSet(this, _Safe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _Safe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _Safe_guardManager, new guardManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _Safe_fallbackHandlerManager, new fallbackHandlerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
      }
      /**
       * Returns a new instance of the Safe Core SDK.
       * @param config - Connect Safe configuration
       * @throws "A safeAddress and a predictedSafe cannot be connected at the same time"
       * @throws "SafeProxy contract is not deployed on the current network"
       * @throws "MultiSend contract is not deployed on the current network"
       * @throws "MultiSendCallOnly contract is not deployed on the current network"
       */
      async connect(config) {
        const { ethAdapter, safeAddress, predictedSafe, isL1SafeMasterCopy, contractNetworks } = config;
        const configProps = {
          ethAdapter: ethAdapter || __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          isL1SafeMasterCopy: isL1SafeMasterCopy || __classPrivateFieldGet(this, _Safe_contractManager, "f").isL1SafeMasterCopy,
          contractNetworks: contractNetworks || __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks
        };
        if (safeAddress) {
          return await _Safe.create({
            safeAddress,
            ...configProps
          });
        }
        if (predictedSafe) {
          return await _Safe.create({
            predictedSafe,
            ...configProps
          });
        }
        if (__classPrivateFieldGet(this, _Safe_predictedSafe, "f")) {
          return await _Safe.create({
            predictedSafe: __classPrivateFieldGet(this, _Safe_predictedSafe, "f"),
            ...configProps
          });
        }
        return await _Safe.create({
          safeAddress: await this.getAddress(),
          ...configProps
        });
      }
      /**
       * Returns the address of the current SafeProxy contract.
       *
       * @returns The address of the SafeProxy contract
       */
      async getAddress() {
        var _a;
        if (__classPrivateFieldGet(this, _Safe_predictedSafe, "f")) {
          const safeVersion = await this.getContractVersion();
          if (!(0, utils_2.hasSafeFeature)(utils_2.SAFE_FEATURES.ACCOUNT_ABSTRACTION, safeVersion)) {
            throw new Error("Account Abstraction functionality is not available for Safes with version lower than v1.3.0");
          }
          const chainId = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getChainId();
          return (0, utils_1.predictSafeAddress)({
            ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
            customContracts: (_a = __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks) == null ? void 0 : _a[chainId],
            ...__classPrivateFieldGet(this, _Safe_predictedSafe, "f")
          });
        }
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        return Promise.resolve(__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getAddress());
      }
      /**
       * Returns the ContractManager
       *
       * @returns The current ContractManager
       * */
      getContractManager() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f");
      }
      /**
       * Returns the current EthAdapter.
       *
       * @returns The current EthAdapter
       */
      getEthAdapter() {
        return __classPrivateFieldGet(this, _Safe_ethAdapter, "f");
      }
      /**
       * Returns the address of the MultiSend contract.
       *
       * @returns The address of the MultiSend contract
       */
      getMultiSendAddress() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendContract.getAddress();
      }
      /**
       * Returns the address of the MultiSendCallOnly contract.
       *
       * @returns The address of the MultiSendCallOnly contract
       */
      getMultiSendCallOnlyAddress() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendCallOnlyContract.getAddress();
      }
      /**
       * Checks if the current Safe is deployed.
       *
       * @returns TRUE if the Safe contract is deployed
       */
      async isSafeDeployed() {
        const safeAddress = await this.getAddress();
        const isSafeDeployed = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").isContractDeployed(safeAddress);
        return isSafeDeployed;
      }
      /**
       * Returns the Safe Master Copy contract version.
       *
       * @returns The Safe Master Copy contract version
       */
      async getContractVersion() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getVersion();
        }
        if ((_b = (_a = __classPrivateFieldGet(this, _Safe_predictedSafe, "f")) == null ? void 0 : _a.safeDeploymentConfig) == null ? void 0 : _b.safeVersion) {
          return Promise.resolve(__classPrivateFieldGet(this, _Safe_predictedSafe, "f").safeDeploymentConfig.safeVersion);
        }
        return Promise.resolve(config_1.DEFAULT_SAFE_VERSION);
      }
      /**
       * Returns the list of Safe owner accounts.
       *
       * @returns The list of owners
       */
      async getOwners() {
        var _a;
        if ((_a = __classPrivateFieldGet(this, _Safe_predictedSafe, "f")) == null ? void 0 : _a.safeAccountConfig.owners) {
          return Promise.resolve(__classPrivateFieldGet(this, _Safe_predictedSafe, "f").safeAccountConfig.owners);
        }
        return __classPrivateFieldGet(this, _Safe_ownerManager, "f").getOwners();
      }
      /**
       * Returns the Safe nonce.
       *
       * @returns The Safe nonce
       */
      async getNonce() {
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          return Promise.resolve(0);
        }
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getNonce();
      }
      /**
       * Returns the Safe threshold.
       *
       * @returns The Safe threshold
       */
      async getThreshold() {
        var _a;
        if ((_a = __classPrivateFieldGet(this, _Safe_predictedSafe, "f")) == null ? void 0 : _a.safeAccountConfig.threshold) {
          return Promise.resolve(__classPrivateFieldGet(this, _Safe_predictedSafe, "f").safeAccountConfig.threshold);
        }
        return __classPrivateFieldGet(this, _Safe_ownerManager, "f").getThreshold();
      }
      /**
       * Returns the chainId of the connected network.
       *
       * @returns The chainId of the connected network
       */
      async getChainId() {
        return __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getChainId();
      }
      /**
       * Returns the ETH balance of the Safe.
       *
       * @returns The ETH balance of the Safe
       */
      async getBalance() {
        return __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getBalance(await this.getAddress());
      }
      /**
       * Returns the address of the FallbackHandler contract.
       *
       * @returns The address of the FallbackHandler contract
       */
      getFallbackHandler() {
        return __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, "f").getFallbackHandler();
      }
      /**
       * Returns the enabled Safe guard or 0x address if no guards are enabled.
       *
       * @returns The address of the enabled Safe guard
       * @throws "Current version of the Safe does not support Safe transaction guards functionality"
       */
      async getGuard() {
        return __classPrivateFieldGet(this, _Safe_guardManager, "f").getGuard();
      }
      /**
       * Returns the list of addresses of all the enabled Safe modules.
       *
       * @returns The list of addresses of all the enabled Safe modules
       */
      async getModules() {
        return __classPrivateFieldGet(this, _Safe_moduleManager, "f").getModules();
      }
      /**
       * Checks if a specific Safe module is enabled for the current Safe.
       *
       * @param moduleAddress - The desired module address
       * @returns TRUE if the module is enabled
       */
      async isModuleEnabled(moduleAddress) {
        return __classPrivateFieldGet(this, _Safe_moduleManager, "f").isModuleEnabled(moduleAddress);
      }
      /**
       * Checks if a specific address is an owner of the current Safe.
       *
       * @param ownerAddress - The account address
       * @returns TRUE if the account is an owner
       */
      async isOwner(ownerAddress) {
        var _a, _b;
        if ((_a = __classPrivateFieldGet(this, _Safe_predictedSafe, "f")) == null ? void 0 : _a.safeAccountConfig.owners) {
          return Promise.resolve((_b = __classPrivateFieldGet(this, _Safe_predictedSafe, "f")) == null ? void 0 : _b.safeAccountConfig.owners.some((owner) => (0, utils_2.sameString)(owner, ownerAddress)));
        }
        return __classPrivateFieldGet(this, _Safe_ownerManager, "f").isOwner(ownerAddress);
      }
      /**
       * Returns a Safe transaction ready to be signed by the owners.
       *
       * @param createTransactionProps - The createTransaction props
       * @returns The Safe transaction
       * @throws "Invalid empty array of transactions"
       */
      async createTransaction({ safeTransactionData, onlyCalls = false, options }) {
        const safeVersion = await this.getContractVersion();
        if (__classPrivateFieldGet(this, _Safe_predictedSafe, "f") && !(0, utils_2.hasSafeFeature)(utils_2.SAFE_FEATURES.ACCOUNT_ABSTRACTION, safeVersion)) {
          throw new Error("Account Abstraction functionality is not available for Safes with version lower than v1.3.0");
        }
        if ((0, utils_2.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length === 0) {
          throw new Error("Invalid empty array of transactions");
        }
        let newTransaction;
        if ((0, utils_2.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length > 1) {
          const multiSendContract = onlyCalls ? __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendCallOnlyContract : __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendContract;
          const multiSendData = (0, utils_4.encodeMultiSendData)(safeTransactionData.map(utils_4.standardizeMetaTransactionData));
          const multiSendTransaction = {
            ...options,
            to: multiSendContract.getAddress(),
            value: "0",
            data: multiSendContract.encode("multiSend", [multiSendData]),
            operation: safe_core_sdk_types_1.OperationType.DelegateCall
          };
          newTransaction = multiSendTransaction;
        } else {
          newTransaction = (0, utils_2.isMetaTransactionArray)(safeTransactionData) ? { ...options, ...safeTransactionData[0] } : safeTransactionData;
        }
        if (__classPrivateFieldGet(this, _Safe_predictedSafe, "f")) {
          return new SafeTransaction_1.default(await (0, utils_4.standardizeSafeTransactionData)({
            predictedSafe: __classPrivateFieldGet(this, _Safe_predictedSafe, "f"),
            ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
            tx: newTransaction,
            contractNetworks: __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks
          }));
        }
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        return new SafeTransaction_1.default(await (0, utils_4.standardizeSafeTransactionData)({
          safeContract: __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract,
          ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          tx: newTransaction,
          contractNetworks: __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks
        }));
      }
      /**
       * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.
       *
       * @param nonce - The nonce of the transaction/s that are going to be rejected
       * @returns The Safe transaction that invalidates the pending Safe transaction/s
       */
      async createRejectionTransaction(nonce) {
        const safeTransactionData = {
          to: await this.getAddress(),
          nonce,
          value: "0",
          data: "0x",
          safeTxGas: "0"
        };
        return this.createTransaction({ safeTransactionData });
      }
      /**
       * Copies a Safe transaction
       *
       * @param safeTransaction - The Safe transaction
       * @returns The new Safe transaction
       */
      async copyTransaction(safeTransaction) {
        const signedSafeTransaction = await this.createTransaction({
          safeTransactionData: safeTransaction.data
        });
        safeTransaction.signatures.forEach((signature) => {
          signedSafeTransaction.addSignature(signature);
        });
        return signedSafeTransaction;
      }
      /**
       * Returns the transaction hash of a Safe transaction.
       *
       * @param safeTransaction - The Safe transaction
       * @returns The transaction hash of the Safe transaction
       */
      async getTransactionHash(safeTransaction) {
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        const safeTransactionData = safeTransaction.data;
        const txHash = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getTransactionHash(safeTransactionData);
        return txHash;
      }
      /**
       * Signs a hash using the current signer account.
       *
       * @param hash - The hash to sign
       * @returns The Safe signature
       */
      async signTransactionHash(hash) {
        return (0, utils_3.generateSignature)(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), hash);
      }
      /**
       * Signs a transaction according to the EIP-712 using the current signer account.
       *
       * @param safeTransaction - The Safe transaction to be signed
       * @param methodVersion - EIP-712 version. Optional
       * @returns The Safe signature
       */
      async signTypedData(safeTransaction, methodVersion) {
        const safeTransactionEIP712Args = {
          safeAddress: await this.getAddress(),
          safeVersion: await this.getContractVersion(),
          chainId: await this.getEthAdapter().getChainId(),
          safeTransactionData: safeTransaction.data
        };
        return (0, utils_3.generateEIP712Signature)(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), safeTransactionEIP712Args, methodVersion);
      }
      /**
       * Adds the signature of the current signer to the Safe transaction object.
       *
       * @param safeTransaction - The Safe transaction to be signed
       * @param signingMethod - Method followed to sign a transaction. Optional. Default value is "eth_sign"
       * @returns The signed Safe transaction
       * @throws "Transactions can only be signed by Safe owners"
       */
      async signTransaction(safeTransaction, signingMethod = "eth_signTypedData_v4") {
        const transaction = (0, utils_2.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const addressIsOwner = owners.some((owner) => signerAddress && (0, utils_2.sameString)(owner, signerAddress));
        if (!addressIsOwner) {
          throw new Error("Transactions can only be signed by Safe owners");
        }
        let signature;
        if (signingMethod === "eth_signTypedData_v4") {
          signature = await this.signTypedData(transaction, "v4");
        } else if (signingMethod === "eth_signTypedData_v3") {
          signature = await this.signTypedData(transaction, "v3");
        } else if (signingMethod === "eth_signTypedData") {
          signature = await this.signTypedData(transaction);
        } else {
          const safeVersion = await this.getContractVersion();
          if (!(0, utils_2.hasSafeFeature)(utils_2.SAFE_FEATURES.ETH_SIGN, safeVersion)) {
            throw new Error("eth_sign is only supported by Safes >= v1.1.0");
          }
          const txHash = await this.getTransactionHash(transaction);
          signature = await this.signTransactionHash(txHash);
        }
        const signedSafeTransaction = await this.createTransaction({
          safeTransactionData: transaction.data
        });
        transaction.signatures.forEach((signature2) => {
          signedSafeTransaction.addSignature(signature2);
        });
        signedSafeTransaction.addSignature(signature);
        return signedSafeTransaction;
      }
      /**
       * Approves on-chain a hash using the current signer account.
       *
       * @param hash - The hash to approve
       * @param options - The Safe transaction execution options. Optional
       * @returns The Safe transaction response
       * @throws "Transaction hashes can only be approved by Safe owners"
       * @throws "Cannot specify gas and gasLimit together in transaction options"
       */
      async approveTransactionHash(hash, options) {
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const addressIsOwner = owners.some((owner) => signerAddress && (0, utils_2.sameString)(owner, signerAddress));
        if (!addressIsOwner) {
          throw new Error("Transaction hashes can only be approved by Safe owners");
        }
        if ((options == null ? void 0 : options.gas) && (options == null ? void 0 : options.gasLimit)) {
          throw new Error("Cannot specify gas and gasLimit together in transaction options");
        }
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.approveHash(hash, {
          from: signerAddress,
          ...options
        });
      }
      /**
       * Returns a list of owners who have approved a specific Safe transaction.
       *
       * @param txHash - The Safe transaction hash
       * @returns The list of owners
       */
      async getOwnersWhoApprovedTx(txHash) {
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        const owners = await this.getOwners();
        const ownersWhoApproved = [];
        for (const owner of owners) {
          const approved = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.approvedHashes(owner, txHash);
          if (approved.gt(0)) {
            ownersWhoApproved.push(owner);
          }
        }
        return ownersWhoApproved;
      }
      /**
       * Returns the Safe transaction to enable the fallback handler.
       *
       * @param address - The new fallback handler address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid fallback handler address provided"
       * @throws "Fallback handler provided is already enabled"
       * @throws "Current version of the Safe does not support the fallback handler functionality"
       */
      async createEnableFallbackHandlerTx(fallbackHandlerAddress, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, "f").encodeEnableFallbackHandlerData(fallbackHandlerAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to disable the fallback handler.
       *
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "There is no fallback handler enabled yet"
       * @throws "Current version of the Safe does not support the fallback handler functionality"
       */
      async createDisableFallbackHandlerTx(options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, "f").encodeDisableFallbackHandlerData(),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to enable a Safe guard.
       *
       * @param guardAddress - The desired guard address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid guard address provided"
       * @throws "Guard provided is already enabled"
       * @throws "Current version of the Safe does not support Safe transaction guards functionality"
       */
      async createEnableGuardTx(guardAddress, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_guardManager, "f").encodeEnableGuardData(guardAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to disable a Safe guard.
       *
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "There is no guard enabled yet"
       * @throws "Current version of the Safe does not support Safe transaction guards functionality"
       */
      async createDisableGuardTx(options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_guardManager, "f").encodeDisableGuardData(),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to enable a Safe module.
       *
       * @param moduleAddress - The desired module address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid module address provided"
       * @throws "Module provided is already enabled"
       */
      async createEnableModuleTx(moduleAddress, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_moduleManager, "f").encodeEnableModuleData(moduleAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to disable a Safe module.
       *
       * @param moduleAddress - The desired module address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid module address provided"
       * @throws "Module provided is not enabled already"
       */
      async createDisableModuleTx(moduleAddress, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_moduleManager, "f").encodeDisableModuleData(moduleAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to add an owner and optionally change the threshold.
       *
       * @param params - The transaction params
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid owner address provided"
       * @throws "Address provided is already an owner"
       * @throws "Threshold needs to be greater than 0"
       * @throws "Threshold cannot exceed owner count"
       */
      async createAddOwnerTx({ ownerAddress, threshold }, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeAddOwnerWithThresholdData(ownerAddress, threshold),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to remove an owner and optionally change the threshold.
       *
       * @param params - The transaction params
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid owner address provided"
       * @throws "Address provided is not an owner"
       * @throws "Threshold needs to be greater than 0"
       * @throws "Threshold cannot exceed owner count"
       */
      async createRemoveOwnerTx({ ownerAddress, threshold }, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeRemoveOwnerData(ownerAddress, threshold),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to replace an owner of the Safe with a new one.
       *
       * @param params - The transaction params
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid new owner address provided"
       * @throws "Invalid old owner address provided"
       * @throws "New address provided is already an owner"
       * @throws "Old address provided is not an owner"
       */
      async createSwapOwnerTx({ oldOwnerAddress, newOwnerAddress }, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to change the threshold.
       *
       * @param threshold - The new threshold
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Threshold needs to be greater than 0"
       * @throws "Threshold cannot exceed owner count"
       */
      async createChangeThresholdTx(threshold, options) {
        const safeTransactionData = {
          to: await this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeChangeThresholdData(threshold),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Converts a transaction from type SafeMultisigTransactionResponse to type SafeTransaction
       *
       * @param serviceTransactionResponse - The transaction to convert
       * @returns The converted transaction with type SafeTransaction
       */
      async toSafeTransactionType(serviceTransactionResponse) {
        var _a;
        const safeTransactionData = {
          to: serviceTransactionResponse.to,
          value: serviceTransactionResponse.value,
          data: serviceTransactionResponse.data || "0x",
          operation: serviceTransactionResponse.operation,
          safeTxGas: serviceTransactionResponse.safeTxGas.toString(),
          baseGas: serviceTransactionResponse.baseGas.toString(),
          gasPrice: serviceTransactionResponse.gasPrice,
          gasToken: serviceTransactionResponse.gasToken,
          refundReceiver: serviceTransactionResponse.refundReceiver,
          nonce: serviceTransactionResponse.nonce
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        (_a = serviceTransactionResponse.confirmations) == null ? void 0 : _a.map((confirmation) => {
          const signature = new utils_2.EthSafeSignature(confirmation.owner, confirmation.signature);
          safeTransaction.addSignature(signature);
        });
        return safeTransaction;
      }
      /**
       * Checks if a Safe transaction can be executed successfully with no errors.
       *
       * @param safeTransaction - The Safe transaction to check
       * @param options - The Safe transaction execution options. Optional
       * @returns TRUE if the Safe transaction can be executed successfully with no errors
       */
      async isValidTransaction(safeTransaction, options) {
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        const transaction = (0, utils_2.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;
        const signedSafeTransaction = await this.copyTransaction(transaction);
        const txHash = await this.getTransactionHash(signedSafeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
          signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(owner));
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        if (owners.includes(signerAddress)) {
          signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(signerAddress));
        }
        const isTxValid = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.isValidTransaction(signedSafeTransaction, {
          from: signerAddress,
          ...options
        });
        return isTxValid;
      }
      /**
       * Executes a Safe transaction.
       *
       * @param safeTransaction - The Safe transaction to execute
       * @param options - The Safe transaction execution options. Optional
       * @returns The Safe transaction response
       * @throws "No signer provided"
       * @throws "There are X signatures missing"
       * @throws "Cannot specify gas and gasLimit together in transaction options"
       */
      async executeTransaction(safeTransaction, options) {
        if (!__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract) {
          throw new Error("Safe is not deployed");
        }
        const transaction = (0, utils_2.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;
        const signedSafeTransaction = await this.copyTransaction(transaction);
        const txHash = await this.getTransactionHash(signedSafeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
          signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(owner));
        }
        const owners = await this.getOwners();
        const threshold = await this.getThreshold();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (threshold > signedSafeTransaction.signatures.size && signerAddress && owners.includes(signerAddress)) {
          signedSafeTransaction.addSignature((0, utils_3.generatePreValidatedSignature)(signerAddress));
        }
        if (threshold > signedSafeTransaction.signatures.size) {
          const signaturesMissing = threshold - signedSafeTransaction.signatures.size;
          throw new Error(`There ${signaturesMissing > 1 ? "are" : "is"} ${signaturesMissing} signature${signaturesMissing > 1 ? "s" : ""} missing`);
        }
        const value = bignumber_1.BigNumber.from(signedSafeTransaction.data.value);
        if (!value.isZero()) {
          const balance = await this.getBalance();
          if (value.gt(bignumber_1.BigNumber.from(balance))) {
            throw new Error("Not enough Ether funds");
          }
        }
        if ((options == null ? void 0 : options.gas) && (options == null ? void 0 : options.gasLimit)) {
          throw new Error("Cannot specify gas and gasLimit together in transaction options");
        }
        const txResponse = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.execTransaction(signedSafeTransaction, {
          from: signerAddress,
          ...options
        });
        return txResponse;
      }
      /**
       * Returns the Safe Transaction encoded
       *
       * @async
       * @param {SafeTransaction} safeTransaction - The Safe transaction to be encoded.
       * @returns {Promise<string>} The encoded transaction
       *
       */
      async getEncodedTransaction(safeTransaction) {
        var _a;
        const safeVersion = await this.getContractVersion();
        const chainId = await this.getChainId();
        const customContracts = (_a = __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks) == null ? void 0 : _a[chainId];
        const isL1SafeMasterCopy = __classPrivateFieldGet(this, _Safe_contractManager, "f").isL1SafeMasterCopy;
        const safeSingletonContract = await (0, safeDeploymentContracts_1.getSafeContract)({
          ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          safeVersion,
          isL1SafeMasterCopy,
          customContracts
        });
        const encodedTransaction = safeSingletonContract.encode("execTransaction", [
          safeTransaction.data.to,
          safeTransaction.data.value,
          safeTransaction.data.data,
          safeTransaction.data.operation,
          safeTransaction.data.safeTxGas,
          safeTransaction.data.baseGas,
          safeTransaction.data.gasPrice,
          safeTransaction.data.gasToken,
          safeTransaction.data.refundReceiver,
          safeTransaction.encodedSignatures()
        ]);
        return encodedTransaction;
      }
      /**
       * Wraps a Safe transaction into a Safe deployment batch.
       *
       * This function creates a transaction batch of 2 transactions, which includes the
       * deployment of the Safe and the provided Safe transaction.
       *
       * @async
       * @param {SafeTransaction} safeTransaction - The Safe transaction to be wrapped into the deployment batch.
       * @param {TransactionOptions} [transactionOptions] - Optional. Options for the transaction, such as from, gas price, gas limit, etc.
       * @param {string} [customSaltNonce] - Optional. a Custom salt nonce to be used for the deployment of the Safe. If not provided, a default value is used.
       * @returns {Promise<Transaction>} A promise that resolves to a Transaction object representing the prepared batch of transactions.
       * @throws Will throw an error if the safe is already deployed.
       *
       */
      async wrapSafeTransactionIntoDeploymentBatch(safeTransaction, transactionOptions, customSaltNonce) {
        const isSafeDeployed = await this.isSafeDeployed();
        if (isSafeDeployed) {
          throw new Error("Safe already deployed");
        }
        const safeDeploymentTransaction = await this.createSafeDeploymentTransaction(customSaltNonce);
        const safeDeploymentBatchTransaction = {
          to: safeDeploymentTransaction.to,
          value: safeDeploymentTransaction.value,
          data: safeDeploymentTransaction.data,
          operation: safe_core_sdk_types_1.OperationType.Call
        };
        const safeBatchTransaction = {
          to: await this.getAddress(),
          value: "0",
          data: await this.getEncodedTransaction(safeTransaction),
          operation: safe_core_sdk_types_1.OperationType.Call
        };
        const transactions = [safeDeploymentBatchTransaction, safeBatchTransaction];
        const safeDeploymentBatch = await this.createTransactionBatch(transactions, transactionOptions);
        return safeDeploymentBatch;
      }
      /**
       * Creates a Safe deployment transaction.
       *
       * This function prepares a transaction for the deployment of a Safe.
       * Both the saltNonce and options parameters are optional, and if not
       * provided, default values will be used.
       *
       * @async
       * @param {string} [customSaltNonce] - Optional. a Custom salt nonce to be used for the deployment of the Safe. If not provided, a default value is used.
       * @param {TransactionOptions} [options] - Optional. Options for the transaction, such as gas price, gas limit, etc.
       * @returns {Promise<Transaction>} A promise that resolves to a Transaction object representing the prepared Safe deployment transaction.
       *
       */
      async createSafeDeploymentTransaction(customSaltNonce, transactionOptions) {
        var _a;
        if (!__classPrivateFieldGet(this, _Safe_predictedSafe, "f")) {
          throw new Error("Predict Safe should be present");
        }
        const { safeAccountConfig, safeDeploymentConfig } = __classPrivateFieldGet(this, _Safe_predictedSafe, "f");
        const safeVersion = await this.getContractVersion();
        const ethAdapter = __classPrivateFieldGet(this, _Safe_ethAdapter, "f");
        const chainId = await ethAdapter.getChainId();
        const isL1SafeMasterCopy = __classPrivateFieldGet(this, _Safe_contractManager, "f").isL1SafeMasterCopy;
        const customContracts = (_a = __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks) == null ? void 0 : _a[chainId];
        const safeSingletonContract = await (0, safeDeploymentContracts_1.getSafeContract)({
          ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          safeVersion,
          isL1SafeMasterCopy,
          customContracts
        });
        const safeProxyFactoryContract = await (0, safeDeploymentContracts_1.getProxyFactoryContract)({
          ethAdapter,
          safeVersion,
          customContracts
        });
        const initializer = await (0, utils_1.encodeSetupCallData)({
          ethAdapter,
          safeContract: safeSingletonContract,
          safeAccountConfig,
          customContracts
        });
        const saltNonce = customSaltNonce || (safeDeploymentConfig == null ? void 0 : safeDeploymentConfig.saltNonce) || utils_1.PREDETERMINED_SALT_NONCE;
        const safeDeployTransactionData = {
          ...transactionOptions,
          to: safeProxyFactoryContract.getAddress(),
          value: "0",
          // we use the createProxyWithNonce method to create the Safe in a deterministic address, see: https://github.com/safe-global/safe-contracts/blob/main/contracts/proxies/SafeProxyFactory.sol#L52
          data: safeProxyFactoryContract.encode("createProxyWithNonce", [
            safeSingletonContract.getAddress(),
            initializer,
            saltNonce
          ])
        };
        return safeDeployTransactionData;
      }
      /**
       * This function creates a batch of the provided Safe transactions using the MultiSend contract.
       * It groups the transactions together into a single transaction which can then be executed atomically.
       *
       * @async
       * @function createTransactionBatch
       * @param {MetaTransactionData[]} transactions - An array of MetaTransactionData objects to be batched together.
       * @param {TransactionOption} [transactionOptions] - Optional TransactionOption object to specify additional options for the transaction batch.
       * @returns {Promise<Transaction>} A Promise that resolves with the created transaction batch.
       *
       */
      async createTransactionBatch(transactions, transactionOptions) {
        var _a;
        const chainId = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getChainId();
        const multiSendCallOnlyContract = await (0, safeDeploymentContracts_1.getMultiSendCallOnlyContract)({
          ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          safeVersion: await this.getContractVersion(),
          customContracts: (_a = __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks) == null ? void 0 : _a[chainId]
        });
        const batchData = multiSendCallOnlyContract.encode("multiSend", [
          (0, utils_4.encodeMultiSendData)(transactions)
          // encoded transactions
        ]);
        const transactionBatch = {
          ...transactionOptions,
          to: multiSendCallOnlyContract.getAddress(),
          value: "0",
          data: batchData
        };
        return transactionBatch;
      }
    };
    _Safe_predictedSafe = /* @__PURE__ */ new WeakMap(), _Safe_ethAdapter = /* @__PURE__ */ new WeakMap(), _Safe_contractManager = /* @__PURE__ */ new WeakMap(), _Safe_ownerManager = /* @__PURE__ */ new WeakMap(), _Safe_moduleManager = /* @__PURE__ */ new WeakMap(), _Safe_guardManager = /* @__PURE__ */ new WeakMap(), _Safe_fallbackHandlerManager = /* @__PURE__ */ new WeakMap();
    exports.default = Safe;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.0.0/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.0.0/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        constant: false,
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "DOMAIN_SEPARATOR_TYPEHASH",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "",
            type: "address"
          },
          {
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_masterCopy",
            type: "address"
          }
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SENTINEL_MODULES",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SENTINEL_OWNERS",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
          {
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
          {
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SAFE_MSG_TYPEHASH",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SAFE_TX_TYPEHASH",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "prevModule",
            type: "address"
          },
          {
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "prevOwner",
            type: "address"
          },
          {
            name: "oldOwner",
            type: "address"
          },
          {
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "prevOwner",
            type: "address"
          },
          {
            name: "owner",
            type: "address"
          },
          {
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "txHash",
            type: "bytes32"
          }
        ],
        name: "ExecutionFailed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "newContract",
            type: "address"
          }
        ],
        name: "ContractCreation",
        type: "event"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_owners",
            type: "address[]"
          },
          {
            name: "_threshold",
            type: "uint256"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "paymentToken",
            type: "address"
          },
          {
            name: "payment",
            type: "uint256"
          },
          {
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          },
          {
            name: "safeTxGas",
            type: "uint256"
          },
          {
            name: "baseGas",
            type: "uint256"
          },
          {
            name: "gasPrice",
            type: "uint256"
          },
          {
            name: "gasToken",
            type: "address"
          },
          {
            name: "refundReceiver",
            type: "address"
          },
          {
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_data",
            type: "bytes"
          },
          {
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            name: "",
            type: "bytes4"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          },
          {
            name: "safeTxGas",
            type: "uint256"
          },
          {
            name: "baseGas",
            type: "uint256"
          },
          {
            name: "gasPrice",
            type: "uint256"
          },
          {
            name: "gasToken",
            type: "address"
          },
          {
            name: "refundReceiver",
            type: "address"
          },
          {
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          },
          {
            name: "safeTxGas",
            type: "uint256"
          },
          {
            name: "baseGas",
            type: "uint256"
          },
          {
            name: "gasPrice",
            type: "uint256"
          },
          {
            name: "gasToken",
            type: "address"
          },
          {
            name: "refundReceiver",
            type: "address"
          },
          {
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.0.0/factories/Proxy_factory__factory.js
var require_Proxy_factory_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.0.0/factories/Proxy_factory__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        constant: false,
        inputs: [
          {
            name: "_mastercopy",
            type: "address"
          },
          {
            name: "initializer",
            type: "bytes"
          },
          {
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "masterCopy",
            type: "address"
          },
          {
            name: "data",
            type: "bytes"
          }
        ],
        name: "createProxy",
        outputs: [
          {
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
          {
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "proxy",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      }
    ];
    var Proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Proxy_factory__factory = Proxy_factory__factory;
    Proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.1.1/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.1.1/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "masterCopy",
            type: "address"
          }
        ],
        name: "ChangedMasterCopy",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_masterCopy",
            type: "address"
          }
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.1.1/factories/Multi_send__factory.js
var require_Multi_send_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.1.1/factories/Multi_send__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Multi_send__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send__factory = Multi_send__factory;
    Multi_send__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.1.1/factories/Proxy_factory__factory.js
var require_Proxy_factory_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.1.1/factories/Proxy_factory__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "masterCopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "createProxy",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_mastercopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_mastercopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          },
          {
            internalType: "contract IProxyCreationCallback",
            name: "callback",
            type: "address"
          }
        ],
        name: "createProxyWithCallback",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_mastercopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "calculateCreateProxyWithNonceAddress",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Proxy_factory__factory = Proxy_factory__factory;
    Proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.2.0/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.2.0/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "masterCopy",
            type: "address"
          }
        ],
        name: "ChangedMasterCopy",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_masterCopy",
            type: "address"
          }
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "isModuleEnabled",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: true,
        stateMutability: "payable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Compatibility_fallback_handler__factory.js
var require_Compatibility_fallback_handler_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Compatibility_fallback_handler__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compatibility_fallback_handler__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract GnosisSafe",
            name: "safe",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHashForSafe",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "targetContract",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "calldataPayload",
            type: "bytes"
          }
        ],
        name: "simulate",
        outputs: [
          {
            internalType: "bytes",
            name: "response",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var Compatibility_fallback_handler__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Compatibility_fallback_handler__factory = Compatibility_fallback_handler__factory;
    Compatibility_fallback_handler__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Create_call__factory.js
var require_Create_call_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Create_call__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Create_call__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        name: "ContractCreation",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "deploymentData",
            type: "bytes"
          }
        ],
        name: "performCreate",
        outputs: [
          {
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "deploymentData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "salt",
            type: "bytes32"
          }
        ],
        name: "performCreate2",
        outputs: [
          {
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Create_call__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Create_call__factory = Create_call__factory;
    Create_call__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory4 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "ChangedFallbackHandler",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "ChangedGuard",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "SafeReceived",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "initiator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address[]",
            name: "owners",
            type: "address[]"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "address",
            name: "initializer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          }
        ],
        name: "SafeSetup",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        stateMutability: "nonpayable",
        type: "fallback"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "requiredSignatures",
            type: "uint256"
          }
        ],
        name: "checkNSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "checkSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getChainId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "offset",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "length",
            type: "uint256"
          }
        ],
        name: "getStorageAt",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "isModuleEnabled",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "setGuard",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "targetContract",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "calldataPayload",
            type: "bytes"
          }
        ],
        name: "simulateAndRevert",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send__factory.js
var require_Multi_send_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
    var Multi_send__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send__factory = Multi_send__factory;
    Multi_send__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send_call_only__factory.js
var require_Multi_send_call_only_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send_call_only__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send_call_only__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
    var Multi_send_call_only__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send_call_only__factory = Multi_send_call_only__factory;
    Multi_send_call_only__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Proxy_factory__factory.js
var require_Proxy_factory_factory3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Proxy_factory__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "singleton",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "calculateCreateProxyWithNonceAddress",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "createProxy",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          },
          {
            internalType: "contract IProxyCreationCallback",
            name: "callback",
            type: "address"
          }
        ],
        name: "createProxyWithCallback",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var Proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Proxy_factory__factory = Proxy_factory__factory;
    Proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Sign_message_lib__factory.js
var require_Sign_message_lib_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Sign_message_lib__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sign_message_lib__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Sign_message_lib__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Sign_message_lib__factory = Sign_message_lib__factory;
    Sign_message_lib__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Simulate_tx_accessor__factory.js
var require_Simulate_tx_accessor_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.3.0/factories/Simulate_tx_accessor__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Simulate_tx_accessor__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "simulate",
        outputs: [
          {
            internalType: "uint256",
            name: "estimate",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Simulate_tx_accessor__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Simulate_tx_accessor__factory = Simulate_tx_accessor__factory;
    Simulate_tx_accessor__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Compatibility_fallback_handler__factory.js
var require_Compatibility_fallback_handler_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Compatibility_fallback_handler__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compatibility_fallback_handler__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [
          {
            internalType: "contract Safe",
            name: "safe",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "encodeMessageDataForSafe",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract Safe",
            name: "safe",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHashForSafe",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "targetContract",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "calldataPayload",
            type: "bytes"
          }
        ],
        name: "simulate",
        outputs: [
          {
            internalType: "bytes",
            name: "response",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var Compatibility_fallback_handler__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Compatibility_fallback_handler__factory = Compatibility_fallback_handler__factory;
    Compatibility_fallback_handler__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Create_call__factory.js
var require_Create_call_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Create_call__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Create_call__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        name: "ContractCreation",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "deploymentData",
            type: "bytes"
          }
        ],
        name: "performCreate",
        outputs: [
          {
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "deploymentData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "salt",
            type: "bytes32"
          }
        ],
        name: "performCreate2",
        outputs: [
          {
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Create_call__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Create_call__factory = Create_call__factory;
    Create_call__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Multi_send__factory.js
var require_Multi_send_factory3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Multi_send__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
    var Multi_send__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send__factory = Multi_send__factory;
    Multi_send__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Multi_send_call_only__factory.js
var require_Multi_send_call_only_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Multi_send_call_only__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send_call_only__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
    var Multi_send_call_only__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send_call_only__factory = Multi_send_call_only__factory;
    Multi_send_call_only__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Safe__factory.js
var require_Safe_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Safe__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "ChangedFallbackHandler",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "ChangedGuard",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "SafeReceived",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "initiator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address[]",
            name: "owners",
            type: "address[]"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "address",
            name: "initializer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          }
        ],
        name: "SafeSetup",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        stateMutability: "nonpayable",
        type: "fallback"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "requiredSignatures",
            type: "uint256"
          }
        ],
        name: "checkNSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "checkSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getChainId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "offset",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "length",
            type: "uint256"
          }
        ],
        name: "getStorageAt",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "isModuleEnabled",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "setGuard",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "targetContract",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "calldataPayload",
            type: "bytes"
          }
        ],
        name: "simulateAndRevert",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var Safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Safe__factory = Safe__factory;
    Safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Safe_proxy_factory__factory.js
var require_Safe_proxy_factory_factory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Safe_proxy_factory__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Safe_proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "contract SafeProxy",
            name: "proxy",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "singleton",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createChainSpecificProxyWithNonce",
        outputs: [
          {
            internalType: "contract SafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          },
          {
            internalType: "contract IProxyCreationCallback",
            name: "callback",
            type: "address"
          }
        ],
        name: "createProxyWithCallback",
        outputs: [
          {
            internalType: "contract SafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            internalType: "contract SafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getChainId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var Safe_proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Safe_proxy_factory__factory = Safe_proxy_factory__factory;
    Safe_proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Sign_message_lib__factory.js
var require_Sign_message_lib_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Sign_message_lib__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sign_message_lib__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Sign_message_lib__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Sign_message_lib__factory = Sign_message_lib__factory;
    Sign_message_lib__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Simulate_tx_accessor__factory.js
var require_Simulate_tx_accessor_factory2 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/typechain/src/ethers-v5/v1.4.1/factories/Simulate_tx_accessor__factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Simulate_tx_accessor__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "simulate",
        outputs: [
          {
            internalType: "uint256",
            name: "estimate",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Simulate_tx_accessor__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Simulate_tx_accessor__factory = Simulate_tx_accessor__factory;
    Simulate_tx_accessor__factory.abi = _abi;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CompatibilityFallbackHandler/CompatibilityFallbackHandlerEthersContract.js
var require_CompatibilityFallbackHandlerEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CompatibilityFallbackHandler/CompatibilityFallbackHandlerEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = CompatibilityFallbackHandlerEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CompatibilityFallbackHandler/v1.3.0/CompatibilityFallbackHandler_V1_3_0_Ethers.js
var require_CompatibilityFallbackHandler_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CompatibilityFallbackHandler/v1.3.0/CompatibilityFallbackHandler_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerEthersContract_1 = __importDefault(require_CompatibilityFallbackHandlerEthersContract());
    var CompatibilityFallbackHandler_V1_3_0_Ethers = class extends CompatibilityFallbackHandlerEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CompatibilityFallbackHandler_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CompatibilityFallbackHandler/v1.4.1/CompatibilityFallbackHandler_V1_4_1_Ethers.js
var require_CompatibilityFallbackHandler_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CompatibilityFallbackHandler/v1.4.1/CompatibilityFallbackHandler_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerEthersContract_1 = __importDefault(require_CompatibilityFallbackHandlerEthersContract());
    var CompatibilityFallbackHandler_V1_4_1_Ethers = class extends CompatibilityFallbackHandlerEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CompatibilityFallbackHandler_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/utils/index.js
var require_utils18 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSignerCompatible = exports.isTypedDataSigner = exports.toTxResult = exports.sameString = void 0;
    var abstract_signer_1 = (init_lib6(), __toCommonJS(lib_exports6));
    function sameString(str1, str2) {
      return str1.toLowerCase() === str2.toLowerCase();
    }
    exports.sameString = sameString;
    function toTxResult(transactionResponse, options) {
      return {
        hash: transactionResponse.hash,
        options,
        transactionResponse
      };
    }
    exports.toTxResult = toTxResult;
    function isTypedDataSigner(signer) {
      return signer._signTypedData !== void 0;
    }
    exports.isTypedDataSigner = isTypedDataSigner;
    function isSignerCompatible(signerOrProvider) {
      const candidate = signerOrProvider;
      return typeof candidate.signMessage === "function" && typeof candidate.signTransaction === "function" && candidate._isSigner || candidate instanceof abstract_signer_1.Signer;
    }
    exports.isSignerCompatible = isSignerCompatible;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CreateCall/CreateCallEthersContract.js
var require_CreateCallEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CreateCall/CreateCallEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var CreateCallEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
      async performCreate2(value, deploymentData, salt, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("performCreate2", [value, deploymentData, salt], {
            ...options
          });
        }
        const txResponse = await this.contract.performCreate2(value, deploymentData, salt, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async performCreate(value, deploymentData, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("performCreate", [value, deploymentData], {
            ...options
          });
        }
        const txResponse = await this.contract.performCreate(value, deploymentData, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toString();
      }
    };
    exports.default = CreateCallEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CreateCall/v1.3.0/CreateCallEthersContract_V1_3_0_Ethers.js
var require_CreateCallEthersContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CreateCall/v1.3.0/CreateCallEthersContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CreateCallEthersContract_1 = __importDefault(require_CreateCallEthersContract());
    var CreateCallContract_V1_3_0_Ethers = class extends CreateCallEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CreateCallContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CreateCall/v1.4.1/CreateCallEthersContract_V1_4_1_Ethers.js
var require_CreateCallEthersContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/CreateCall/v1.4.1/CreateCallEthersContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CreateCallEthersContract_1 = __importDefault(require_CreateCallEthersContract());
    var CreateCallContract_V1_4_1_Ethers = class extends CreateCallEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CreateCallContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/MultiSendEthersContract.js
var require_MultiSendEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/MultiSendEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = MultiSendEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/v1.1.1/MultiSendContract_V1_1_1_Ethers.js
var require_MultiSendContract_V1_1_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/v1.1.1/MultiSendContract_V1_1_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    var MultiSendContract_V1_1_1_Ethers = class extends MultiSendEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_1_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/v1.3.0/MultiSendContract_V1_3_0_Ethers.js
var require_MultiSendContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/v1.3.0/MultiSendContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    var MultiSendContract_V1_3_0_Ethers = class extends MultiSendEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/v1.4.1/MultiSendContract_V1_4_1_Ethers.js
var require_MultiSendContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSend/v1.4.1/MultiSendContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    var MultiSendContract_V1_4_1_Ethers = class extends MultiSendEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSendCallOnly/MultiSendCallOnlyEthersContract.js
var require_MultiSendCallOnlyEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSendCallOnly/MultiSendCallOnlyEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = MultiSendCallOnlyEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSendCallOnly/v1.3.0/MultiSendCallOnlyContract_V1_3_0_Ethers.js
var require_MultiSendCallOnlyContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSendCallOnly/v1.3.0/MultiSendCallOnlyContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyEthersContract_1 = __importDefault(require_MultiSendCallOnlyEthersContract());
    var MultiSendCallOnlyContract_V1_3_0_Ethers = class extends MultiSendCallOnlyEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendCallOnlyContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSendCallOnly/v1.4.1/MultiSendCallOnlyContract_V1_4_1_Ethers.js
var require_MultiSendCallOnlyContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/MultiSendCallOnly/v1.4.1/MultiSendCallOnlyContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyEthersContract_1 = __importDefault(require_MultiSendCallOnlyEthersContract());
    var MultiSendCallOnlyContract_V1_4_1_Ethers = class extends MultiSendCallOnlyEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendCallOnlyContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/utils/constants.js
var require_constants4 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SENTINEL_ADDRESS = exports.EMPTY_DATA = exports.ZERO_ADDRESS = void 0;
    exports.ZERO_ADDRESS = `0x${"0".repeat(40)}`;
    exports.EMPTY_DATA = "0x";
    exports.SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/SafeContractEthers.js
var require_SafeContractEthers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/SafeContractEthers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var SafeContractEthers = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      async getVersion() {
        return await this.contract.VERSION();
      }
      getAddress() {
        return this.contract.address;
      }
      async getNonce() {
        return (await this.contract.nonce()).toNumber();
      }
      async getThreshold() {
        return (await this.contract.getThreshold()).toNumber();
      }
      async getOwners() {
        return this.contract.getOwners();
      }
      async isOwner(address) {
        return this.contract.isOwner(address);
      }
      async getTransactionHash(safeTransactionData) {
        return this.contract.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce);
      }
      async approvedHashes(ownerAddress, hash) {
        return this.contract.approvedHashes(ownerAddress, hash);
      }
      async approveHash(hash, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("approveHash", [hash], { ...options });
        }
        const txResponse = await this.contract.approveHash(hash, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async isValidTransaction(safeTransaction, options) {
        let isTxValid = false;
        try {
          if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas("execTransaction", [
              safeTransaction.data.to,
              safeTransaction.data.value,
              safeTransaction.data.data,
              safeTransaction.data.operation,
              safeTransaction.data.safeTxGas,
              safeTransaction.data.baseGas,
              safeTransaction.data.gasPrice,
              safeTransaction.data.gasToken,
              safeTransaction.data.refundReceiver,
              safeTransaction.encodedSignatures()
            ], {
              ...options
            });
          }
          isTxValid = await this.contract.callStatic.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        } catch {
        }
        return isTxValid;
      }
      async execTransaction(safeTransaction, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("execTransaction", [
            safeTransaction.data.to,
            safeTransaction.data.value,
            safeTransaction.data.data,
            safeTransaction.data.operation,
            safeTransaction.data.safeTxGas,
            safeTransaction.data.baseGas,
            safeTransaction.data.gasPrice,
            safeTransaction.data.gasToken,
            safeTransaction.data.refundReceiver,
            safeTransaction.encodedSignatures()
          ], {
            ...options
          });
        }
        const txResponse = await this.contract.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async estimateGas(methodName, params, options) {
        const a = (await this.contract.estimateGas[methodName](...params, options)).toString();
        return a;
      }
    };
    exports.default = SafeContractEthers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.0.0/SafeContract_V1_0_0_Ethers.js
var require_SafeContract_V1_0_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.0.0/SafeContract_V1_0_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants4();
    var SafeContractEthers_1 = __importDefault(require_SafeContractEthers());
    var SafeContract_V1_0_0_Ethers = class extends SafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.getModules();
      }
      async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
      }
    };
    exports.default = SafeContract_V1_0_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.1.1/SafeContract_V1_1_1_Ethers.js
var require_SafeContract_V1_1_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.1.1/SafeContract_V1_1_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants4();
    var SafeContractEthers_1 = __importDefault(require_SafeContractEthers());
    var SafeContract_V1_1_1_Ethers = class extends SafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.getModules();
      }
      async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
      }
    };
    exports.default = SafeContract_V1_1_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.2.0/SafeContract_V1_2_0_Ethers.js
var require_SafeContract_V1_2_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.2.0/SafeContract_V1_2_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants4();
    var SafeContractEthers_1 = __importDefault(require_SafeContractEthers());
    var SafeContract_V1_2_0_Ethers = class extends SafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.getModules();
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
      }
    };
    exports.default = SafeContract_V1_2_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.3.0/SafeContract_V1_3_0_Ethers.js
var require_SafeContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.3.0/SafeContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants4();
    var SafeContractEthers_1 = __importDefault(require_SafeContractEthers());
    var SafeContract_V1_3_0_Ethers = class extends SafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        const { array } = await this.contract.getModulesPaginated(constants_1.SENTINEL_ADDRESS, 10);
        return array;
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
      }
    };
    exports.default = SafeContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.4.1/SafeContract_V1_4_1_Ethers.js
var require_SafeContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/Safe/v1.4.1/SafeContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants4();
    var SafeContractEthers_1 = __importDefault(require_SafeContractEthers());
    var SafeContract_V1_4_1_Ethers = class extends SafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        const { array } = await this.contract.getModulesPaginated(constants_1.SENTINEL_ADDRESS, 10);
        return array;
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
      }
    };
    exports.default = SafeContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/SafeProxyFactoryEthersContract.js
var require_SafeProxyFactoryEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/SafeProxyFactoryEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var SafeProxyFactoryEthersContract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.address;
      }
      async proxyCreationCode() {
        return this.contract.proxyCreationCode();
      }
      async createProxy({ safeMasterCopyAddress, initializer, saltNonce, options, callback }) {
        if (bignumber_1.BigNumber.from(saltNonce).lt(0))
          throw new Error("saltNonce must be greater than or equal to 0");
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("createProxyWithNonce", [safeMasterCopyAddress, initializer, saltNonce], {
            ...options
          });
        }
        const proxyAddress = this.contract.createProxyWithNonce(safeMasterCopyAddress, initializer, saltNonce, options).then(async (txResponse) => {
          var _a;
          if (callback) {
            callback(txResponse.hash);
          }
          const txReceipt = await txResponse.wait();
          const proxyCreationEvent = (_a = txReceipt == null ? void 0 : txReceipt.events) == null ? void 0 : _a.find(({ event }) => event === "ProxyCreation");
          if (!proxyCreationEvent || !proxyCreationEvent.args) {
            throw new Error("SafeProxy was not deployed correctly");
          }
          const proxyAddress2 = proxyCreationEvent.args[0];
          return proxyAddress2;
        });
        return proxyAddress;
      }
      encode(methodName, params) {
        return this.contract.interface.encodeFunctionData(methodName, params);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toString();
      }
    };
    exports.default = SafeProxyFactoryEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.0.0/SafeProxyFactoryContract_V1_0_0_Ethers.js
var require_SafeProxyFactoryContract_V1_0_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.0.0/SafeProxyFactoryContract_V1_0_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryEthersContract_1 = __importDefault(require_SafeProxyFactoryEthersContract());
    var SafeProxyFactoryContract_V1_0_0_Ethers = class extends SafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_0_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.1.1/SafeProxyFactoryContract_V1_1_1_Ethers.js
var require_SafeProxyFactoryContract_V1_1_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.1.1/SafeProxyFactoryContract_V1_1_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryEthersContract_1 = __importDefault(require_SafeProxyFactoryEthersContract());
    var SafeProxyFactoryContract_V1_1_1_Ethers = class extends SafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_1_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.3.0/SafeProxyFactoryContract_V1_3_0_Ethers.js
var require_SafeProxyFactoryContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.3.0/SafeProxyFactoryContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryEthersContract_1 = __importDefault(require_SafeProxyFactoryEthersContract());
    var SafeProxyFactoryContract_V1_3_0_Ethers = class extends SafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.4.1/SafeProxyFactoryContract_V1_4_1_Ethers.js
var require_SafeProxyFactoryContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SafeProxyFactory/v1.4.1/SafeProxyFactoryContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryEthersContract_1 = __importDefault(require_SafeProxyFactoryEthersContract());
    var SafeProxyFactoryContract_V1_4_1_Ethers = class extends SafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SignMessageLib/SignMessageLibEthersContract.js
var require_SignMessageLibEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SignMessageLib/SignMessageLibEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var SignMessageLibEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
      async signMessage(data, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("signMessage", [data], { ...options });
        }
        const txResponse = await this.contract.signMessage(data, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getMessageHash(message) {
        return this.contract.getMessageHash(message);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toString();
      }
    };
    exports.default = SignMessageLibEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SignMessageLib/v1.3.0/SignMessageLibContract_V1_3_0_Ethers.js
var require_SignMessageLibContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SignMessageLib/v1.3.0/SignMessageLibContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SignMessageLibEthersContract_1 = __importDefault(require_SignMessageLibEthersContract());
    var SignMessageLibContract_V1_3_0_Ethers = class extends SignMessageLibEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SignMessageLibContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SignMessageLib/v1.4.1/SignMessageLibContract_V1_4_1_Ethers.js
var require_SignMessageLibContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SignMessageLib/v1.4.1/SignMessageLibContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SignMessageLibEthersContract_1 = __importDefault(require_SignMessageLibEthersContract());
    var SignMessageLibContract_V1_4_1_Ethers = class extends SignMessageLibEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SignMessageLibContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SimulateTxAccessor/SimulateTxAccessorEthersContract.js
var require_SimulateTxAccessorEthersContract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SimulateTxAccessor/SimulateTxAccessorEthersContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SimulateTxAccessorEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = SimulateTxAccessorEthersContract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SimulateTxAccessor/v1.3.0/SimulateTxAccessorContract_V1_3_0_Ethers.js
var require_SimulateTxAccessorContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SimulateTxAccessor/v1.3.0/SimulateTxAccessorContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SimulateTxAccessorEthersContract_1 = __importDefault(require_SimulateTxAccessorEthersContract());
    var SimulateTxAccessorContract_V1_3_0_Ethers = class extends SimulateTxAccessorEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SimulateTxAccessorContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SimulateTxAccessor/v1.4.1/SimulateTxAccessorContract_V1_4_1_Ethers.js
var require_SimulateTxAccessorContract_V1_4_1_Ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/SimulateTxAccessor/v1.4.1/SimulateTxAccessorContract_V1_4_1_Ethers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SimulateTxAccessorEthersContract_1 = __importDefault(require_SimulateTxAccessorEthersContract());
    var SimulateTxAccessorContract_V1_4_1_Ethers = class extends SimulateTxAccessorEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SimulateTxAccessorContract_V1_4_1_Ethers;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/contractInstancesEthers.js
var require_contractInstancesEthers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/contracts/contractInstancesEthers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSimulateTxAccessorContractInstance = exports.getCreateCallContractInstance = exports.getSignMessageLibContractInstance = exports.getSafeProxyFactoryContractInstance = exports.getMultiSendCallOnlyContractInstance = exports.getMultiSendContractInstance = exports.getCompatibilityFallbackHandlerContractInstance = exports.getSafeContractInstance = void 0;
    var Gnosis_safe__factory_1 = require_Gnosis_safe_factory();
    var Proxy_factory__factory_1 = require_Proxy_factory_factory();
    var Gnosis_safe__factory_2 = require_Gnosis_safe_factory2();
    var Multi_send__factory_1 = require_Multi_send_factory();
    var Proxy_factory__factory_2 = require_Proxy_factory_factory2();
    var Gnosis_safe__factory_3 = require_Gnosis_safe_factory3();
    var Compatibility_fallback_handler__factory_1 = require_Compatibility_fallback_handler_factory();
    var Create_call__factory_1 = require_Create_call_factory();
    var Gnosis_safe__factory_4 = require_Gnosis_safe_factory4();
    var Multi_send__factory_2 = require_Multi_send_factory2();
    var Multi_send_call_only__factory_1 = require_Multi_send_call_only_factory();
    var Proxy_factory__factory_3 = require_Proxy_factory_factory3();
    var Sign_message_lib__factory_1 = require_Sign_message_lib_factory();
    var Simulate_tx_accessor__factory_1 = require_Simulate_tx_accessor_factory();
    var Compatibility_fallback_handler__factory_2 = require_Compatibility_fallback_handler_factory2();
    var Create_call__factory_2 = require_Create_call_factory2();
    var Multi_send__factory_3 = require_Multi_send_factory3();
    var Multi_send_call_only__factory_2 = require_Multi_send_call_only_factory2();
    var Safe__factory_1 = require_Safe_factory();
    var Safe_proxy_factory__factory_1 = require_Safe_proxy_factory_factory();
    var Sign_message_lib__factory_2 = require_Sign_message_lib_factory2();
    var Simulate_tx_accessor__factory_2 = require_Simulate_tx_accessor_factory2();
    var CompatibilityFallbackHandler_V1_3_0_Ethers_1 = __importDefault(require_CompatibilityFallbackHandler_V1_3_0_Ethers());
    var CompatibilityFallbackHandler_V1_4_1_Ethers_1 = __importDefault(require_CompatibilityFallbackHandler_V1_4_1_Ethers());
    var CreateCallEthersContract_V1_3_0_Ethers_1 = __importDefault(require_CreateCallEthersContract_V1_3_0_Ethers());
    var CreateCallEthersContract_V1_4_1_Ethers_1 = __importDefault(require_CreateCallEthersContract_V1_4_1_Ethers());
    var MultiSendContract_V1_1_1_Ethers_1 = __importDefault(require_MultiSendContract_V1_1_1_Ethers());
    var MultiSendContract_V1_3_0_Ethers_1 = __importDefault(require_MultiSendContract_V1_3_0_Ethers());
    var MultiSendContract_V1_4_1_Ethers_1 = __importDefault(require_MultiSendContract_V1_4_1_Ethers());
    var MultiSendCallOnlyContract_V1_3_0_Ethers_1 = __importDefault(require_MultiSendCallOnlyContract_V1_3_0_Ethers());
    var MultiSendCallOnlyContract_V1_4_1_Ethers_1 = __importDefault(require_MultiSendCallOnlyContract_V1_4_1_Ethers());
    var SafeContract_V1_0_0_Ethers_1 = __importDefault(require_SafeContract_V1_0_0_Ethers());
    var SafeContract_V1_1_1_Ethers_1 = __importDefault(require_SafeContract_V1_1_1_Ethers());
    var SafeContract_V1_2_0_Ethers_1 = __importDefault(require_SafeContract_V1_2_0_Ethers());
    var SafeContract_V1_3_0_Ethers_1 = __importDefault(require_SafeContract_V1_3_0_Ethers());
    var SafeContract_V1_4_1_Ethers_1 = __importDefault(require_SafeContract_V1_4_1_Ethers());
    var SafeProxyFactoryContract_V1_0_0_Ethers_1 = __importDefault(require_SafeProxyFactoryContract_V1_0_0_Ethers());
    var SafeProxyFactoryContract_V1_1_1_Ethers_1 = __importDefault(require_SafeProxyFactoryContract_V1_1_1_Ethers());
    var SafeProxyFactoryContract_V1_3_0_Ethers_1 = __importDefault(require_SafeProxyFactoryContract_V1_3_0_Ethers());
    var SafeProxyFactoryContract_V1_4_1_Ethers_1 = __importDefault(require_SafeProxyFactoryContract_V1_4_1_Ethers());
    var SignMessageLibContract_V1_3_0_Ethers_1 = __importDefault(require_SignMessageLibContract_V1_3_0_Ethers());
    var SignMessageLibContract_V1_4_1_Ethers_1 = __importDefault(require_SignMessageLibContract_V1_4_1_Ethers());
    var SimulateTxAccessorContract_V1_3_0_Ethers_1 = __importDefault(require_SimulateTxAccessorContract_V1_3_0_Ethers());
    var SimulateTxAccessorContract_V1_4_1_Ethers_1 = __importDefault(require_SimulateTxAccessorContract_V1_4_1_Ethers());
    function getSafeContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let safeContract;
      switch (safeVersion) {
        case "1.4.1":
          safeContract = Safe__factory_1.Safe__factory.connect(contractAddress, signerOrProvider);
          return new SafeContract_V1_4_1_Ethers_1.default(safeContract);
        case "1.3.0":
          safeContract = Gnosis_safe__factory_4.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new SafeContract_V1_3_0_Ethers_1.default(safeContract);
        case "1.2.0":
          safeContract = Gnosis_safe__factory_3.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new SafeContract_V1_2_0_Ethers_1.default(safeContract);
        case "1.1.1":
          safeContract = Gnosis_safe__factory_2.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new SafeContract_V1_1_1_Ethers_1.default(safeContract);
        case "1.0.0":
          safeContract = Gnosis_safe__factory_1.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new SafeContract_V1_0_0_Ethers_1.default(safeContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSafeContractInstance = getSafeContractInstance;
    function getCompatibilityFallbackHandlerContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let compatibilityFallbackHandlerContract;
      switch (safeVersion) {
        case "1.4.1":
          compatibilityFallbackHandlerContract = Compatibility_fallback_handler__factory_2.Compatibility_fallback_handler__factory.connect(contractAddress, signerOrProvider);
          return new CompatibilityFallbackHandler_V1_4_1_Ethers_1.default(compatibilityFallbackHandlerContract);
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
          compatibilityFallbackHandlerContract = Compatibility_fallback_handler__factory_1.Compatibility_fallback_handler__factory.connect(contractAddress, signerOrProvider);
          return new CompatibilityFallbackHandler_V1_3_0_Ethers_1.default(compatibilityFallbackHandlerContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getCompatibilityFallbackHandlerContractInstance = getCompatibilityFallbackHandlerContractInstance;
    function getMultiSendContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let multiSendContract;
      switch (safeVersion) {
        case "1.4.1":
          multiSendContract = Multi_send__factory_3.Multi_send__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendContract_V1_4_1_Ethers_1.default(multiSendContract);
        case "1.3.0":
          multiSendContract = Multi_send__factory_2.Multi_send__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendContract_V1_3_0_Ethers_1.default(multiSendContract);
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          multiSendContract = Multi_send__factory_1.Multi_send__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendContract_V1_1_1_Ethers_1.default(multiSendContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getMultiSendContractInstance = getMultiSendContractInstance;
    function getMultiSendCallOnlyContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let multiSendCallOnlyContract;
      switch (safeVersion) {
        case "1.4.1":
          multiSendCallOnlyContract = Multi_send_call_only__factory_2.Multi_send_call_only__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendCallOnlyContract_V1_4_1_Ethers_1.default(multiSendCallOnlyContract);
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          multiSendCallOnlyContract = Multi_send_call_only__factory_1.Multi_send_call_only__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendCallOnlyContract_V1_3_0_Ethers_1.default(multiSendCallOnlyContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getMultiSendCallOnlyContractInstance = getMultiSendCallOnlyContractInstance;
    function getSafeProxyFactoryContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let safeProxyFactoryContract;
      switch (safeVersion) {
        case "1.4.1":
          safeProxyFactoryContract = Safe_proxy_factory__factory_1.Safe_proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new SafeProxyFactoryContract_V1_4_1_Ethers_1.default(safeProxyFactoryContract);
        case "1.3.0":
          safeProxyFactoryContract = Proxy_factory__factory_3.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new SafeProxyFactoryContract_V1_3_0_Ethers_1.default(safeProxyFactoryContract);
        case "1.2.0":
        case "1.1.1":
          safeProxyFactoryContract = Proxy_factory__factory_2.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new SafeProxyFactoryContract_V1_1_1_Ethers_1.default(safeProxyFactoryContract);
        case "1.0.0":
          safeProxyFactoryContract = Proxy_factory__factory_1.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new SafeProxyFactoryContract_V1_0_0_Ethers_1.default(safeProxyFactoryContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSafeProxyFactoryContractInstance = getSafeProxyFactoryContractInstance;
    function getSignMessageLibContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let signMessageLibContract;
      switch (safeVersion) {
        case "1.4.1":
          signMessageLibContract = Sign_message_lib__factory_2.Sign_message_lib__factory.connect(contractAddress, signerOrProvider);
          return new SignMessageLibContract_V1_4_1_Ethers_1.default(signMessageLibContract);
        case "1.3.0":
          signMessageLibContract = Sign_message_lib__factory_1.Sign_message_lib__factory.connect(contractAddress, signerOrProvider);
          return new SignMessageLibContract_V1_3_0_Ethers_1.default(signMessageLibContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSignMessageLibContractInstance = getSignMessageLibContractInstance;
    function getCreateCallContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let createCallContract;
      switch (safeVersion) {
        case "1.4.1":
          createCallContract = Create_call__factory_2.Create_call__factory.connect(contractAddress, signerOrProvider);
          return new CreateCallEthersContract_V1_4_1_Ethers_1.default(createCallContract);
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          createCallContract = Create_call__factory_1.Create_call__factory.connect(contractAddress, signerOrProvider);
          return new CreateCallEthersContract_V1_3_0_Ethers_1.default(createCallContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getCreateCallContractInstance = getCreateCallContractInstance;
    function getSimulateTxAccessorContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let simulateTxAccessorContract;
      switch (safeVersion) {
        case "1.4.1":
          simulateTxAccessorContract = Simulate_tx_accessor__factory_2.Simulate_tx_accessor__factory.connect(contractAddress, signerOrProvider);
          return new SimulateTxAccessorContract_V1_4_1_Ethers_1.default(simulateTxAccessorContract);
        case "1.3.0":
          simulateTxAccessorContract = Simulate_tx_accessor__factory_1.Simulate_tx_accessor__factory.connect(contractAddress, signerOrProvider);
          return new SimulateTxAccessorContract_V1_3_0_Ethers_1.default(simulateTxAccessorContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSimulateTxAccessorContractInstance = getSimulateTxAccessorContractInstance;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/EthersAdapter.js
var require_EthersAdapter = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/EthersAdapter.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _EthersAdapter_ethers;
    var _EthersAdapter_signer;
    var _EthersAdapter_provider;
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var utils_1 = require_utils17();
    var contractInstancesEthers_1 = require_contractInstancesEthers();
    var utils_2 = require_utils18();
    var EthersAdapter2 = class {
      constructor({ ethers, signerOrProvider }) {
        _EthersAdapter_ethers.set(this, void 0);
        _EthersAdapter_signer.set(this, void 0);
        _EthersAdapter_provider.set(this, void 0);
        if (!ethers) {
          throw new Error("ethers property missing from options");
        }
        __classPrivateFieldSet(this, _EthersAdapter_ethers, ethers, "f");
        const isSigner = (0, utils_2.isSignerCompatible)(signerOrProvider);
        if (isSigner) {
          const signer = signerOrProvider;
          if (!signer.provider) {
            throw new Error("Signer must be connected to a provider");
          }
          __classPrivateFieldSet(this, _EthersAdapter_provider, signer.provider, "f");
          __classPrivateFieldSet(this, _EthersAdapter_signer, signer, "f");
        } else {
          __classPrivateFieldSet(this, _EthersAdapter_provider, signerOrProvider, "f");
        }
      }
      getProvider() {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
      }
      getSigner() {
        return __classPrivateFieldGet(this, _EthersAdapter_signer, "f");
      }
      isAddress(address) {
        return __classPrivateFieldGet(this, _EthersAdapter_ethers, "f").utils.isAddress(address);
      }
      async getEip3770Address(fullAddress) {
        const chainId = await this.getChainId();
        return (0, utils_1.validateEip3770Address)(fullAddress, chainId);
      }
      async getBalance(address, blockTag) {
        return bignumber_1.BigNumber.from(await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getBalance(address, blockTag));
      }
      async getNonce(address, blockTag) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getTransactionCount(address, blockTag);
      }
      async getChainId() {
        return (await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getNetwork()).chainId;
      }
      getChecksummedAddress(address) {
        return __classPrivateFieldGet(this, _EthersAdapter_ethers, "f").utils.getAddress(address);
      }
      async getSafeContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SafeProxy contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSafeContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getSafeProxyFactoryContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SafeProxyFactory contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSafeProxyFactoryContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getMultiSendContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid MultiSend contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getMultiSendContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getMultiSendCallOnlyContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid MultiSendCallOnly contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getMultiSendCallOnlyContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getCompatibilityFallbackHandlerContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid CompatibilityFallbackHandler contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getCompatibilityFallbackHandlerContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getSignMessageLibContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SignMessageLib contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSignMessageLibContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getCreateCallContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid CreateCall contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getCreateCallContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getSimulateTxAccessorContract({ safeVersion, singletonDeployment, customContractAddress }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SimulateTxAccessor contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSimulateTxAccessorContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getContractCode(address, blockTag) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getCode(address, blockTag);
      }
      async isContractDeployed(address, blockTag) {
        const contractCode = await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getCode(address, blockTag);
        return contractCode !== "0x";
      }
      async getStorageAt(address, position) {
        const content = await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getStorageAt(address, position);
        const decodedContent = this.decodeParameters(["address"], content);
        return decodedContent[0];
      }
      async getTransaction(transactionHash) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getTransaction(transactionHash);
      }
      async getSignerAddress() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _EthersAdapter_signer, "f")) == null ? void 0 : _a.getAddress();
      }
      signMessage(message) {
        if (!__classPrivateFieldGet(this, _EthersAdapter_signer, "f")) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const messageArray = __classPrivateFieldGet(this, _EthersAdapter_ethers, "f").utils.arrayify(message);
        return __classPrivateFieldGet(this, _EthersAdapter_signer, "f").signMessage(messageArray);
      }
      async signTypedData(safeTransactionEIP712Args) {
        if (!__classPrivateFieldGet(this, _EthersAdapter_signer, "f")) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        if ((0, utils_2.isTypedDataSigner)(__classPrivateFieldGet(this, _EthersAdapter_signer, "f"))) {
          const typedData = (0, utils_1.generateTypedData)(safeTransactionEIP712Args);
          const signature = await __classPrivateFieldGet(this, _EthersAdapter_signer, "f")._signTypedData(typedData.domain, { SafeTx: typedData.types.SafeTx }, typedData.message);
          return signature;
        }
        throw new Error("The current signer does not implement EIP-712 to sign typed data");
      }
      async estimateGas(transaction) {
        return (await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").estimateGas(transaction)).toString();
      }
      call(transaction, blockTag) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").call(transaction, blockTag);
      }
      encodeParameters(types, values) {
        return new (__classPrivateFieldGet(this, _EthersAdapter_ethers, "f")).utils.AbiCoder().encode(types, values);
      }
      decodeParameters(types, values) {
        return new (__classPrivateFieldGet(this, _EthersAdapter_ethers, "f")).utils.AbiCoder().decode(types, values);
      }
    };
    _EthersAdapter_ethers = /* @__PURE__ */ new WeakMap(), _EthersAdapter_signer = /* @__PURE__ */ new WeakMap(), _EthersAdapter_provider = /* @__PURE__ */ new WeakMap();
    exports.default = EthersAdapter2;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/index.js
var require_ethers = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/ethers/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignMessageLibEthersContract = exports.SafeProxyFactoryEthersContract = exports.SafeContractEthers = exports.MultiSendEthersContract = exports.MultiSendCallOnlyEthersContract = exports.EthersAdapter = exports.CreateCallEthersContract = void 0;
    var EthersAdapter_1 = __importDefault(require_EthersAdapter());
    exports.EthersAdapter = EthersAdapter_1.default;
    var CreateCallEthersContract_1 = __importDefault(require_CreateCallEthersContract());
    exports.CreateCallEthersContract = CreateCallEthersContract_1.default;
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    exports.MultiSendEthersContract = MultiSendEthersContract_1.default;
    var MultiSendCallOnlyEthersContract_1 = __importDefault(require_MultiSendCallOnlyEthersContract());
    exports.MultiSendCallOnlyEthersContract = MultiSendCallOnlyEthersContract_1.default;
    var SafeContractEthers_1 = __importDefault(require_SafeContractEthers());
    exports.SafeContractEthers = SafeContractEthers_1.default;
    var SafeProxyFactoryEthersContract_1 = __importDefault(require_SafeProxyFactoryEthersContract());
    exports.SafeProxyFactoryEthersContract = SafeProxyFactoryEthersContract_1.default;
    var SignMessageLibEthersContract_1 = __importDefault(require_SignMessageLibEthersContract());
    exports.SignMessageLibEthersContract = SignMessageLibEthersContract_1.default;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CompatibilityFallbackHandler/CompatibilityFallbackHandlerWeb3Contract.js
var require_CompatibilityFallbackHandlerWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CompatibilityFallbackHandler/CompatibilityFallbackHandlerWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
    };
    exports.default = CompatibilityFallbackHandlerWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CompatibilityFallbackHandler/v1.3.0/CompatibilityFallbackHandler_V1_3_0_Web3.js
var require_CompatibilityFallbackHandler_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CompatibilityFallbackHandler/v1.3.0/CompatibilityFallbackHandler_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerWeb3Contract_1 = __importDefault(require_CompatibilityFallbackHandlerWeb3Contract());
    var CompatibilityFallbackHandler_V1_3_0_Web3 = class extends CompatibilityFallbackHandlerWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CompatibilityFallbackHandler_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CompatibilityFallbackHandler/v1.4.1/CompatibilityFallbackHandler_V1_4_1_Web3.js
var require_CompatibilityFallbackHandler_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CompatibilityFallbackHandler/v1.4.1/CompatibilityFallbackHandler_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerWeb3Contract_1 = __importDefault(require_CompatibilityFallbackHandlerWeb3Contract());
    var CompatibilityFallbackHandler_V1_4_1_Web3 = class extends CompatibilityFallbackHandlerWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CompatibilityFallbackHandler_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/utils/index.js
var require_utils19 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTxResult = exports.sameString = void 0;
    function sameString(str1, str2) {
      return str1.toLowerCase() === str2.toLowerCase();
    }
    exports.sameString = sameString;
    async function toTxResult(promiEvent, options) {
      return new Promise((resolve, reject) => promiEvent.once("transactionHash", (hash) => resolve({ hash, promiEvent, options })).catch(reject));
    }
    exports.toTxResult = toTxResult;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CreateCall/CreateCallWeb3Contract.js
var require_CreateCallWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CreateCall/CreateCallWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var CreateCallWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      async performCreate2(value, deploymentData, salt, options) {
        if (options && !options.gas) {
          options.gas = await this.estimateGas("performCreate2", [value, deploymentData, salt], {
            ...options
          });
        }
        const txResponse = this.contract.methods.performCreate2(value, deploymentData, salt).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async performCreate(value, deploymentData, options) {
        if (options && !options.gas) {
          options.gas = await this.estimateGas("performCreate", [value, deploymentData], { ...options });
        }
        const txResponse = this.contract.methods.performCreate(value, deploymentData).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
      }
    };
    exports.default = CreateCallWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CreateCall/v1.3.0/CreateCallEthersContract_V1_3_0_Web3.js
var require_CreateCallEthersContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CreateCall/v1.3.0/CreateCallEthersContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CreateCallWeb3Contract_1 = __importDefault(require_CreateCallWeb3Contract());
    var CreateCallContract_V1_3_0_Web3 = class extends CreateCallWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CreateCallContract_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CreateCall/v1.4.1/CreateCallEthersContract_V1_4_1_Web3.js
var require_CreateCallEthersContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/CreateCall/v1.4.1/CreateCallEthersContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CreateCallWeb3Contract_1 = __importDefault(require_CreateCallWeb3Contract());
    var CreateCallContract_V1_4_1_Web3 = class extends CreateCallWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CreateCallContract_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/MultiSendWeb3Contract.js
var require_MultiSendWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/MultiSendWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
    };
    exports.default = MultiSendWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/v1.1.1/MultiSendContract_V1_1_1_Web3.js
var require_MultiSendContract_V1_1_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/v1.1.1/MultiSendContract_V1_1_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendWeb3Contract_1 = __importDefault(require_MultiSendWeb3Contract());
    var MultiSendContract_V1_1_1_Web3 = class extends MultiSendWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_1_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/v1.3.0/MultiSendContract_V1_3_0_Web3.js
var require_MultiSendContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/v1.3.0/MultiSendContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendWeb3Contract_1 = __importDefault(require_MultiSendWeb3Contract());
    var MultiSendContract_V1_3_0_Web3 = class extends MultiSendWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/v1.4.1/MultiSendContract_V1_4_1_Web3.js
var require_MultiSendContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSend/v1.4.1/MultiSendContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendWeb3Contract_1 = __importDefault(require_MultiSendWeb3Contract());
    var MultiSendContract_V1_4_1_Web3 = class extends MultiSendWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSendCallOnly/MultiSendCallOnlyWeb3Contract.js
var require_MultiSendCallOnlyWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSendCallOnly/MultiSendCallOnlyWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
    };
    exports.default = MultiSendCallOnlyWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSendCallOnly/v1.3.0/MultiSendCallOnlyContract_V1_3_0_Web3.js
var require_MultiSendCallOnlyContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSendCallOnly/v1.3.0/MultiSendCallOnlyContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyWeb3Contract_1 = __importDefault(require_MultiSendCallOnlyWeb3Contract());
    var MultiSendCallOnlyContract_V1_3_0_Web3 = class extends MultiSendCallOnlyWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendCallOnlyContract_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSendCallOnly/v1.4.1/MultiSendCallOnlyContract_V1_4_1_Web3.js
var require_MultiSendCallOnlyContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/MultiSendCallOnly/v1.4.1/MultiSendCallOnlyContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyWeb3Contract_1 = __importDefault(require_MultiSendCallOnlyWeb3Contract());
    var MultiSendCallOnlyContract_V1_4_1_Web3 = class extends MultiSendCallOnlyWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendCallOnlyContract_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/utils/constants.js
var require_constants5 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SENTINEL_ADDRESS = exports.EMPTY_DATA = exports.ZERO_ADDRESS = void 0;
    exports.ZERO_ADDRESS = `0x${"0".repeat(40)}`;
    exports.EMPTY_DATA = "0x";
    exports.SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/SafeContractWeb3.js
var require_SafeContractWeb3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/SafeContractWeb3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var utils_1 = require_utils19();
    var SafeContractWeb3 = class {
      constructor(contract) {
        this.contract = contract;
      }
      async getVersion() {
        return await this.contract.methods.VERSION().call();
      }
      getAddress() {
        return this.contract.options.address;
      }
      async getNonce() {
        return Number(await this.contract.methods.nonce().call());
      }
      async getThreshold() {
        return Number(await this.contract.methods.getThreshold().call());
      }
      async getOwners() {
        return this.contract.methods.getOwners().call();
      }
      async isOwner(address) {
        return this.contract.methods.isOwner(address).call();
      }
      async getTransactionHash(safeTransactionData) {
        return this.contract.methods.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce).call();
      }
      async approvedHashes(ownerAddress, hash) {
        return bignumber_1.BigNumber.from(await this.contract.methods.approvedHashes(ownerAddress, hash).call());
      }
      async approveHash(hash, options) {
        if (options && !options.gas) {
          options.gas = await this.estimateGas("approveHash", [hash], { ...options });
        }
        const txResponse = this.contract.methods.approveHash(hash).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async isValidTransaction(safeTransaction, options) {
        let isTxValid = false;
        try {
          if (options && !options.gas) {
            options.gas = await this.estimateGas("execTransaction", [
              safeTransaction.data.to,
              safeTransaction.data.value,
              safeTransaction.data.data,
              safeTransaction.data.operation,
              safeTransaction.data.safeTxGas,
              safeTransaction.data.baseGas,
              safeTransaction.data.gasPrice,
              safeTransaction.data.gasToken,
              safeTransaction.data.refundReceiver,
              safeTransaction.encodedSignatures()
            ], {
              ...options
            });
          }
          isTxValid = await this.contract.methods.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures()).call(options);
        } catch {
        }
        return isTxValid;
      }
      async execTransaction(safeTransaction, options) {
        if (options && !options.gas) {
          options.gas = await this.estimateGas("execTransaction", [
            safeTransaction.data.to,
            safeTransaction.data.value,
            safeTransaction.data.data,
            safeTransaction.data.operation,
            safeTransaction.data.safeTxGas,
            safeTransaction.data.baseGas,
            safeTransaction.data.gasPrice,
            safeTransaction.data.gasToken,
            safeTransaction.data.refundReceiver,
            safeTransaction.encodedSignatures()
          ], {
            ...options
          });
        }
        const txResponse = this.contract.methods.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures()).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
      }
    };
    exports.default = SafeContractWeb3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.0.0/SafeContract_V1_0_0_Web3.js
var require_SafeContract_V1_0_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.0.0/SafeContract_V1_0_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var constants_1 = require_constants5();
    var SafeContractWeb3_1 = __importDefault(require_SafeContractWeb3());
    var SafeContract_V1_0_0_Web3 = class extends SafeContractWeb3_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
          options.gas = await this.estimateGas("setup", [owners, threshold, to, data, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = this.contract.methods.setup(owners, threshold, to, data, paymentToken, payment, paymentReceiver).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.methods.getModules().call();
      }
      async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
      }
    };
    exports.default = SafeContract_V1_0_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.1.1/SafeContract_V1_1_1_Web3.js
var require_SafeContract_V1_1_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.1.1/SafeContract_V1_1_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var constants_1 = require_constants5();
    var SafeContractWeb3_1 = __importDefault(require_SafeContractWeb3());
    var SafeContract_V1_1_1_Web3 = class extends SafeContractWeb3_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
          options.gas = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = this.contract.methods.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.methods.getModules().call();
      }
      async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
      }
    };
    exports.default = SafeContract_V1_1_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.2.0/SafeContract_V1_2_0_Web3.js
var require_SafeContract_V1_2_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.2.0/SafeContract_V1_2_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var constants_1 = require_constants5();
    var SafeContractWeb3_1 = __importDefault(require_SafeContractWeb3());
    var SafeContract_V1_2_0_Web3 = class extends SafeContractWeb3_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
          options.gas = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = this.contract.methods.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.methods.getModules().call();
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.methods.isModuleEnabled(moduleAddress).call();
      }
    };
    exports.default = SafeContract_V1_2_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.3.0/SafeContract_V1_3_0_Web3.js
var require_SafeContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.3.0/SafeContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var constants_1 = require_constants5();
    var SafeContractWeb3_1 = __importDefault(require_SafeContractWeb3());
    var SafeContract_V1_3_0_Web3 = class extends SafeContractWeb3_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
          options.gas = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = this.contract.methods.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        const { array } = await this.contract.methods.getModulesPaginated(constants_1.SENTINEL_ADDRESS, 10).call();
        return array;
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.methods.isModuleEnabled(moduleAddress).call();
      }
    };
    exports.default = SafeContract_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.4.1/SafeContract_V1_4_1_Web3.js
var require_SafeContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/Safe/v1.4.1/SafeContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var constants_1 = require_constants5();
    var SafeContractWeb3_1 = __importDefault(require_SafeContractWeb3());
    var SafeContract_V1_4_1_Web3 = class extends SafeContractWeb3_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gas) {
          options.gas = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = this.contract.methods.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        const { array } = await this.contract.methods.getModulesPaginated(constants_1.SENTINEL_ADDRESS, 10).call();
        return array;
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.methods.isModuleEnabled(moduleAddress).call();
      }
    };
    exports.default = SafeContract_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/SafeProxyFactoryWeb3Contract.js
var require_SafeProxyFactoryWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/SafeProxyFactoryWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var utils_1 = require_utils19();
    var SafeProxyFactoryWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      async proxyCreationCode() {
        return this.contract.methods.proxyCreationCode().call();
      }
      async createProxy({ safeMasterCopyAddress, initializer, saltNonce, options, callback }) {
        var _a, _b, _c;
        if (bignumber_1.BigNumber.from(saltNonce).lt(0))
          throw new Error("saltNonce must be greater than or equal to 0");
        if (options && !options.gas) {
          options.gas = await this.estimateGas("createProxyWithNonce", [safeMasterCopyAddress, initializer, saltNonce], {
            ...options
          });
        }
        const txResponse = this.contract.methods.createProxyWithNonce(safeMasterCopyAddress, initializer, saltNonce).send(options);
        if (callback) {
          const txResult2 = await (0, utils_1.toTxResult)(txResponse);
          callback(txResult2.hash);
        }
        const txResult = await new Promise((resolve, reject) => txResponse.once("receipt", (receipt) => resolve(receipt)).catch(reject));
        const proxyAddress = (_c = (_b = (_a = txResult.events) == null ? void 0 : _a.ProxyCreation) == null ? void 0 : _b.returnValues) == null ? void 0 : _c.proxy;
        if (!proxyAddress) {
          throw new Error("SafeProxy was not deployed correctly");
        }
        return proxyAddress;
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
      }
    };
    exports.default = SafeProxyFactoryWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.0.0/SafeProxyFactoryContract_V1_0_0_Web3.js
var require_SafeProxyFactoryContract_V1_0_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.0.0/SafeProxyFactoryContract_V1_0_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryWeb3Contract_1 = __importDefault(require_SafeProxyFactoryWeb3Contract());
    var SafeProxyFactoryContract_V1_0_0_Web3 = class extends SafeProxyFactoryWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_0_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.1.1/SafeProxyFactoryContract_V1_1_1_Web3.js
var require_SafeProxyFactoryContract_V1_1_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.1.1/SafeProxyFactoryContract_V1_1_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryWeb3Contract_1 = __importDefault(require_SafeProxyFactoryWeb3Contract());
    var SafeProxyFactoryContract_V1_1_1_Web3 = class extends SafeProxyFactoryWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_1_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.3.0/SafeProxyFactoryContract_V1_3_0_Web3.js
var require_SafeProxyFactoryContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.3.0/SafeProxyFactoryContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryWeb3Contract_1 = __importDefault(require_SafeProxyFactoryWeb3Contract());
    var SafeProxyFactoryContract_V1_3_0_Web3 = class extends SafeProxyFactoryWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.4.1/SafeProxyFactoryContract_V1_4_1_Web3.js
var require_SafeProxyFactoryContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SafeProxyFactory/v1.4.1/SafeProxyFactoryContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SafeProxyFactoryWeb3Contract_1 = __importDefault(require_SafeProxyFactoryWeb3Contract());
    var SafeProxyFactoryContract_V1_4_1_Web3 = class extends SafeProxyFactoryWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SafeProxyFactoryContract_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SignMessageLib/SignMessageLibWeb3Contract.js
var require_SignMessageLibWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SignMessageLib/SignMessageLibWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils19();
    var SignMessageLibWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      async signMessage(data, options) {
        if (options && !options.gas) {
          options.gas = await this.estimateGas("signMessage", [data], { ...options });
        }
        const txResponse = this.contract.methods.signMessage(data).send(options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getMessageHash(message) {
        return this.contract.methods.getMessageHash(message).call();
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.methods[methodName](...params).estimateGas(options)).toString();
      }
    };
    exports.default = SignMessageLibWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SignMessageLib/v1.3.0/SignMessageLibContract_V1_3_0_Web3.js
var require_SignMessageLibContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SignMessageLib/v1.3.0/SignMessageLibContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SignMessageLibWeb3Contract_1 = __importDefault(require_SignMessageLibWeb3Contract());
    var SignMessageLibContract_V1_3_0_Web3 = class extends SignMessageLibWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SignMessageLibContract_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SignMessageLib/v1.4.1/SignMessageLibContract_V1_4_1_Web3.js
var require_SignMessageLibContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SignMessageLib/v1.4.1/SignMessageLibContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SignMessageLibWeb3Contract_1 = __importDefault(require_SignMessageLibWeb3Contract());
    var SignMessageLibContract_V1_4_1_Web3 = class extends SignMessageLibWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SignMessageLibContract_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SimulateTxAccessor/SimulateTxAccessorWeb3Contract.js
var require_SimulateTxAccessorWeb3Contract = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SimulateTxAccessor/SimulateTxAccessorWeb3Contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SimulateTxAccessorWeb3Contract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.options.address;
      }
      encode(methodName, params) {
        return this.contract.methods[methodName](...params).encodeABI();
      }
    };
    exports.default = SimulateTxAccessorWeb3Contract;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SimulateTxAccessor/v1.3.0/SimulateTxAccessorContract_V1_3_0_Web3.js
var require_SimulateTxAccessorContract_V1_3_0_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SimulateTxAccessor/v1.3.0/SimulateTxAccessorContract_V1_3_0_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SimulateTxAccessorWeb3Contract_1 = __importDefault(require_SimulateTxAccessorWeb3Contract());
    var SimulateTxAccessor_V1_3_0_Web3 = class extends SimulateTxAccessorWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SimulateTxAccessor_V1_3_0_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SimulateTxAccessor/v1.4.1/SimulateTxAccessorContract_V1_4_1_Web3.js
var require_SimulateTxAccessorContract_V1_4_1_Web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/SimulateTxAccessor/v1.4.1/SimulateTxAccessorContract_V1_4_1_Web3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SimulateTxAccessorWeb3Contract_1 = __importDefault(require_SimulateTxAccessorWeb3Contract());
    var SimulateTxAccessor_V1_4_1_Web3 = class extends SimulateTxAccessorWeb3Contract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SimulateTxAccessor_V1_4_1_Web3;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/contractInstancesWeb3.js
var require_contractInstancesWeb3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/contracts/contractInstancesWeb3.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSimulateTxAccessorContractInstance = exports.getCreateCallContractInstance = exports.getSignMessageLibContractInstance = exports.getSafeProxyFactoryContractInstance = exports.getMultiSendCallOnlyContractInstance = exports.getMultiSendContractInstance = exports.getCompatibilityFallbackHandlerContractInstance = exports.getSafeContractInstance = void 0;
    var CompatibilityFallbackHandler_V1_3_0_Web3_1 = __importDefault(require_CompatibilityFallbackHandler_V1_3_0_Web3());
    var CompatibilityFallbackHandler_V1_4_1_Web3_1 = __importDefault(require_CompatibilityFallbackHandler_V1_4_1_Web3());
    var CreateCallEthersContract_V1_3_0_Web3_1 = __importDefault(require_CreateCallEthersContract_V1_3_0_Web3());
    var CreateCallEthersContract_V1_4_1_Web3_1 = __importDefault(require_CreateCallEthersContract_V1_4_1_Web3());
    var MultiSendContract_V1_1_1_Web3_1 = __importDefault(require_MultiSendContract_V1_1_1_Web3());
    var MultiSendContract_V1_3_0_Web3_1 = __importDefault(require_MultiSendContract_V1_3_0_Web3());
    var MultiSendContract_V1_4_1_Web3_1 = __importDefault(require_MultiSendContract_V1_4_1_Web3());
    var MultiSendCallOnlyContract_V1_3_0_Web3_1 = __importDefault(require_MultiSendCallOnlyContract_V1_3_0_Web3());
    var MultiSendCallOnlyContract_V1_4_1_Web3_1 = __importDefault(require_MultiSendCallOnlyContract_V1_4_1_Web3());
    var SafeContract_V1_0_0_Web3_1 = __importDefault(require_SafeContract_V1_0_0_Web3());
    var SafeContract_V1_1_1_Web3_1 = __importDefault(require_SafeContract_V1_1_1_Web3());
    var SafeContract_V1_2_0_Web3_1 = __importDefault(require_SafeContract_V1_2_0_Web3());
    var SafeContract_V1_3_0_Web3_1 = __importDefault(require_SafeContract_V1_3_0_Web3());
    var SafeContract_V1_4_1_Web3_1 = __importDefault(require_SafeContract_V1_4_1_Web3());
    var SafeProxyFactoryContract_V1_0_0_Web3_1 = __importDefault(require_SafeProxyFactoryContract_V1_0_0_Web3());
    var SafeProxyFactoryContract_V1_1_1_Web3_1 = __importDefault(require_SafeProxyFactoryContract_V1_1_1_Web3());
    var SafeProxyFactoryContract_V1_3_0_Web3_1 = __importDefault(require_SafeProxyFactoryContract_V1_3_0_Web3());
    var SafeProxyFactoryContract_V1_4_1_Web3_1 = __importDefault(require_SafeProxyFactoryContract_V1_4_1_Web3());
    var SignMessageLibContract_V1_3_0_Web3_1 = __importDefault(require_SignMessageLibContract_V1_3_0_Web3());
    var SignMessageLibContract_V1_4_1_Web3_1 = __importDefault(require_SignMessageLibContract_V1_4_1_Web3());
    var SimulateTxAccessorContract_V1_3_0_Web3_1 = __importDefault(require_SimulateTxAccessorContract_V1_3_0_Web3());
    var SimulateTxAccessorContract_V1_4_1_Web3_1 = __importDefault(require_SimulateTxAccessorContract_V1_4_1_Web3());
    function getSafeContractInstance(safeVersion, safeContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new SafeContract_V1_4_1_Web3_1.default(safeContract);
        case "1.3.0":
          return new SafeContract_V1_3_0_Web3_1.default(safeContract);
        case "1.2.0":
          return new SafeContract_V1_2_0_Web3_1.default(safeContract);
        case "1.1.1":
          return new SafeContract_V1_1_1_Web3_1.default(safeContract);
        case "1.0.0":
          return new SafeContract_V1_0_0_Web3_1.default(safeContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSafeContractInstance = getSafeContractInstance;
    function getCompatibilityFallbackHandlerContractInstance(safeVersion, compatibilityFallbackhandlerContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new CompatibilityFallbackHandler_V1_4_1_Web3_1.default(compatibilityFallbackhandlerContract);
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
          return new CompatibilityFallbackHandler_V1_3_0_Web3_1.default(compatibilityFallbackhandlerContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getCompatibilityFallbackHandlerContractInstance = getCompatibilityFallbackHandlerContractInstance;
    function getMultiSendContractInstance(safeVersion, multiSendContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new MultiSendContract_V1_4_1_Web3_1.default(multiSendContract);
        case "1.3.0":
          return new MultiSendContract_V1_3_0_Web3_1.default(multiSendContract);
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          return new MultiSendContract_V1_1_1_Web3_1.default(multiSendContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getMultiSendContractInstance = getMultiSendContractInstance;
    function getMultiSendCallOnlyContractInstance(safeVersion, multiSendCallOnlyContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new MultiSendCallOnlyContract_V1_4_1_Web3_1.default(multiSendCallOnlyContract);
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          return new MultiSendCallOnlyContract_V1_3_0_Web3_1.default(multiSendCallOnlyContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getMultiSendCallOnlyContractInstance = getMultiSendCallOnlyContractInstance;
    function getSafeProxyFactoryContractInstance(safeVersion, safeProxyFactoryContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new SafeProxyFactoryContract_V1_4_1_Web3_1.default(safeProxyFactoryContract);
        case "1.3.0":
          return new SafeProxyFactoryContract_V1_3_0_Web3_1.default(safeProxyFactoryContract);
        case "1.2.0":
        case "1.1.1":
          return new SafeProxyFactoryContract_V1_1_1_Web3_1.default(safeProxyFactoryContract);
        case "1.0.0":
          return new SafeProxyFactoryContract_V1_0_0_Web3_1.default(safeProxyFactoryContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSafeProxyFactoryContractInstance = getSafeProxyFactoryContractInstance;
    function getSignMessageLibContractInstance(safeVersion, signMessageLibContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new SignMessageLibContract_V1_4_1_Web3_1.default(signMessageLibContract);
        case "1.3.0":
          return new SignMessageLibContract_V1_3_0_Web3_1.default(signMessageLibContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSignMessageLibContractInstance = getSignMessageLibContractInstance;
    function getCreateCallContractInstance(safeVersion, createCallContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new CreateCallEthersContract_V1_4_1_Web3_1.default(createCallContract);
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          return new CreateCallEthersContract_V1_3_0_Web3_1.default(createCallContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getCreateCallContractInstance = getCreateCallContractInstance;
    function getSimulateTxAccessorContractInstance(safeVersion, simulateTxAccessorContract) {
      switch (safeVersion) {
        case "1.4.1":
          return new SimulateTxAccessorContract_V1_4_1_Web3_1.default(simulateTxAccessorContract);
        case "1.3.0":
          return new SimulateTxAccessorContract_V1_3_0_Web3_1.default(simulateTxAccessorContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSimulateTxAccessorContractInstance = getSimulateTxAccessorContractInstance;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/Web3Adapter.js
var require_Web3Adapter = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/Web3Adapter.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Web3Adapter_web3;
    var _Web3Adapter_signerAddress;
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var utils_1 = require_utils17();
    var contractInstancesWeb3_1 = require_contractInstancesWeb3();
    var Web3Adapter = class {
      constructor({ web3, signerAddress }) {
        _Web3Adapter_web3.set(this, void 0);
        _Web3Adapter_signerAddress.set(this, void 0);
        if (!web3) {
          throw new Error("web3 property missing from options");
        }
        __classPrivateFieldSet(this, _Web3Adapter_web3, web3, "f");
        __classPrivateFieldSet(this, _Web3Adapter_signerAddress, signerAddress, "f");
      }
      isAddress(address) {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").utils.isAddress(address);
      }
      async getEip3770Address(fullAddress) {
        const chainId = await this.getChainId();
        return (0, utils_1.validateEip3770Address)(fullAddress, chainId);
      }
      async getBalance(address, defaultBlock) {
        const balance = defaultBlock ? await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getBalance(address, defaultBlock) : await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getBalance(address);
        return bignumber_1.BigNumber.from(balance);
      }
      async getNonce(address, defaultBlock) {
        const nonce = defaultBlock ? await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getTransactionCount(address, defaultBlock) : await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getTransactionCount(address);
        return nonce;
      }
      async getChainId() {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getChainId();
      }
      getChecksummedAddress(address) {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").utils.toChecksumAddress(address);
      }
      async getSafeContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SafeProxy contract address");
        }
        const safeContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getSafeContractInstance)(safeVersion, safeContract);
      }
      async getSafeProxyFactoryContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SafeProxyFactory contract address");
        }
        const proxyFactoryContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getSafeProxyFactoryContractInstance)(safeVersion, proxyFactoryContract);
      }
      async getMultiSendContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid MultiSend contract address");
        }
        const multiSendContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getMultiSendContractInstance)(safeVersion, multiSendContract);
      }
      async getMultiSendCallOnlyContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid MultiSendCallOnly contract address");
        }
        const multiSendContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getMultiSendCallOnlyContractInstance)(safeVersion, multiSendContract);
      }
      async getCompatibilityFallbackHandlerContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid Compatibility Fallback Handler contract address");
        }
        const multiSendContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getCompatibilityFallbackHandlerContractInstance)(safeVersion, multiSendContract);
      }
      async getSignMessageLibContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SignMessageLib contract address");
        }
        const signMessageLibContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getSignMessageLibContractInstance)(safeVersion, signMessageLibContract);
      }
      async getCreateCallContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid CreateCall contract address");
        }
        const createCallContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getCreateCallContractInstance)(safeVersion, createCallContract);
      }
      async getSimulateTxAccessorContract({ safeVersion, singletonDeployment, customContractAddress, customContractAbi }) {
        const chainId = await this.getChainId();
        const contractAddress = customContractAddress ?? (singletonDeployment == null ? void 0 : singletonDeployment.networkAddresses[chainId]);
        if (!contractAddress) {
          throw new Error("Invalid SimulateTxAccessor contract address");
        }
        const simulateTxAccessorContract = this.getContract(contractAddress, customContractAbi ?? (singletonDeployment == null ? void 0 : singletonDeployment.abi));
        return (0, contractInstancesWeb3_1.getSimulateTxAccessorContractInstance)(safeVersion, simulateTxAccessorContract);
      }
      getContract(address, abi, options) {
        return new (__classPrivateFieldGet(this, _Web3Adapter_web3, "f")).eth.Contract(abi, address, options);
      }
      async getContractCode(address, defaultBlock) {
        const code = defaultBlock ? await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getCode(address, defaultBlock) : await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getCode(address);
        return code;
      }
      async isContractDeployed(address, defaultBlock) {
        const contractCode = await this.getContractCode(address, defaultBlock);
        return contractCode !== "0x";
      }
      async getStorageAt(address, position) {
        const content = await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getStorageAt(address, position);
        const decodedContent = this.decodeParameters(["address"], content);
        return decodedContent[0];
      }
      async getTransaction(transactionHash) {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.getTransaction(transactionHash);
      }
      async getSignerAddress() {
        return __classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f");
      }
      signMessage(message) {
        if (!__classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f")) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.sign(message, __classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f"));
      }
      async signTypedData(safeTransactionEIP712Args, methodVersion) {
        if (!__classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f")) {
          throw new Error("This method requires a signer");
        }
        const typedData = (0, utils_1.generateTypedData)(safeTransactionEIP712Args);
        let method = "eth_signTypedData_v3";
        if (methodVersion === "v4") {
          method = "eth_signTypedData_v4";
        } else if (!methodVersion) {
          method = "eth_signTypedData";
        }
        const jsonTypedData = JSON.stringify(typedData);
        const signedTypedData = {
          jsonrpc: "2.0",
          method,
          params: methodVersion === "v3" || methodVersion === "v4" ? [__classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f"), jsonTypedData] : [jsonTypedData, __classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f")],
          from: __classPrivateFieldGet(this, _Web3Adapter_signerAddress, "f"),
          id: (/* @__PURE__ */ new Date()).getTime()
        };
        return new Promise((resolve, reject) => {
          const provider = __classPrivateFieldGet(this, _Web3Adapter_web3, "f").currentProvider;
          function callback(err, val) {
            if (err) {
              reject(err);
              return;
            }
            if ((val == null ? void 0 : val.result) == null) {
              reject(new Error("EIP-712 is not supported by user's wallet"));
              return;
            }
            resolve(val.result);
          }
          provider.send(signedTypedData, callback);
        });
      }
      async estimateGas(transaction, callback) {
        return (await __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.estimateGas(transaction, callback)).toString();
      }
      call(transaction, defaultBlock) {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.call(transaction, defaultBlock);
      }
      encodeParameters(types, values) {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.abi.encodeParameters(types, values);
      }
      decodeParameters(types, values) {
        return __classPrivateFieldGet(this, _Web3Adapter_web3, "f").eth.abi.decodeParameters(types, values);
      }
    };
    _Web3Adapter_web3 = /* @__PURE__ */ new WeakMap(), _Web3Adapter_signerAddress = /* @__PURE__ */ new WeakMap();
    exports.default = Web3Adapter;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/index.js
var require_web3 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/adapters/web3/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Adapter = exports.SignMessageLibWeb3Contract = exports.SafeProxyFactoryWeb3Contract = exports.SafeContractWeb3 = exports.MultiSendWeb3Contract = exports.MultiSendCallOnlyWeb3Contract = exports.CreateCallWeb3Contract = void 0;
    var Web3Adapter_1 = __importDefault(require_Web3Adapter());
    exports.Web3Adapter = Web3Adapter_1.default;
    var CreateCallWeb3Contract_1 = __importDefault(require_CreateCallWeb3Contract());
    exports.CreateCallWeb3Contract = CreateCallWeb3Contract_1.default;
    var MultiSendWeb3Contract_1 = __importDefault(require_MultiSendWeb3Contract());
    exports.MultiSendWeb3Contract = MultiSendWeb3Contract_1.default;
    var MultiSendCallOnlyWeb3Contract_1 = __importDefault(require_MultiSendCallOnlyWeb3Contract());
    exports.MultiSendCallOnlyWeb3Contract = MultiSendCallOnlyWeb3Contract_1.default;
    var SafeContractWeb3_1 = __importDefault(require_SafeContractWeb3());
    exports.SafeContractWeb3 = SafeContractWeb3_1.default;
    var SafeProxyFactoryWeb3Contract_1 = __importDefault(require_SafeProxyFactoryWeb3Contract());
    exports.SafeProxyFactoryWeb3Contract = SafeProxyFactoryWeb3Contract_1.default;
    var SignMessageLibWeb3Contract_1 = __importDefault(require_SignMessageLibWeb3Contract());
    exports.SignMessageLibWeb3Contract = SignMessageLibWeb3Contract_1.default;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/safeFactory/index.js
var require_safeFactory = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/safeFactory/index.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _SafeFactory_contractNetworks;
    var _SafeFactory_isL1SafeMasterCopy;
    var _SafeFactory_safeVersion;
    var _SafeFactory_ethAdapter;
    var _SafeFactory_safeProxyFactoryContract;
    var _SafeFactory_safeContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var Safe_1 = __importDefault(require_Safe());
    var config_1 = require_config();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    var utils_1 = require_utils8();
    var SafeFactory = class _SafeFactory {
      constructor() {
        _SafeFactory_contractNetworks.set(this, void 0);
        _SafeFactory_isL1SafeMasterCopy.set(this, void 0);
        _SafeFactory_safeVersion.set(this, void 0);
        _SafeFactory_ethAdapter.set(this, void 0);
        _SafeFactory_safeProxyFactoryContract.set(this, void 0);
        _SafeFactory_safeContract.set(this, void 0);
      }
      static async create({ ethAdapter, safeVersion = config_1.DEFAULT_SAFE_VERSION, isL1SafeMasterCopy = false, contractNetworks }) {
        const safeFactorySdk = new _SafeFactory();
        await safeFactorySdk.init({ ethAdapter, safeVersion, isL1SafeMasterCopy, contractNetworks });
        return safeFactorySdk;
      }
      async init({ ethAdapter, safeVersion, isL1SafeMasterCopy, contractNetworks }) {
        __classPrivateFieldSet(this, _SafeFactory_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _SafeFactory_safeVersion, safeVersion, "f");
        __classPrivateFieldSet(this, _SafeFactory_isL1SafeMasterCopy, isL1SafeMasterCopy, "f");
        __classPrivateFieldSet(this, _SafeFactory_contractNetworks, contractNetworks, "f");
        const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
        const customContracts = contractNetworks == null ? void 0 : contractNetworks[chainId];
        __classPrivateFieldSet(this, _SafeFactory_safeProxyFactoryContract, await (0, safeDeploymentContracts_1.getProxyFactoryContract)({
          ethAdapter,
          safeVersion,
          customContracts
        }), "f");
        __classPrivateFieldSet(this, _SafeFactory_safeContract, await (0, safeDeploymentContracts_1.getSafeContract)({
          ethAdapter,
          safeVersion,
          isL1SafeMasterCopy,
          customContracts
        }), "f");
      }
      getEthAdapter() {
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f");
      }
      getSafeVersion() {
        return __classPrivateFieldGet(this, _SafeFactory_safeVersion, "f");
      }
      getAddress() {
        return __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").getAddress();
      }
      async getChainId() {
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
      }
      async predictSafeAddress(safeAccountConfig, saltNonce = utils_1.PREDETERMINED_SALT_NONCE) {
        var _a;
        const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
        const customContracts = (_a = __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")) == null ? void 0 : _a[chainId];
        const safeVersion = __classPrivateFieldGet(this, _SafeFactory_safeVersion, "f");
        const safeDeploymentConfig = { saltNonce, safeVersion };
        return (0, utils_1.predictSafeAddress)({
          ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
          safeAccountConfig,
          safeDeploymentConfig,
          isL1SafeMasterCopy: __classPrivateFieldGet(this, _SafeFactory_isL1SafeMasterCopy, "f"),
          customContracts
        });
      }
      async deploySafe({ safeAccountConfig, saltNonce = utils_1.PREDETERMINED_SALT_NONCE, options, callback }) {
        var _a;
        (0, utils_1.validateSafeAccountConfig)(safeAccountConfig);
        (0, utils_1.validateSafeDeploymentConfig)({ saltNonce });
        const signerAddress = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const chainId = await this.getChainId();
        const customContracts = (_a = __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")) == null ? void 0 : _a[chainId];
        const initializer = await (0, utils_1.encodeSetupCallData)({
          ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
          safeAccountConfig,
          safeContract: __classPrivateFieldGet(this, _SafeFactory_safeContract, "f"),
          customContracts
        });
        if ((options == null ? void 0 : options.gas) && (options == null ? void 0 : options.gasLimit)) {
          throw new Error("Cannot specify gas and gasLimit together in transaction options");
        }
        const safeAddress = await __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").createProxy({
          safeMasterCopyAddress: __classPrivateFieldGet(this, _SafeFactory_safeContract, "f").getAddress(),
          initializer,
          saltNonce,
          options: {
            from: signerAddress,
            ...options
          },
          callback
        });
        const isContractDeployed = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").isContractDeployed(safeAddress);
        if (!isContractDeployed) {
          throw new Error("SafeProxy contract is not deployed on the current network");
        }
        const safe = await Safe_1.default.create({
          ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
          safeAddress,
          isL1SafeMasterCopy: __classPrivateFieldGet(this, _SafeFactory_isL1SafeMasterCopy, "f"),
          contractNetworks: __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")
        });
        return safe;
      }
    };
    _SafeFactory_contractNetworks = /* @__PURE__ */ new WeakMap(), _SafeFactory_isL1SafeMasterCopy = /* @__PURE__ */ new WeakMap(), _SafeFactory_safeVersion = /* @__PURE__ */ new WeakMap(), _SafeFactory_ethAdapter = /* @__PURE__ */ new WeakMap(), _SafeFactory_safeProxyFactoryContract = /* @__PURE__ */ new WeakMap(), _SafeFactory_safeContract = /* @__PURE__ */ new WeakMap();
    exports.default = SafeFactory;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/utils/erc-20/index.js
var require_erc_20 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/utils/erc-20/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createERC20TokenTransferTransaction = exports.isGasTokenCompatibleWithHandlePayment = exports.getERC20Decimals = void 0;
    var abi_1 = (init_lib5(), __toCommonJS(lib_exports5));
    var constants_1 = require_constants();
    var ERC20_ABI = [
      "function transfer(address recipient, uint256 amount) returns (bool)",
      "function decimals() view returns (uint8)"
    ];
    async function getERC20Decimals(tokenAddress, safe) {
      const ethAdapter = safe.getEthAdapter();
      const erc20Interface = new abi_1.Interface(ERC20_ABI);
      const getTokenDecimalsTransaction = {
        to: tokenAddress,
        from: tokenAddress,
        value: "0",
        data: erc20Interface.encodeFunctionData("decimals")
      };
      const response = await ethAdapter.call(getTokenDecimalsTransaction);
      const decimals = Number(response);
      if (Number.isNaN(decimals)) {
        throw new Error("Invalid ERC-20 decimals");
      }
      return decimals;
    }
    exports.getERC20Decimals = getERC20Decimals;
    var STANDARD_ERC20_DECIMALS = 18;
    async function isGasTokenCompatibleWithHandlePayment(gasToken, safe) {
      const isNativeToken = gasToken === constants_1.ZERO_ADDRESS;
      if (isNativeToken) {
        return true;
      }
      const gasTokenDecimals = await getERC20Decimals(gasToken, safe);
      const hasTokenStandardERC20Decimals = gasTokenDecimals === STANDARD_ERC20_DECIMALS;
      return hasTokenStandardERC20Decimals;
    }
    exports.isGasTokenCompatibleWithHandlePayment = isGasTokenCompatibleWithHandlePayment;
    function createERC20TokenTransferTransaction(tokenAddress, toAddress, amount) {
      const erc20Interface = new abi_1.Interface(ERC20_ABI);
      const transferTransaction = {
        to: tokenAddress,
        value: "0",
        data: erc20Interface.encodeFunctionData("transfer", [toAddress, amount])
      };
      return transferTransaction;
    }
    exports.createERC20TokenTransferTransaction = createERC20TokenTransferTransaction;
  }
});

// node_modules/@safe-global/protocol-kit/dist/src/index.js
var require_src7 = __commonJS({
  "node_modules/@safe-global/protocol-kit/dist/src/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.standardizeSafeTransactionData = exports.predictSafeAddress = exports.isGasTokenCompatibleWithHandlePayment = exports.getSignMessageLibContract = exports.getSafeContract = exports.getProxyFactoryContract = exports.getMultiSendContract = exports.getMultiSendCallOnlyContract = exports.getERC20Decimals = exports.getCreateCallContract = exports.getCompatibilityFallbackHandlerContract = exports.encodeSetupCallData = exports.encodeMultiSendData = exports.encodeCreateProxyWithNonce = exports.Web3Adapter = exports.SignMessageLibWeb3Contract = exports.SignMessageLibEthersContract = exports.SafeProxyFactoryWeb3Contract = exports.SafeProxyFactoryEthersContract = exports.SafeFactory = exports.SafeContractWeb3 = exports.SafeContractEthers = exports.PREDETERMINED_SALT_NONCE = exports.MultiSendWeb3Contract = exports.MultiSendEthersContract = exports.MultiSendCallOnlyWeb3Contract = exports.MultiSendCallOnlyEthersContract = exports.EthersAdapter = exports.EthSafeSignature = exports.DEFAULT_SAFE_VERSION = exports.createERC20TokenTransferTransaction = exports.CreateCallWeb3Contract = exports.CreateCallEthersContract = exports.ContractManager = exports.estimateSafeDeploymentGas = exports.estimateSafeTxGas = exports.estimateTxGas = exports.estimateTxBaseGas = void 0;
    var Safe_1 = __importDefault(require_Safe());
    var ethers_1 = require_ethers();
    Object.defineProperty(exports, "CreateCallEthersContract", { enumerable: true, get: function() {
      return ethers_1.CreateCallEthersContract;
    } });
    Object.defineProperty(exports, "EthersAdapter", { enumerable: true, get: function() {
      return ethers_1.EthersAdapter;
    } });
    Object.defineProperty(exports, "MultiSendCallOnlyEthersContract", { enumerable: true, get: function() {
      return ethers_1.MultiSendCallOnlyEthersContract;
    } });
    Object.defineProperty(exports, "MultiSendEthersContract", { enumerable: true, get: function() {
      return ethers_1.MultiSendEthersContract;
    } });
    Object.defineProperty(exports, "SafeContractEthers", { enumerable: true, get: function() {
      return ethers_1.SafeContractEthers;
    } });
    Object.defineProperty(exports, "SafeProxyFactoryEthersContract", { enumerable: true, get: function() {
      return ethers_1.SafeProxyFactoryEthersContract;
    } });
    Object.defineProperty(exports, "SignMessageLibEthersContract", { enumerable: true, get: function() {
      return ethers_1.SignMessageLibEthersContract;
    } });
    var web3_1 = require_web3();
    Object.defineProperty(exports, "CreateCallWeb3Contract", { enumerable: true, get: function() {
      return web3_1.CreateCallWeb3Contract;
    } });
    Object.defineProperty(exports, "MultiSendCallOnlyWeb3Contract", { enumerable: true, get: function() {
      return web3_1.MultiSendCallOnlyWeb3Contract;
    } });
    Object.defineProperty(exports, "MultiSendWeb3Contract", { enumerable: true, get: function() {
      return web3_1.MultiSendWeb3Contract;
    } });
    Object.defineProperty(exports, "SafeContractWeb3", { enumerable: true, get: function() {
      return web3_1.SafeContractWeb3;
    } });
    Object.defineProperty(exports, "SafeProxyFactoryWeb3Contract", { enumerable: true, get: function() {
      return web3_1.SafeProxyFactoryWeb3Contract;
    } });
    Object.defineProperty(exports, "SignMessageLibWeb3Contract", { enumerable: true, get: function() {
      return web3_1.SignMessageLibWeb3Contract;
    } });
    Object.defineProperty(exports, "Web3Adapter", { enumerable: true, get: function() {
      return web3_1.Web3Adapter;
    } });
    var config_1 = require_config();
    Object.defineProperty(exports, "DEFAULT_SAFE_VERSION", { enumerable: true, get: function() {
      return config_1.DEFAULT_SAFE_VERSION;
    } });
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    Object.defineProperty(exports, "getCompatibilityFallbackHandlerContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getCompatibilityFallbackHandlerContract;
    } });
    Object.defineProperty(exports, "getCreateCallContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getCreateCallContract;
    } });
    Object.defineProperty(exports, "getMultiSendCallOnlyContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getMultiSendCallOnlyContract;
    } });
    Object.defineProperty(exports, "getMultiSendContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getMultiSendContract;
    } });
    Object.defineProperty(exports, "getProxyFactoryContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getProxyFactoryContract;
    } });
    Object.defineProperty(exports, "getSafeContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getSafeContract;
    } });
    Object.defineProperty(exports, "getSignMessageLibContract", { enumerable: true, get: function() {
      return safeDeploymentContracts_1.getSignMessageLibContract;
    } });
    var utils_1 = require_utils8();
    Object.defineProperty(exports, "PREDETERMINED_SALT_NONCE", { enumerable: true, get: function() {
      return utils_1.PREDETERMINED_SALT_NONCE;
    } });
    Object.defineProperty(exports, "encodeCreateProxyWithNonce", { enumerable: true, get: function() {
      return utils_1.encodeCreateProxyWithNonce;
    } });
    Object.defineProperty(exports, "encodeSetupCallData", { enumerable: true, get: function() {
      return utils_1.encodeSetupCallData;
    } });
    Object.defineProperty(exports, "predictSafeAddress", { enumerable: true, get: function() {
      return utils_1.predictSafeAddress;
    } });
    var contractManager_1 = __importDefault(require_contractManager());
    exports.ContractManager = contractManager_1.default;
    var safeFactory_1 = __importDefault(require_safeFactory());
    exports.SafeFactory = safeFactory_1.default;
    var utils_2 = require_utils17();
    Object.defineProperty(exports, "EthSafeSignature", { enumerable: true, get: function() {
      return utils_2.EthSafeSignature;
    } });
    Object.defineProperty(exports, "estimateTxBaseGas", { enumerable: true, get: function() {
      return utils_2.estimateTxBaseGas;
    } });
    Object.defineProperty(exports, "estimateTxGas", { enumerable: true, get: function() {
      return utils_2.estimateTxGas;
    } });
    Object.defineProperty(exports, "estimateSafeTxGas", { enumerable: true, get: function() {
      return utils_2.estimateSafeTxGas;
    } });
    Object.defineProperty(exports, "estimateSafeDeploymentGas", { enumerable: true, get: function() {
      return utils_2.estimateSafeDeploymentGas;
    } });
    var utils_3 = require_utils16();
    Object.defineProperty(exports, "encodeMultiSendData", { enumerable: true, get: function() {
      return utils_3.encodeMultiSendData;
    } });
    Object.defineProperty(exports, "standardizeSafeTransactionData", { enumerable: true, get: function() {
      return utils_3.standardizeSafeTransactionData;
    } });
    var erc_20_1 = require_erc_20();
    Object.defineProperty(exports, "getERC20Decimals", { enumerable: true, get: function() {
      return erc_20_1.getERC20Decimals;
    } });
    Object.defineProperty(exports, "isGasTokenCompatibleWithHandlePayment", { enumerable: true, get: function() {
      return erc_20_1.isGasTokenCompatibleWithHandlePayment;
    } });
    Object.defineProperty(exports, "createERC20TokenTransferTransaction", { enumerable: true, get: function() {
      return erc_20_1.createERC20TokenTransferTransaction;
    } });
    exports.default = Safe_1.default;
  }
});

// node_modules/@thirdweb-dev/wallets/evm/connectors/safe/dist/thirdweb-dev-wallets-evm-connectors-safe.browser.esm.js
init_lib9();
var import_safe_ethers_adapters = __toESM(require_src2());
var import_protocol_kit = __toESM(require_src7());
var CHAIN_ID_TO_GNOSIS_SERVER_URL = {
  // mainnet
  1: "https://safe-transaction-mainnet.safe.global",
  // Sepolia
  11155111: "https://safe-transaction-sepolia.safe.global",
  // optimism
  10: "https://safe-transaction-optimism.safe.global",
  // bsc
  56: "https://safe-transaction-bsc.safe.global",
  // gnosis
  100: "https://safe-transaction-gnosis-chain.safe.global",
  // polygon
  137: "https://safe-transaction-polygon.safe.global",
  // avalanche
  43114: "https://safe-transaction-avalanche.safe.global",
  // arbitrum
  42161: "https://safe-transaction-arbitrum.safe.global",
  // celo
  42220: "https://safe-transaction-celo.safe.global",
  // Base mainnet
  8453: "https://safe-transaction-base.safe.global",
  // aurora
  1313161554: "https://safe-transaction-aurora.safe.global",
  //  Polygon zkEVM
  1101: "https://safe-transaction-zkevm.safe.global",
  //  ZkSync Mainnet
  324: "https://safe-transaction-zksync.safe.global"
};
var CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS = {
  // mainnet
  1: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // polygon
  137: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // bsc
  56: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // arbitrum
  42161: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // aurora
  1313161554: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // avalanche
  43114: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // optimism
  10: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // celo
  42220: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // gnosis chain - https://docs.safe.global/smart-account-supported-networks/v1.3.0#gnosis
  100: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // Sepolia - https://docs.safe.global/smart-account-supported-networks/v1.3.0#sepolia
  11155111: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // base mainnet - https://docs.safe.global/smart-account-supported-networks/v1.3.0#base
  8453: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // Polygon zkEVM - https://docs.safe.global/smart-account-supported-networks/v1.3.0#polygon-zkevm
  1101: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // ZkSync Mainnet - https://docs.safe.global/smart-account-supported-networks/v1.3.0#zksync-mainnet
  324: "0x357147caf9C0cCa67DfA0CF5369318d8193c8407"
};
var SIGN_MESSAGE_LIB_ABI = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "bytes32",
    name: "msgHash",
    type: "bytes32"
  }],
  name: "SignMsg",
  type: "event"
}, {
  inputs: [{
    internalType: "bytes",
    name: "message",
    type: "bytes"
  }],
  name: "getMessageHash",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "signMessage",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var __IS_SERVER__ = false;
var SafeConnector = class _SafeConnector extends Connector {
  // config
  // private options: SafeOptions;
  constructor() {
    super();
    _defineProperty(this, "supportedChains", _SafeConnector.supportedChains);
    _defineProperty(this, "id", "safe-wallet");
    _defineProperty(this, "ready", !__IS_SERVER__);
    _defineProperty(this, "name", "Safe Wallet");
    {
      this.ready = true;
    }
  }
  async connect(args) {
    if (!(args.chain.chainId in CHAIN_ID_TO_GNOSIS_SERVER_URL)) {
      throw new Error("Chain not supported by Safe");
    }
    this.safeSigner = await this.createSafeSigner(args);
    return await this.getAddress();
  }
  async createSafeSigner(params) {
    this.personalWallet = params.personalWallet;
    const signer = await params.personalWallet.getSigner();
    const safeAddress = params.safeAddress;
    const safeChainId = params.chain.chainId;
    if (!signer) {
      throw new Error("cannot create Gnosis Safe signer without a personal signer");
    }
    const signerChainId = await signer.getChainId();
    if (signerChainId !== safeChainId) {
      throw new Error("chainId of personal signer has to match safe chainId");
    }
    if (!safeAddress) {
      throw new Error("safeAddress is required");
    }
    if (!safeChainId) {
      throw new Error("safeChainId is required");
    }
    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];
    const signMessageLibAddress = CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS[safeChainId];
    if (!serverUrl || !signMessageLibAddress) {
      throw new Error("Chain not supported");
    }
    const ethAdapter = new import_protocol_kit.EthersAdapter({
      ethers: ethers_exports,
      signerOrProvider: signer
    });
    const safe = await import_protocol_kit.default.create({
      ethAdapter,
      safeAddress
    });
    const service = new import_safe_ethers_adapters.SafeService(serverUrl);
    const safeSigner = new import_safe_ethers_adapters.SafeEthersSigner(safe, service, signer.provider);
    safeSigner.signMessage = async (message) => {
      var _a;
      const contract = new ethers_exports.BaseContract(signMessageLibAddress, SIGN_MESSAGE_LIB_ABI);
      const data = contract.interface.encodeFunctionData("signMessage", [ethers_exports.utils.hashMessage(message)]);
      const to = signMessageLibAddress;
      const value = "0";
      const operation = 1;
      const safeTxGas = 5e4;
      const baseGas = 5e4;
      const gasPrice = 0;
      const gasToken = ethers_exports.constants.AddressZero;
      const refundReceiver = ethers_exports.constants.AddressZero;
      const safeTx = await safe.createTransaction({
        safeTransactionData: {
          to,
          value,
          operation,
          data,
          baseGas,
          safeTxGas,
          gasPrice,
          gasToken,
          refundReceiver
        }
      });
      const safeTxHash = await safe.getTransactionHash(safeTx);
      const safeSignature = await safe.signTransactionHash(safeTxHash);
      await service.proposeTx(await safe.getAddress(), safeTxHash, safeTx, safeSignature);
      while (true) {
        try {
          const txDetails = await service.getSafeTxDetails(safeTxHash);
          if (txDetails.transactionHash) {
            await ((_a = signer.provider) == null ? void 0 : _a.waitForTransaction(txDetails.transactionHash));
            break;
          }
        } catch (e) {
        }
        await new Promise((resolve) => setTimeout(resolve, 5e3));
      }
      return "0x";
    };
    this.previousConnector = params.personalWallet;
    return safeSigner;
  }
  async disconnect() {
    this.safeSigner = void 0;
    this.previousConnector = void 0;
    return void 0;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return await signer.getAddress();
  }
  async getChainId() {
    return (await this.getSigner()).getChainId();
  }
  async getProvider() {
    const provider = (await this.getSigner()).provider;
    if (!provider) {
      throw new Error("No provider available");
    }
    return provider;
  }
  async getSigner() {
    if (!this.safeSigner) {
      throw new Error("not connected - please call connect() first");
    }
    return this.safeSigner;
  }
  async isConnected() {
    try {
      const account = await this.getAddress();
      return !!account;
    } catch (e) {
      return false;
    }
  }
  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      if (accounts[0]) {
        this.emit("change", {
          account: ethers_exports.utils.getAddress(accounts[0])
        });
      }
    }
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  switchChain() {
    throw new Error("Safe connector does not support switching chains");
  }
  updateChains() {
  }
  async setupListeners() {
  }
};
_defineProperty(SafeConnector, "supportedChains", (() => Object.keys(CHAIN_ID_TO_GNOSIS_SERVER_URL))());
export {
  SafeConnector
};
/*! Bundled license information:

utf8/utf8.js:
  (*! https://mths.be/utf8js v3.0.0 by @mathias *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-safe.browser.esm-G4EWZBDB.js.map
