import {
  StandardErc721
} from "./chunk-FFUOHEF7.js";
import "./chunk-OIIBEHL6.js";
import {
  hasERC20Allowance
} from "./chunk-RDT5JWJO.js";
import "./chunk-NIG2CF6U.js";
import {
  isTokenApprovedForTransfer
} from "./chunk-GOK6MZRL.js";
import {
  ContractOwner,
  ContractRoyalty
} from "./chunk-AQZXUCJH.js";
import {
  require_fast_deep_equal
} from "./chunk-RBNKNJXH.js";
import "./chunk-COSZBCPD.js";
import {
  uploadOrExtractURI
} from "./chunk-ZATXNSOB.js";
import {
  normalizePriceValue
} from "./chunk-KC5M5N6O.js";
import {
  ContractRoles
} from "./chunk-IOF4KDCZ.js";
import {
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractMetadata,
  GasCostEstimator,
  fetchCurrencyMetadata
} from "./chunk-OPQDTNHM.js";
import {
  AbiSchema,
  ContractWrapper,
  MULTIWRAP_CONTRACT_ROLES,
  MultiwrapContractSchema,
  Transaction,
  buildTransactionFunction,
  require_bs58,
  resolveAddress
} from "./chunk-RH5X6O6Y.js";
import "./chunk-C4RZ3FR3.js";
import "./chunk-RLCZAOQ6.js";
import "./chunk-OSKR2P2Q.js";
import "./chunk-LYEG5PGG.js";
import "./chunk-RPXC7Q6H.js";
import "./chunk-OP3MHZRI.js";
import "./chunk-FNDLL6VS.js";
import "./chunk-6D6UEHK3.js";
import "./chunk-NI75G64R.js";
import "./chunk-NXQSFSYO.js";
import "./chunk-7JTQECNY.js";
import "./chunk-UHBWZKE6.js";
import {
  init_lib,
  utils_exports
} from "./chunk-I3BLH5LU.js";
import "./chunk-MFKPCOBF.js";
import {
  require_utils
} from "./chunk-VZ6GM6HX.js";
import "./chunk-QDKWUOME.js";
import "./chunk-3JDV7GMI.js";
import {
  require_bn
} from "./chunk-JVFNGTH2.js";
import "./chunk-UFR7PFM3.js";
import {
  __publicField,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@thirdweb-dev/sdk/dist/multiwrap-cff091c3.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_utils = __toESM(require_utils());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var _Multiwrap = class _Multiwrap extends StandardErc721 {
  /**
   * Configure royalties
   * @remarks Set your own royalties for the entire contract or per token
   * @example
   * ```javascript
   * // royalties on the whole contract
   * contract.royalties.setDefaultRoyaltyInfo({
   *   seller_fee_basis_points: 100, // 1%
   *   fee_recipient: "0x..."
   * });
   * // override royalty for a particular token
   * contract.royalties.setTokenRoyaltyInfo(tokenId, {
   *   seller_fee_basis_points: 500, // 5%
   *   fee_recipient: "0x..."
   * });
   * ```
   */
  constructor(network, address, storage) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : void 0;
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);
    super(contractWrapper, storage, chainId);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Wrap any number of ERC20/ERC721/ERC1155 tokens into a single wrapped token
     * @example
     * ```javascript
     * const tx = await contract.wrap({
     *   erc20Tokens: [{
     *     contractAddress: "0x...",
     *     quantity: "0.8"
     *   }],
     *   erc721Tokens: [{
     *     contractAddress: "0x...",
     *     tokenId: "0"
     *   }],
     *   erc1155Tokens: [{
     *     contractAddress: "0x...",
     *     tokenId: "1",
     *     quantity: "2"
     *   }]
     * }, {
     *     name: "Wrapped bundle",
     *     description: "This is a wrapped bundle of tokens and NFTs",
     *     image: "ipfs://...",
     * });
     * const receipt = tx.receipt(); // the transaction receipt
     * const wrappedTokenId = tx.id; // the id of the wrapped token bundle
     * ```
     * @param contents - the contents to wrap
     * @param wrappedTokenMetadata - metadata to represent the wrapped token bundle
     * @param recipientAddress - Optional. The address to send the wrapped token bundle to
     */
    __publicField(this, "wrap", buildTransactionFunction(async (contents, wrappedTokenMetadata, recipientAddress) => {
      const [uri, tokens, recipient] = await Promise.all([uploadOrExtractURI(wrappedTokenMetadata, this.storage), this.toTokenStructList(contents), resolveAddress(recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress())]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "wrap",
        args: [tokens, uri, recipient],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensWrapped", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("TokensWrapped event not found");
          }
          const tokenId = event[0].args.tokenIdOfWrappedToken;
          return {
            id: tokenId,
            receipt,
            data: () => this.get(tokenId)
          };
        }
      });
    }));
    /**
     * Unwrap a wrapped token bundle, and retrieve its contents
     * @example
     * ```javascript
     * await contract.unwrap(wrappedTokenId);
     * ```
     * @param wrappedTokenId - the id of the wrapped token bundle
     * @param recipientAddress - Optional. The address to send the unwrapped tokens to
     */
    __publicField(this, "unwrap", buildTransactionFunction(async (wrappedTokenId, recipientAddress) => {
      const recipient = await resolveAddress(recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress());
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "unwrap",
        args: [wrappedTokenId, recipient]
      });
    }));
    this.abi = AbiSchema.parse(abi || []);
    this.metadata = new ContractMetadata(this.contractWrapper, MultiwrapContractSchema, this.storage);
    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Multiwrap.contractRoles);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.owner = new ContractOwner(this.contractWrapper);
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the contents of a wrapped token bundle
   * @example
   * ```javascript
   * const contents = await contract.getWrappedContents(wrappedTokenId);
   * console.log(contents.erc20Tokens);
   * console.log(contents.erc721Tokens);
   * console.log(contents.erc1155Tokens);
   * ```
   * @param wrappedTokenId - the id of the wrapped token bundle
   */
  async getWrappedContents(wrappedTokenId) {
    const wrappedTokens = await this.contractWrapper.read("getWrappedContents", [wrappedTokenId]);
    const erc20Tokens = [];
    const erc721Tokens = [];
    const erc1155Tokens = [];
    for (const token of wrappedTokens) {
      switch (token.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), token.assetContract);
          erc20Tokens.push({
            contractAddress: token.assetContract,
            quantity: utils_exports.formatUnits(token.totalAmount, tokenMetadata.decimals)
          });
          break;
        }
        case 1: {
          erc721Tokens.push({
            contractAddress: token.assetContract,
            tokenId: token.tokenId
          });
          break;
        }
        case 2: {
          erc1155Tokens.push({
            contractAddress: token.assetContract,
            tokenId: token.tokenId,
            quantity: token.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Tokens,
      erc721Tokens,
      erc1155Tokens
    };
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  async toTokenStructList(contents) {
    const tokens = [];
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    if (contents.erc20Tokens) {
      for (const erc20 of contents.erc20Tokens) {
        const normalizedQuantity = await normalizePriceValue(provider, erc20.quantity, erc20.contractAddress);
        const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, normalizedQuantity);
        if (!hasAllowance) {
          throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${erc20.quantity});

`);
        }
        tokens.push({
          assetContract: erc20.contractAddress,
          totalAmount: normalizedQuantity,
          tokenId: 0,
          tokenType: 0
        });
      }
    }
    if (contents.erc721Tokens) {
      for (const erc721 of contents.erc721Tokens) {
        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
        if (!isApproved) {
          throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
        }
        tokens.push({
          assetContract: erc721.contractAddress,
          totalAmount: 0,
          tokenId: erc721.tokenId,
          tokenType: 1
        });
      }
    }
    if (contents.erc1155Tokens) {
      for (const erc1155 of contents.erc1155Tokens) {
        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
        if (!isApproved) {
          throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
        }
        tokens.push({
          assetContract: erc1155.contractAddress,
          totalAmount: erc1155.quantity,
          tokenId: erc1155.tokenId,
          tokenType: 2
        });
      }
    }
    return tokens;
  }
  /**
   * @internal
   */
  async prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  /**
   * @internal
   */
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
};
__publicField(_Multiwrap, "contractRoles", MULTIWRAP_CONTRACT_ROLES);
var Multiwrap = _Multiwrap;
export {
  Multiwrap
};
//# sourceMappingURL=multiwrap-cff091c3.browser.esm-ZXN6ERKM.js.map
