{
  "version": 3,
  "sources": ["../../@ethersproject/abi/src.ts/_version.ts", "../../@ethersproject/abi/src.ts/fragments.ts", "../../@ethersproject/abi/src.ts/coders/abstract-coder.ts", "../../@ethersproject/abi/src.ts/coders/address.ts", "../../@ethersproject/abi/src.ts/coders/anonymous.ts", "../../@ethersproject/abi/src.ts/coders/array.ts", "../../@ethersproject/abi/src.ts/coders/boolean.ts", "../../@ethersproject/abi/src.ts/coders/bytes.ts", "../../@ethersproject/abi/src.ts/coders/fixed-bytes.ts", "../../@ethersproject/abi/src.ts/coders/null.ts", "../../@ethersproject/abi/src.ts/coders/number.ts", "../../@ethersproject/abi/src.ts/coders/string.ts", "../../@ethersproject/abi/src.ts/coders/tuple.ts", "../../@ethersproject/abi/src.ts/abi-coder.ts", "../../@ethersproject/abi/src.ts/interface.ts", "../../@ethersproject/abi/src.ts/index.ts", "../../@ethersproject/contracts/src.ts/_version.ts", "../../@ethersproject/contracts/src.ts/index.ts", "../../@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts", "../../@ethersproject/pbkdf2/src.ts/index.ts", "../../@ethersproject/wordlists/src.ts/_version.ts", "../../@ethersproject/wordlists/src.ts/wordlist.ts", "../../@ethersproject/wordlists/src.ts/lang-en.ts", "../../@ethersproject/wordlists/src.ts/browser-wordlists.ts", "../../@ethersproject/wordlists/src.ts/index.ts", "../../@ethersproject/hdnode/src.ts/_version.ts", "../../@ethersproject/hdnode/src.ts/index.ts", "../../@ethersproject/json-wallets/src.ts/_version.ts", "../../@ethersproject/json-wallets/src.ts/utils.ts", "../../@ethersproject/json-wallets/src.ts/crowdsale.ts", "../../@ethersproject/json-wallets/src.ts/inspect.ts", "../../@ethersproject/json-wallets/src.ts/keystore.ts", "../../@ethersproject/json-wallets/src.ts/index.ts", "../../@ethersproject/wallet/src.ts/_version.ts", "../../@ethersproject/wallet/src.ts/index.ts", "../../@ethersproject/solidity/src.ts/_version.ts", "../../@ethersproject/solidity/src.ts/index.ts", "../../@ethersproject/units/src.ts/_version.ts", "../../@ethersproject/units/src.ts/index.ts", "../../ethers/src.ts/utils.ts", "../../ethers/src.ts/_version.ts", "../../ethers/src.ts/ethers.ts", "../../ethers/src.ts/index.ts"],
  "sourcesContent": ["export const version = \"abi/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nexport interface JsonFragmentType {\r\n    readonly name?: string;\r\n    readonly indexed?: boolean;\r\n    readonly type?: string;\r\n    readonly internalType?: any; // @TODO: in v6 reduce type\r\n    readonly components?: ReadonlyArray<JsonFragmentType>;\r\n}\r\n\r\nexport interface JsonFragment {\r\n    readonly name?: string;\r\n    readonly type?: string;\r\n\r\n    readonly anonymous?: boolean;\r\n\r\n    readonly payable?: boolean;\r\n    readonly constant?: boolean;\r\n    readonly stateMutability?: string;\r\n\r\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\r\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\r\n\r\n    readonly gas?: string;\r\n};\r\n\r\nconst _constructorGuard = { };\r\n\r\n// AST Node parser state\r\ntype ParseState = {\r\n    allowArray?: boolean,\r\n    allowName?: boolean,\r\n    allowParams?: boolean,\r\n    allowType?: boolean,\r\n    readArray?: boolean,\r\n};\r\n\r\n// AST Node\r\ntype ParseNode = {\r\n    parent?: any,\r\n    type?: string,\r\n    name?: string,\r\n    state?: ParseState,\r\n    indexed?: boolean,\r\n    components?: Array<ParseNode>\r\n};\r\n\r\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\r\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\r\nfunction checkModifier(type: string, name: string): boolean {\r\n    if (type === \"bytes\" || type === \"string\") {\r\n        if (ModifiersBytes[name]) { return true; }\r\n    } else if (type === \"address\") {\r\n        if (name === \"payable\") { return true; }\r\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\r\n        if (ModifiersNest[name]) { return true; }\r\n    }\r\n    if (ModifiersBytes[name] || name === \"payable\") {\r\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\r\n    }\r\n    return false;\r\n}\r\n\r\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\r\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\r\n\r\n    let originalParam = param;\r\n    function throwError(i: number) {\r\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\r\n    }\r\n    param = param.replace(/\\s/g, \" \");\r\n\r\n    function newNode(parent: ParseNode): ParseNode {\r\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\r\n        if (allowIndexed) { node.indexed = false; }\r\n        return node\r\n    }\r\n\r\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\r\n    let node = parent;\r\n\r\n    for (let i = 0; i < param.length; i++) {\r\n        let c = param[i];\r\n        switch (c) {\r\n            case \"(\":\r\n                if (node.state.allowType && node.type === \"\") {\r\n                    node.type = \"tuple\";\r\n                } else if (!node.state.allowParams) {\r\n                    throwError(i);\r\n                }\r\n                node.state.allowType = false;\r\n                node.type = verifyType(node.type);\r\n                node.components = [ newNode(node) ];\r\n                node = node.components[0];\r\n                break;\r\n\r\n            case \")\":\r\n                delete node.state;\r\n\r\n                if (node.name === \"indexed\") {\r\n                    if (!allowIndexed) { throwError(i); }\r\n                    node.indexed = true;\r\n                    node.name = \"\";\r\n                }\r\n\r\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\r\n\r\n                node.type = verifyType(node.type);\r\n\r\n                let child = node;\r\n                node = node.parent;\r\n                if (!node) { throwError(i); }\r\n                delete child.parent;\r\n                node.state.allowParams = false;\r\n                node.state.allowName = true;\r\n                node.state.allowArray = true;\r\n                break;\r\n\r\n            case \",\":\r\n                delete node.state;\r\n\r\n                if (node.name === \"indexed\") {\r\n                    if (!allowIndexed) { throwError(i); }\r\n                    node.indexed = true;\r\n                    node.name = \"\";\r\n                }\r\n\r\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\r\n\r\n                node.type = verifyType(node.type);\r\n\r\n                let sibling: ParseNode = newNode(node.parent);\r\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\r\n                node.parent.components.push(sibling);\r\n                delete node.parent;\r\n                node = sibling;\r\n                break;\r\n\r\n            // Hit a space...\r\n            case \" \":\r\n\r\n                // If reading type, the type is done and may read a param or name\r\n                if (node.state.allowType) {\r\n                    if (node.type !== \"\") {\r\n                        node.type = verifyType(node.type);\r\n                        delete node.state.allowType;\r\n                        node.state.allowName = true;\r\n                        node.state.allowParams = true;\r\n                    }\r\n                }\r\n\r\n                // If reading name, the name is done\r\n                if (node.state.allowName) {\r\n                    if (node.name !== \"\") {\r\n                        if (node.name === \"indexed\") {\r\n                            if (!allowIndexed) { throwError(i); }\r\n                            if (node.indexed) { throwError(i); }\r\n                            node.indexed = true;\r\n                            node.name = \"\";\r\n                        } else if (checkModifier(node.type, node.name)) {\r\n                            node.name = \"\";\r\n                        } else {\r\n                            node.state.allowName = false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                break;\r\n\r\n            case \"[\":\r\n                if (!node.state.allowArray) { throwError(i); }\r\n\r\n                node.type += c;\r\n\r\n                node.state.allowArray = false;\r\n                node.state.allowName = false;\r\n                node.state.readArray = true;\r\n                break;\r\n\r\n            case \"]\":\r\n                if (!node.state.readArray) { throwError(i); }\r\n\r\n                node.type += c;\r\n\r\n                node.state.readArray = false;\r\n                node.state.allowArray = true;\r\n                node.state.allowName = true;\r\n                break;\r\n\r\n            default:\r\n                if (node.state.allowType) {\r\n                    node.type += c;\r\n                    node.state.allowParams = true;\r\n                    node.state.allowArray = true;\r\n                } else if (node.state.allowName) {\r\n                    node.name += c;\r\n                    delete node.state.allowArray;\r\n                } else if (node.state.readArray) {\r\n                    node.type += c;\r\n                } else {\r\n                    throwError(i);\r\n               }\r\n        }\r\n    }\r\n\r\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\r\n\r\n    delete parent.state;\r\n\r\n    if (node.name === \"indexed\") {\r\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\r\n        if (node.indexed) { throwError(originalParam.length - 7); }\r\n        node.indexed = true;\r\n        node.name = \"\";\r\n    } else if (checkModifier(node.type, node.name)) {\r\n        node.name = \"\";\r\n    }\r\n\r\n    parent.type = verifyType(parent.type);\r\n\r\n    return parent;\r\n}\r\n\r\nfunction populate(object: any, params: any) {\r\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\r\n}\r\n\r\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\r\n    // Bare formatting, as is needed for computing a sighash of an event or function\r\n    sighash: \"sighash\",\r\n\r\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\r\n    minimal: \"minimal\",\r\n\r\n    // Human-Readable with nice spacing, including all names\r\n    full: \"full\",\r\n\r\n    // JSON-format a la Solidity\r\n    json: \"json\"\r\n});\r\n\r\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\r\n\r\nexport class ParamType {\r\n\r\n    // The local name of the parameter (of null if unbound)\r\n    readonly name: string;\r\n\r\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\r\n    readonly type: string;\r\n\r\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\r\n    readonly baseType: string;\r\n\r\n    // Indexable Paramters ONLY (otherwise null)\r\n    readonly indexed: boolean;\r\n\r\n    // Tuples ONLY: (otherwise null)\r\n    //  - sub-components\r\n    readonly components: Array<ParamType>;\r\n\r\n    // Arrays ONLY: (otherwise null)\r\n    //  - length of the array (-1 for dynamic length)\r\n    //  - child type\r\n    readonly arrayLength: number;\r\n    readonly arrayChildren: ParamType;\r\n\r\n    readonly _isParamType: boolean;\r\n\r\n    constructor(constructorGuard: any, params: any) {\r\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n            operation: \"new ParamType()\"\r\n        }); }\r\n        populate(this, params);\r\n\r\n        let match = this.type.match(paramTypeArray);\r\n        if (match) {\r\n            populate(this, {\r\n                arrayLength: parseInt(match[2] || \"-1\"),\r\n                arrayChildren: ParamType.fromObject({\r\n                    type: match[1],\r\n                    components: this.components\r\n                }),\r\n                baseType: \"array\"\r\n            });\r\n        } else {\r\n            populate(this, {\r\n                arrayLength: null,\r\n                arrayChildren: null,\r\n                baseType: ((this.components != null) ? \"tuple\": this.type)\r\n            });\r\n        }\r\n\r\n        this._isParamType = true;\r\n\r\n        Object.freeze(this);\r\n    }\r\n\r\n    // Format the parameter fragment\r\n    //   - sighash: \"(uint256,address)\"\r\n    //   - minimal: \"tuple(uint256,address) indexed\"\r\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\r\n    format(format?: string): string {\r\n        if (!format) { format = FormatTypes.sighash; }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n\r\n        if (format === FormatTypes.json) {\r\n            let result: any = {\r\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\r\n                name: (this.name || undefined)\r\n            };\r\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\r\n            if (this.components) {\r\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\r\n            }\r\n            return JSON.stringify(result);\r\n        }\r\n\r\n        let result = \"\";\r\n\r\n        // Array\r\n        if (this.baseType === \"array\") {\r\n            result += this.arrayChildren.format(format);\r\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\r\n        } else {\r\n            if (this.baseType === \"tuple\") {\r\n                if (format !== FormatTypes.sighash) {\r\n                    result += this.type;\r\n                }\r\n                result += \"(\" + this.components.map(\r\n                    (comp) => comp.format(format)\r\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\r\n            } else {\r\n                result += this.type;\r\n            }\r\n        }\r\n\r\n        if (format !== FormatTypes.sighash) {\r\n            if (this.indexed === true) { result += \" indexed\"; }\r\n            if (format === FormatTypes.full && this.name) {\r\n                result += \" \" + this.name;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\r\n        if (typeof(value) === \"string\") {\r\n            return ParamType.fromString(value, allowIndexed);\r\n        }\r\n        return ParamType.fromObject(value);\r\n    }\r\n\r\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\r\n        if (ParamType.isParamType(value)) { return value; }\r\n\r\n        return new ParamType(_constructorGuard, {\r\n            name: (value.name || null),\r\n            type: verifyType(value.type),\r\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\r\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\r\n        });\r\n    }\r\n\r\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\r\n        function ParamTypify(node: ParseNode): ParamType {\r\n            return ParamType.fromObject({\r\n                name: node.name,\r\n                type: node.type,\r\n                indexed: node.indexed,\r\n                components: node.components\r\n            });\r\n        }\r\n\r\n        return ParamTypify(parseParamType(value, !!allowIndexed));\r\n    }\r\n\r\n    static isParamType(value: any): value is ParamType {\r\n        return !!(value != null && value._isParamType);\r\n    }\r\n};\r\n\r\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\r\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\r\n}\r\n\r\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\r\n\r\ninterface _Fragment {\r\n    readonly type: string;\r\n    readonly name: string;\r\n    readonly inputs: ReadonlyArray<ParamType>;\r\n}\r\n\r\nexport abstract class Fragment {\r\n\r\n    readonly type: string;\r\n    readonly name: string;\r\n    readonly inputs: Array<ParamType>;\r\n\r\n    readonly _isFragment: boolean;\r\n\r\n    constructor(constructorGuard: any, params: any) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new Fragment()\"\r\n            });\r\n        }\r\n        populate(this, params);\r\n\r\n        this._isFragment = true;\r\n\r\n        Object.freeze(this);\r\n    }\r\n\r\n    abstract format(format?: string): string;\r\n\r\n    static from(value: Fragment | JsonFragment | string): Fragment {\r\n        if (Fragment.isFragment(value)) { return value; }\r\n\r\n        if (typeof(value) === \"string\") {\r\n            return Fragment.fromString(value);\r\n        }\r\n\r\n        return Fragment.fromObject(value);\r\n    }\r\n\r\n    static fromObject(value: Fragment | JsonFragment): Fragment {\r\n        if (Fragment.isFragment(value)) { return value; }\r\n\r\n        switch (value.type) {\r\n            case \"function\":\r\n                return FunctionFragment.fromObject(value);\r\n            case \"event\":\r\n                return EventFragment.fromObject(value);\r\n            case \"constructor\":\r\n                return ConstructorFragment.fromObject(value);\r\n            case \"error\":\r\n                return ErrorFragment.fromObject(value);\r\n            case \"fallback\":\r\n            case \"receive\":\r\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\r\n                return null;\r\n        }\r\n\r\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\r\n    }\r\n\r\n    static fromString(value: string): Fragment {\r\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\r\n        value = value.replace(/\\s/g, \" \");\r\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\r\n        value = value.trim();\r\n\r\n        if (value.split(\" \")[0] === \"event\") {\r\n           return EventFragment.fromString(value.substring(5).trim());\r\n        } else if (value.split(\" \")[0] === \"function\") {\r\n            return FunctionFragment.fromString(value.substring(8).trim());\r\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\r\n            return ConstructorFragment.fromString(value.trim());\r\n        } else if (value.split(\" \")[0] === \"error\") {\r\n           return ErrorFragment.fromString(value.substring(5).trim());\r\n        }\r\n\r\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\r\n    }\r\n\r\n    static isFragment(value: any): value is Fragment {\r\n        return !!(value && value._isFragment);\r\n    }\r\n}\r\n\r\ninterface _EventFragment extends _Fragment {\r\n    readonly anonymous: boolean;\r\n}\r\n\r\nexport class EventFragment extends Fragment {\r\n    readonly anonymous: boolean;\r\n\r\n    format(format?: string): string {\r\n        if (!format) { format = FormatTypes.sighash; }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"event\",\r\n                anonymous: this.anonymous,\r\n                name: this.name,\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\r\n            });\r\n        }\r\n\r\n        let result = \"\";\r\n\r\n        if (format !== FormatTypes.sighash) {\r\n            result += \"event \";\r\n        }\r\n\r\n        result += this.name + \"(\" + this.inputs.map(\r\n            (input) => input.format(format)\r\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\r\n\r\n        if (format !== FormatTypes.sighash) {\r\n            if (this.anonymous) {\r\n                result += \"anonymous \";\r\n            }\r\n        }\r\n\r\n        return result.trim();\r\n    }\r\n\r\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\r\n        if (typeof(value) === \"string\") {\r\n            return EventFragment.fromString(value);\r\n        }\r\n        return EventFragment.fromObject(value);\r\n    }\r\n\r\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\r\n        if (EventFragment.isEventFragment(value)) { return value; }\r\n\r\n        if (value.type !== \"event\") {\r\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\r\n        }\r\n\r\n        const params: TypeCheck<_EventFragment> = {\r\n            name: verifyIdentifier(value.name),\r\n            anonymous: value.anonymous,\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\r\n            type: \"event\"\r\n        };\r\n\r\n        return new EventFragment(_constructorGuard, params);\r\n    }\r\n\r\n    static fromString(value: string): EventFragment {\r\n\r\n        let match = value.match(regexParen);\r\n        if (!match) {\r\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\r\n        }\r\n\r\n        let anonymous = false;\r\n        match[3].split(\" \").forEach((modifier) => {\r\n            switch(modifier.trim()) {\r\n                case \"anonymous\":\r\n                    anonymous = true;\r\n                    break;\r\n                case \"\":\r\n                    break;\r\n                default:\r\n                    logger.warn(\"unknown modifier: \" + modifier);\r\n            }\r\n        });\r\n\r\n        return EventFragment.fromObject({\r\n            name: match[1].trim(),\r\n            anonymous: anonymous,\r\n            inputs: parseParams(match[2], true),\r\n            type: \"event\"\r\n        });\r\n    }\r\n\r\n    static isEventFragment(value: any): value is EventFragment {\r\n        return (value && value._isFragment && value.type === \"event\");\r\n    }\r\n}\r\n\r\nfunction parseGas(value: string, params: any): string {\r\n    params.gas = null;\r\n\r\n    let comps = value.split(\"@\");\r\n    if (comps.length !== 1) {\r\n        if (comps.length > 2) {\r\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\r\n        }\r\n        if (!comps[1].match(/^[0-9]+$/)) {\r\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\r\n        }\r\n        params.gas = BigNumber.from(comps[1]);\r\n        return comps[0];\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nfunction parseModifiers(value: string, params: any): void {\r\n    params.constant = false;\r\n    params.payable = false;\r\n    params.stateMutability = \"nonpayable\";\r\n\r\n    value.split(\" \").forEach((modifier) => {\r\n        switch (modifier.trim()) {\r\n            case \"constant\":\r\n                params.constant = true;\r\n                break;\r\n            case \"payable\":\r\n                params.payable = true;\r\n                params.stateMutability = \"payable\";\r\n                break;\r\n            case \"nonpayable\":\r\n                params.payable = false;\r\n                params.stateMutability = \"nonpayable\";\r\n                break;\r\n            case \"pure\":\r\n                params.constant = true;\r\n                params.stateMutability = \"pure\";\r\n                break;\r\n            case \"view\":\r\n                params.constant = true;\r\n                params.stateMutability = \"view\";\r\n                break;\r\n            case \"external\":\r\n            case \"public\":\r\n            case \"\":\r\n                break;\r\n            default:\r\n                console.log(\"unknown modifier: \" + modifier);\r\n        }\r\n    });\r\n}\r\n\r\ntype StateInputValue = {\r\n    constant?: boolean;\r\n    payable?: boolean;\r\n    stateMutability?: string;\r\n    type?: string;\r\n};\r\n\r\ntype StateOutputValue = {\r\n    constant: boolean;\r\n    payable: boolean;\r\n    stateMutability: string;\r\n};\r\n\r\nfunction verifyState(value: StateInputValue): StateOutputValue {\r\n    let result: any = {\r\n        constant: false,\r\n        payable: true,\r\n        stateMutability: \"payable\"\r\n    };\r\n\r\n    if (value.stateMutability != null) {\r\n        result.stateMutability = value.stateMutability;\r\n\r\n        // Set (and check things are consistent) the constant property\r\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\r\n        if (value.constant != null) {\r\n            if ((!!value.constant) !== result.constant) {\r\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\r\n            }\r\n        }\r\n\r\n        // Set (and check things are consistent) the payable property\r\n        result.payable = (result.stateMutability === \"payable\");\r\n        if (value.payable != null) {\r\n            if ((!!value.payable) !== result.payable) {\r\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\r\n            }\r\n        }\r\n\r\n    } else if (value.payable != null) {\r\n        result.payable = !!value.payable;\r\n\r\n        // If payable we can assume non-constant; otherwise we can't assume\r\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\r\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\r\n        }\r\n\r\n        result.constant = !!value.constant;\r\n\r\n        if (result.constant) {\r\n            result.stateMutability = \"view\";\r\n        } else {\r\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\r\n        }\r\n\r\n        if (result.payable && result.constant) {\r\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\r\n        }\r\n\r\n    } else if (value.constant != null) {\r\n        result.constant = !!value.constant;\r\n        result.payable = !result.constant;\r\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\r\n\r\n    } else if (value.type !== \"constructor\") {\r\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\ninterface _ConstructorFragment extends _Fragment {\r\n    stateMutability: string;\r\n    payable: boolean;\r\n    gas?: BigNumber;\r\n}\r\n\r\nexport class ConstructorFragment extends Fragment {\r\n    stateMutability: string;\r\n    payable: boolean;\r\n    gas?: BigNumber;\r\n\r\n    format(format?: string): string {\r\n        if (!format) { format = FormatTypes.sighash; }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"constructor\",\r\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\r\n                payable: this.payable,\r\n                gas: (this.gas ? this.gas.toNumber(): undefined),\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\r\n            });\r\n        }\r\n\r\n        if (format === FormatTypes.sighash) {\r\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"format(sighash)\"\r\n            });\r\n        }\r\n\r\n        let result = \"constructor(\" + this.inputs.map(\r\n            (input) => input.format(format)\r\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\r\n\r\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\r\n            result += this.stateMutability + \" \";\r\n        }\r\n\r\n        return result.trim();\r\n    }\r\n\r\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\r\n        if (typeof(value) === \"string\") {\r\n            return ConstructorFragment.fromString(value);\r\n        }\r\n        return ConstructorFragment.fromObject(value);\r\n    }\r\n\r\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\r\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\r\n\r\n        if (value.type !== \"constructor\") {\r\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\r\n        }\r\n\r\n        let state = verifyState(value);\r\n        if (state.constant) {\r\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\r\n        }\r\n\r\n        const params: TypeCheck<_ConstructorFragment> = {\r\n            name: null,\r\n            type: value.type,\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\r\n            payable: state.payable,\r\n            stateMutability: state.stateMutability,\r\n            gas: (value.gas ? BigNumber.from(value.gas): null)\r\n        };\r\n\r\n        return new ConstructorFragment(_constructorGuard, params);\r\n    }\r\n\r\n    static fromString(value: string): ConstructorFragment {\r\n        let params: any = { type: \"constructor\" };\r\n\r\n        value = parseGas(value, params);\r\n\r\n        let parens = value.match(regexParen);\r\n        if (!parens || parens[1].trim() !== \"constructor\") {\r\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\r\n        }\r\n\r\n        params.inputs = parseParams(parens[2].trim(), false);\r\n\r\n        parseModifiers(parens[3].trim(), params);\r\n\r\n        return ConstructorFragment.fromObject(params);\r\n    }\r\n\r\n    static isConstructorFragment(value: any): value is ConstructorFragment {\r\n        return (value && value._isFragment && value.type === \"constructor\");\r\n    }\r\n}\r\n\r\ninterface _FunctionFragment extends _ConstructorFragment {\r\n    constant: boolean;\r\n    outputs?: Array<ParamType>;\r\n}\r\n\r\nexport class FunctionFragment extends ConstructorFragment {\r\n    constant: boolean;\r\n    outputs?: Array<ParamType>;\r\n\r\n    format(format?: string): string {\r\n        if (!format) { format = FormatTypes.sighash; }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"function\",\r\n                name: this.name,\r\n                constant: this.constant,\r\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\r\n                payable: this.payable,\r\n                gas: (this.gas ? this.gas.toNumber(): undefined),\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\r\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\r\n            });\r\n        }\r\n\r\n        let result = \"\";\r\n\r\n        if (format !== FormatTypes.sighash) {\r\n            result += \"function \";\r\n        }\r\n\r\n        result += this.name + \"(\" + this.inputs.map(\r\n            (input) => input.format(format)\r\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\r\n\r\n        if (format !== FormatTypes.sighash) {\r\n            if (this.stateMutability) {\r\n                if (this.stateMutability !== \"nonpayable\") {\r\n                    result += (this.stateMutability + \" \");\r\n                }\r\n            } else if (this.constant) {\r\n                result += \"view \";\r\n            }\r\n\r\n            if (this.outputs && this.outputs.length) {\r\n                result += \"returns (\" + this.outputs.map(\r\n                    (output) => output.format(format)\r\n                ).join(\", \") + \") \";\r\n            }\r\n\r\n            if (this.gas != null) {\r\n                result += \"@\" + this.gas.toString() + \" \";\r\n            }\r\n        }\r\n\r\n        return result.trim();\r\n    }\r\n\r\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\r\n        if (typeof(value) === \"string\") {\r\n            return FunctionFragment.fromString(value);\r\n        }\r\n        return FunctionFragment.fromObject(value);\r\n    }\r\n\r\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\r\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\r\n\r\n        if (value.type !== \"function\") {\r\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\r\n        }\r\n\r\n        let state = verifyState(value);\r\n\r\n        const params: TypeCheck<_FunctionFragment> = {\r\n            type: value.type,\r\n            name: verifyIdentifier(value.name),\r\n            constant: state.constant,\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\r\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\r\n            payable: state.payable,\r\n            stateMutability: state.stateMutability,\r\n            gas: (value.gas ? BigNumber.from(value.gas): null)\r\n        };\r\n\r\n        return new FunctionFragment(_constructorGuard, params);\r\n    }\r\n\r\n    static fromString(value: string): FunctionFragment {\r\n        let params: any = { type: \"function\" };\r\n        value = parseGas(value, params);\r\n\r\n        let comps = value.split(\" returns \");\r\n        if (comps.length > 2) {\r\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\r\n        }\r\n\r\n        let parens = comps[0].match(regexParen);\r\n        if (!parens) {\r\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\r\n        }\r\n\r\n        params.name = parens[1].trim();\r\n        if (params.name) { verifyIdentifier(params.name); }\r\n\r\n        params.inputs = parseParams(parens[2], false);\r\n\r\n        parseModifiers(parens[3].trim(), params);\r\n\r\n        // We have outputs\r\n        if (comps.length > 1) {\r\n           let returns = comps[1].match(regexParen);\r\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\r\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\r\n            }\r\n            params.outputs = parseParams(returns[2], false);\r\n        } else {\r\n            params.outputs = [ ];\r\n        }\r\n\r\n        return FunctionFragment.fromObject(params);\r\n    }\r\n\r\n    static isFunctionFragment(value: any): value is FunctionFragment {\r\n        return (value && value._isFragment && value.type === \"function\");\r\n    }\r\n}\r\n\r\n//export class StructFragment extends Fragment {\r\n//}\r\n\r\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\r\n    const sig = fragment.format();\r\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\r\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\r\n    }\r\n    return fragment;\r\n}\r\n\r\nexport class ErrorFragment extends Fragment {\r\n\r\n    format(format?: string): string {\r\n        if (!format) { format = FormatTypes.sighash; }\r\n        if (!FormatTypes[format]) {\r\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\r\n        }\r\n\r\n        if (format === FormatTypes.json) {\r\n            return JSON.stringify({\r\n                type: \"error\",\r\n                name: this.name,\r\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\r\n            });\r\n        }\r\n\r\n        let result = \"\";\r\n\r\n        if (format !== FormatTypes.sighash) {\r\n            result += \"error \";\r\n        }\r\n\r\n        result += this.name + \"(\" + this.inputs.map(\r\n            (input) => input.format(format)\r\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\r\n\r\n        return result.trim();\r\n    }\r\n\r\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\r\n        if (typeof(value) === \"string\") {\r\n            return ErrorFragment.fromString(value);\r\n        }\r\n        return ErrorFragment.fromObject(value);\r\n    }\r\n\r\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\r\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\r\n\r\n        if (value.type !== \"error\") {\r\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\r\n        }\r\n\r\n        const params: TypeCheck<_Fragment> = {\r\n            type: value.type,\r\n            name: verifyIdentifier(value.name),\r\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\r\n        };\r\n\r\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\r\n    }\r\n\r\n    static fromString(value: string): ErrorFragment {\r\n        let params: any = { type: \"error\" };\r\n\r\n        let parens = value.match(regexParen);\r\n        if (!parens) {\r\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\r\n        }\r\n\r\n        params.name = parens[1].trim();\r\n        if (params.name) { verifyIdentifier(params.name); }\r\n\r\n        params.inputs = parseParams(parens[2], false);\r\n\r\n        return checkForbidden(ErrorFragment.fromObject(params));\r\n    }\r\n\r\n    static isErrorFragment(value: any): value is ErrorFragment {\r\n        return (value && value._isFragment && value.type === \"error\");\r\n    }\r\n}\r\n\r\nfunction verifyType(type: string): string {\r\n\r\n    // These need to be transformed to their full description\r\n    if (type.match(/^uint($|[^1-9])/)) {\r\n        type = \"uint256\" + type.substring(4);\r\n    } else if (type.match(/^int($|[^1-9])/)) {\r\n        type = \"int256\" + type.substring(3);\r\n    }\r\n\r\n    // @TODO: more verification\r\n\r\n    return type;\r\n}\r\n\r\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\r\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\r\nfunction verifyIdentifier(value: string): string {\r\n    if (!value || !value.match(regexIdentifier)) {\r\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\r\n    }\r\n    return value;\r\n}\r\n\r\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\r\n\r\nfunction splitNesting(value: string): Array<any> {\r\n    value = value.trim();\r\n\r\n    let result = [];\r\n    let accum = \"\";\r\n    let depth = 0;\r\n    for (let offset = 0; offset < value.length; offset++) {\r\n        let c = value[offset];\r\n        if (c === \",\" && depth === 0) {\r\n            result.push(accum);\r\n            accum = \"\";\r\n        } else {\r\n            accum += c;\r\n            if (c === \"(\") {\r\n                depth++;\r\n            } else if (c === \")\") {\r\n                depth--;\r\n                if (depth === -1) {\r\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (accum) { result.push(accum); }\r\n\r\n    return result;\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"../_version\";\r\nconst logger = new Logger(version);\r\n\r\nexport interface Result extends ReadonlyArray<any> {\r\n    readonly [key: string]: any;\r\n}\r\n\r\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\r\n    // Find the first error (if any)\r\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\r\n\r\n    const checkErrors = function(path: Array<string | number>, object: any): void {\r\n        if (!Array.isArray(object)) { return; }\r\n        for (let key in object) {\r\n            const childPath = path.slice();\r\n            childPath.push(key);\r\n\r\n            try {\r\n                 checkErrors(childPath, object[key]);\r\n            } catch (error) {\r\n                errors.push({ path: childPath, error: error });\r\n            }\r\n        }\r\n    }\r\n    checkErrors([ ], result);\r\n\r\n    return errors;\r\n\r\n}\r\n\r\nexport type CoerceFunc = (type: string, value: any) => any;\r\n\r\nexport abstract class Coder {\r\n\r\n    // The coder name:\r\n    //   - address, uint256, tuple, array, etc.\r\n    readonly name: string;\r\n\r\n    // The fully expanded type, including composite types:\r\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\r\n    readonly type: string;\r\n\r\n    // The localName bound in the signature, in this example it is \"baz\":\r\n    //   - tuple(address foo, uint bar) baz\r\n    readonly localName: string;\r\n\r\n    // Whether this type is dynamic:\r\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\r\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\r\n    readonly dynamic: boolean;\r\n\r\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\r\n        // @TODO: defineReadOnly these\r\n        this.name = name;\r\n        this.type = type;\r\n        this.localName = localName;\r\n        this.dynamic = dynamic;\r\n    }\r\n\r\n    _throwError(message: string, value: any): void {\r\n        logger.throwArgumentError(message, this.localName, value);\r\n    }\r\n\r\n    abstract encode(writer: Writer, value: any): number;\r\n    abstract decode(reader: Reader): any;\r\n\r\n    abstract defaultValue(): any;\r\n}\r\n\r\nexport class Writer {\r\n    readonly wordSize: number;\r\n\r\n    _data: Array<Uint8Array>;\r\n    _dataLength: number;\r\n    _padding: Uint8Array;\r\n\r\n    constructor(wordSize?: number) {\r\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\r\n        this._data = [ ];\r\n        this._dataLength = 0;\r\n        this._padding = new Uint8Array(wordSize);\r\n    }\r\n\r\n    get data(): string {\r\n        return hexConcat(this._data);\r\n    }\r\n    get length(): number { return this._dataLength; }\r\n\r\n    _writeData(data: Uint8Array): number {\r\n        this._data.push(data);\r\n        this._dataLength += data.length;\r\n        return data.length;\r\n    }\r\n\r\n    appendWriter(writer: Writer): number {\r\n        return this._writeData(concat(writer._data));\r\n    }\r\n\r\n    // Arrayish items; padded on the right to wordSize\r\n    writeBytes(value: BytesLike): number {\r\n        let bytes = arrayify(value);\r\n        const paddingOffset = bytes.length % this.wordSize;\r\n        if (paddingOffset) {\r\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\r\n        }\r\n        return this._writeData(bytes);\r\n    }\r\n\r\n    _getValue(value: BigNumberish): Uint8Array {\r\n        let bytes = arrayify(BigNumber.from(value));\r\n        if (bytes.length > this.wordSize) {\r\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\r\n                length: this.wordSize,\r\n                offset: bytes.length\r\n            });\r\n        }\r\n        if (bytes.length % this.wordSize) {\r\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\r\n        }\r\n        return bytes;\r\n    }\r\n\r\n    // BigNumberish items; padded on the left to wordSize\r\n    writeValue(value: BigNumberish): number {\r\n        return this._writeData(this._getValue(value));\r\n    }\r\n\r\n    writeUpdatableValue(): (value: BigNumberish) => void {\r\n        const offset = this._data.length;\r\n        this._data.push(this._padding);\r\n        this._dataLength += this.wordSize;\r\n        return (value: BigNumberish) => {\r\n            this._data[offset] = this._getValue(value);\r\n        };\r\n    }\r\n}\r\n\r\nexport class Reader {\r\n    readonly wordSize: number;\r\n    readonly allowLoose: boolean;\r\n\r\n    readonly _data: Uint8Array;\r\n    readonly _coerceFunc: CoerceFunc;\r\n\r\n    _offset: number;\r\n\r\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\r\n        defineReadOnly(this, \"_data\", arrayify(data));\r\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\r\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\r\n        defineReadOnly(this, \"allowLoose\", allowLoose);\r\n\r\n        this._offset = 0;\r\n    }\r\n\r\n    get data(): string { return hexlify(this._data); }\r\n    get consumed(): number { return this._offset; }\r\n\r\n    // The default Coerce function\r\n    static coerce(name: string, value: any): any {\r\n        let match = name.match(\"^u?int([0-9]+)$\");\r\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\r\n        return value;\r\n    }\r\n\r\n    coerce(name: string, value: any): any {\r\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\r\n        return Reader.coerce(name, value);\r\n    }\r\n\r\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\r\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\r\n        if (this._offset + alignedLength > this._data.length) {\r\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\r\n                alignedLength = length;\r\n            } else {\r\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\r\n                    length: this._data.length,\r\n                    offset: this._offset + alignedLength\r\n                });\r\n            }\r\n        }\r\n        return this._data.slice(this._offset, this._offset + alignedLength)\r\n    }\r\n\r\n    subReader(offset: number): Reader {\r\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\r\n    }\r\n\r\n    readBytes(length: number, loose?: boolean): Uint8Array {\r\n        let bytes = this._peekBytes(0, length, !!loose);\r\n        this._offset += bytes.length;\r\n        // @TODO: Make sure the length..end bytes are all 0?\r\n        return bytes.slice(0, length);\r\n    }\r\n\r\n    readValue(): BigNumber {\r\n        return BigNumber.from(this.readBytes(this.wordSize));\r\n    }\r\n}\r\n", "\"use strict\";\r\n\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { hexZeroPad } from \"@ethersproject/bytes\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\nexport class AddressCoder extends Coder {\r\n\r\n    constructor(localName: string) {\r\n        super(\"address\", \"address\", localName, false);\r\n    }\r\n\r\n    defaultValue(): string {\r\n        return \"0x0000000000000000000000000000000000000000\";\r\n    }\r\n\r\n    encode(writer: Writer, value: string): number {\r\n        try {\r\n            value = getAddress(value)\r\n        } catch (error) {\r\n            this._throwError(error.message, value);\r\n        }\r\n        return writer.writeValue(value);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\r\n    }\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\n// Clones the functionality of an existing Coder, but without a localName\r\nexport class AnonymousCoder extends Coder {\r\n    private coder: Coder;\r\n\r\n    constructor(coder: Coder) {\r\n        super(coder.name, coder.type, undefined, coder.dynamic);\r\n        this.coder = coder;\r\n    }\r\n\r\n    defaultValue(): any {\r\n        return this.coder.defaultValue();\r\n    }\r\n\r\n    encode(writer: Writer, value: any): number {\r\n        return this.coder.encode(writer, value);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return this.coder.decode(reader);\r\n    }\r\n}\r\n", "\"use strict\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"../_version\";\r\nconst logger = new Logger(version);\r\n\r\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\r\nimport { AnonymousCoder } from \"./anonymous\";\r\n\r\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\r\n    let arrayValues: Array<any> = null;\r\n\r\n    if (Array.isArray(values)) {\r\n       arrayValues = values;\r\n\r\n    } else if (values && typeof(values) === \"object\") {\r\n        let unique: { [ name: string ]: boolean } = { };\r\n\r\n        arrayValues = coders.map((coder) => {\r\n            const name = coder.localName;\r\n            if (!name) {\r\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\r\n                    argument: \"values\",\r\n                    coder: coder,\r\n                    value: values\r\n                });\r\n            }\r\n\r\n            if (unique[name]) {\r\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\r\n                    argument: \"values\",\r\n                    coder: coder,\r\n                    value: values\r\n                });\r\n            }\r\n\r\n            unique[name] = true;\r\n\r\n            return values[name];\r\n        });\r\n\r\n    } else {\r\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\r\n    }\r\n\r\n    if (coders.length !== arrayValues.length) {\r\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\r\n    }\r\n\r\n    let staticWriter = new Writer(writer.wordSize);\r\n    let dynamicWriter = new Writer(writer.wordSize);\r\n\r\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\r\n    coders.forEach((coder, index) => {\r\n        let value = arrayValues[index];\r\n\r\n        if (coder.dynamic) {\r\n            // Get current dynamic offset (for the future pointer)\r\n            let dynamicOffset = dynamicWriter.length;\r\n\r\n            // Encode the dynamic value into the dynamicWriter\r\n            coder.encode(dynamicWriter, value);\r\n\r\n            // Prepare to populate the correct offset once we are done\r\n            let updateFunc = staticWriter.writeUpdatableValue();\r\n            updateFuncs.push((baseOffset: number) => {\r\n                updateFunc(baseOffset + dynamicOffset);\r\n            });\r\n\r\n        } else {\r\n            coder.encode(staticWriter, value);\r\n        }\r\n    });\r\n\r\n    // Backfill all the dynamic offsets, now that we know the static length\r\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\r\n\r\n    let length = writer.appendWriter(staticWriter);\r\n    length += writer.appendWriter(dynamicWriter);\r\n    return length;\r\n}\r\n\r\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\r\n    let values: any = [];\r\n\r\n    // A reader anchored to this base\r\n    let baseReader = reader.subReader(0);\r\n\r\n    coders.forEach((coder) => {\r\n        let value: any = null;\r\n\r\n        if (coder.dynamic) {\r\n            let offset = reader.readValue();\r\n            let offsetReader = baseReader.subReader(offset.toNumber());\r\n            try {\r\n                value = coder.decode(offsetReader);\r\n            } catch (error) {\r\n                // Cannot recover from this\r\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\r\n                value = error;\r\n                value.baseType = coder.name;\r\n                value.name = coder.localName;\r\n                value.type = coder.type;\r\n            }\r\n\r\n        } else {\r\n            try {\r\n                value = coder.decode(reader);\r\n            } catch (error) {\r\n                // Cannot recover from this\r\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\r\n                value = error;\r\n                value.baseType = coder.name;\r\n                value.name = coder.localName;\r\n                value.type = coder.type;\r\n            }\r\n        }\r\n\r\n        if (value != undefined) {\r\n            values.push(value);\r\n        }\r\n    });\r\n\r\n    // We only output named properties for uniquely named coders\r\n    const uniqueNames = coders.reduce((accum, coder) => {\r\n        const name = coder.localName;\r\n        if (name) {\r\n            if (!accum[name]) { accum[name] = 0; }\r\n            accum[name]++;\r\n        }\r\n        return accum;\r\n    }, <{ [ name: string ]: number }>{ });\r\n\r\n    // Add any named parameters (i.e. tuples)\r\n    coders.forEach((coder: Coder, index: number) => {\r\n        let name = coder.localName;\r\n        if (!name || uniqueNames[name] !== 1) { return; }\r\n\r\n        if (name === \"length\") { name = \"_length\"; }\r\n\r\n        if (values[name] != null) { return; }\r\n\r\n        const value = values[index];\r\n\r\n        if (value instanceof Error) {\r\n            Object.defineProperty(values, name, {\r\n                enumerable: true,\r\n                get: () => { throw value; }\r\n            });\r\n        } else {\r\n            values[name] = value;\r\n        }\r\n    });\r\n\r\n    for (let i = 0; i < values.length; i++) {\r\n        const value = values[i];\r\n        if (value instanceof Error) {\r\n            Object.defineProperty(values, i, {\r\n                enumerable: true,\r\n                get: () => { throw value; }\r\n            });\r\n        }\r\n    }\r\n\r\n    return Object.freeze(values);\r\n}\r\n\r\n\r\nexport class ArrayCoder extends Coder {\r\n    readonly coder: Coder;\r\n    readonly length: number;\r\n\r\n    constructor(coder: Coder, length: number, localName: string) {\r\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\r\n        const dynamic = (length === -1 || coder.dynamic);\r\n        super(\"array\", type, localName, dynamic);\r\n\r\n        this.coder = coder;\r\n        this.length = length;\r\n    }\r\n\r\n    defaultValue(): Array<any> {\r\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\r\n        const defaultChild = this.coder.defaultValue();\r\n\r\n        const result: Array<any> = [];\r\n        for (let i = 0; i < this.length; i++) {\r\n            result.push(defaultChild);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    encode(writer: Writer, value: Array<any>): number {\r\n        if (!Array.isArray(value)) {\r\n            this._throwError(\"expected array value\", value);\r\n        }\r\n\r\n        let count = this.length;\r\n\r\n        if (count === -1) {\r\n            count = value.length;\r\n            writer.writeValue(value.length);\r\n        }\r\n\r\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\r\n\r\n        let coders = [];\r\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\r\n\r\n        return pack(writer, coders, value);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        let count = this.length;\r\n        if (count === -1) {\r\n            count = reader.readValue().toNumber();\r\n\r\n            // Check that there is *roughly* enough data to ensure\r\n            // stray random data is not being read as a length. Each\r\n            // slot requires at least 32 bytes for their value (or 32\r\n            // bytes as a link to the data). This could use a much\r\n            // tighter bound, but we are erroring on the side of safety.\r\n            if (count * 32 > reader._data.length) {\r\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\r\n                    length: reader._data.length,\r\n                    count: count\r\n                });\r\n            }\r\n        }\r\n        let coders = [];\r\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\r\n\r\n        return reader.coerce(this.name, unpack(reader, coders));\r\n    }\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\nexport class BooleanCoder extends Coder {\r\n\r\n    constructor(localName: string) {\r\n        super(\"bool\", \"bool\", localName, false);\r\n    }\r\n\r\n    defaultValue(): boolean {\r\n        return false;\r\n    }\r\n\r\n    encode(writer: Writer, value: boolean): number {\r\n        return writer.writeValue(value ? 1: 0);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return reader.coerce(this.type, !reader.readValue().isZero());\r\n    }\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\nexport class DynamicBytesCoder extends Coder {\r\n    constructor(type: string, localName: string) {\r\n       super(type, type, localName, true);\r\n    }\r\n\r\n    defaultValue(): string {\r\n        return \"0x\";\r\n    }\r\n\r\n    encode(writer: Writer, value: any): number {\r\n        value = arrayify(value);\r\n        let length = writer.writeValue(value.length);\r\n        length += writer.writeBytes(value);\r\n        return length;\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return reader.readBytes(reader.readValue().toNumber(), true);\r\n    }\r\n}\r\n\r\nexport class BytesCoder extends DynamicBytesCoder {\r\n    constructor(localName: string) {\r\n        super(\"bytes\", localName);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\r\n    }\r\n}\r\n\r\n\r\n", "\"use strict\";\r\n\r\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\n// @TODO: Merge this with bytes\r\nexport class FixedBytesCoder extends Coder {\r\n    readonly size: number;\r\n\r\n    constructor(size: number, localName: string) {\r\n        let name = \"bytes\" + String(size);\r\n        super(name, name, localName, false);\r\n        this.size = size;\r\n    }\r\n\r\n    defaultValue(): string {\r\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\r\n    }\r\n\r\n    encode(writer: Writer, value: BytesLike): number {\r\n        let data = arrayify(value);\r\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\r\n        return writer.writeBytes(data);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\r\n    }\r\n}\r\n", "\"use strict\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\nexport class NullCoder extends Coder {\r\n\r\n    constructor(localName: string) {\r\n        super(\"null\", \"\", localName, false);\r\n    }\r\n\r\n    defaultValue(): null {\r\n        return null;\r\n    }\r\n\r\n    encode(writer: Writer, value: any): number {\r\n        if (value != null) { this._throwError(\"not null\", value); }\r\n        return writer.writeBytes([ ]);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        reader.readBytes(0);\r\n        return reader.coerce(this.name, null);\r\n    }\r\n}\r\n", "\"use strict\";\r\n\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\n\r\nexport class NumberCoder extends Coder {\r\n    readonly size: number;\r\n    readonly signed: boolean;\r\n\r\n    constructor(size: number, signed: boolean, localName: string) {\r\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\r\n        super(name, name, localName, false);\r\n\r\n        this.size = size;\r\n        this.signed = signed;\r\n    }\r\n\r\n    defaultValue(): number {\r\n        return 0;\r\n    }\r\n\r\n    encode(writer: Writer, value: BigNumberish): number {\r\n        let v = BigNumber.from(value);\r\n\r\n        // Check bounds are safe for encoding\r\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\r\n        if (this.signed) {\r\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\r\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\r\n                this._throwError(\"value out-of-bounds\", value);\r\n            }\r\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\r\n            this._throwError(\"value out-of-bounds\", value);\r\n        }\r\n\r\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\r\n\r\n        if (this.signed) {\r\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\r\n        }\r\n\r\n        return writer.writeValue(v);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        let value = reader.readValue().mask(this.size * 8);\r\n\r\n        if (this.signed) {\r\n            value = value.fromTwos(this.size * 8);\r\n        }\r\n\r\n        return reader.coerce(this.name, value);\r\n    }\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\r\n\r\nimport { Reader, Writer } from \"./abstract-coder\";\r\nimport { DynamicBytesCoder } from \"./bytes\";\r\n\r\nexport class StringCoder extends DynamicBytesCoder {\r\n\r\n    constructor(localName: string) {\r\n        super(\"string\", localName);\r\n    }\r\n\r\n    defaultValue(): string {\r\n        return \"\";\r\n    }\r\n\r\n    encode(writer: Writer, value: any): number {\r\n        return super.encode(writer, toUtf8Bytes(value));\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return toUtf8String(super.decode(reader));\r\n    }\r\n}\r\n", "\"use strict\";\r\n\r\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\r\nimport { pack, unpack } from \"./array\";\r\n\r\nexport class TupleCoder extends Coder {\r\n    readonly coders: Array<Coder>;\r\n\r\n    constructor(coders: Array<Coder>, localName: string) {\r\n        let dynamic = false;\r\n        const types: Array<string> = [];\r\n        coders.forEach((coder) => {\r\n            if (coder.dynamic) { dynamic = true; }\r\n            types.push(coder.type);\r\n        });\r\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\r\n\r\n        super(\"tuple\", type, localName, dynamic);\r\n        this.coders = coders;\r\n    }\r\n\r\n    defaultValue(): any {\r\n        const values: any = [ ];\r\n        this.coders.forEach((coder) => {\r\n            values.push(coder.defaultValue());\r\n        });\r\n\r\n        // We only output named properties for uniquely named coders\r\n        const uniqueNames = this.coders.reduce((accum, coder) => {\r\n            const name = coder.localName;\r\n            if (name) {\r\n                if (!accum[name]) { accum[name] = 0; }\r\n                accum[name]++;\r\n            }\r\n            return accum;\r\n        }, <{ [ name: string ]: number }>{ });\r\n\r\n        // Add named values\r\n        this.coders.forEach((coder: Coder, index: number) => {\r\n            let name = coder.localName;\r\n            if (!name || uniqueNames[name] !== 1) { return; }\r\n\r\n            if (name === \"length\") { name = \"_length\"; }\r\n\r\n            if (values[name] != null) { return; }\r\n\r\n            values[name] = values[index];\r\n        });\r\n\r\n        return Object.freeze(values);\r\n    }\r\n\r\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\r\n        return pack(writer, this.coders, value);\r\n    }\r\n\r\n    decode(reader: Reader): any {\r\n        return reader.coerce(this.name, unpack(reader, this.coders));\r\n    }\r\n}\r\n\r\n", "\"use strict\";\r\n\r\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\r\n\r\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\r\nimport { AddressCoder } from \"./coders/address\";\r\nimport { ArrayCoder } from \"./coders/array\";\r\nimport { BooleanCoder } from \"./coders/boolean\";\r\nimport { BytesCoder } from \"./coders/bytes\";\r\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\r\nimport { NullCoder } from \"./coders/null\";\r\nimport { NumberCoder } from \"./coders/number\";\r\nimport { StringCoder } from \"./coders/string\";\r\nimport { TupleCoder } from \"./coders/tuple\";\r\n\r\nimport { ParamType } from \"./fragments\";\r\n\r\n\r\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\r\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\r\n\r\n\r\nexport type CoerceFunc = (type: string, value: any) => any;\r\n\r\nexport class AbiCoder {\r\n    readonly coerceFunc: CoerceFunc;\r\n\r\n    constructor(coerceFunc?: CoerceFunc) {\r\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\r\n    }\r\n\r\n    _getCoder(param: ParamType): Coder {\r\n\r\n        switch (param.baseType) {\r\n            case \"address\":\r\n                return new AddressCoder(param.name);\r\n            case \"bool\":\r\n                return new BooleanCoder(param.name);\r\n            case \"string\":\r\n                return new StringCoder(param.name);\r\n            case \"bytes\":\r\n                return new BytesCoder(param.name);\r\n            case \"array\":\r\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\r\n            case \"tuple\":\r\n                return new TupleCoder((param.components || []).map((component) => {\r\n                    return this._getCoder(component);\r\n                }), param.name);\r\n            case \"\":\r\n                return new NullCoder(param.name);\r\n        }\r\n\r\n        // u?int[0-9]*\r\n        let match = param.type.match(paramTypeNumber);\r\n        if (match) {\r\n            let size = parseInt(match[2] || \"256\");\r\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\r\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\r\n            }\r\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\r\n        }\r\n\r\n        // bytes[0-9]+\r\n        match = param.type.match(paramTypeBytes);\r\n        if (match) {\r\n            let size = parseInt(match[1]);\r\n            if (size === 0 || size > 32) {\r\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\r\n            }\r\n            return new FixedBytesCoder(size, param.name);\r\n        }\r\n\r\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\r\n    }\r\n\r\n    _getWordSize(): number { return 32; }\r\n\r\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\r\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\r\n    }\r\n\r\n    _getWriter(): Writer {\r\n        return new Writer(this._getWordSize());\r\n    }\r\n\r\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\r\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\r\n        const coder = new TupleCoder(coders, \"_\");\r\n        return coder.defaultValue();\r\n    }\r\n\r\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\r\n        if (types.length !== values.length) {\r\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\r\n                count: { types: types.length, values: values.length },\r\n                value: { types: types, values: values }\r\n            });\r\n        }\r\n\r\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\r\n        const coder = (new TupleCoder(coders, \"_\"));\r\n\r\n        const writer = this._getWriter();\r\n        coder.encode(writer, values);\r\n        return writer.data;\r\n    }\r\n\r\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\r\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\r\n        const coder = new TupleCoder(coders, \"_\");\r\n        return coder.decode(this._getReader(arrayify(data), loose));\r\n    }\r\n}\r\n\r\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\r\n\r\n", "\"use strict\";\r\n\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\r\nimport { id } from \"@ethersproject/hash\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\"\r\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\r\n\r\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\r\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\r\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nexport { checkResultErrors, Result };\r\n\r\nexport class LogDescription extends Description<LogDescription> {\r\n    readonly eventFragment: EventFragment;\r\n    readonly name: string;\r\n    readonly signature: string;\r\n    readonly topic: string;\r\n    readonly args: Result\r\n}\r\n\r\nexport class TransactionDescription extends Description<TransactionDescription> {\r\n    readonly functionFragment: FunctionFragment;\r\n    readonly name: string;\r\n    readonly args: Result;\r\n    readonly signature: string;\r\n    readonly sighash: string;\r\n    readonly value: BigNumber;\r\n}\r\n\r\nexport class ErrorDescription extends Description<ErrorDescription> {\r\n    readonly errorFragment: ErrorFragment;\r\n    readonly name: string;\r\n    readonly args: Result;\r\n    readonly signature: string;\r\n    readonly sighash: string;\r\n}\r\n\r\nexport class Indexed extends Description<Indexed> {\r\n    readonly hash: string;\r\n    readonly _isIndexed: boolean;\r\n\r\n    static isIndexed(value: any): value is Indexed {\r\n        return !!(value && value._isIndexed);\r\n    }\r\n}\r\n\r\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\r\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\r\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\r\n}\r\n\r\nfunction wrapAccessError(property: string, error: Error): Error {\r\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\r\n    (<any>wrap).error = error;\r\n    return wrap;\r\n}\r\n\r\n/*\r\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\r\n    params.reduce((accum, param) => {\r\n        if (param.name) {\r\n            if (accum[param.name]) {\r\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\r\n            }\r\n            accum[param.name] = true;\r\n        }\r\n        return accum;\r\n    }, <{ [ name: string ]: boolean }>{ });\r\n}\r\n*/\r\nexport class Interface {\r\n    readonly fragments: ReadonlyArray<Fragment>;\r\n\r\n    readonly errors: { [ name: string ]: ErrorFragment };\r\n    readonly events: { [ name: string ]: EventFragment };\r\n    readonly functions: { [ name: string ]: FunctionFragment };\r\n    readonly structs: { [ name: string ]: any };\r\n\r\n    readonly deploy: ConstructorFragment;\r\n\r\n    readonly _abiCoder: AbiCoder;\r\n\r\n    readonly _isInterface: boolean;\r\n\r\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\r\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\r\n        if (typeof(fragments) === \"string\") {\r\n            abi = JSON.parse(fragments);\r\n        } else {\r\n            abi = fragments;\r\n        }\r\n\r\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\r\n            return Fragment.from(fragment);\r\n        }).filter((fragment) => (fragment != null)));\r\n\r\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\r\n\r\n        defineReadOnly(this, \"functions\", { });\r\n        defineReadOnly(this, \"errors\", { });\r\n        defineReadOnly(this, \"events\", { });\r\n        defineReadOnly(this, \"structs\", { });\r\n\r\n        // Add all fragments by their signature\r\n        this.fragments.forEach((fragment) => {\r\n            let bucket: { [ name: string ]: Fragment } = null;\r\n            switch (fragment.type) {\r\n                case \"constructor\":\r\n                    if (this.deploy) {\r\n                        logger.warn(\"duplicate definition - constructor\");\r\n                        return;\r\n                    }\r\n                    //checkNames(fragment, \"input\", fragment.inputs);\r\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\r\n                    return;\r\n                case \"function\":\r\n                    //checkNames(fragment, \"input\", fragment.inputs);\r\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\r\n                    bucket = this.functions;\r\n                    break;\r\n                case \"event\":\r\n                    //checkNames(fragment, \"input\", fragment.inputs);\r\n                    bucket = this.events;\r\n                    break;\r\n                case \"error\":\r\n                    bucket = this.errors;\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n\r\n            let signature = fragment.format();\r\n            if (bucket[signature]) {\r\n                logger.warn(\"duplicate definition - \" + signature);\r\n                return;\r\n            }\r\n\r\n            bucket[signature] = fragment;\r\n        });\r\n\r\n        // If we do not have a constructor add a default\r\n        if (!this.deploy) {\r\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\r\n                payable: false,\r\n                type: \"constructor\"\r\n            }));\r\n        }\r\n\r\n        defineReadOnly(this, \"_isInterface\", true);\r\n    }\r\n\r\n    format(format?: string): string | Array<string> {\r\n        if (!format) { format = FormatTypes.full; }\r\n        if (format === FormatTypes.sighash) {\r\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\r\n        }\r\n\r\n        const abi = this.fragments.map((fragment) => fragment.format(format));\r\n\r\n        // We need to re-bundle the JSON fragments a bit\r\n        if (format === FormatTypes.json) {\r\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\r\n        }\r\n\r\n        return abi;\r\n    }\r\n\r\n    // Sub-classes can override these to handle other blockchains\r\n    static getAbiCoder(): AbiCoder {\r\n        return defaultAbiCoder;\r\n    }\r\n\r\n    static getAddress(address: string): string {\r\n        return getAddress(address);\r\n    }\r\n\r\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\r\n        return hexDataSlice(id(fragment.format()), 0, 4);\r\n    }\r\n\r\n    static getEventTopic(eventFragment: EventFragment): string {\r\n        return id(eventFragment.format());\r\n    }\r\n\r\n    // Find a function definition by any means necessary (unless it is ambiguous)\r\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\r\n        if (isHexString(nameOrSignatureOrSighash)) {\r\n            for (const name in this.functions) {\r\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\r\n                    return this.functions[name];\r\n                }\r\n            }\r\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\r\n        }\r\n\r\n        // It is a bare name, look up the function (will return null if ambiguous)\r\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\r\n            const name = nameOrSignatureOrSighash.trim();\r\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\r\n            if (matching.length === 0) {\r\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\r\n            } else if (matching.length > 1) {\r\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\r\n            }\r\n\r\n            return this.functions[matching[0]];\r\n        }\r\n\r\n        // Normalize the signature and lookup the function\r\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\r\n        if (!result) {\r\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Find an event definition by any means necessary (unless it is ambiguous)\r\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\r\n        if (isHexString(nameOrSignatureOrTopic)) {\r\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\r\n            for (const name in this.events) {\r\n                if (topichash === this.getEventTopic(name)) {\r\n                    return this.events[name];\r\n                }\r\n            }\r\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\r\n        }\r\n\r\n        // It is a bare name, look up the function (will return null if ambiguous)\r\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\r\n            const name = nameOrSignatureOrTopic.trim();\r\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\r\n            if (matching.length === 0) {\r\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\r\n            } else if (matching.length > 1) {\r\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\r\n            }\r\n\r\n            return this.events[matching[0]];\r\n        }\r\n\r\n        // Normalize the signature and lookup the function\r\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\r\n        if (!result) {\r\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Find a function definition by any means necessary (unless it is ambiguous)\r\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\r\n        if (isHexString(nameOrSignatureOrSighash)) {\r\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\r\n            for (const name in this.errors) {\r\n                const error = this.errors[name];\r\n                if (nameOrSignatureOrSighash === getSighash(error)) {\r\n                    return this.errors[name];\r\n                }\r\n            }\r\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\r\n        }\r\n\r\n        // It is a bare name, look up the function (will return null if ambiguous)\r\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\r\n            const name = nameOrSignatureOrSighash.trim();\r\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\r\n            if (matching.length === 0) {\r\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\r\n            } else if (matching.length > 1) {\r\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\r\n            }\r\n\r\n            return this.errors[matching[0]];\r\n        }\r\n\r\n        // Normalize the signature and lookup the function\r\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\r\n        if (!result) {\r\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\r\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\r\n        if (typeof(fragment) === \"string\") {\r\n            try {\r\n                fragment = this.getFunction(fragment);\r\n            } catch (error) {\r\n                try {\r\n                    fragment = this.getError(<string>fragment);\r\n                } catch (_) {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n\r\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\r\n    }\r\n\r\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\r\n    getEventTopic(eventFragment: EventFragment | string): string {\r\n        if (typeof(eventFragment) === \"string\") {\r\n            eventFragment = this.getEvent(eventFragment);\r\n        }\r\n\r\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\r\n    }\r\n\r\n\r\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\r\n        return this._abiCoder.decode(params, data)\r\n    }\r\n\r\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\r\n        return this._abiCoder.encode(params, values)\r\n    }\r\n\r\n    encodeDeploy(values?: ReadonlyArray<any>): string {\r\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\r\n    }\r\n\r\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\r\n        if (typeof(fragment) === \"string\") {\r\n            fragment = this.getError(fragment);\r\n        }\r\n\r\n        const bytes = arrayify(data);\r\n\r\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\r\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\r\n        }\r\n\r\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\r\n    }\r\n\r\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\r\n        if (typeof(fragment) === \"string\") {\r\n            fragment = this.getError(fragment);\r\n        }\r\n\r\n        return hexlify(concat([\r\n            this.getSighash(fragment),\r\n            this._encodeParams(fragment.inputs, values || [ ])\r\n        ]));\r\n    }\r\n\r\n    // Decode the data for a function call (e.g. tx.data)\r\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\r\n        if (typeof(functionFragment) === \"string\") {\r\n            functionFragment = this.getFunction(functionFragment);\r\n        }\r\n\r\n        const bytes = arrayify(data);\r\n\r\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\r\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\r\n        }\r\n\r\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\r\n    }\r\n\r\n    // Encode the data for a function call (e.g. tx.data)\r\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\r\n        if (typeof(functionFragment) === \"string\") {\r\n            functionFragment = this.getFunction(functionFragment);\r\n        }\r\n\r\n        return hexlify(concat([\r\n            this.getSighash(functionFragment),\r\n            this._encodeParams(functionFragment.inputs, values || [ ])\r\n        ]));\r\n    }\r\n\r\n    // Decode the result from a function call (e.g. from eth_call)\r\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\r\n        if (typeof(functionFragment) === \"string\") {\r\n            functionFragment = this.getFunction(functionFragment);\r\n        }\r\n\r\n        let bytes = arrayify(data);\r\n\r\n        let reason: string = null;\r\n        let message = \"\";\r\n        let errorArgs: Result = null;\r\n        let errorName: string = null;\r\n        let errorSignature: string = null;\r\n        switch (bytes.length % this._abiCoder._getWordSize()) {\r\n            case 0:\r\n                try {\r\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\r\n                } catch (error) { }\r\n                break;\r\n\r\n            case 4: {\r\n                const selector = hexlify(bytes.slice(0, 4));\r\n                const builtin = BuiltinErrors[selector];\r\n                if (builtin) {\r\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\r\n                    errorName = builtin.name;\r\n                    errorSignature = builtin.signature;\r\n                    if (builtin.reason) { reason = errorArgs[0]; }\r\n                    if (errorName === \"Error\") {\r\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\r\n                    } else if (errorName === \"Panic\") {\r\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\r\n                    }\r\n                } else {\r\n                    try {\r\n                        const error = this.getError(selector);\r\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\r\n                        errorName = error.name;\r\n                        errorSignature = error.format();\r\n                    } catch (error) { }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\r\n            method: functionFragment.format(),\r\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\r\n        });\r\n    }\r\n\r\n    // Encode the result for a function call (e.g. for eth_call)\r\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\r\n        if (typeof(functionFragment) === \"string\") {\r\n            functionFragment = this.getFunction(functionFragment);\r\n        }\r\n\r\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\r\n    }\r\n\r\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\r\n    encodeFilterTopics(eventFragment: EventFragment | string, values: ReadonlyArray<any>): Array<string | Array<string>> {\r\n        if (typeof(eventFragment) === \"string\") {\r\n            eventFragment = this.getEvent(eventFragment);\r\n        }\r\n\r\n        if (values.length > eventFragment.inputs.length) {\r\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\r\n                argument: \"values\",\r\n                value: values\r\n            })\r\n        }\r\n\r\n        let topics: Array<string | Array<string>> = [];\r\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\r\n\r\n        const encodeTopic = (param: ParamType, value: any): string => {\r\n            if (param.type === \"string\") {\r\n                 return id(value);\r\n            } else if (param.type === \"bytes\") {\r\n                 return keccak256(hexlify(value));\r\n            }\r\n\r\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\r\n                value = (value ? \"0x01\": \"0x00\");\r\n            }\r\n\r\n            if (param.type.match(/^u?int/)) {\r\n                value = BigNumber.from(value).toHexString();\r\n            }\r\n\r\n            // Check addresses are valid\r\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\r\n            return hexZeroPad(hexlify(value), 32);\r\n        };\r\n\r\n        values.forEach((value, index) => {\r\n\r\n            let param = (<EventFragment>eventFragment).inputs[index];\r\n\r\n            if (!param.indexed) {\r\n                if (value != null) {\r\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (value == null) {\r\n                topics.push(null);\r\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\r\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\r\n            } else if (Array.isArray(value)) {\r\n                topics.push(value.map((value) => encodeTopic(param, value)));\r\n            } else {\r\n                topics.push(encodeTopic(param, value));\r\n            }\r\n        });\r\n\r\n        // Trim off trailing nulls\r\n        while (topics.length && topics[topics.length - 1] === null) {\r\n            topics.pop();\r\n        }\r\n\r\n        return topics;\r\n    }\r\n\r\n    encodeEventLog(eventFragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\r\n        if (typeof(eventFragment) === \"string\") {\r\n            eventFragment = this.getEvent(eventFragment);\r\n        }\r\n\r\n        const topics: Array<string> = [ ];\r\n\r\n        const dataTypes: Array<ParamType> = [ ];\r\n        const dataValues: Array<string> = [ ];\r\n\r\n        if (!eventFragment.anonymous) {\r\n            topics.push(this.getEventTopic(eventFragment));\r\n        }\r\n\r\n        if (values.length !== eventFragment.inputs.length) {\r\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\r\n        }\r\n\r\n        eventFragment.inputs.forEach((param, index) => {\r\n            const value = values[index];\r\n            if (param.indexed) {\r\n                if (param.type === \"string\") {\r\n                    topics.push(id(value))\r\n                } else if (param.type === \"bytes\") {\r\n                    topics.push(keccak256(value))\r\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\r\n                    // @TODO\r\n                    throw new Error(\"not implemented\");\r\n                } else {\r\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\r\n                }\r\n            } else {\r\n                dataTypes.push(param);\r\n                dataValues.push(value);\r\n            }\r\n        });\r\n\r\n        return {\r\n            data: this._abiCoder.encode(dataTypes , dataValues),\r\n            topics: topics\r\n        };\r\n    }\r\n\r\n    // Decode a filter for the event and the search criteria\r\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\r\n        if (typeof(eventFragment) === \"string\") {\r\n            eventFragment = this.getEvent(eventFragment);\r\n        }\r\n\r\n        if (topics != null && !eventFragment.anonymous) {\r\n            let topicHash = this.getEventTopic(eventFragment);\r\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\r\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\r\n            }\r\n            topics = topics.slice(1);\r\n        }\r\n\r\n        let indexed: Array<ParamType> = [];\r\n        let nonIndexed: Array<ParamType> = [];\r\n        let dynamic: Array<boolean> = [];\r\n\r\n        eventFragment.inputs.forEach((param, index) => {\r\n            if (param.indexed) {\r\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\r\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\r\n                    dynamic.push(true);\r\n                } else {\r\n                    indexed.push(param);\r\n                    dynamic.push(false);\r\n                }\r\n            } else {\r\n                nonIndexed.push(param);\r\n                dynamic.push(false);\r\n            }\r\n        });\r\n\r\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\r\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\r\n\r\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\r\n        let nonIndexedIndex = 0, indexedIndex = 0;\r\n        eventFragment.inputs.forEach((param, index) => {\r\n            if (param.indexed) {\r\n                if (resultIndexed == null) {\r\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\r\n\r\n                } else if (dynamic[index]) {\r\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\r\n\r\n                } else {\r\n                    try {\r\n                        result[index] = resultIndexed[indexedIndex++];\r\n                    } catch (error) {\r\n                        result[index] = error;\r\n                    }\r\n                }\r\n            } else {\r\n                try {\r\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\r\n                } catch (error) {\r\n                    result[index] = error;\r\n                }\r\n            }\r\n\r\n            // Add the keyword argument if named and safe\r\n            if (param.name && result[param.name] == null) {\r\n                const value = result[index];\r\n\r\n                // Make error named values throw on access\r\n                if (value instanceof Error) {\r\n                    Object.defineProperty(result, param.name, {\r\n                        enumerable: true,\r\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\r\n                    });\r\n                } else {\r\n                    result[param.name] = value;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Make all error indexed values throw on access\r\n        for (let i = 0; i < result.length; i++) {\r\n            const value = result[i];\r\n            if (value instanceof Error) {\r\n                Object.defineProperty(result, i, {\r\n                    enumerable: true,\r\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\r\n                });\r\n            }\r\n        }\r\n\r\n        return Object.freeze(result);\r\n    }\r\n\r\n    // Given a transaction, find the matching function fragment (if any) and\r\n    // determine all its properties and call parameters\r\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\r\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\r\n\r\n        if (!fragment) { return null; }\r\n\r\n        return new TransactionDescription({\r\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\r\n            functionFragment: fragment,\r\n            name: fragment.name,\r\n            signature: fragment.format(),\r\n            sighash: this.getSighash(fragment),\r\n            value: BigNumber.from(tx.value || \"0\"),\r\n        });\r\n    }\r\n\r\n    // @TODO\r\n    //parseCallResult(data: BytesLike): ??\r\n\r\n    // Given an event log, find the matching event fragment (if any) and\r\n    // determine all its properties and values\r\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\r\n        let fragment = this.getEvent(log.topics[0]);\r\n\r\n        if (!fragment || fragment.anonymous) { return null; }\r\n\r\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\r\n        //        Probably not, because just because it is the only event in the ABI does\r\n        //        not mean we have the full ABI; maybe just a fragment?\r\n\r\n\r\n       return new LogDescription({\r\n            eventFragment: fragment,\r\n            name: fragment.name,\r\n            signature: fragment.format(),\r\n            topic: this.getEventTopic(fragment),\r\n            args: this.decodeEventLog(fragment, log.data, log.topics)\r\n        });\r\n    }\r\n\r\n    parseError(data: BytesLike): ErrorDescription {\r\n        const hexData = hexlify(data);\r\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\r\n\r\n        if (!fragment) { return null; }\r\n\r\n        return new ErrorDescription({\r\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\r\n            errorFragment: fragment,\r\n            name: fragment.name,\r\n            signature: fragment.format(),\r\n            sighash: this.getSighash(fragment),\r\n        });\r\n    }\r\n\r\n\r\n    /*\r\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\r\n        if (Interface.isInterface(value)) {\r\n            return value;\r\n        }\r\n        if (typeof(value) === \"string\") {\r\n            return new Interface(JSON.parse(value));\r\n        }\r\n        return new Interface(value);\r\n    }\r\n    */\r\n\r\n    static isInterface(value: any): value is Interface {\r\n        return !!(value && value._isInterface);\r\n    }\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, JsonFragmentType, ParamType } from \"./fragments\";\r\nimport { AbiCoder, CoerceFunc, defaultAbiCoder } from \"./abi-coder\";\r\nimport { checkResultErrors, Indexed, Interface, LogDescription, Result, TransactionDescription } from \"./interface\";\r\n\r\nexport {\r\n    ConstructorFragment,\r\n    ErrorFragment,\r\n    EventFragment,\r\n    Fragment,\r\n    FunctionFragment,\r\n    ParamType,\r\n    FormatTypes,\r\n\r\n    AbiCoder,\r\n    defaultAbiCoder,\r\n\r\n    Interface,\r\n    Indexed,\r\n\r\n    /////////////////////////\r\n    // Types\r\n\r\n    CoerceFunc,\r\n    JsonFragment,\r\n    JsonFragmentType,\r\n\r\n    Result,\r\n    checkResultErrors,\r\n\r\n    LogDescription,\r\n    TransactionDescription\r\n};\r\n", "export const version = \"contracts/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\r\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\r\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\r\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\r\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\r\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\n\r\nconst logger = new Logger(version);\r\n\r\nexport interface Overrides {\r\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\r\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\r\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\r\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\r\n    nonce?: BigNumberish | Promise<BigNumberish>;\r\n    type?: number;\r\n    accessList?: AccessListish;\r\n    customData?: Record<string, any>;\r\n    ccipReadEnabled?: boolean;\r\n};\r\n\r\nexport interface PayableOverrides extends Overrides {\r\n    value?: BigNumberish | Promise<BigNumberish>;\r\n}\r\n\r\nexport interface CallOverrides extends PayableOverrides {\r\n    blockTag?: BlockTag | Promise<BlockTag>;\r\n    from?: string | Promise<string>;\r\n}\r\n\r\n// @TODO: Better hierarchy with: (in v6)\r\n//  - abstract-provider:TransactionRequest\r\n//  - transactions:Transaction\r\n//  - transaction:UnsignedTransaction\r\n\r\nexport interface PopulatedTransaction {\r\n    to?: string;\r\n    from?: string;\r\n    nonce?: number;\r\n\r\n    gasLimit?: BigNumber;\r\n    gasPrice?: BigNumber;\r\n\r\n    data?: string;\r\n    value?: BigNumber;\r\n    chainId?: number;\r\n\r\n    type?: number;\r\n    accessList?: AccessList;\r\n\r\n    maxFeePerGas?: BigNumber;\r\n    maxPriorityFeePerGas?: BigNumber;\r\n\r\n    customData?: Record<string, any>;\r\n    ccipReadEnabled?: boolean;\r\n};\r\n\r\nexport type EventFilter = {\r\n    address?: string;\r\n    topics?: Array<string|Array<string>>;\r\n};\r\n\r\n\r\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\r\n\r\n\r\n// The (n + 1)th parameter passed to contract event callbacks\r\nexport interface Event extends Log {\r\n\r\n    // The event name\r\n    event?: string;\r\n\r\n    // The event signature\r\n    eventSignature?: string;\r\n\r\n    // The parsed arguments to the event\r\n    args?: Result;\r\n\r\n    // If parsing the arguments failed, this is the error\r\n    decodeError?: Error;\r\n\r\n    // A function that can be used to decode event data and topics\r\n    decode?: (data: string, topics?: Array<string>) => any;\r\n\r\n    // A function that will remove the listener responsible for this event (if any)\r\n    removeListener: () => void;\r\n\r\n    // Get blockchain details about this event's block and transaction\r\n    getBlock: () => Promise<Block>;\r\n    getTransaction: () => Promise<TransactionResponse>;\r\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\r\n}\r\n\r\nexport interface ContractReceipt extends TransactionReceipt {\r\n    events?: Array<Event>;\r\n}\r\n\r\nexport interface ContractTransaction extends TransactionResponse {\r\n    wait(confirmations?: number): Promise<ContractReceipt>;\r\n}\r\n\r\n///////////////////////////////\r\n\r\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\r\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\r\n    type: true, accessList: true,\r\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\r\n    customData: true,\r\n    ccipReadEnabled: true\r\n}\r\n\r\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\r\n    const name = await nameOrPromise;\r\n\r\n    if (typeof(name) !== \"string\") {\r\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\r\n    }\r\n\r\n    // If it is already an address, just use it (after adding checksum)\r\n    try {\r\n        return getAddress(name);\r\n    } catch (error) { }\r\n\r\n    if (!resolver) {\r\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n            operation: \"resolveName\"\r\n        });\r\n    }\r\n\r\n    const address = await resolver.resolveName(name);\r\n\r\n    if (address == null) {\r\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\r\n    }\r\n\r\n    return address;\r\n}\r\n\r\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\r\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\r\n    if (Array.isArray(paramType)) {\r\n        return await Promise.all(paramType.map((paramType, index) => {\r\n            return resolveAddresses(\r\n                resolver,\r\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\r\n                paramType\r\n            );\r\n        }));\r\n    }\r\n\r\n    if (paramType.type === \"address\") {\r\n        return await resolveName(resolver, value);\r\n    }\r\n\r\n    if (paramType.type === \"tuple\") {\r\n        return await resolveAddresses(resolver, value, paramType.components);\r\n    }\r\n\r\n    if (paramType.baseType === \"array\") {\r\n        if (!Array.isArray(value)) {\r\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\r\n                argument: \"value\",\r\n                value\r\n            }));\r\n        }\r\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\r\n    // If an extra argument is given, it is overrides\r\n    let overrides: CallOverrides = { };\r\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\r\n        overrides = shallowCopy(args.pop());\r\n    }\r\n\r\n    // Make sure the parameter count matches\r\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\r\n\r\n    // Populate \"from\" override (allow promises)\r\n    if (contract.signer) {\r\n        if (overrides.from) {\r\n            // Contracts with a Signer are from the Signer's frame-of-reference;\r\n            // but we allow overriding \"from\" if it matches the signer\r\n            overrides.from = resolveProperties({\r\n                override: resolveName(contract.signer, overrides.from),\r\n                signer: contract.signer.getAddress()\r\n            }).then(async (check) => {\r\n                if (getAddress(check.signer) !== check.override) {\r\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                        operation: \"overrides.from\"\r\n                    });\r\n                }\r\n\r\n                return check.override;\r\n            });\r\n\r\n        } else {\r\n            overrides.from = contract.signer.getAddress();\r\n        }\r\n\r\n    } else if (overrides.from) {\r\n        overrides.from = resolveName(contract.provider, overrides.from);\r\n\r\n    //} else {\r\n        // Contracts without a signer can override \"from\", and if\r\n        // unspecified the zero address is used\r\n        //overrides.from = AddressZero;\r\n    }\r\n\r\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\r\n    const resolved = await resolveProperties({\r\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\r\n        address: contract.resolvedAddress,\r\n        overrides: (resolveProperties(overrides) || { })\r\n    });\r\n\r\n    // The ABI coded transaction\r\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\r\n    const tx: PopulatedTransaction = {\r\n      data: data,\r\n      to: resolved.address\r\n    };\r\n\r\n    // Resolved Overrides\r\n    const ro = resolved.overrides;\r\n\r\n    // Populate simple overrides\r\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\r\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\r\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\r\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\r\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\r\n    if (ro.from != null) { tx.from = ro.from; }\r\n\r\n    if (ro.type != null) { tx.type = ro.type; }\r\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\r\n\r\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\r\n    if (tx.gasLimit == null && fragment.gas != null) {\r\n        // Compute the intrinsic gas cost for this transaction\r\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\r\n        // we may wish to parameterize in v6 as part of the Network object. Since this\r\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\r\n        // similar logic to the ContractFactory.\r\n        let intrinsic = 21000;\r\n        const bytes = arrayify(data);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            intrinsic += 4;\r\n            if (bytes[i]) { intrinsic += 64; }\r\n        }\r\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\r\n    }\r\n\r\n    // Populate \"value\" override\r\n    if (ro.value) {\r\n        const roValue = BigNumber.from(ro.value);\r\n        if (!roValue.isZero() && !fragment.payable) {\r\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"overrides.value\",\r\n                value: overrides.value\r\n            });\r\n        }\r\n        tx.value = roValue;\r\n    }\r\n\r\n    if (ro.customData) {\r\n        tx.customData = shallowCopy(ro.customData);\r\n    }\r\n\r\n    if (ro.ccipReadEnabled) {\r\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\r\n    }\r\n\r\n    // Remove the overrides\r\n    delete overrides.nonce;\r\n    delete overrides.gasLimit;\r\n    delete overrides.gasPrice;\r\n    delete overrides.from;\r\n    delete overrides.value;\r\n\r\n    delete overrides.type;\r\n    delete overrides.accessList;\r\n\r\n    delete overrides.maxFeePerGas;\r\n    delete overrides.maxPriorityFeePerGas;\r\n\r\n    delete overrides.customData;\r\n    delete overrides.ccipReadEnabled;\r\n\r\n    // Make sure there are no stray overrides, which may indicate a\r\n    // typo or using an unsupported key.\r\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\r\n    if (leftovers.length) {\r\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\r\n            operation: \"overrides\",\r\n            overrides: leftovers\r\n        });\r\n    }\r\n\r\n    return tx;\r\n}\r\n\r\n\r\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\r\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\r\n        return populateTransaction(contract, fragment, args);\r\n    };\r\n}\r\n\r\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\r\n    const signerOrProvider = (contract.signer || contract.provider);\r\n    return async function(...args: Array<any>): Promise<BigNumber> {\r\n        if (!signerOrProvider) {\r\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"estimateGas\"\r\n            })\r\n        }\r\n\r\n        const tx = await populateTransaction(contract, fragment, args);\r\n        return await signerOrProvider.estimateGas(tx);\r\n    };\r\n}\r\n\r\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\r\n    const wait = tx.wait.bind(tx);\r\n    tx.wait = (confirmations?: number) => {\r\n        return wait(confirmations).then((receipt: ContractReceipt) => {\r\n            receipt.events = receipt.logs.map((log) => {\r\n                let event: Event = (<Event>deepCopy(log));\r\n                let parsed: LogDescription = null;\r\n                try {\r\n                    parsed = contract.interface.parseLog(log);\r\n                } catch (e){ }\r\n\r\n                // Successfully parsed the event log; include it\r\n                if (parsed) {\r\n                    event.args = parsed.args;\r\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\r\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\r\n                    };\r\n                    event.event = parsed.name;\r\n                    event.eventSignature = parsed.signature;\r\n                }\r\n\r\n                // Useful operations\r\n                event.removeListener = () => { return contract.provider; }\r\n                event.getBlock = () => {\r\n                    return contract.provider.getBlock(receipt.blockHash);\r\n                }\r\n                event.getTransaction = () => {\r\n                    return contract.provider.getTransaction(receipt.transactionHash);\r\n                }\r\n                event.getTransactionReceipt = () => {\r\n                    return Promise.resolve(receipt);\r\n                }\r\n\r\n                return event;\r\n            });\r\n\r\n            return receipt;\r\n        });\r\n    };\r\n}\r\n\r\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\r\n    const signerOrProvider = (contract.signer || contract.provider);\r\n\r\n    return async function(...args: Array<any>): Promise<any> {\r\n        // Extract the \"blockTag\" override if present\r\n        let blockTag = undefined;\r\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\r\n            const overrides = shallowCopy(args.pop());\r\n            if (overrides.blockTag != null) {\r\n                blockTag = await overrides.blockTag;\r\n            }\r\n            delete overrides.blockTag;\r\n            args.push(overrides);\r\n        }\r\n\r\n        // If the contract was just deployed, wait until it is mined\r\n        if (contract.deployTransaction != null) {\r\n            await contract._deployed(blockTag);\r\n        }\r\n\r\n        // Call a node and get the result\r\n        const tx = await populateTransaction(contract, fragment, args);\r\n        const result = await signerOrProvider.call(tx, blockTag);\r\n\r\n        try {\r\n            let value = contract.interface.decodeFunctionResult(fragment, result);\r\n            if (collapseSimple && fragment.outputs.length === 1) {\r\n                value = value[0];\r\n            }\r\n            return value;\r\n\r\n        } catch (error) {\r\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\r\n                error.address = contract.address;\r\n                error.args = args;\r\n                error.transaction = tx;\r\n            }\r\n            throw error;\r\n         }\r\n    };\r\n}\r\n\r\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\r\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\r\n        if (!contract.signer) {\r\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"sendTransaction\"\r\n            })\r\n        }\r\n\r\n        // If the contract was just deployed, wait until it is mined\r\n        if (contract.deployTransaction != null) {\r\n            await contract._deployed();\r\n        }\r\n\r\n        const txRequest = await populateTransaction(contract, fragment, args);\r\n\r\n        const tx = await contract.signer.sendTransaction(txRequest);\r\n\r\n        // Tweak the tx.wait so the receipt has extra properties\r\n        addContractWait(contract, tx);\r\n\r\n        return tx;\r\n    };\r\n}\r\n\r\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\r\n    if (fragment.constant) {\r\n        return buildCall(contract, fragment, collapseSimple);\r\n    }\r\n    return buildSend(contract, fragment);\r\n}\r\n\r\nfunction getEventTag(filter: EventFilter): string {\r\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\r\n        return \"*\";\r\n    }\r\n\r\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\r\n        if (Array.isArray(topic)) {\r\n            return topic.join(\"|\");\r\n        }\r\n        return topic;\r\n    }).join(\":\"): \"\");\r\n}\r\n\r\nclass RunningEvent {\r\n    readonly tag: string;\r\n    readonly filter: EventFilter;\r\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\r\n\r\n    constructor(tag: string, filter: EventFilter) {\r\n        defineReadOnly(this, \"tag\", tag);\r\n        defineReadOnly(this, \"filter\", filter);\r\n        this._listeners = [ ];\r\n    }\r\n\r\n    addListener(listener: Listener, once: boolean): void {\r\n        this._listeners.push({ listener: listener, once: once });\r\n    }\r\n\r\n    removeListener(listener: Listener): void {\r\n        let done = false;\r\n        this._listeners = this._listeners.filter((item) => {\r\n            if (done || item.listener !== listener) { return true; }\r\n            done = true;\r\n            return false;\r\n        });\r\n    }\r\n\r\n    removeAllListeners(): void {\r\n        this._listeners = [];\r\n    }\r\n\r\n    listeners(): Array<Listener> {\r\n        return this._listeners.map((i) => i.listener);\r\n    }\r\n\r\n    listenerCount(): number {\r\n        return this._listeners.length;\r\n    }\r\n\r\n    run(args: Array<any>): number {\r\n        const listenerCount = this.listenerCount();\r\n        this._listeners = this._listeners.filter((item) => {\r\n\r\n            const argsCopy = args.slice();\r\n\r\n            // Call the callback in the next event loop\r\n            setTimeout(() => {\r\n                item.listener.apply(this, argsCopy);\r\n            }, 0);\r\n\r\n            // Reschedule it if it not \"once\"\r\n            return !(item.once);\r\n        });\r\n\r\n        return listenerCount;\r\n    }\r\n\r\n    prepareEvent(event: Event): void {\r\n    }\r\n\r\n    // Returns the array that will be applied to an emit\r\n    getEmit(event: Event): Array<any> {\r\n        return [ event ];\r\n    }\r\n}\r\n\r\nclass ErrorRunningEvent extends RunningEvent {\r\n    constructor() {\r\n        super(\"error\", null);\r\n    }\r\n}\r\n\r\n\r\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\r\n//       or have a common abstract super class, with enough constructor\r\n//       options to configure both.\r\n\r\n// A Fragment Event will populate all the properties that Wildcard\r\n// will, and additionally dereference the arguments when emitting\r\nclass FragmentRunningEvent extends RunningEvent {\r\n    readonly address: string;\r\n    readonly interface: Interface;\r\n    readonly fragment: EventFragment;\r\n\r\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\r\n        const filter: EventFilter = {\r\n            address: address\r\n        }\r\n\r\n        let topic = contractInterface.getEventTopic(fragment);\r\n        if (topics) {\r\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\r\n            filter.topics = topics.slice();\r\n        } else {\r\n            filter.topics = [ topic ];\r\n        }\r\n\r\n        super(getEventTag(filter), filter);\r\n        defineReadOnly(this, \"address\", address);\r\n        defineReadOnly(this, \"interface\", contractInterface);\r\n        defineReadOnly(this, \"fragment\", fragment);\r\n    }\r\n\r\n\r\n    prepareEvent(event: Event): void {\r\n        super.prepareEvent(event);\r\n\r\n        event.event = this.fragment.name;\r\n        event.eventSignature = this.fragment.format();\r\n\r\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\r\n            return this.interface.decodeEventLog(this.fragment, data, topics);\r\n        };\r\n\r\n        try {\r\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\r\n        } catch (error) {\r\n            event.args = null;\r\n            event.decodeError = error;\r\n        }\r\n    }\r\n\r\n    getEmit(event: Event): Array<any> {\r\n        const errors = checkResultErrors(event.args);\r\n        if (errors.length) { throw errors[0].error; }\r\n\r\n        const args = (event.args || []).slice();\r\n        args.push(event);\r\n        return args;\r\n    }\r\n}\r\n\r\n// A Wildcard Event will attempt to populate:\r\n//  - event            The name of the event name\r\n//  - eventSignature   The full signature of the event\r\n//  - decode           A function to decode data and topics\r\n//  - args             The decoded data and topics\r\nclass WildcardRunningEvent extends RunningEvent {\r\n    readonly address: string;\r\n    readonly interface: Interface;\r\n\r\n    constructor(address: string, contractInterface: Interface) {\r\n        super(\"*\", { address: address });\r\n        defineReadOnly(this, \"address\", address);\r\n        defineReadOnly(this, \"interface\", contractInterface);\r\n    }\r\n\r\n    prepareEvent(event: Event): void {\r\n        super.prepareEvent(event);\r\n\r\n        try {\r\n            const parsed = this.interface.parseLog(event);\r\n            event.event = parsed.name;\r\n            event.eventSignature = parsed.signature;\r\n\r\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\r\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\r\n            };\r\n\r\n            event.args = parsed.args;\r\n        } catch (error) {\r\n            // No matching event\r\n        }\r\n    }\r\n}\r\n\r\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\r\n\r\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\r\n\r\n\r\nexport class BaseContract {\r\n    readonly address: string;\r\n    readonly interface: Interface;\r\n\r\n    readonly signer: Signer;\r\n    readonly provider: Provider;\r\n\r\n    readonly functions: { [ name: string ]: ContractFunction };\r\n\r\n    readonly callStatic: { [ name: string ]: ContractFunction };\r\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\r\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\r\n\r\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\r\n\r\n    // This will always be an address. This will only differ from\r\n    // address if an ENS name was used in the constructor\r\n    readonly resolvedAddress: Promise<string>;\r\n\r\n    // This is only set if the contract was created with a call to deploy\r\n    readonly deployTransaction: TransactionResponse;\r\n\r\n    _deployedPromise: Promise<Contract>;\r\n\r\n    // A list of RunningEvents to track listeners for each event tag\r\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\r\n\r\n    // Wrapped functions to call emit and allow deregistration from the provider\r\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\r\n\r\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\r\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\r\n        //address = getAddress(address);\r\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\r\n\r\n        if (signerOrProvider == null) {\r\n            defineReadOnly(this, \"provider\", null);\r\n            defineReadOnly(this, \"signer\", null);\r\n        } else if (Signer.isSigner(signerOrProvider)) {\r\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\r\n            defineReadOnly(this, \"signer\", signerOrProvider);\r\n        } else if (Provider.isProvider(signerOrProvider)) {\r\n            defineReadOnly(this, \"provider\", signerOrProvider);\r\n            defineReadOnly(this, \"signer\", null);\r\n        } else {\r\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\r\n        }\r\n\r\n        defineReadOnly(this, \"callStatic\", { });\r\n        defineReadOnly(this, \"estimateGas\", { });\r\n        defineReadOnly(this, \"functions\", { });\r\n        defineReadOnly(this, \"populateTransaction\", { });\r\n\r\n        defineReadOnly(this, \"filters\", { });\r\n\r\n        {\r\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\r\n            Object.keys(this.interface.events).forEach((eventSignature) => {\r\n                const event = this.interface.events[eventSignature];\r\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\r\n                    return {\r\n                        address: this.address,\r\n                        topics: this.interface.encodeFilterTopics(event, args)\r\n                   }\r\n                });\r\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\r\n                uniqueFilters[event.name].push(eventSignature);\r\n            });\r\n\r\n            Object.keys(uniqueFilters).forEach((name) => {\r\n                const filters = uniqueFilters[name];\r\n                if (filters.length === 1) {\r\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\r\n                } else {\r\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\r\n                }\r\n            });\r\n        }\r\n\r\n        defineReadOnly(this, \"_runningEvents\", { });\r\n        defineReadOnly(this, \"_wrappedEmits\", { });\r\n\r\n        if (addressOrName == null) {\r\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\r\n        }\r\n\r\n        defineReadOnly(this, \"address\", addressOrName);\r\n        if (this.provider) {\r\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\r\n        } else {\r\n            try {\r\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\r\n            } catch (error) {\r\n                // Without a provider, we cannot use ENS names\r\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                    operation: \"new Contract\"\r\n                });\r\n            }\r\n        }\r\n\r\n        // Swallow bad ENS names to prevent Unhandled Exceptions\r\n        this.resolvedAddress.catch((e) => { });\r\n\r\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\r\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\r\n        Object.keys(this.interface.functions).forEach((signature) => {\r\n            const fragment = this.interface.functions[signature];\r\n\r\n            // Check that the signature is unique; if not the ABI generation has\r\n            // not been cleaned or may be incorrectly generated\r\n            if (uniqueSignatures[signature]) {\r\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\r\n                return;\r\n            }\r\n            uniqueSignatures[signature] = true;\r\n\r\n            // Track unique names; we only expose bare named functions if they\r\n            // are ambiguous\r\n            {\r\n                const name = fragment.name;\r\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\r\n                uniqueNames[`%${ name }`].push(signature);\r\n            }\r\n\r\n            if ((<Contract>this)[signature] == null) {\r\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\r\n            }\r\n\r\n            // We do not collapse simple calls on this bucket, which allows\r\n            // frameworks to safely use this without introspection as well as\r\n            // allows decoding error recovery.\r\n            if (this.functions[signature] == null) {\r\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\r\n            }\r\n\r\n            if (this.callStatic[signature] == null) {\r\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\r\n            }\r\n\r\n            if (this.populateTransaction[signature] == null) {\r\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\r\n            }\r\n\r\n            if (this.estimateGas[signature] == null) {\r\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\r\n            }\r\n        });\r\n\r\n        Object.keys(uniqueNames).forEach((name) => {\r\n            // Ambiguous names to not get attached as bare names\r\n            const signatures = uniqueNames[name];\r\n            if (signatures.length > 1) { return; }\r\n\r\n            // Strip off the leading \"%\" used for prototype protection\r\n            name = name.substring(1);\r\n\r\n            const signature = signatures[0];\r\n\r\n            // If overwriting a member property that is null, swallow the error\r\n            try {\r\n                if ((<Contract>this)[name] == null) {\r\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\r\n                }\r\n            } catch (e) { }\r\n\r\n            if (this.functions[name] == null) {\r\n                defineReadOnly(this.functions, name, this.functions[signature]);\r\n            }\r\n\r\n            if (this.callStatic[name] == null) {\r\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\r\n            }\r\n\r\n            if (this.populateTransaction[name] == null) {\r\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\r\n            }\r\n\r\n            if (this.estimateGas[name] == null) {\r\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\r\n            }\r\n        });\r\n    }\r\n\r\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\r\n        return getContractAddress(transaction);\r\n    }\r\n\r\n    static getInterface(contractInterface: ContractInterface): Interface {\r\n        if (Interface.isInterface(contractInterface)) {\r\n            return contractInterface;\r\n        }\r\n        return new Interface(contractInterface);\r\n    }\r\n\r\n    // @TODO: Allow timeout?\r\n    deployed(): Promise<Contract> {\r\n        return this._deployed();\r\n    }\r\n\r\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\r\n        if (!this._deployedPromise) {\r\n\r\n            // If we were just deployed, we know the transaction we should occur in\r\n            if (this.deployTransaction) {\r\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\r\n                    return this;\r\n                });\r\n\r\n            } else {\r\n                // @TODO: Once we allow a timeout to be passed in, we will wait\r\n                // up to that many blocks for getCode\r\n\r\n                // Otherwise, poll for our code to be deployed\r\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\r\n                    if (code === \"0x\") {\r\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                            contractAddress: this.address,\r\n                            operation: \"getDeployed\"\r\n                        });\r\n                    }\r\n                    return this;\r\n                });\r\n            }\r\n        }\r\n\r\n        return this._deployedPromise;\r\n    }\r\n\r\n    // @TODO:\r\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\r\n\r\n    // @TODO:\r\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\r\n\r\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\r\n        if (!this.signer) {\r\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\r\n        }\r\n\r\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\r\n\r\n        [\"from\", \"to\"].forEach(function(key) {\r\n            if ((<any>tx)[key] == null) { return; }\r\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\r\n        });\r\n\r\n        tx.to = this.resolvedAddress;\r\n        return this.deployed().then(() => {\r\n            return this.signer.sendTransaction(tx);\r\n        });\r\n    }\r\n\r\n    // Reconnect to a different signer or provider\r\n    connect(signerOrProvider: Signer | Provider | string): Contract {\r\n        if (typeof(signerOrProvider) === \"string\") {\r\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\r\n        }\r\n\r\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\r\n        if (this.deployTransaction) {\r\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\r\n        }\r\n\r\n        return contract;\r\n    }\r\n\r\n    // Re-attach to a different on-chain instance of this contract\r\n    attach(addressOrName: string): Contract {\r\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\r\n    }\r\n\r\n    static isIndexed(value: any): value is Indexed {\r\n        return Indexed.isIndexed(value);\r\n    }\r\n\r\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\r\n        // Already have an instance of this event running; we can re-use it\r\n        if (this._runningEvents[runningEvent.tag]) {\r\n            return this._runningEvents[runningEvent.tag];\r\n         }\r\n         return runningEvent\r\n    }\r\n\r\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\r\n        if (typeof(eventName) === \"string\") {\r\n\r\n            // Listen for \"error\" events (if your contract has an error event, include\r\n            // the full signature to bypass this special event keyword)\r\n            if (eventName === \"error\") {\r\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\r\n            }\r\n\r\n            // Listen for any event that is registered\r\n            if (eventName === \"event\") {\r\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\r\n            }\r\n\r\n            // Listen for any event\r\n            if (eventName === \"*\") {\r\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\r\n            }\r\n\r\n            // Get the event Fragment (throws if ambiguous/unknown event)\r\n            const fragment = this.interface.getEvent(eventName)\r\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\r\n        }\r\n\r\n        // We have topics to filter by...\r\n        if (eventName.topics && eventName.topics.length > 0) {\r\n\r\n            // Is it a known topichash? (throws if no matching topichash)\r\n            try {\r\n                const topic = eventName.topics[0];\r\n                if (typeof(topic) !== \"string\") {\r\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\r\n                }\r\n                const fragment = this.interface.getEvent(topic);\r\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\r\n            } catch (error) { }\r\n\r\n            // Filter by the unknown topichash\r\n            const filter: EventFilter = {\r\n                address: this.address,\r\n                topics: eventName.topics\r\n            }\r\n\r\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\r\n        }\r\n\r\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\r\n    }\r\n\r\n    _checkRunningEvents(runningEvent: RunningEvent): void {\r\n        if (runningEvent.listenerCount() === 0) {\r\n            delete this._runningEvents[runningEvent.tag];\r\n\r\n            // If we have a poller for this, remove it\r\n            const emit = this._wrappedEmits[runningEvent.tag];\r\n            if (emit && runningEvent.filter) {\r\n                this.provider.off(runningEvent.filter, emit);\r\n                delete this._wrappedEmits[runningEvent.tag];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Subclasses can override this to gracefully recover\r\n    // from parse errors if they wish\r\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\r\n        const event = <Event>deepCopy(log);\r\n\r\n        event.removeListener = () => {\r\n            if (!listener) { return; }\r\n            runningEvent.removeListener(listener);\r\n            this._checkRunningEvents(runningEvent);\r\n        };\r\n\r\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\r\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\r\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\r\n\r\n        // This may throw if the topics and data mismatch the signature\r\n        runningEvent.prepareEvent(event);\r\n\r\n        return event;\r\n    }\r\n\r\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\r\n        if (!this.provider) {\r\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\r\n        }\r\n\r\n        runningEvent.addListener(listener, once);\r\n\r\n        // Track this running event and its listeners (may already be there; but no hard in updating)\r\n        this._runningEvents[runningEvent.tag] = runningEvent;\r\n\r\n        // If we are not polling the provider, start polling\r\n        if (!this._wrappedEmits[runningEvent.tag]) {\r\n            const wrappedEmit = (log: Log) => {\r\n                let event = this._wrapEvent(runningEvent, log, listener);\r\n\r\n                // Try to emit the result for the parameterized event...\r\n                if (event.decodeError == null) {\r\n                    try {\r\n                        const args = runningEvent.getEmit(event);\r\n                        this.emit(runningEvent.filter, ...args);\r\n                    } catch (error) {\r\n                        event.decodeError = error.error;\r\n                    }\r\n                }\r\n\r\n                // Always emit \"event\" for fragment-base events\r\n                if (runningEvent.filter != null) {\r\n                    this.emit(\"event\", event);\r\n                }\r\n\r\n                // Emit \"error\" if there was an error\r\n                if (event.decodeError != null) {\r\n                    this.emit(\"error\", event.decodeError, event);\r\n                }\r\n            };\r\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\r\n\r\n            // Special events, like \"error\" do not have a filter\r\n            if (runningEvent.filter != null) {\r\n                this.provider.on(runningEvent.filter, wrappedEmit);\r\n            }\r\n        }\r\n    }\r\n\r\n    queryFilter(event: EventFilter | string, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\r\n        const runningEvent = this._getRunningEvent(event);\r\n        const filter = shallowCopy(runningEvent.filter);\r\n\r\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\r\n            if (toBlock != null) {\r\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\r\n            }\r\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\r\n        } else {\r\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\r\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\r\n        }\r\n\r\n        return this.provider.getLogs(filter).then((logs) => {\r\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\r\n        });\r\n    }\r\n\r\n    on(event: EventFilter | string, listener: Listener): this {\r\n        this._addEventListener(this._getRunningEvent(event), listener, false);\r\n        return this;\r\n    }\r\n\r\n    once(event: EventFilter | string, listener: Listener): this {\r\n        this._addEventListener(this._getRunningEvent(event), listener, true);\r\n        return this;\r\n    }\r\n\r\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\r\n        if (!this.provider) { return false; }\r\n\r\n        const runningEvent = this._getRunningEvent(eventName);\r\n        const result = (runningEvent.run(args) > 0);\r\n\r\n        // May have drained all the \"once\" events; check for living events\r\n        this._checkRunningEvents(runningEvent);\r\n\r\n        return result;\r\n    }\r\n\r\n    listenerCount(eventName?: EventFilter | string): number {\r\n        if (!this.provider) { return 0; }\r\n        if (eventName == null) {\r\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\r\n                return accum + this._runningEvents[key].listenerCount();\r\n            }, 0);\r\n        }\r\n        return this._getRunningEvent(eventName).listenerCount();\r\n    }\r\n\r\n    listeners(eventName?: EventFilter | string): Array<Listener> {\r\n        if (!this.provider) { return []; }\r\n\r\n        if (eventName == null) {\r\n            const result: Array<Listener> = [ ];\r\n            for (let tag in this._runningEvents) {\r\n                this._runningEvents[tag].listeners().forEach((listener) => {\r\n                    result.push(listener)\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n\r\n        return this._getRunningEvent(eventName).listeners();\r\n    }\r\n\r\n    removeAllListeners(eventName?: EventFilter | string): this {\r\n        if (!this.provider) { return this; }\r\n\r\n        if (eventName == null) {\r\n            for (const tag in this._runningEvents) {\r\n                const runningEvent = this._runningEvents[tag];\r\n                runningEvent.removeAllListeners();\r\n                this._checkRunningEvents(runningEvent);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // Delete any listeners\r\n        const runningEvent = this._getRunningEvent(eventName);\r\n        runningEvent.removeAllListeners();\r\n        this._checkRunningEvents(runningEvent);\r\n\r\n        return this;\r\n    }\r\n\r\n    off(eventName: EventFilter | string, listener: Listener): this {\r\n        if (!this.provider) { return this; }\r\n        const runningEvent = this._getRunningEvent(eventName);\r\n        runningEvent.removeListener(listener);\r\n        this._checkRunningEvents(runningEvent);\r\n        return this;\r\n    }\r\n\r\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\r\n        return this.off(eventName, listener);\r\n    }\r\n\r\n}\r\n\r\nexport class Contract extends BaseContract {\r\n    // The meta-class properties\r\n    readonly [ key: string ]: ContractFunction | any;\r\n}\r\n\r\nexport class ContractFactory {\r\n\r\n    readonly interface: Interface;\r\n    readonly bytecode: string;\r\n    readonly signer: Signer;\r\n\r\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\r\n\r\n        let bytecodeHex: string = null;\r\n\r\n        if (typeof(bytecode) === \"string\") {\r\n            bytecodeHex = bytecode;\r\n        } else if (isBytes(bytecode)) {\r\n            bytecodeHex = hexlify(bytecode);\r\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\r\n            // Allow the bytecode object from the Solidity compiler\r\n            bytecodeHex = (<any>bytecode).object;\r\n        } else {\r\n            // Crash in the next verification step\r\n            bytecodeHex = \"!\";\r\n        }\r\n\r\n        // Make sure it is 0x prefixed\r\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\r\n\r\n        // Make sure the final result is valid bytecode\r\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\r\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\r\n        }\r\n\r\n        // If we have a signer, make sure it is valid\r\n        if (signer && !Signer.isSigner(signer)) {\r\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\r\n        }\r\n\r\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\r\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\r\n        defineReadOnly(this, \"signer\", signer || null);\r\n    }\r\n\r\n    // @TODO: Future; rename to populateTransaction?\r\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\r\n        let tx: TransactionRequest = { };\r\n\r\n        // If we have 1 additional argument, we allow transaction overrides\r\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\r\n            tx = shallowCopy(args.pop());\r\n            for (const key in tx) {\r\n                if (!allowedTransactionKeys[key]) {\r\n                    throw new Error(\"unknown transaction override \" + key);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Do not allow these to be overridden in a deployment transaction\r\n        [\"data\", \"from\", \"to\"].forEach((key) => {\r\n            if ((<any>tx)[key] == null) { return; }\r\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\r\n        });\r\n\r\n        if (tx.value) {\r\n            const value = BigNumber.from(tx.value);\r\n            if (!value.isZero() && !this.interface.deploy.payable) {\r\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                    operation: \"overrides.value\",\r\n                    value: tx.value\r\n                });\r\n            }\r\n        }\r\n\r\n        // Make sure the call matches the constructor signature\r\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\r\n\r\n        // Set the data to the bytecode + the encoded constructor arguments\r\n        tx.data = hexlify(concat([\r\n            this.bytecode,\r\n            this.interface.encodeDeploy(args)\r\n        ]));\r\n\r\n        return tx\r\n    }\r\n\r\n    async deploy(...args: Array<any>): Promise<Contract> {\r\n\r\n        let overrides: any = { };\r\n\r\n        // If 1 extra parameter was passed in, it contains overrides\r\n        if (args.length === this.interface.deploy.inputs.length + 1) {\r\n            overrides = args.pop();\r\n        }\r\n\r\n        // Make sure the call matches the constructor signature\r\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\r\n\r\n        // Resolve ENS names and promises in the arguments\r\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\r\n        params.push(overrides);\r\n\r\n        // Get the deployment transaction (with optional overrides)\r\n        const unsignedTx = this.getDeployTransaction(...params);\r\n\r\n        // Send the deployment transaction\r\n        const tx = await this.signer.sendTransaction(unsignedTx);\r\n\r\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\r\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\r\n\r\n        // Add the modified wait that wraps events\r\n        addContractWait(contract, tx);\r\n\r\n        defineReadOnly(contract, \"deployTransaction\", tx);\r\n        return contract;\r\n    }\r\n\r\n    attach(address: string): Contract {\r\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\r\n    }\r\n\r\n    connect(signer: Signer) {\r\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\r\n    }\r\n\r\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\r\n        if (compilerOutput == null) {\r\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\r\n        }\r\n\r\n        if (typeof(compilerOutput) === \"string\") {\r\n            compilerOutput = JSON.parse(compilerOutput);\r\n        }\r\n\r\n        const abi = compilerOutput.abi;\r\n\r\n        let bytecode: any = null;\r\n        if (compilerOutput.bytecode) {\r\n            bytecode = compilerOutput.bytecode;\r\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\r\n            bytecode = compilerOutput.evm.bytecode;\r\n        }\r\n\r\n        return new this(abi, bytecode, signer);\r\n    }\r\n\r\n    static getInterface(contractInterface: ContractInterface) {\r\n        return Contract.getInterface(contractInterface);\r\n    }\r\n\r\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\r\n        return getContractAddress(tx);\r\n    }\r\n\r\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\r\n        return new Contract(address, contractInterface, signer);\r\n    }\r\n}\r\n", "\"use strict\";\r\n\r\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\r\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\r\n\r\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\r\n    password = arrayify(password);\r\n    salt = arrayify(salt);\r\n    let hLen;\r\n    let l = 1;\r\n    const DK = new Uint8Array(keylen)\r\n    const block1 = new Uint8Array(salt.length + 4)\r\n    block1.set(salt);\r\n    //salt.copy(block1, 0, 0, salt.length)\r\n\r\n    let r: number;\r\n    let T: Uint8Array;\r\n\r\n    for (let i = 1; i <= l; i++) {\r\n        //block1.writeUInt32BE(i, salt.length)\r\n        block1[salt.length] = (i >> 24) & 0xff;\r\n        block1[salt.length + 1] = (i >> 16) & 0xff;\r\n        block1[salt.length + 2] = (i >> 8) & 0xff;\r\n        block1[salt.length + 3] = i & 0xff;\r\n\r\n        //let U = createHmac(password).update(block1).digest();\r\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\r\n\r\n        if (!hLen) {\r\n            hLen = U.length\r\n            T = new Uint8Array(hLen)\r\n            l = Math.ceil(keylen / hLen)\r\n            r = keylen - (l - 1) * hLen\r\n        }\r\n\r\n        //U.copy(T, 0, 0, hLen)\r\n        T.set(U);\r\n\r\n\r\n        for (let j = 1; j < iterations; j++) {\r\n            //U = createHmac(password).update(U).digest();\r\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\r\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\r\n        }\r\n\r\n\r\n        const destPos = (i - 1) * hLen\r\n        const len = (i === l ? r : hLen)\r\n        //T.copy(DK, destPos, 0, len)\r\n        DK.set(arrayify(T).slice(0, len), destPos);\r\n    }\r\n\r\n    return hexlify(DK)\r\n}\r\n\r\n", "\r\nexport { pbkdf2 } from \"./pbkdf2\";\r\n", "export const version = \"wordlists/5.7.0\";\r\n", "\"use strict\";\r\n\r\n// This gets overridden by rollup\r\nconst exportWordlist = false;\r\n\r\nimport { id } from \"@ethersproject/hash\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nexport const logger = new Logger(version);\r\n\r\nexport abstract class Wordlist {\r\n    readonly locale: string;\r\n\r\n    constructor(locale: string) {\r\n        logger.checkAbstract(new.target, Wordlist);\r\n        defineReadOnly(this, \"locale\", locale);\r\n    }\r\n\r\n    abstract getWord(index: number): string;\r\n    abstract getWordIndex(word: string): number;\r\n\r\n    // Subclasses may override this\r\n    split(mnemonic: string): Array<string> {\r\n        return mnemonic.toLowerCase().split(/ +/g)\r\n    }\r\n\r\n    // Subclasses may override this\r\n    join(words: Array<string>): string {\r\n        return words.join(\" \");\r\n    }\r\n\r\n    static check(wordlist: Wordlist): string {\r\n        const words = [];\r\n        for (let i = 0; i < 2048; i++) {\r\n            const word = wordlist.getWord(i);\r\n            /* istanbul ignore if */\r\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\r\n            words.push(word);\r\n        }\r\n        return id(words.join(\"\\n\") + \"\\n\");\r\n    }\r\n\r\n    static register(lang: Wordlist, name?: string): void {\r\n        if (!name) { name = lang.locale; }\r\n\r\n        /* istanbul ignore if */\r\n        if (exportWordlist) {\r\n            try {\r\n                const anyGlobal = (window as any)\r\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\r\n                    if (!anyGlobal._ethers.wordlists[name]) {\r\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\r\n                    }\r\n                }\r\n            } catch (error) { }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { Wordlist } from \"./wordlist\";\r\n\r\n\r\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\r\n\r\nlet wordlist: Array<string> = null;\r\n\r\n\r\nfunction loadWords(lang: Wordlist): void {\r\n    if (wordlist != null) { return; }\r\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\r\n\r\n    // Verify the computed list matches the official list\r\n    /* istanbul ignore if */\r\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\r\n        wordlist = null;\r\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\r\n    }\r\n}\r\n\r\nclass LangEn extends Wordlist {\r\n    constructor() {\r\n        super(\"en\");\r\n    }\r\n\r\n    getWord(index: number): string {\r\n        loadWords(this);\r\n        return wordlist[index];\r\n    }\r\n\r\n    getWordIndex(word: string): number {\r\n        loadWords(this);\r\n        return wordlist.indexOf(word);\r\n    }\r\n}\r\n\r\nconst langEn = new LangEn();\r\nWordlist.register(langEn);\r\n\r\nexport { langEn };\r\n", "\"use strict\";\r\n\r\n// Wordlists\r\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\r\n\r\n// Browser; only include English by default\r\n\r\nimport { Wordlist } from \"./wordlist\";\r\n\r\nimport { langEn as en } from \"./lang-en\";\r\n\r\nexport const wordlists: { [ locale: string ]: Wordlist } = {\r\n  en: en\r\n}\r\n", "\"use strict\";\r\n\r\n// Wordlists\r\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\r\n\r\nimport { logger, Wordlist } from \"./wordlist\";\r\n\r\nimport { wordlists } from \"./wordlists\";\r\n\r\nexport {\r\n    logger,\r\n    Wordlist,\r\n    wordlists\r\n}\r\n", "export const version = \"hdnode/5.7.0\";\r\n", "\"use strict\";\r\n\r\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\r\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\r\n\r\n\r\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\r\nimport { Base58 } from \"@ethersproject/basex\";\r\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\r\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\nimport { SigningKey } from \"@ethersproject/signing-key\";\r\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\r\nimport { computeAddress } from \"@ethersproject/transactions\";\r\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\r\n\r\n\r\n// \"Bitcoin seed\"\r\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\r\n\r\nconst HardenedBit = 0x80000000;\r\n\r\n// Returns a byte with the MSB bits set\r\nfunction getUpperMask(bits: number): number {\r\n   return ((1 << bits) - 1) << (8 - bits);\r\n}\r\n\r\n// Returns a byte with the LSB bits set\r\nfunction getLowerMask(bits: number): number {\r\n   return (1 << bits) - 1;\r\n}\r\n\r\nfunction bytes32(value: BigNumber | Uint8Array): string {\r\n    return hexZeroPad(hexlify(value), 32);\r\n}\r\n\r\nfunction base58check(data: Uint8Array): string {\r\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\r\n}\r\n\r\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\r\n    if (wordlist == null) {\r\n        return wordlists[\"en\"];\r\n    }\r\n\r\n    if (typeof(wordlist) === \"string\") {\r\n        const words = wordlists[wordlist];\r\n        if (words == null) {\r\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\r\n        }\r\n        return words;\r\n    }\r\n\r\n    return wordlist;\r\n}\r\n\r\nconst _constructorGuard: any = {};\r\n\r\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\r\n\r\nexport interface Mnemonic {\r\n    readonly phrase: string;\r\n    readonly path: string;\r\n    readonly locale: string;\r\n};\r\n\r\nexport class HDNode implements ExternallyOwnedAccount {\r\n    readonly privateKey: string;\r\n    readonly publicKey: string;\r\n\r\n    readonly fingerprint: string;\r\n    readonly parentFingerprint: string;\r\n\r\n    readonly address: string;\r\n\r\n    readonly mnemonic?: Mnemonic;\r\n    readonly path: string;\r\n\r\n    readonly chainCode: string;\r\n\r\n    readonly index: number;\r\n    readonly depth: number;\r\n\r\n    /**\r\n     *  This constructor should not be called directly.\r\n     *\r\n     *  Please use:\r\n     *   - fromMnemonic\r\n     *   - fromSeed\r\n     */\r\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\r\n        /* istanbul ignore if */\r\n        if (constructorGuard !== _constructorGuard) {\r\n            throw new Error(\"HDNode constructor cannot be called directly\");\r\n        }\r\n\r\n        if (privateKey) {\r\n            const signingKey = new SigningKey(privateKey);\r\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\r\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\r\n        } else {\r\n            defineReadOnly(this, \"privateKey\", null);\r\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\r\n        }\r\n\r\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\r\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\r\n\r\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\r\n\r\n        defineReadOnly(this, \"chainCode\", chainCode);\r\n\r\n        defineReadOnly(this, \"index\", index);\r\n        defineReadOnly(this, \"depth\", depth);\r\n\r\n        if (mnemonicOrPath == null) {\r\n            // From a source that does not preserve the path (e.g. extended keys)\r\n            defineReadOnly(this, \"mnemonic\", null);\r\n            defineReadOnly(this, \"path\", null);\r\n\r\n        } else if (typeof(mnemonicOrPath) === \"string\") {\r\n            // From a source that does not preserve the mnemonic (e.g. neutered)\r\n            defineReadOnly(this, \"mnemonic\", null);\r\n            defineReadOnly(this, \"path\", mnemonicOrPath);\r\n\r\n        } else {\r\n            // From a fully qualified source\r\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\r\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\r\n        }\r\n    }\r\n\r\n    get extendedKey(): string {\r\n        // We only support the mainnet values for now, but if anyone needs\r\n        // testnet values, let me know. I believe current sentiment is that\r\n        // we should always use mainnet, and use BIP-44 to derive the network\r\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\r\n        //   - Testnet: public=0x043587CF, private=0x04358394\r\n\r\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\r\n\r\n        return base58check(concat([\r\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\r\n            hexlify(this.depth),\r\n            this.parentFingerprint,\r\n            hexZeroPad(hexlify(this.index), 4),\r\n            this.chainCode,\r\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\r\n        ]));\r\n    }\r\n\r\n    neuter(): HDNode {\r\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\r\n    }\r\n\r\n    private _derive(index: number): HDNode {\r\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\r\n\r\n        // Base path\r\n        let path = this.path;\r\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\r\n\r\n        const data = new Uint8Array(37);\r\n\r\n        if (index & HardenedBit) {\r\n            if (!this.privateKey) {\r\n                throw new Error(\"cannot derive child of neutered node\");\r\n            }\r\n\r\n            // Data = 0x00 || ser_256(k_par)\r\n            data.set(arrayify(this.privateKey), 1);\r\n\r\n            // Hardened path\r\n            if (path) { path += \"'\"; }\r\n\r\n        } else {\r\n            // Data = ser_p(point(k_par))\r\n            data.set(arrayify(this.publicKey));\r\n        }\r\n\r\n        // Data += ser_32(i)\r\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\r\n\r\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\r\n        const IL = I.slice(0, 32);\r\n        const IR = I.slice(32);\r\n\r\n        // The private key\r\n        let ki: string = null\r\n\r\n        // The public key\r\n        let Ki: string = null;\r\n\r\n        if (this.privateKey) {\r\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\r\n        } else {\r\n            const ek = new SigningKey(hexlify(IL));\r\n            Ki = ek._addPoint(this.publicKey);\r\n        }\r\n\r\n        let mnemonicOrPath: Mnemonic | string = path;\r\n\r\n        const srcMnemonic =  this.mnemonic;\r\n        if (srcMnemonic) {\r\n            mnemonicOrPath = Object.freeze({\r\n                phrase: srcMnemonic.phrase,\r\n                path: path,\r\n                locale: (srcMnemonic.locale || \"en\")\r\n            });\r\n        }\r\n\r\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\r\n    }\r\n\r\n    derivePath(path: string): HDNode {\r\n        const components = path.split(\"/\");\r\n\r\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\r\n            throw new Error(\"invalid path - \" + path);\r\n        }\r\n\r\n        if (components[0] === \"m\") { components.shift(); }\r\n\r\n        let result: HDNode = this;\r\n        for (let i = 0; i < components.length; i++) {\r\n            const component = components[i];\r\n            if (component.match(/^[0-9]+'$/)) {\r\n                const index = parseInt(component.substring(0, component.length - 1));\r\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\r\n                result = result._derive(HardenedBit + index);\r\n            } else if (component.match(/^[0-9]+$/)) {\r\n                const index = parseInt(component);\r\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\r\n                result = result._derive(index);\r\n            } else {\r\n                throw new Error(\"invalid path component - \" + component);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\r\n        const seedArray: Uint8Array = arrayify(seed);\r\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\r\n\r\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\r\n\r\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\r\n    }\r\n\r\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\r\n\r\n        // If a locale name was passed in, find the associated wordlist\r\n        wordlist = getWordlist(wordlist);\r\n\r\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\r\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\r\n\r\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\r\n            phrase: mnemonic,\r\n            path: \"m\",\r\n            locale: wordlist.locale\r\n        });\r\n    }\r\n\r\n    static fromSeed(seed: BytesLike): HDNode {\r\n        return HDNode._fromSeed(seed, null);\r\n    }\r\n\r\n    static fromExtendedKey(extendedKey: string): HDNode {\r\n        const bytes = Base58.decode(extendedKey);\r\n\r\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\r\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\r\n        }\r\n\r\n        const depth = bytes[4];\r\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\r\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\r\n        const chainCode = hexlify(bytes.slice(13, 45));\r\n        const key = bytes.slice(45, 78);\r\n\r\n        switch (hexlify(bytes.slice(0, 4))) {\r\n            // Public Key\r\n            case \"0x0488b21e\": case \"0x043587cf\":\r\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\r\n\r\n            // Private Key\r\n            case \"0x0488ade4\": case \"0x04358394 \":\r\n                if (key[0] !== 0) { break; }\r\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\r\n        }\r\n\r\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\r\n    }\r\n}\r\n\r\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\r\n    if (!password) { password = \"\"; }\r\n\r\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\r\n\r\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\r\n}\r\n\r\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\r\n    wordlist = getWordlist(wordlist);\r\n\r\n    logger.checkNormalize();\r\n\r\n    const words = wordlist.split(mnemonic);\r\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\r\n\r\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\r\n\r\n    let offset = 0;\r\n    for (let i = 0; i < words.length; i++) {\r\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\r\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\r\n\r\n        for (let bit = 0; bit < 11; bit++) {\r\n            if (index & (1 << (10 - bit))) {\r\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\r\n            }\r\n            offset++;\r\n        }\r\n    }\r\n\r\n    const entropyBits = 32 * words.length / 3;\r\n\r\n    const checksumBits = words.length / 3;\r\n    const checksumMask = getUpperMask(checksumBits);\r\n\r\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\r\n\r\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\r\n        throw new Error(\"invalid checksum\");\r\n    }\r\n\r\n    return hexlify(entropy.slice(0, entropyBits / 8));\r\n}\r\n\r\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\r\n    wordlist = getWordlist(wordlist);\r\n\r\n    entropy = arrayify(entropy);\r\n\r\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\r\n        throw new Error(\"invalid entropy\");\r\n    }\r\n\r\n    const indices: Array<number> = [ 0 ];\r\n\r\n    let remainingBits = 11;\r\n    for (let i = 0; i < entropy.length; i++) {\r\n\r\n        // Consume the whole byte (with still more to go)\r\n        if (remainingBits > 8) {\r\n            indices[indices.length - 1] <<= 8;\r\n            indices[indices.length - 1] |= entropy[i];\r\n\r\n            remainingBits -= 8;\r\n\r\n        // This byte will complete an 11-bit index\r\n        } else {\r\n            indices[indices.length - 1] <<= remainingBits;\r\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\r\n\r\n            // Start the next word\r\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\r\n\r\n            remainingBits += 3;\r\n        }\r\n    }\r\n\r\n    // Compute the checksum bits\r\n    const checksumBits = entropy.length / 4;\r\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\r\n\r\n    // Shift the checksum into the word indices\r\n    indices[indices.length - 1] <<= checksumBits;\r\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\r\n\r\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\r\n}\r\n\r\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\r\n    try {\r\n        mnemonicToEntropy(mnemonic, wordlist);\r\n        return true;\r\n    } catch (error) { }\r\n    return false;\r\n}\r\n\r\nexport function getAccountPath(index: number): string {\r\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\r\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\r\n    }\r\n    return `m/44'/60'/${ index }'/0/0`;\r\n}\r\n", "export const version = \"json-wallets/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { arrayify, Bytes, BytesLike, hexlify } from \"@ethersproject/bytes\";\r\nimport { toUtf8Bytes, UnicodeNormalizationForm } from '@ethersproject/strings';\r\n\r\nexport function looseArrayify(hexString: string): Uint8Array {\r\n    if (typeof(hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\r\n        hexString = '0x' + hexString;\r\n    }\r\n    return arrayify(hexString);\r\n}\r\n\r\nexport function zpad(value: String | number, length: number): String {\r\n    value = String(value);\r\n    while (value.length < length) { value = '0' + value; }\r\n    return value;\r\n}\r\n\r\nexport function getPassword(password: Bytes | string): Uint8Array {\r\n    if (typeof(password) === 'string') {\r\n        return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);\r\n    }\r\n    return arrayify(password);\r\n}\r\n\r\nexport function searchPath(object: any, path: string): string {\r\n    let currentChild = object;\r\n\r\n    const comps = path.toLowerCase().split('/');\r\n    for (let i = 0; i < comps.length; i++) {\r\n\r\n        // Search for a child object with a case-insensitive matching key\r\n        let matchingChild = null;\r\n        for (const key in currentChild) {\r\n             if (key.toLowerCase() === comps[i]) {\r\n                 matchingChild = currentChild[key];\r\n                 break;\r\n             }\r\n        }\r\n\r\n        // Didn't find one. :'(\r\n        if (matchingChild === null) {\r\n            return null;\r\n        }\r\n\r\n        // Now check this child...\r\n        currentChild = matchingChild;\r\n    }\r\n\r\n    return currentChild;\r\n}\r\n\r\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\r\nexport function uuidV4(randomBytes: BytesLike): string {\r\n    const bytes = arrayify(randomBytes);\r\n\r\n    // Section: 4.1.3:\r\n    // - time_hi_and_version[12:16] = 0b0100\r\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n\r\n    // Section 4.4\r\n    // - clock_seq_hi_and_reserved[6] = 0b0\r\n    // - clock_seq_hi_and_reserved[7] = 0b1\r\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n\r\n    const value = hexlify(bytes);\r\n\r\n    return [\r\n       value.substring(2, 10),\r\n       value.substring(10, 14),\r\n       value.substring(14, 18),\r\n       value.substring(18, 22),\r\n       value.substring(22, 34),\r\n    ].join(\"-\");\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport aes from \"aes-js\";\r\n\r\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { arrayify, Bytes } from \"@ethersproject/bytes\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\r\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\r\nimport { Description } from \"@ethersproject/properties\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\r\n\r\nexport interface _CrowdsaleAccount {\r\n    address: string;\r\n    privateKey: string;\r\n\r\n    _isCrowdsaleAccount: boolean;\r\n}\r\n\r\nexport class CrowdsaleAccount extends Description<_CrowdsaleAccount> implements ExternallyOwnedAccount {\r\n    readonly address: string;\r\n    readonly privateKey: string;\r\n    readonly mnemonic?: string;\r\n    readonly path?: string;\r\n\r\n    readonly _isCrowdsaleAccount: boolean;\r\n\r\n    isCrowdsaleAccount(value: any): value is CrowdsaleAccount {\r\n        return !!(value && value._isCrowdsaleAccount);\r\n    }\r\n}\r\n\r\n// See: https://github.com/ethereum/pyethsaletool\r\nexport function decrypt(json: string, password: Bytes | string): ExternallyOwnedAccount {\r\n    const data = JSON.parse(json);\r\n\r\n    password = getPassword(password);\r\n\r\n    // Ethereum Address\r\n    const ethaddr = getAddress(searchPath(data, \"ethaddr\"));\r\n\r\n    // Encrypted Seed\r\n    const encseed = looseArrayify(searchPath(data, \"encseed\"));\r\n    if (!encseed || (encseed.length % 16) !== 0) {\r\n        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\r\n    }\r\n\r\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\r\n\r\n    const iv = encseed.slice(0, 16);\r\n    const encryptedSeed = encseed.slice(16);\r\n\r\n    // Decrypt the seed\r\n    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\r\n    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));\r\n\r\n    // This wallet format is weird... Convert the binary encoded hex to a string.\r\n    let seedHex = \"\";\r\n    for (let i = 0; i < seed.length; i++) {\r\n        seedHex += String.fromCharCode(seed[i]);\r\n    }\r\n\r\n    const seedHexBytes = toUtf8Bytes(seedHex);\r\n\r\n    const privateKey = keccak256(seedHexBytes);\r\n\r\n    return new CrowdsaleAccount ({\r\n        _isCrowdsaleAccount: true,\r\n        address: ethaddr,\r\n        privateKey: privateKey\r\n    });\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { getAddress } from \"@ethersproject/address\";\r\n\r\n\r\nexport function isCrowdsaleWallet(json: string): boolean {\r\n    let data: any = null;\r\n    try {\r\n        data = JSON.parse(json);\r\n    } catch (error) { return false; }\r\n\r\n    return (data.encseed && data.ethaddr);\r\n}\r\n\r\nexport function isKeystoreWallet(json: string): boolean {\r\n    let data: any = null;\r\n    try {\r\n        data = JSON.parse(json);\r\n    } catch (error) { return false; }\r\n\r\n    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\r\n        return false;\r\n    }\r\n\r\n    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\r\n    return true;\r\n}\r\n\r\n//export function isJsonWallet(json: string): boolean {\r\n//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\r\n//}\r\n\r\nexport function getJsonWalletAddress(json: string): string {\r\n    if (isCrowdsaleWallet(json)) {\r\n        try {\r\n            return getAddress(JSON.parse(json).ethaddr);\r\n        } catch (error) { return null; }\r\n    }\r\n\r\n    if (isKeystoreWallet(json)) {\r\n        try {\r\n            return getAddress(JSON.parse(json).address);\r\n        } catch (error) { return null; }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport aes from \"aes-js\";\r\nimport scrypt from \"scrypt-js\";\r\n\r\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { arrayify, Bytes, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\r\nimport { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from \"@ethersproject/hdnode\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\r\nimport { randomBytes } from \"@ethersproject/random\";\r\nimport { Description } from \"@ethersproject/properties\";\r\nimport { computeAddress } from \"@ethersproject/transactions\";\r\n\r\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\n// Exported Types\r\n\r\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\r\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\r\n}\r\n\r\nexport interface _KeystoreAccount {\r\n    address: string;\r\n    privateKey: string;\r\n    mnemonic?: Mnemonic;\r\n\r\n    _isKeystoreAccount: boolean;\r\n}\r\n\r\nexport class KeystoreAccount extends Description<_KeystoreAccount> implements ExternallyOwnedAccount {\r\n    readonly address: string;\r\n    readonly privateKey: string;\r\n    readonly mnemonic?: Mnemonic;\r\n\r\n    readonly _isKeystoreAccount: boolean;\r\n\r\n    isKeystoreAccount(value: any): value is KeystoreAccount {\r\n        return !!(value && value._isKeystoreAccount);\r\n    }\r\n}\r\n\r\nexport type ProgressCallback = (percent: number) => void;\r\n\r\nexport type EncryptOptions = {\r\n   iv?: BytesLike;\r\n   entropy?: BytesLike;\r\n   client?: string;\r\n   salt?: BytesLike;\r\n   uuid?: string;\r\n   scrypt?: {\r\n       N?: number;\r\n       r?: number;\r\n       p?: number;\r\n   }\r\n}\r\n\r\nfunction _decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): Uint8Array {\r\n    const cipher = searchPath(data, \"crypto/cipher\");\r\n    if (cipher === \"aes-128-ctr\") {\r\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"))\r\n        const counter = new aes.Counter(iv);\r\n\r\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\r\n\r\n        return arrayify(aesCtr.decrypt(ciphertext));\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction _getAccount(data: any, key: Uint8Array): KeystoreAccount {\r\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\r\n\r\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\r\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\r\n        throw new Error(\"invalid password\");\r\n    }\r\n\r\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\r\n\r\n    if (!privateKey) {\r\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n            operation: \"decrypt\"\r\n        });\r\n    }\r\n\r\n    const mnemonicKey = key.slice(32, 64);\r\n\r\n    const address = computeAddress(privateKey);\r\n    if (data.address) {\r\n        let check = data.address.toLowerCase();\r\n        if (check.substring(0, 2) !== \"0x\") { check = \"0x\" + check; }\r\n\r\n        if (getAddress(check) !== address) {\r\n            throw new Error(\"address mismatch\");\r\n        }\r\n    }\r\n\r\n    const account: _KeystoreAccount = {\r\n        _isKeystoreAccount: true,\r\n        address: address,\r\n        privateKey: hexlify(privateKey)\r\n    };\r\n\r\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\r\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\r\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\r\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\r\n\r\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\r\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\r\n\r\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\r\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\r\n\r\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\r\n\r\n        try {\r\n            const mnemonic = entropyToMnemonic(entropy, locale);\r\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\r\n\r\n            if (node.privateKey != account.privateKey) {\r\n                throw new Error(\"mnemonic mismatch\");\r\n            }\r\n\r\n            account.mnemonic = node.mnemonic;\r\n\r\n        } catch (error) {\r\n            // If we don't have the locale wordlist installed to\r\n            // read this mnemonic, just bail and don't set the\r\n            // mnemonic\r\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    return new KeystoreAccount(account);\r\n}\r\n\r\ntype ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p: number, dkLen: number, callback?: ProgressCallback) => T;\r\ntype Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;\r\n\r\nfunction pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {\r\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\r\n}\r\n\r\nfunction pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {\r\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\r\n}\r\n\r\nfunction _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {\r\n    const passwordBytes = getPassword(password);\r\n\r\n    const kdf = searchPath(data, \"crypto/kdf\");\r\n\r\n    if (kdf && typeof(kdf) === \"string\") {\r\n        const throwError = function(name: string, value: any): never {\r\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\r\n        }\r\n\r\n        if (kdf.toLowerCase() === \"scrypt\") {\r\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\r\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\r\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\r\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\r\n\r\n            // Check for all required parameters\r\n            if (!N || !r || !p) { throwError(\"kdf\", kdf); }\r\n\r\n            // Make sure N is a power of 2\r\n            if ((N & (N - 1)) !== 0) { throwError(\"N\", N); }\r\n\r\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\r\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\r\n\r\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\r\n\r\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\r\n\r\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\r\n\r\n            let prfFunc: string = null;\r\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\r\n            if (prf === \"hmac-sha256\") {\r\n                prfFunc = \"sha256\";\r\n            } else if (prf === \"hmac-sha512\") {\r\n                prfFunc = \"sha512\";\r\n            } else {\r\n                throwError(\"prf\", prf);\r\n            }\r\n\r\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\r\n\r\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\r\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\r\n\r\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\r\n        }\r\n    }\r\n\r\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\r\n}\r\n\r\n\r\nexport function decryptSync(json: string, password: Bytes | string): KeystoreAccount {\r\n    const data = JSON.parse(json);\r\n\r\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\r\n    return _getAccount(data, key);\r\n}\r\n\r\nexport async function decrypt(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<KeystoreAccount> {\r\n    const data = JSON.parse(json);\r\n\r\n    const key = await _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\r\n    return _getAccount(data, key);\r\n}\r\n\r\n\r\nexport function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {\r\n\r\n    try {\r\n        // Check the address matches the private key\r\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\r\n            throw new Error(\"address/privateKey mismatch\");\r\n        }\r\n\r\n        // Check the mnemonic (if any) matches the private key\r\n        if (hasMnemonic(account)) {\r\n            const mnemonic = account.mnemonic;\r\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\r\n\r\n            if (node.privateKey != account.privateKey) {\r\n                throw new Error(\"mnemonic mismatch\");\r\n            }\r\n        }\r\n\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n\r\n    // The options are optional, so adjust the call as needed\r\n    if (typeof(options) === \"function\" && !progressCallback) {\r\n        progressCallback = options;\r\n        options = {};\r\n    }\r\n    if (!options) { options = {}; }\r\n\r\n    const privateKey: Uint8Array = arrayify(account.privateKey);\r\n    const passwordBytes = getPassword(password);\r\n\r\n    let entropy: Uint8Array = null\r\n    let path: string = null;\r\n    let locale: string = null;\r\n    if (hasMnemonic(account)) {\r\n        const srcMnemonic = account.mnemonic;\r\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\r\n        path = srcMnemonic.path || defaultPath;\r\n        locale = srcMnemonic.locale || \"en\";\r\n    }\r\n\r\n    let client = options.client;\r\n    if (!client) { client = \"ethers.js\"; }\r\n\r\n    // Check/generate the salt\r\n    let salt: Uint8Array = null;\r\n    if (options.salt) {\r\n        salt = arrayify(options.salt);\r\n    } else {\r\n        salt = randomBytes(32);;\r\n    }\r\n\r\n    // Override initialization vector\r\n    let iv: Uint8Array = null;\r\n    if (options.iv) {\r\n        iv = arrayify(options.iv);\r\n        if (iv.length !== 16) { throw new Error(\"invalid iv\"); }\r\n    } else {\r\n       iv = randomBytes(16);\r\n    }\r\n\r\n    // Override the uuid\r\n    let uuidRandom: Uint8Array = null;\r\n    if (options.uuid) {\r\n        uuidRandom = arrayify(options.uuid);\r\n        if (uuidRandom.length !== 16) { throw new Error(\"invalid uuid\"); }\r\n    } else {\r\n        uuidRandom = randomBytes(16);\r\n    }\r\n\r\n    // Override the scrypt password-based key derivation function parameters\r\n    let N = (1 << 17), r = 8, p = 1;\r\n    if (options.scrypt) {\r\n        if (options.scrypt.N) { N = options.scrypt.N; }\r\n        if (options.scrypt.r) { r = options.scrypt.r; }\r\n        if (options.scrypt.p) { p = options.scrypt.p; }\r\n    }\r\n\r\n    // We take 64 bytes:\r\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\r\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\r\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\r\n        key = arrayify(key);\r\n\r\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\r\n        const derivedKey = key.slice(0, 16);\r\n        const macPrefix = key.slice(16, 32);\r\n\r\n        // This will be used to encrypt the mnemonic phrase (if any)\r\n        const mnemonicKey = key.slice(32, 64);\r\n\r\n        // Encrypt the private key\r\n        const counter = new aes.Counter(iv);\r\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\r\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\r\n\r\n        // Compute the message authentication code, used to check the password\r\n        const mac = keccak256(concat([macPrefix, ciphertext]))\r\n\r\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\r\n        const data: { [key: string]: any } = {\r\n            address: account.address.substring(2).toLowerCase(),\r\n            id: uuidV4(uuidRandom),\r\n            version: 3,\r\n            crypto: {\r\n                cipher: \"aes-128-ctr\",\r\n                cipherparams: {\r\n                    iv: hexlify(iv).substring(2),\r\n                },\r\n                ciphertext: hexlify(ciphertext).substring(2),\r\n                kdf: \"scrypt\",\r\n                kdfparams: {\r\n                    salt: hexlify(salt).substring(2),\r\n                    n: N,\r\n                    dklen: 32,\r\n                    p: p,\r\n                    r: r\r\n                },\r\n                mac: mac.substring(2)\r\n            }\r\n        };\r\n\r\n        // If we have a mnemonic, encrypt it into the JSON wallet\r\n        if (entropy) {\r\n            const mnemonicIv = randomBytes(16);\r\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\r\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\r\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\r\n            const now = new Date();\r\n            const timestamp = (now.getUTCFullYear() + \"-\" +\r\n                               zpad(now.getUTCMonth() + 1, 2) + \"-\" +\r\n                               zpad(now.getUTCDate(), 2) + \"T\" +\r\n                               zpad(now.getUTCHours(), 2) + \"-\" +\r\n                               zpad(now.getUTCMinutes(), 2) + \"-\" +\r\n                               zpad(now.getUTCSeconds(), 2) + \".0Z\"\r\n                              );\r\n            data[\"x-ethers\"] = {\r\n                client: client,\r\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\r\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\r\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\r\n                path: path,\r\n                locale: locale,\r\n                version: \"0.1\"\r\n            };\r\n        }\r\n\r\n        return JSON.stringify(data);\r\n    });\r\n}\r\n", "\"use strict\";\r\n\r\nimport { Bytes } from \"@ethersproject/bytes\";\r\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\r\n\r\nimport { decrypt as decryptCrowdsale } from \"./crowdsale\";\r\nimport { getJsonWalletAddress, isCrowdsaleWallet, isKeystoreWallet } from \"./inspect\";\r\nimport { decrypt as decryptKeystore, decryptSync as decryptKeystoreSync, encrypt as encryptKeystore, EncryptOptions, ProgressCallback } from \"./keystore\";\r\n\r\nfunction decryptJsonWallet(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<ExternallyOwnedAccount> {\r\n    if (isCrowdsaleWallet(json)) {\r\n        if (progressCallback) { progressCallback(0); }\r\n        const account = decryptCrowdsale(json, password)\r\n        if (progressCallback) { progressCallback(1); }\r\n        return Promise.resolve(account);\r\n    }\r\n\r\n    if (isKeystoreWallet(json)) {\r\n        return decryptKeystore(json, password, progressCallback);\r\n    }\r\n\r\n    return Promise.reject(new Error(\"invalid JSON wallet\"));\r\n}\r\n\r\nfunction decryptJsonWalletSync(json: string, password: Bytes | string): ExternallyOwnedAccount {\r\n    if (isCrowdsaleWallet(json)) {\r\n        return decryptCrowdsale(json, password)\r\n    }\r\n\r\n    if (isKeystoreWallet(json)) {\r\n        return decryptKeystoreSync(json, password);\r\n    }\r\n\r\n    throw new Error(\"invalid JSON wallet\");\r\n}\r\n\r\nexport {\r\n    decryptCrowdsale,\r\n\r\n    decryptKeystore,\r\n    decryptKeystoreSync,\r\n    encryptKeystore,\r\n\r\n    isCrowdsaleWallet,\r\n    isKeystoreWallet,\r\n    getJsonWalletAddress,\r\n\r\n    decryptJsonWallet,\r\n    decryptJsonWalletSync,\r\n\r\n    ProgressCallback,\r\n    EncryptOptions,\r\n};\r\n", "export const version = \"wallet/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\r\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\r\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\r\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\r\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\r\nimport { randomBytes } from \"@ethersproject/random\";\r\nimport { SigningKey } from \"@ethersproject/signing-key\";\r\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\r\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\r\nimport { Wordlist } from \"@ethersproject/wordlists\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\r\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\r\n}\r\n\r\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\r\n    const mnemonic = value.mnemonic;\r\n    return (mnemonic && mnemonic.phrase);\r\n}\r\n\r\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\r\n\r\n    readonly address: string;\r\n    readonly provider: Provider;\r\n\r\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\r\n    // leaking the private key in console.log; still, be careful! :)\r\n    readonly _signingKey: () => SigningKey;\r\n    readonly _mnemonic: () => Mnemonic;\r\n\r\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\r\n        super();\r\n\r\n        if (isAccount(privateKey)) {\r\n            const signingKey = new SigningKey(privateKey.privateKey);\r\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\r\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\r\n\r\n            if (this.address !== getAddress(privateKey.address)) {\r\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\r\n            }\r\n\r\n            if (hasMnemonic(privateKey)) {\r\n                const srcMnemonic = privateKey.mnemonic;\r\n                defineReadOnly(this, \"_mnemonic\", () => (\r\n                    {\r\n                        phrase: srcMnemonic.phrase,\r\n                        path: srcMnemonic.path || defaultPath,\r\n                        locale: srcMnemonic.locale || \"en\"\r\n                    }\r\n                ));\r\n                const mnemonic = this.mnemonic;\r\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\r\n                if (computeAddress(node.privateKey) !== this.address) {\r\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\r\n                }\r\n            } else {\r\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\r\n            }\r\n\r\n\r\n        } else {\r\n            if (SigningKey.isSigningKey(privateKey)) {\r\n                /* istanbul ignore if */\r\n                if (privateKey.curve !== \"secp256k1\") {\r\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\r\n                }\r\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\r\n\r\n            } else {\r\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\r\n                if (typeof(privateKey) === \"string\") {\r\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\r\n                        privateKey = \"0x\" + privateKey;\r\n                    }\r\n                }\r\n\r\n                const signingKey = new SigningKey(privateKey);\r\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\r\n            }\r\n\r\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\r\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (provider && !Provider.isProvider(provider)) {\r\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\r\n        }\r\n\r\n        defineReadOnly(this, \"provider\", provider || null);\r\n    }\r\n\r\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\r\n    get privateKey(): string { return this._signingKey().privateKey; }\r\n    get publicKey(): string { return this._signingKey().publicKey; }\r\n\r\n    getAddress(): Promise<string> {\r\n        return Promise.resolve(this.address);\r\n    }\r\n\r\n    connect(provider: Provider): Wallet {\r\n        return new Wallet(this, provider);\r\n    }\r\n\r\n    signTransaction(transaction: TransactionRequest): Promise<string> {\r\n        return resolveProperties(transaction).then((tx) => {\r\n            if (tx.from != null) {\r\n                if (getAddress(tx.from) !== this.address) {\r\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\r\n                }\r\n                delete tx.from;\r\n            }\r\n\r\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\r\n            return serialize(<UnsignedTransaction>tx, signature);\r\n        });\r\n    }\r\n\r\n    async signMessage(message: Bytes | string): Promise<string> {\r\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\r\n    }\r\n\r\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\r\n        // Populate any ENS names\r\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\r\n            if (this.provider == null) {\r\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                    operation: \"resolveName\",\r\n                    value: name\r\n                });\r\n            }\r\n            return this.provider.resolveName(name);\r\n        });\r\n\r\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\r\n    }\r\n\r\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\r\n        if (typeof(options) === \"function\" && !progressCallback) {\r\n            progressCallback = options;\r\n            options = {};\r\n        }\r\n\r\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\r\n            throw new Error(\"invalid callback\");\r\n        }\r\n\r\n        if (!options) { options = {}; }\r\n\r\n        return encryptKeystore(this, password, options, progressCallback);\r\n    }\r\n\r\n\r\n    /**\r\n     *  Static methods to create Wallet instances.\r\n     */\r\n    static createRandom(options?: any): Wallet {\r\n        let entropy: Uint8Array = randomBytes(16);\r\n\r\n        if (!options) { options = { }; }\r\n\r\n        if (options.extraEntropy) {\r\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\r\n        }\r\n\r\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\r\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\r\n    }\r\n\r\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\r\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\r\n            return new Wallet(account);\r\n        });\r\n    }\r\n\r\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\r\n        return new Wallet(decryptJsonWalletSync(json, password));\r\n    }\r\n\r\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\r\n        if (!path) { path = defaultPath; }\r\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\r\n    }\r\n}\r\n\r\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\r\n    return recoverAddress(hashMessage(message), signature);\r\n}\r\n\r\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\r\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\r\n}\r\n", "export const version = \"solidity/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\r\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\r\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\r\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\r\n\r\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\r\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\r\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\r\n\r\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\n\r\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\r\n    switch(type) {\r\n        case \"address\":\r\n            if (isArray) { return zeroPad(value, 32); }\r\n            return arrayify(value);\r\n        case \"string\":\r\n            return toUtf8Bytes(value);\r\n        case \"bytes\":\r\n            return arrayify(value);\r\n        case \"bool\":\r\n            value = (value ? \"0x01\": \"0x00\");\r\n            if (isArray) { return zeroPad(value, 32); }\r\n            return arrayify(value);\r\n    }\r\n\r\n    let match =  type.match(regexNumber);\r\n    if (match) {\r\n        //let signed = (match[1] === \"int\")\r\n        let size = parseInt(match[2] || \"256\")\r\n\r\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\r\n            logger.throwArgumentError(\"invalid number type\", \"type\", type)\r\n        }\r\n\r\n        if (isArray) { size = 256; }\r\n\r\n        value = BigNumber.from(value).toTwos(size);\r\n\r\n        return zeroPad(value, size / 8);\r\n    }\r\n\r\n    match = type.match(regexBytes);\r\n    if (match) {\r\n        const size = parseInt(match[1]);\r\n\r\n        if (String(size) !== match[1] || size === 0 || size > 32) {\r\n            logger.throwArgumentError(\"invalid bytes type\", \"type\", type)\r\n        }\r\n        if (arrayify(value).byteLength !== size) {\r\n            logger.throwArgumentError(`invalid value for ${ type }`, \"value\", value)\r\n        }\r\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\r\n        return value;\r\n    }\r\n\r\n    match = type.match(regexArray);\r\n    if (match && Array.isArray(value)) {\r\n        const baseType = match[1];\r\n        const count = parseInt(match[2] || String(value.length));\r\n        if (count != value.length) {\r\n            logger.throwArgumentError(`invalid array length for ${ type }`, \"value\", value)\r\n        }\r\n        const result: Array<Uint8Array> = [];\r\n        value.forEach(function(value) {\r\n            result.push(_pack(baseType, value, true));\r\n        });\r\n        return concat(result);\r\n    }\r\n\r\n    return logger.throwArgumentError(\"invalid type\", \"type\", type)\r\n}\r\n\r\n// @TODO: Array Enum\r\n\r\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\r\n    if (types.length != values.length) {\r\n        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values)\r\n    }\r\n    const tight: Array<Uint8Array> = [];\r\n    types.forEach(function(type, index) {\r\n        tight.push(_pack(type, values[index]));\r\n    });\r\n    return hexlify(concat(tight));\r\n}\r\n\r\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\r\n    return hashKeccak256(pack(types, values));\r\n}\r\n\r\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\r\n    return hashSha256(pack(types, values));\r\n}\r\n", "export const version = \"units/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nconst names = [\r\n    \"wei\",\r\n    \"kwei\",\r\n    \"mwei\",\r\n    \"gwei\",\r\n    \"szabo\",\r\n    \"finney\",\r\n    \"ether\",\r\n];\r\n\r\n\r\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\r\n// use them.\r\nexport function commify(value: string | number): string {\r\n    const comps = String(value).split(\".\");\r\n\r\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\r\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\r\n    }\r\n\r\n    // Make sure we have at least one whole digit (0 if none)\r\n    let whole = comps[0];\r\n\r\n    let negative = \"\";\r\n    if (whole.substring(0, 1) === \"-\") {\r\n        negative = \"-\";\r\n        whole = whole.substring(1);\r\n    }\r\n\r\n    // Make sure we have at least 1 whole digit with no leading zeros\r\n    while (whole.substring(0, 1) === \"0\") { whole = whole.substring(1); }\r\n    if (whole === \"\") { whole = \"0\"; }\r\n\r\n    let suffix = \"\";\r\n    if (comps.length === 2) { suffix = \".\" + (comps[1] || \"0\"); }\r\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\r\n        suffix = suffix.substring(0, suffix.length - 1);\r\n    }\r\n\r\n    const formatted = [];\r\n    while (whole.length) {\r\n        if (whole.length <= 3) {\r\n            formatted.unshift(whole);\r\n            break;\r\n        } else {\r\n            const index = whole.length - 3;\r\n            formatted.unshift(whole.substring(index));\r\n            whole = whole.substring(0, index);\r\n        }\r\n    }\r\n\r\n    return negative + formatted.join(\",\") + suffix;\r\n}\r\n\r\nexport function formatUnits(value: BigNumberish, unitName?: string | BigNumberish): string {\r\n    if (typeof(unitName) === \"string\") {\r\n        const index = names.indexOf(unitName);\r\n        if (index !== -1) { unitName = 3 * index; }\r\n    }\r\n    return formatFixed(value, (unitName != null) ? unitName: 18);\r\n}\r\n\r\nexport function parseUnits(value: string, unitName?: BigNumberish): BigNumber {\r\n    if (typeof(value) !== \"string\") {\r\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\r\n    }\r\n    if (typeof(unitName) === \"string\") {\r\n        const index = names.indexOf(unitName);\r\n        if (index !== -1) { unitName = 3 * index; }\r\n    }\r\n    return parseFixed(value, (unitName != null) ? unitName: 18);\r\n}\r\n\r\nexport function formatEther(wei: BigNumberish): string {\r\n    return formatUnits(wei, 18);\r\n}\r\n\r\nexport function parseEther(ether: string): BigNumber {\r\n    return parseUnits(ether, 18);\r\n}\r\n\r\n", "\"use strict\";\r\n\r\nimport { AbiCoder, checkResultErrors, ConstructorFragment, defaultAbiCoder, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, Indexed, Interface, LogDescription, ParamType, Result, TransactionDescription }from \"@ethersproject/abi\";\r\nimport { getAddress, getCreate2Address, getContractAddress, getIcapAddress, isAddress } from \"@ethersproject/address\";\r\nimport * as base64 from \"@ethersproject/base64\";\r\nimport { Base58 as base58 } from \"@ethersproject/basex\";\r\nimport { arrayify, concat, hexConcat, hexDataSlice, hexDataLength, hexlify, hexStripZeros, hexValue, hexZeroPad, isBytes, isBytesLike, isHexString, joinSignature, zeroPad, splitSignature, stripZeros } from \"@ethersproject/bytes\";\r\nimport { _TypedDataEncoder, dnsEncode, hashMessage, id, isValidName, namehash } from \"@ethersproject/hash\";\r\nimport { defaultPath, entropyToMnemonic, getAccountPath, HDNode, isValidMnemonic, mnemonicToEntropy, mnemonicToSeed } from \"@ethersproject/hdnode\";\r\nimport { getJsonWalletAddress } from \"@ethersproject/json-wallets\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { computeHmac, ripemd160, sha256, sha512 } from \"@ethersproject/sha2\";\r\nimport { keccak256 as solidityKeccak256, pack as solidityPack, sha256 as soliditySha256 } from \"@ethersproject/solidity\";\r\nimport { randomBytes, shuffled } from \"@ethersproject/random\";\r\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\r\nimport * as RLP from \"@ethersproject/rlp\";\r\nimport { computePublicKey, recoverPublicKey, SigningKey } from \"@ethersproject/signing-key\";\r\nimport { formatBytes32String, nameprep, parseBytes32String, _toEscapedUtf8String, toUtf8Bytes, toUtf8CodePoints, toUtf8String, Utf8ErrorFuncs } from \"@ethersproject/strings\";\r\nimport { accessListify, computeAddress, parse as parseTransaction, recoverAddress, serialize as serializeTransaction, TransactionTypes } from \"@ethersproject/transactions\";\r\nimport { commify, formatEther, parseEther, formatUnits, parseUnits } from \"@ethersproject/units\";\r\nimport { verifyMessage, verifyTypedData } from \"@ethersproject/wallet\";\r\nimport { _fetchData, fetchJson, poll } from \"@ethersproject/web\";\r\n\r\n////////////////////////\r\n// Enums\r\n\r\nimport { SupportedAlgorithm } from \"@ethersproject/sha2\";\r\nimport { UnicodeNormalizationForm, Utf8ErrorReason } from \"@ethersproject/strings\";\r\nimport { UnsignedTransaction } from \"@ethersproject/transactions\";\r\n\r\n////////////////////////\r\n// Types and Interfaces\r\n\r\nimport { CoerceFunc } from \"@ethersproject/abi\";\r\nimport { Bytes, BytesLike, Hexable } from \"@ethersproject/bytes\"\r\nimport { Mnemonic } from \"@ethersproject/hdnode\";\r\nimport { EncryptOptions, ProgressCallback } from \"@ethersproject/json-wallets\";\r\nimport { Deferrable } from \"@ethersproject/properties\";\r\nimport { Utf8ErrorFunc } from \"@ethersproject/strings\";\r\nimport { AccessList, AccessListish } from \"@ethersproject/transactions\";\r\nimport { ConnectionInfo, FetchJsonResponse, OnceBlockable, OncePollable, PollOptions } from \"@ethersproject/web\";\r\n\r\n////////////////////////\r\n// Exports\r\n\r\nexport {\r\n    AbiCoder,\r\n    defaultAbiCoder,\r\n\r\n    Fragment,\r\n    ConstructorFragment,\r\n    ErrorFragment,\r\n    EventFragment,\r\n    FunctionFragment,\r\n    ParamType,\r\n    FormatTypes,\r\n\r\n    checkResultErrors,\r\n    Result,\r\n\r\n    Logger,\r\n\r\n    RLP,\r\n\r\n    _fetchData,\r\n    fetchJson,\r\n    poll,\r\n\r\n    checkProperties,\r\n    deepCopy,\r\n    defineReadOnly,\r\n    getStatic,\r\n    resolveProperties,\r\n    shallowCopy,\r\n\r\n    arrayify,\r\n\r\n    concat,\r\n    stripZeros,\r\n    zeroPad,\r\n\r\n    isBytes,\r\n    isBytesLike,\r\n\r\n    defaultPath,\r\n    HDNode,\r\n    SigningKey,\r\n\r\n    Interface,\r\n\r\n    LogDescription,\r\n    TransactionDescription,\r\n\r\n    base58,\r\n    base64,\r\n\r\n    hexlify,\r\n    isHexString,\r\n    hexConcat,\r\n    hexStripZeros,\r\n    hexValue,\r\n    hexZeroPad,\r\n    hexDataLength,\r\n    hexDataSlice,\r\n\r\n    nameprep,\r\n    _toEscapedUtf8String,\r\n    toUtf8Bytes,\r\n    toUtf8CodePoints,\r\n    toUtf8String,\r\n    Utf8ErrorFuncs,\r\n\r\n    formatBytes32String,\r\n    parseBytes32String,\r\n\r\n    dnsEncode,\r\n    hashMessage,\r\n    namehash,\r\n    isValidName,\r\n    id,\r\n\r\n    _TypedDataEncoder,\r\n\r\n    getAddress,\r\n    getIcapAddress,\r\n    getContractAddress,\r\n    getCreate2Address,\r\n    isAddress,\r\n\r\n    formatEther,\r\n    parseEther,\r\n\r\n    formatUnits,\r\n    parseUnits,\r\n\r\n    commify,\r\n\r\n    computeHmac,\r\n    keccak256,\r\n    ripemd160,\r\n    sha256,\r\n    sha512,\r\n\r\n    randomBytes,\r\n    shuffled,\r\n\r\n    solidityPack,\r\n    solidityKeccak256,\r\n    soliditySha256,\r\n\r\n    splitSignature,\r\n    joinSignature,\r\n\r\n    accessListify,\r\n    parseTransaction,\r\n    serializeTransaction,\r\n    TransactionTypes,\r\n\r\n    getJsonWalletAddress,\r\n\r\n    computeAddress,\r\n    recoverAddress,\r\n\r\n    computePublicKey,\r\n    recoverPublicKey,\r\n\r\n    verifyMessage,\r\n    verifyTypedData,\r\n\r\n    getAccountPath,\r\n    mnemonicToEntropy,\r\n    entropyToMnemonic,\r\n    isValidMnemonic,\r\n    mnemonicToSeed,\r\n\r\n\r\n    ////////////////////////\r\n    // Enums\r\n\r\n    SupportedAlgorithm,\r\n\r\n    UnicodeNormalizationForm,\r\n    Utf8ErrorReason,\r\n\r\n    ////////////////////////\r\n    // Types\r\n\r\n    Bytes,\r\n    BytesLike,\r\n    Hexable,\r\n\r\n    AccessList,\r\n    AccessListish,\r\n    UnsignedTransaction,\r\n\r\n    CoerceFunc,\r\n\r\n    Indexed,\r\n\r\n    Mnemonic,\r\n\r\n    Deferrable,\r\n\r\n    Utf8ErrorFunc,\r\n\r\n    ConnectionInfo,\r\n    OnceBlockable,\r\n    OncePollable,\r\n    PollOptions,\r\n    FetchJsonResponse,\r\n\r\n    EncryptOptions,\r\n    ProgressCallback\r\n}\r\n\r\n", "export const version = \"ethers/5.7.2\";\r\n", "\"use strict\";\r\n\r\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\r\n\r\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\r\n\r\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\r\nimport { Wallet } from \"@ethersproject/wallet\";\r\n\r\nimport * as constants from \"@ethersproject/constants\";\r\n\r\nimport * as providers from \"@ethersproject/providers\";\r\nimport { getDefaultProvider } from \"@ethersproject/providers\";\r\n\r\nimport { Wordlist, wordlists} from \"@ethersproject/wordlists\";\r\n\r\nimport * as utils from \"./utils\";\r\n\r\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\r\n\r\n////////////////////////\r\n// Types\r\n\r\nimport type { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\r\nimport { BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { Bytes, BytesLike, Signature } from \"@ethersproject/bytes\";\r\nimport { Transaction, UnsignedTransaction } from \"@ethersproject/transactions\";\r\n\r\n\r\n////////////////////////\r\n// Compile-Time Constants\r\n\r\n// This is generated by \"npm run dist\"\r\nimport { version } from \"./_version\";\r\n\r\nconst logger = new Logger(version);\r\n\r\n////////////////////////\r\n// Types\r\n\r\nimport {\r\n    ContractFunction,\r\n    ContractReceipt,\r\n    ContractTransaction,\r\n\r\n    Event,\r\n    EventFilter,\r\n\r\n    Overrides,\r\n    PayableOverrides,\r\n    CallOverrides,\r\n\r\n    PopulatedTransaction,\r\n\r\n    ContractInterface\r\n} from \"@ethersproject/contracts\";\r\n\r\n\r\n////////////////////////\r\n// Exports\r\n\r\nexport {\r\n    Signer,\r\n\r\n    Wallet,\r\n    VoidSigner,\r\n\r\n    getDefaultProvider,\r\n    providers,\r\n\r\n    BaseContract,\r\n    Contract,\r\n    ContractFactory,\r\n\r\n    BigNumber,\r\n    FixedNumber,\r\n\r\n    constants,\r\n    errors,\r\n\r\n    logger,\r\n\r\n    utils,\r\n\r\n    wordlists,\r\n\r\n\r\n    ////////////////////////\r\n    // Compile-Time Constants\r\n\r\n    version,\r\n\r\n\r\n    ////////////////////////\r\n    // Types\r\n\r\n    ContractFunction,\r\n    ContractReceipt,\r\n    ContractTransaction,\r\n    Event,\r\n    EventFilter,\r\n\r\n    Overrides,\r\n    PayableOverrides,\r\n    CallOverrides,\r\n\r\n    PopulatedTransaction,\r\n\r\n    ContractInterface,\r\n\r\n    TypedDataDomain,\r\n    TypedDataField,\r\n\r\n    BigNumberish,\r\n\r\n    Bytes,\r\n    BytesLike,\r\n\r\n    Signature,\r\n\r\n    Transaction,\r\n    UnsignedTransaction,\r\n\r\n    Wordlist\r\n};\r\n\r\n", "\"use strict\";\r\n\r\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\r\n\r\nimport * as ethers from \"./ethers\";\r\n\r\ntry {\r\n    const anyGlobal = (window as any);\r\n\r\n    if (anyGlobal._ethers == null) {\r\n        anyGlobal._ethers = ethers;\r\n    }\r\n} catch (error) { }\r\n\r\nexport { ethers };\r\n\r\nexport {\r\n    Signer,\r\n\r\n    Wallet,\r\n    VoidSigner,\r\n\r\n    getDefaultProvider,\r\n    providers,\r\n\r\n    BaseContract,\r\n    Contract,\r\n    ContractFactory,\r\n\r\n    BigNumber,\r\n    FixedNumber,\r\n\r\n    constants,\r\n    errors,\r\n\r\n    logger,\r\n\r\n    utils,\r\n\r\n    wordlists,\r\n\r\n\r\n    ////////////////////////\r\n    // Compile-Time Constants\r\n\r\n    version,\r\n\r\n\r\n    ////////////////////////\r\n    // Types\r\n\r\n    ContractFunction,\r\n    ContractReceipt,\r\n    ContractTransaction,\r\n    Event,\r\n    EventFilter,\r\n\r\n    Overrides,\r\n    PayableOverrides,\r\n    CallOverrides,\r\n\r\n    PopulatedTransaction,\r\n\r\n    ContractInterface,\r\n\r\n    TypedDataDomain,\r\n    TypedDataField,\r\n\r\n    BigNumberish,\r\n\r\n    Bytes,\r\n    BytesLike,\r\n\r\n    Signature,\r\n\r\n    Transaction,\r\n    UnsignedTransaction,\r\n\r\n    Wordlist\r\n} from \"./ethers\";\r\n"],
  "mappings": "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",
  "names": ["parent", "node", "init_lib", "result", "logger", "init_lib", "init_lib", "logger", "init_lib", "init_lib", "init_lib", "init_lib", "logger", "init_lib", "logger", "init_lib", "value", "lib_exports", "init_lib", "version", "init_version", "logger", "paramType", "init_lib", "init_version", "version", "runningEvent", "init_lib", "init_lib", "version", "init_version", "logger", "init_lib", "init_version", "version", "words", "wordlist", "init_lib", "version", "init_version", "lib_exports", "wordlist", "words", "logger", "_constructorGuard", "init_lib", "init_version", "version", "version", "init_version", "randomBytes", "init_lib", "logger", "aes", "init_lib", "init_version", "version", "init_lib", "aes", "logger", "pbkdf2", "N", "scrypt", "decrypt", "import_aes_js", "init_lib", "init_version", "version", "lib_exports", "decrypt", "init_lib", "version", "init_version", "lib_exports", "hasMnemonic", "logger", "init_lib", "init_version", "version", "wordlist", "version", "init_version", "lib_exports", "keccak256", "pack", "sha256", "logger", "value", "init_lib", "init_version", "version", "version", "init_version", "lib_exports", "logger", "init_lib", "init_version", "version", "lib_exports", "keccak256", "pack", "sha256", "init_utils", "init_lib", "version", "init_version", "lib_exports", "logger", "version", "init_lib", "init_utils", "init_version", "lib_exports", "logger", "version", "init_lib"]
}
