import {
  LOGIN_PROVIDER,
  init_openlogin_esm
} from "./chunk-44CMTREF.js";
import {
  require_dist
} from "./chunk-QMXEXLRZ.js";
import {
  bowser_default,
  init_bowser
} from "./chunk-6VMHIOOS.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  CHAIN_NAMESPACES,
  EVM_ADAPTERS,
  SOLANA_ADAPTERS,
  SafeEventEmitter,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  _defineProperty,
  getChainConfig,
  init_base_esm,
  init_defineProperty,
  init_openloginJrpc_esm,
  log,
  require_lodash,
  storageAvailable
} from "./chunk-MC6I55GU.js";
import "./chunk-UEWYYRZC.js";
import "./chunk-PUGUP7MZ.js";
import "./chunk-BU2HI77A.js";
import "./chunk-OHW4TDCP.js";
import "./chunk-AQ6RT5SW.js";
import "./chunk-P3UYPI43.js";
import {
  index_es_exports,
  init_index_es
} from "./chunk-LI4R27ON.js";
import {
  require_react_is
} from "./chunk-K5VULBV4.js";
import "./chunk-7TIJRBWW.js";
import "./chunk-YNZJHIXH.js";
import {
  require_crypto
} from "./chunk-Y2LWIENH.js";
import "./chunk-FDRWN2QF.js";
import {
  require_events
} from "./chunk-GPX5XOM5.js";
import "./chunk-OP3MHZRI.js";
import "./chunk-RLCZAOQ6.js";
import {
  require_jsx_runtime
} from "./chunk-VVPHE36V.js";
import {
  require_aes_js,
  require_scrypt
} from "./chunk-TZBESOIF.js";
import {
  require_bech32
} from "./chunk-7GHALKSO.js";
import {
  require_sha3
} from "./chunk-JVHSL6P6.js";
import {
  require_hash
} from "./chunk-XRYAEC2L.js";
import {
  require_buffer
} from "./chunk-3JC5L5ZG.js";
import "./chunk-UFR7PFM3.js";
import {
  require_react_dom
} from "./chunk-R2JNQI3O.js";
import {
  require_react
} from "./chunk-JTDWFPTU.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/core-js-pure/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js-pure/internals/global.js"(exports, module) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js-pure/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js-pure/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js-pure/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js-pure/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js-pure/internals/function-apply.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn2) {
      return function() {
        return call.apply(fn2, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js-pure/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString2 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString2(it), 8, -1);
    };
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn2) {
      if (classofRaw(fn2) === "Function")
        return uncurryThis(fn2);
    };
  }
});

// node_modules/core-js-pure/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js-pure/internals/is-callable.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js-pure/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js-pure/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js-pure/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js-pure/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js-pure/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js-pure/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js-pure/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js-pure/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js-pure/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js-pure/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js-pure/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it))
        throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js-pure/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js-pure/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js-pure/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js-pure/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js-pure/internals/path.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in.js"(exports, module) {
    "use strict";
    var path = require_path();
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = function(variable) {
      return isCallable(variable) ? variable : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
    };
  }
});

// node_modules/core-js-pure/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js-pure/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js-pure/internals/engine-user-agent.js"(exports, module) {
    "use strict";
    module.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  }
});

// node_modules/core-js-pure/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js-pure/internals/engine-v8-version.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global2.process;
    var Deno2 = global2.Deno;
    var versions = process2 && process2.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match;
    var version28;
    if (v8) {
      match = v8.split(".");
      version28 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version28 && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version28 = +match[1];
      }
    }
    module.exports = version28;
  }
});

// node_modules/core-js-pure/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js-pure/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    var global2 = require_global();
    var $String = global2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js-pure/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js-pure/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js-pure/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js-pure/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js-pure/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js-pure/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js-pure/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js-pure/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js-pure/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js-pure/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P2) {
      var func = V[P2];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js-pure/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn2, val;
      if (pref === "string" && isCallable(fn2 = input.toString) && !isObject(val = call(fn2, input)))
        return val;
      if (isCallable(fn2 = input.valueOf) && !isObject(val = call(fn2, input)))
        return val;
      if (pref !== "string" && isCallable(fn2 = input.toString) && !isObject(val = call(fn2, input)))
        return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js-pure/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js-pure/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = true;
  }
});

// node_modules/core-js-pure/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js-pure/internals/define-global-property.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module.exports = function(key2, value) {
      try {
        defineProperty(global2, key2, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key2] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js-pure/internals/shared-store.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.36.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.36.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js-pure/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js-pure/internals/shared.js"(exports, module) {
    "use strict";
    var store = require_shared_store();
    module.exports = function(key2, value) {
      return store[key2] || (store[key2] = value || {});
    };
  }
});

// node_modules/core-js-pure/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js-pure/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js-pure/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js-pure/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn(it, key2) {
      return hasOwnProperty(toObject(it), key2);
    };
  }
});

// node_modules/core-js-pure/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js-pure/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id2 = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis(1 .toString);
    module.exports = function(key2) {
      return "Symbol(" + (key2 === void 0 ? "" : key2) + ")_" + toString2(++id2 + postfix, 36);
    };
  }
});

// node_modules/core-js-pure/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = global2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name2) {
      if (!hasOwn(WellKnownSymbolsStore, name2)) {
        WellKnownSymbolsStore[name2] = NATIVE_SYMBOL && hasOwn(Symbol2, name2) ? Symbol2[name2] : createWellKnownSymbol("Symbol." + name2);
      }
      return WellKnownSymbolsStore[name2];
    };
  }
});

// node_modules/core-js-pure/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result))
          return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js-pure/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js-pure/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key2 = toPrimitive(argument, "string");
      return isSymbol(key2) ? key2 : key2 + "";
    };
  }
});

// node_modules/core-js-pure/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js-pure/internals/document-create-element.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var isObject = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js-pure/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js-pure/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P2) {
      O2 = toIndexedObject(O2);
      P2 = toPropertyKey(P2);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O2, P2);
        } catch (error) {
        }
      if (hasOwn(O2, P2))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
    };
  }
});

// node_modules/core-js-pure/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js-pure/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js-pure/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-context.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module.exports = function(fn2, that) {
      aCallable(fn2);
      return that === void 0 ? fn2 : NATIVE_BIND ? bind(fn2, that) : function() {
        return fn2.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js-pure/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js-pure/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js-pure/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject(argument))
        return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js-pure/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js-pure/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P2, Attributes) {
      anObject(O2);
      P2 = toPropertyKey(P2);
      anObject(Attributes);
      if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O2, P2);
        if (current && current[WRITABLE]) {
          O2[P2] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O2, P2, Attributes);
    } : $defineProperty : function defineProperty(O2, P2, Attributes) {
      anObject(O2);
      P2 = toPropertyKey(P2);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O2, P2, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O2[P2] = Attributes.value;
      return O2;
    };
  }
});

// node_modules/core-js-pure/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js-pure/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key2, value) {
      return definePropertyModule.f(object, key2, createPropertyDescriptor(1, value));
    } : function(object, key2, value) {
      object[key2] = value;
      return object;
    };
  }
});

// node_modules/core-js-pure/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js-pure/internals/export.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var uncurryThis = require_function_uncurry_this_clause();
    var isCallable = require_is_callable();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var isForced = require_is_forced();
    var path = require_path();
    var bind = require_function_bind_context();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    require_shared_store();
    var wrapConstructor = function(NativeConstructor) {
      var Wrapper = function(a2, b2, c2) {
        if (this instanceof Wrapper) {
          switch (arguments.length) {
            case 0:
              return new NativeConstructor();
            case 1:
              return new NativeConstructor(a2);
            case 2:
              return new NativeConstructor(a2, b2);
          }
          return new NativeConstructor(a2, b2, c2);
        }
        return apply(NativeConstructor, this, arguments);
      };
      Wrapper.prototype = NativeConstructor.prototype;
      return Wrapper;
    };
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var PROTO = options.proto;
      var nativeSource = GLOBAL ? global2 : STATIC ? global2[TARGET] : global2[TARGET] && global2[TARGET].prototype;
      var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
      var targetPrototype = target.prototype;
      var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
      var key2, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
      for (key2 in source) {
        FORCED = isForced(GLOBAL ? key2 : TARGET + (STATIC ? "." : "#") + key2, options.forced);
        USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key2);
        targetProperty = target[key2];
        if (USE_NATIVE)
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(nativeSource, key2);
            nativeProperty = descriptor && descriptor.value;
          } else
            nativeProperty = nativeSource[key2];
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key2];
        if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty)
          continue;
        if (options.bind && USE_NATIVE)
          resultProperty = bind(sourceProperty, global2);
        else if (options.wrap && USE_NATIVE)
          resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable(sourceProperty))
          resultProperty = uncurryThis(sourceProperty);
        else
          resultProperty = sourceProperty;
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(resultProperty, "sham", true);
        }
        createNonEnumerableProperty(target, key2, resultProperty);
        if (PROTO) {
          VIRTUAL_PROTOTYPE = TARGET + "Prototype";
          if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
            createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
          }
          createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key2, sourceProperty);
          if (options.real && targetPrototype && (FORCED || !targetPrototype[key2])) {
            createNonEnumerableProperty(targetPrototype, key2, sourceProperty);
          }
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js-pure/internals/is-array.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray(argument) {
      return classof(argument) === "Array";
    };
  }
});

// node_modules/core-js-pure/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js-pure/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || function trunc(x2) {
      var n2 = +x2;
      return (n2 > 0 ? floor : ceil)(n2);
    };
  }
});

// node_modules/core-js-pure/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js-pure/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js-pure/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js-pure/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min(len, 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js-pure/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js-pure/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    module.exports = function(it) {
      if (it > MAX_SAFE_INTEGER2)
        throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js-pure/internals/create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js-pure/internals/create-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key2, value) {
      if (DESCRIPTORS)
        definePropertyModule.f(object, key2, createPropertyDescriptor(0, value));
      else
        object[key2] = value;
    };
  }
});

// node_modules/core-js-pure/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js-pure/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js-pure/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js-pure/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key2) {
      try {
        return it[key2];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O2, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) === "Object" && isCallable(O2.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js-pure/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js-pure/internals/inspect-source.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// node_modules/core-js-pure/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js-pure/internals/is-constructor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop = function() {
    };
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js-pure/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js-pure/internals/array-species-constructor.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module.exports = function(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype)))
          C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null)
            C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// node_modules/core-js-pure/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js-pure/internals/array-species-create.js"(exports, module) {
    "use strict";
    var arraySpeciesConstructor = require_array_species_constructor();
    module.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js-pure/internals/array-method-has-species-support.js
var require_array_method_has_species_support = __commonJS({
  "node_modules/core-js-pure/internals/array-method-has-species-support.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_engine_v8_version();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(METHOD_NAME) {
      return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES] = function() {
          return { foo: 1 };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
  }
});

// node_modules/core-js-pure/modules/es.array.concat.js
var require_es_array_concat = __commonJS({
  "node_modules/core-js-pure/modules/es.array.concat.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var isArray = require_is_array();
    var isObject = require_is_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var createProperty = require_create_property();
    var arraySpeciesCreate = require_array_species_create();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_engine_v8_version();
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var isConcatSpreadable = function(O2) {
      if (!isObject(O2))
        return false;
      var spreadable = O2[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray(O2);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
    $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat2(arg) {
        var O2 = toObject(this);
        var A2 = arraySpeciesCreate(O2, 0);
        var n2 = 0;
        var i2, k2, length, len, E2;
        for (i2 = -1, length = arguments.length; i2 < length; i2++) {
          E2 = i2 === -1 ? O2 : arguments[i2];
          if (isConcatSpreadable(E2)) {
            len = lengthOfArrayLike(E2);
            doesNotExceedSafeInteger(n2 + len);
            for (k2 = 0; k2 < len; k2++, n2++)
              if (k2 in E2)
                createProperty(A2, n2, E2[k2]);
          } else {
            doesNotExceedSafeInteger(n2 + 1);
            createProperty(A2, n2++, E2);
          }
        }
        A2.length = n2;
        return A2;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.object.to-string.js
var require_es_object_to_string = __commonJS({
  "node_modules/core-js-pure/modules/es.object.to-string.js"() {
  }
});

// node_modules/core-js-pure/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js-pure/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js-pure/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js-pure/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js-pure/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js-pure/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O2 = toIndexedObject($this);
        var length = lengthOfArrayLike(O2);
        if (length === 0)
          return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length > index) {
            value = O2[index++];
            if (value !== value)
              return true;
          }
        else
          for (; length > index; index++) {
            if ((IS_INCLUDES || index in O2) && O2[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js-pure/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js-pure/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js-pure/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names2) {
      var O2 = toIndexedObject(object);
      var i2 = 0;
      var result = [];
      var key2;
      for (key2 in O2)
        !hasOwn(hiddenKeys, key2) && hasOwn(O2, key2) && push(result, key2);
      while (names2.length > i2)
        if (hasOwn(O2, key2 = names2[i2++])) {
          ~indexOf(result, key2) || push(result, key2);
        }
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js-pure/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js-pure/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js-pure/internals/object-keys.js"(exports, module) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys(O2) {
      return internalObjectKeys(O2, enumBugKeys);
    };
  }
});

// node_modules/core-js-pure/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js-pure/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
      anObject(O2);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key2;
      while (length > index)
        definePropertyModule.f(O2, key2 = keys[index++], props[key2]);
      return O2;
    };
  }
});

// node_modules/core-js-pure/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js-pure/internals/html.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js-pure/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js-pure/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key2) {
      return keys[key2] || (keys[key2] = uid(key2));
    };
  }
});

// node_modules/core-js-pure/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js-pure/internals/object-create.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create(O2, Properties) {
      var result;
      if (O2 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O2);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O2;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
      return internalObjectKeys(O2, hiddenKeys);
    };
  }
});

// node_modules/core-js-pure/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js-pure/internals/array-slice.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-names-external.js
var require_object_get_own_property_names_external = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-names-external.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    var toIndexedObject = require_to_indexed_object();
    var $getOwnPropertyNames = require_object_get_own_property_names().f;
    var arraySlice = require_array_slice();
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js-pure/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js-pure/internals/define-built-in.js"(exports, module) {
    "use strict";
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module.exports = function(target, key2, value, options) {
      if (options && options.enumerable)
        target[key2] = value;
      else
        createNonEnumerableProperty(target, key2, value);
      return target;
    };
  }
});

// node_modules/core-js-pure/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "node_modules/core-js-pure/internals/define-built-in-accessor.js"(exports, module) {
    "use strict";
    var defineProperty = require_object_define_property();
    module.exports = function(target, name2, descriptor) {
      return defineProperty.f(target, name2, descriptor);
    };
  }
});

// node_modules/core-js-pure/internals/well-known-symbol-wrapped.js
var require_well_known_symbol_wrapped = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol-wrapped.js"(exports) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    exports.f = wellKnownSymbol;
  }
});

// node_modules/core-js-pure/internals/well-known-symbol-define.js
var require_well_known_symbol_define = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol-define.js"(exports, module) {
    "use strict";
    var path = require_path();
    var hasOwn = require_has_own_property();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineProperty = require_object_define_property().f;
    module.exports = function(NAME) {
      var Symbol2 = path.Symbol || (path.Symbol = {});
      if (!hasOwn(Symbol2, NAME))
        defineProperty(Symbol2, NAME, {
          value: wrappedWellKnownSymbolModule.f(NAME)
        });
    };
  }
});

// node_modules/core-js-pure/internals/symbol-define-to-primitive.js
var require_symbol_define_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/symbol-define-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var getBuiltIn = require_get_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var defineBuiltIn = require_define_built_in();
    module.exports = function() {
      var Symbol2 = getBuiltIn("Symbol");
      var SymbolPrototype = Symbol2 && Symbol2.prototype;
      var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
        defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
          return call(valueOf, this);
        }, { arity: 1 });
      }
    };
  }
});

// node_modules/core-js-pure/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js-pure/internals/object-to-string.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js-pure/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js-pure/internals/set-to-string-tag.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var defineProperty = require_object_define_property().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var toString2 = require_object_to_string();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(it, TAG, STATIC, SET_METHOD) {
      var target = STATIC ? it : it && it.prototype;
      if (target) {
        if (!hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
        if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
          createNonEnumerableProperty(target, "toString", toString2);
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js-pure/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap = global2.WeakMap;
    module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
  }
});

// node_modules/core-js-pure/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js-pure/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js-pure/internals/array-iteration.js
var require_array_iteration = __commonJS({
  "node_modules/core-js-pure/internals/array-iteration.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    var push = uncurryThis([].push);
    var createMethod = function(TYPE) {
      var IS_MAP = TYPE === 1;
      var IS_FILTER = TYPE === 2;
      var IS_SOME = TYPE === 3;
      var IS_EVERY = TYPE === 4;
      var IS_FIND_INDEX = TYPE === 6;
      var IS_FILTER_REJECT = TYPE === 7;
      var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O2 = toObject($this);
        var self2 = IndexedObject(O2);
        var length = lengthOfArrayLike(self2);
        var boundFunction = bind(callbackfn, that);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
        var value, result;
        for (; length > index; index++)
          if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O2);
            if (TYPE) {
              if (IS_MAP)
                target[index] = result;
              else if (result)
                switch (TYPE) {
                  case 3:
                    return true;
                  case 5:
                    return value;
                  case 6:
                    return index;
                  case 2:
                    push(target, value);
                }
              else
                switch (TYPE) {
                  case 4:
                    return false;
                  case 7:
                    push(target, value);
                }
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    module.exports = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod(7)
    };
  }
});

// node_modules/core-js-pure/modules/es.symbol.constructor.js
var require_es_symbol_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.constructor.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var fails = require_fails();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var $toString = require_to_string();
    var createPropertyDescriptor = require_create_property_descriptor();
    var nativeObjectCreate = require_object_create();
    var objectKeys = require_object_keys();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    var definePropertiesModule = require_object_define_properties();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var shared = require_shared();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var uid = require_uid();
    var wellKnownSymbol = require_well_known_symbol();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var defineSymbolToPrimitive = require_symbol_define_to_primitive();
    var setToStringTag = require_set_to_string_tag();
    var InternalStateModule = require_internal_state();
    var $forEach = require_array_iteration().forEach;
    var HIDDEN = sharedKey("hidden");
    var SYMBOL = "Symbol";
    var PROTOTYPE = "prototype";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE];
    var $Symbol = global2.Symbol;
    var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
    var RangeError2 = global2.RangeError;
    var TypeError2 = global2.TypeError;
    var QObject = global2.QObject;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
    var push = uncurryThis([].push);
    var AllSymbols = shared("symbols");
    var ObjectPrototypeSymbols = shared("op-symbols");
    var WellKnownSymbolsStore = shared("wks");
    var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var fallbackDefineProperty = function(O2, P2, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
      if (ObjectPrototypeDescriptor)
        delete ObjectPrototype[P2];
      nativeDefineProperty(O2, P2, Attributes);
      if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype) {
        nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
      }
    };
    var setSymbolDescriptor = DESCRIPTORS && fails(function() {
      return nativeObjectCreate(nativeDefineProperty({}, "a", {
        get: function() {
          return nativeDefineProperty(this, "a", { value: 7 }).a;
        }
      })).a !== 7;
    }) ? fallbackDefineProperty : nativeDefineProperty;
    var wrap = function(tag, description) {
      var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
      setInternalState(symbol, {
        type: SYMBOL,
        tag,
        description
      });
      if (!DESCRIPTORS)
        symbol.description = description;
      return symbol;
    };
    var $defineProperty = function defineProperty(O2, P2, Attributes) {
      if (O2 === ObjectPrototype)
        $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
      anObject(O2);
      var key2 = toPropertyKey(P2);
      anObject(Attributes);
      if (hasOwn(AllSymbols, key2)) {
        if (!Attributes.enumerable) {
          if (!hasOwn(O2, HIDDEN))
            nativeDefineProperty(O2, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
          O2[HIDDEN][key2] = true;
        } else {
          if (hasOwn(O2, HIDDEN) && O2[HIDDEN][key2])
            O2[HIDDEN][key2] = false;
          Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
        }
        return setSymbolDescriptor(O2, key2, Attributes);
      }
      return nativeDefineProperty(O2, key2, Attributes);
    };
    var $defineProperties = function defineProperties(O2, Properties) {
      anObject(O2);
      var properties = toIndexedObject(Properties);
      var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys, function(key2) {
        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key2))
          $defineProperty(O2, key2, properties[key2]);
      });
      return O2;
    };
    var $create = function create(O2, Properties) {
      return Properties === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(V) {
      var P2 = toPropertyKey(V);
      var enumerable = call(nativePropertyIsEnumerable, this, P2);
      if (this === ObjectPrototype && hasOwn(AllSymbols, P2) && !hasOwn(ObjectPrototypeSymbols, P2))
        return false;
      return enumerable || !hasOwn(this, P2) || !hasOwn(AllSymbols, P2) || hasOwn(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O2, P2) {
      var it = toIndexedObject(O2);
      var key2 = toPropertyKey(P2);
      if (it === ObjectPrototype && hasOwn(AllSymbols, key2) && !hasOwn(ObjectPrototypeSymbols, key2))
        return;
      var descriptor = nativeGetOwnPropertyDescriptor(it, key2);
      if (descriptor && hasOwn(AllSymbols, key2) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key2])) {
        descriptor.enumerable = true;
      }
      return descriptor;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(O2) {
      var names2 = nativeGetOwnPropertyNames(toIndexedObject(O2));
      var result = [];
      $forEach(names2, function(key2) {
        if (!hasOwn(AllSymbols, key2) && !hasOwn(hiddenKeys, key2))
          push(result, key2);
      });
      return result;
    };
    var $getOwnPropertySymbols = function(O2) {
      var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype;
      var names2 = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O2));
      var result = [];
      $forEach(names2, function(key2) {
        if (hasOwn(AllSymbols, key2) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key2))) {
          push(result, AllSymbols[key2]);
        }
      });
      return result;
    };
    if (!NATIVE_SYMBOL) {
      $Symbol = function Symbol2() {
        if (isPrototypeOf(SymbolPrototype, this))
          throw new TypeError2("Symbol is not a constructor");
        var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
          var $this = this === void 0 ? global2 : this;
          if ($this === ObjectPrototype)
            call(setter, ObjectPrototypeSymbols, value);
          if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag))
            $this[HIDDEN][tag] = false;
          var descriptor = createPropertyDescriptor(1, value);
          try {
            setSymbolDescriptor($this, tag, descriptor);
          } catch (error) {
            if (!(error instanceof RangeError2))
              throw error;
            fallbackDefineProperty($this, tag, descriptor);
          }
        };
        if (DESCRIPTORS && USE_SETTER)
          setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
        return wrap(tag, description);
      };
      SymbolPrototype = $Symbol[PROTOTYPE];
      defineBuiltIn(SymbolPrototype, "toString", function toString2() {
        return getInternalState(this).tag;
      });
      defineBuiltIn($Symbol, "withoutSetter", function(description) {
        return wrap(uid(description), description);
      });
      propertyIsEnumerableModule.f = $propertyIsEnumerable;
      definePropertyModule.f = $defineProperty;
      definePropertiesModule.f = $defineProperties;
      getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
      getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
      wrappedWellKnownSymbolModule.f = function(name2) {
        return wrap(wellKnownSymbol(name2), name2);
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });
        if (!IS_PURE) {
          defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore), function(name2) {
      defineWellKnownSymbol(name2);
    });
    $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
      useSetter: function() {
        USE_SETTER = true;
      },
      useSimple: function() {
        USE_SETTER = false;
      }
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
      // `Object.create` method
      // https://tc39.es/ecma262/#sec-object.create
      create: $create,
      // `Object.defineProperty` method
      // https://tc39.es/ecma262/#sec-object.defineproperty
      defineProperty: $defineProperty,
      // `Object.defineProperties` method
      // https://tc39.es/ecma262/#sec-object.defineproperties
      defineProperties: $defineProperties,
      // `Object.getOwnPropertyDescriptor` method
      // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
      // `Object.getOwnPropertyNames` method
      // https://tc39.es/ecma262/#sec-object.getownpropertynames
      getOwnPropertyNames: $getOwnPropertyNames
    });
    defineSymbolToPrimitive();
    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
  }
});

// node_modules/core-js-pure/internals/symbol-registry-detection.js
var require_symbol_registry_detection = __commonJS({
  "node_modules/core-js-pure/internals/symbol-registry-detection.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
  }
});

// node_modules/core-js-pure/modules/es.symbol.for.js
var require_es_symbol_for = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.for.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var hasOwn = require_has_own_property();
    var toString2 = require_to_string();
    var shared = require_shared();
    var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
    var StringToSymbolRegistry = shared("string-to-symbol-registry");
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
      "for": function(key2) {
        var string = toString2(key2);
        if (hasOwn(StringToSymbolRegistry, string))
          return StringToSymbolRegistry[string];
        var symbol = getBuiltIn("Symbol")(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.symbol.key-for.js
var require_es_symbol_key_for = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.key-for.js"() {
    "use strict";
    var $ = require_export();
    var hasOwn = require_has_own_property();
    var isSymbol = require_is_symbol();
    var tryToString = require_try_to_string();
    var shared = require_shared();
    var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym))
          throw new TypeError(tryToString(sym) + " is not a symbol");
        if (hasOwn(SymbolToStringRegistry, sym))
          return SymbolToStringRegistry[sym];
      }
    });
  }
});

// node_modules/core-js-pure/internals/get-json-replacer-function.js
var require_get_json_replacer_function = __commonJS({
  "node_modules/core-js-pure/internals/get-json-replacer-function.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isArray = require_is_array();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var toString2 = require_to_string();
    var push = uncurryThis([].push);
    module.exports = function(replacer) {
      if (isCallable(replacer))
        return replacer;
      if (!isArray(replacer))
        return;
      var rawLength = replacer.length;
      var keys = [];
      for (var i2 = 0; i2 < rawLength; i2++) {
        var element = replacer[i2];
        if (typeof element == "string")
          push(keys, element);
        else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String")
          push(keys, toString2(element));
      }
      var keysLength = keys.length;
      var root = true;
      return function(key2, value) {
        if (root) {
          root = false;
          return value;
        }
        if (isArray(this))
          return value;
        for (var j2 = 0; j2 < keysLength; j2++)
          if (keys[j2] === key2)
            return value;
      };
    };
  }
});

// node_modules/core-js-pure/modules/es.json.stringify.js
var require_es_json_stringify = __commonJS({
  "node_modules/core-js-pure/modules/es.json.stringify.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isSymbol = require_is_symbol();
    var arraySlice = require_array_slice();
    var getReplacerFunction = require_get_json_replacer_function();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var $String = String;
    var $stringify = getBuiltIn("JSON", "stringify");
    var exec = uncurryThis(/./.exec);
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var replace = uncurryThis("".replace);
    var numberToString = uncurryThis(1 .toString);
    var tester = /[\uD800-\uDFFF]/g;
    var low = /^[\uD800-\uDBFF]$/;
    var hi = /^[\uDC00-\uDFFF]$/;
    var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
      var symbol = getBuiltIn("Symbol")("stringify detection");
      return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
    });
    var ILL_FORMED_UNICODE = fails(function() {
      return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
    });
    var stringifyWithSymbolsFix = function(it, replacer) {
      var args = arraySlice(arguments);
      var $replacer = getReplacerFunction(replacer);
      if (!isCallable($replacer) && (it === void 0 || isSymbol(it)))
        return;
      args[1] = function(key2, value) {
        if (isCallable($replacer))
          value = call($replacer, this, $String(key2), value);
        if (!isSymbol(value))
          return value;
      };
      return apply($stringify, null, args);
    };
    var fixIllFormed = function(match, offset, string) {
      var prev = charAt(string, offset - 1);
      var next = charAt(string, offset + 1);
      if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
        return "\\u" + numberToString(charCodeAt(match, 0), 16);
      }
      return match;
    };
    if ($stringify) {
      $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify2(it, replacer, space) {
          var args = arraySlice(arguments);
          var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
          return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
        }
      });
    }
  }
});

// node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js
var require_es_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js"() {
    "use strict";
    var $ = require_export();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var fails = require_fails();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var toObject = require_to_object();
    var FORCED = !NATIVE_SYMBOL || fails(function() {
      getOwnPropertySymbolsModule.f(1);
    });
    $({ target: "Object", stat: true, forced: FORCED }, {
      getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.symbol.js
var require_es_symbol = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.js"() {
    "use strict";
    require_es_symbol_constructor();
    require_es_symbol_for();
    require_es_symbol_key_for();
    require_es_json_stringify();
    require_es_object_get_own_property_symbols();
  }
});

// node_modules/core-js-pure/modules/es.symbol.async-iterator.js
var require_es_symbol_async_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.async-iterator.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("asyncIterator");
  }
});

// node_modules/core-js-pure/modules/es.symbol.description.js
var require_es_symbol_description = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.description.js"() {
  }
});

// node_modules/core-js-pure/modules/es.symbol.has-instance.js
var require_es_symbol_has_instance = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.has-instance.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("hasInstance");
  }
});

// node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js
var require_es_symbol_is_concat_spreadable = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("isConcatSpreadable");
  }
});

// node_modules/core-js-pure/modules/es.symbol.iterator.js
var require_es_symbol_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.iterator.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("iterator");
  }
});

// node_modules/core-js-pure/modules/es.symbol.match.js
var require_es_symbol_match = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.match.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("match");
  }
});

// node_modules/core-js-pure/modules/es.symbol.match-all.js
var require_es_symbol_match_all = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.match-all.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("matchAll");
  }
});

// node_modules/core-js-pure/modules/es.symbol.replace.js
var require_es_symbol_replace = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.replace.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("replace");
  }
});

// node_modules/core-js-pure/modules/es.symbol.search.js
var require_es_symbol_search = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.search.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("search");
  }
});

// node_modules/core-js-pure/modules/es.symbol.species.js
var require_es_symbol_species = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.species.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("species");
  }
});

// node_modules/core-js-pure/modules/es.symbol.split.js
var require_es_symbol_split = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.split.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("split");
  }
});

// node_modules/core-js-pure/modules/es.symbol.to-primitive.js
var require_es_symbol_to_primitive = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.to-primitive.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var defineSymbolToPrimitive = require_symbol_define_to_primitive();
    defineWellKnownSymbol("toPrimitive");
    defineSymbolToPrimitive();
  }
});

// node_modules/core-js-pure/modules/es.symbol.to-string-tag.js
var require_es_symbol_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.to-string-tag.js"() {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var setToStringTag = require_set_to_string_tag();
    defineWellKnownSymbol("toStringTag");
    setToStringTag(getBuiltIn("Symbol"), "Symbol");
  }
});

// node_modules/core-js-pure/modules/es.symbol.unscopables.js
var require_es_symbol_unscopables = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.unscopables.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("unscopables");
  }
});

// node_modules/core-js-pure/modules/es.json.to-string-tag.js
var require_es_json_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.json.to-string-tag.js"() {
    "use strict";
    var global2 = require_global();
    var setToStringTag = require_set_to_string_tag();
    setToStringTag(global2.JSON, "JSON", true);
  }
});

// node_modules/core-js-pure/modules/es.math.to-string-tag.js
var require_es_math_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.math.to-string-tag.js"() {
  }
});

// node_modules/core-js-pure/modules/es.reflect.to-string-tag.js
var require_es_reflect_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.reflect.to-string-tag.js"() {
  }
});

// node_modules/core-js-pure/es/symbol/index.js
var require_symbol = __commonJS({
  "node_modules/core-js-pure/es/symbol/index.js"(exports, module) {
    "use strict";
    require_es_array_concat();
    require_es_object_to_string();
    require_es_symbol();
    require_es_symbol_async_iterator();
    require_es_symbol_description();
    require_es_symbol_has_instance();
    require_es_symbol_is_concat_spreadable();
    require_es_symbol_iterator();
    require_es_symbol_match();
    require_es_symbol_match_all();
    require_es_symbol_replace();
    require_es_symbol_search();
    require_es_symbol_species();
    require_es_symbol_split();
    require_es_symbol_to_primitive();
    require_es_symbol_to_string_tag();
    require_es_symbol_unscopables();
    require_es_json_to_string_tag();
    require_es_math_to_string_tag();
    require_es_reflect_to_string_tag();
    var path = require_path();
    module.exports = path.Symbol;
  }
});

// node_modules/core-js-pure/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js-pure/internals/add-to-unscopables.js"(exports, module) {
    "use strict";
    module.exports = function() {
    };
  }
});

// node_modules/core-js-pure/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js-pure/internals/iterators.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js-pure/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js-pure/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js-pure/internals/correct-prototype-getter.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      function F2() {
      }
      F2.prototype.constructor = null;
      return Object.getPrototypeOf(new F2()) !== F2.prototype;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-get-prototype-of.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
      var object = toObject(O2);
      if (hasOwn(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js-pure/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js-pure/internals/iterators-core.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var create = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js-pure/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js-pure/internals/iterator-create-constructor.js"(exports, module) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this-accessor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module.exports = function(object, key2, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key2)[method]));
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js-pure/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS({
  "node_modules/core-js-pure/internals/is-possible-prototype.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    module.exports = function(argument) {
      return isObject(argument) || argument === null;
    };
  }
});

// node_modules/core-js-pure/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js-pure/internals/a-possible-prototype.js"(exports, module) {
    "use strict";
    var isPossiblePrototype = require_is_possible_prototype();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isPossiblePrototype(argument))
        return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js-pure/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-set-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O2, proto) {
        anObject(O2);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O2, proto);
        else
          O2.__proto__ = proto;
        return O2;
      };
    }() : void 0);
  }
});

// node_modules/core-js-pure/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js-pure/internals/iterator-define.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
  }
});

// node_modules/core-js-pure/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js-pure/internals/create-iter-result-object.js"(exports, module) {
    "use strict";
    module.exports = function(value, done) {
      return { value, done };
    };
  }
});

// node_modules/core-js-pure/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject(index, false);
        case "values":
          return createIterResultObject(target[index], false);
      }
      return createIterResultObject([index, target[index]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});

// node_modules/core-js-pure/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js-pure/internals/dom-iterables.js"(exports, module) {
    "use strict";
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js-pure/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js-pure/modules/web.dom-collections.iterator.js"() {
    "use strict";
    require_es_array_iterator();
    var DOMIterables = require_dom_iterables();
    var global2 = require_global();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    for (COLLECTION_NAME in DOMIterables) {
      setToStringTag(global2[COLLECTION_NAME], COLLECTION_NAME);
      Iterators[COLLECTION_NAME] = Iterators.Array;
    }
    var COLLECTION_NAME;
  }
});

// node_modules/core-js-pure/stable/symbol/index.js
var require_symbol2 = __commonJS({
  "node_modules/core-js-pure/stable/symbol/index.js"(exports, module) {
    "use strict";
    var parent = require_symbol();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/modules/esnext.function.metadata.js
var require_esnext_function_metadata = __commonJS({
  "node_modules/core-js-pure/modules/esnext.function.metadata.js"() {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var defineProperty = require_object_define_property().f;
    var METADATA = wellKnownSymbol("metadata");
    var FunctionPrototype = Function.prototype;
    if (FunctionPrototype[METADATA] === void 0) {
      defineProperty(FunctionPrototype, METADATA, {
        value: null
      });
    }
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js
var require_esnext_symbol_async_dispose = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("asyncDispose");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.dispose.js
var require_esnext_symbol_dispose = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.dispose.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("dispose");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.metadata.js
var require_esnext_symbol_metadata = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.metadata.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("metadata");
  }
});

// node_modules/core-js-pure/actual/symbol/index.js
var require_symbol3 = __commonJS({
  "node_modules/core-js-pure/actual/symbol/index.js"(exports, module) {
    "use strict";
    var parent = require_symbol2();
    require_esnext_function_metadata();
    require_esnext_symbol_async_dispose();
    require_esnext_symbol_dispose();
    require_esnext_symbol_metadata();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/internals/symbol-is-registered.js
var require_symbol_is_registered = __commonJS({
  "node_modules/core-js-pure/internals/symbol-is-registered.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var Symbol2 = getBuiltIn("Symbol");
    var keyFor = Symbol2.keyFor;
    var thisSymbolValue = uncurryThis(Symbol2.prototype.valueOf);
    module.exports = Symbol2.isRegisteredSymbol || function isRegisteredSymbol(value) {
      try {
        return keyFor(thisSymbolValue(value)) !== void 0;
      } catch (error) {
        return false;
      }
    };
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.is-registered-symbol.js
var require_esnext_symbol_is_registered_symbol = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.is-registered-symbol.js"() {
    "use strict";
    var $ = require_export();
    var isRegisteredSymbol = require_symbol_is_registered();
    $({ target: "Symbol", stat: true }, {
      isRegisteredSymbol
    });
  }
});

// node_modules/core-js-pure/internals/symbol-is-well-known.js
var require_symbol_is_well_known = __commonJS({
  "node_modules/core-js-pure/internals/symbol-is-well-known.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var isSymbol = require_is_symbol();
    var wellKnownSymbol = require_well_known_symbol();
    var Symbol2 = getBuiltIn("Symbol");
    var $isWellKnownSymbol = Symbol2.isWellKnownSymbol;
    var getOwnPropertyNames = getBuiltIn("Object", "getOwnPropertyNames");
    var thisSymbolValue = uncurryThis(Symbol2.prototype.valueOf);
    var WellKnownSymbolsStore = shared("wks");
    for (i2 = 0, symbolKeys = getOwnPropertyNames(Symbol2), symbolKeysLength = symbolKeys.length; i2 < symbolKeysLength; i2++) {
      try {
        symbolKey = symbolKeys[i2];
        if (isSymbol(Symbol2[symbolKey]))
          wellKnownSymbol(symbolKey);
      } catch (error) {
      }
    }
    var symbolKey;
    var i2;
    var symbolKeys;
    var symbolKeysLength;
    module.exports = function isWellKnownSymbol(value) {
      if ($isWellKnownSymbol && $isWellKnownSymbol(value))
        return true;
      try {
        var symbol = thisSymbolValue(value);
        for (var j2 = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j2 < keysLength; j2++) {
          if (WellKnownSymbolsStore[keys[j2]] == symbol)
            return true;
        }
      } catch (error) {
      }
      return false;
    };
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.is-well-known-symbol.js
var require_esnext_symbol_is_well_known_symbol = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.is-well-known-symbol.js"() {
    "use strict";
    var $ = require_export();
    var isWellKnownSymbol = require_symbol_is_well_known();
    $({ target: "Symbol", stat: true, forced: true }, {
      isWellKnownSymbol
    });
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.matcher.js
var require_esnext_symbol_matcher = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.matcher.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("matcher");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.observable.js
var require_esnext_symbol_observable = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.observable.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("observable");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.is-registered.js
var require_esnext_symbol_is_registered = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.is-registered.js"() {
    "use strict";
    var $ = require_export();
    var isRegisteredSymbol = require_symbol_is_registered();
    $({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, {
      isRegistered: isRegisteredSymbol
    });
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js
var require_esnext_symbol_is_well_known = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js"() {
    "use strict";
    var $ = require_export();
    var isWellKnownSymbol = require_symbol_is_well_known();
    $({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, {
      isWellKnown: isWellKnownSymbol
    });
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js
var require_esnext_symbol_metadata_key = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("metadataKey");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js
var require_esnext_symbol_pattern_match = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("patternMatch");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.replace-all.js
var require_esnext_symbol_replace_all = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.replace-all.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("replaceAll");
  }
});

// node_modules/core-js-pure/full/symbol/index.js
var require_symbol4 = __commonJS({
  "node_modules/core-js-pure/full/symbol/index.js"(exports, module) {
    "use strict";
    var parent = require_symbol3();
    require_esnext_symbol_is_registered_symbol();
    require_esnext_symbol_is_well_known_symbol();
    require_esnext_symbol_matcher();
    require_esnext_symbol_observable();
    require_esnext_symbol_is_registered();
    require_esnext_symbol_is_well_known();
    require_esnext_symbol_metadata_key();
    require_esnext_symbol_pattern_match();
    require_esnext_symbol_replace_all();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/symbol/index.js
var require_symbol5 = __commonJS({
  "node_modules/core-js-pure/features/symbol/index.js"(exports, module) {
    "use strict";
    module.exports = require_symbol4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/symbol.js
var require_symbol6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/symbol.js"(exports, module) {
    module.exports = require_symbol5();
  }
});

// node_modules/core-js-pure/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js-pure/internals/string-multibyte.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S2 = toString2(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S2.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S2, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position) : first : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js-pure/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var toString2 = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString2(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point3;
      if (index >= string.length)
        return createIterResultObject(void 0, true);
      point3 = charAt(string, index);
      state.index += point3.length;
      return createIterResultObject(point3, false);
    });
  }
});

// node_modules/core-js-pure/es/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/core-js-pure/es/symbol/iterator.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_object_to_string();
    require_es_string_iterator();
    require_es_symbol_iterator();
    var WrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    module.exports = WrappedWellKnownSymbolModule.f("iterator");
  }
});

// node_modules/core-js-pure/stable/symbol/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/core-js-pure/stable/symbol/iterator.js"(exports, module) {
    "use strict";
    var parent = require_iterator();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/symbol/iterator.js
var require_iterator3 = __commonJS({
  "node_modules/core-js-pure/actual/symbol/iterator.js"(exports, module) {
    "use strict";
    var parent = require_iterator2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/symbol/iterator.js
var require_iterator4 = __commonJS({
  "node_modules/core-js-pure/full/symbol/iterator.js"(exports, module) {
    "use strict";
    var parent = require_iterator3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/symbol/iterator.js
var require_iterator5 = __commonJS({
  "node_modules/core-js-pure/features/symbol/iterator.js"(exports, module) {
    "use strict";
    module.exports = require_iterator4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/symbol/iterator.js
var require_iterator6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/symbol/iterator.js"(exports, module) {
    module.exports = require_iterator5();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/typeof.js"(exports, module) {
    var _Symbol = require_symbol6();
    var _Symbol$iterator = require_iterator6();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof _Symbol && obj2.constructor === _Symbol && obj2 !== _Symbol.prototype ? "symbol" : typeof obj2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/internals/function-bind.js
var require_function_bind = __commonJS({
  "node_modules/core-js-pure/internals/function-bind.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var arraySlice = require_array_slice();
    var NATIVE_BIND = require_function_bind_native();
    var $Function = Function;
    var concat2 = uncurryThis([].concat);
    var join = uncurryThis([].join);
    var factories = {};
    var construct = function(C, argsLength, args) {
      if (!hasOwn(factories, argsLength)) {
        var list = [];
        var i2 = 0;
        for (; i2 < argsLength; i2++)
          list[i2] = "a[" + i2 + "]";
        factories[argsLength] = $Function("C,a", "return new C(" + join(list, ",") + ")");
      }
      return factories[argsLength](C, args);
    };
    module.exports = NATIVE_BIND ? $Function.bind : function bind(that) {
      var F2 = aCallable(this);
      var Prototype = F2.prototype;
      var partArgs = arraySlice(arguments, 1);
      var boundFunction = function bound() {
        var args = concat2(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct(F2, args.length, args) : F2.apply(that, args);
      };
      if (isObject(Prototype))
        boundFunction.prototype = Prototype;
      return boundFunction;
    };
  }
});

// node_modules/core-js-pure/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "node_modules/core-js-pure/internals/a-constructor.js"(exports, module) {
    "use strict";
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});

// node_modules/core-js-pure/modules/es.reflect.construct.js
var require_es_reflect_construct = __commonJS({
  "node_modules/core-js-pure/modules/es.reflect.construct.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var bind = require_function_bind();
    var aConstructor = require_a_constructor();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var create = require_object_create();
    var fails = require_fails();
    var nativeConstruct = getBuiltIn("Reflect", "construct");
    var ObjectPrototype = Object.prototype;
    var push = [].push;
    var NEW_TARGET_BUG = fails(function() {
      function F2() {
      }
      return !(nativeConstruct(function() {
      }, [], F2) instanceof F2);
    });
    var ARGS_BUG = !fails(function() {
      nativeConstruct(function() {
      });
    });
    var FORCED = NEW_TARGET_BUG || ARGS_BUG;
    $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
      construct: function construct(Target, args) {
        aConstructor(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG)
          return nativeConstruct(Target, args, newTarget);
        if (Target === newTarget) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
          var $args = [null];
          apply(push, $args, args);
          return new (apply(bind, Target, $args))();
        }
        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : ObjectPrototype);
        var result = apply(Target, instance, args);
        return isObject(result) ? result : instance;
      }
    });
  }
});

// node_modules/core-js-pure/es/reflect/construct.js
var require_construct = __commonJS({
  "node_modules/core-js-pure/es/reflect/construct.js"(exports, module) {
    "use strict";
    require_es_reflect_construct();
    var path = require_path();
    module.exports = path.Reflect.construct;
  }
});

// node_modules/core-js-pure/stable/reflect/construct.js
var require_construct2 = __commonJS({
  "node_modules/core-js-pure/stable/reflect/construct.js"(exports, module) {
    "use strict";
    var parent = require_construct();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/reflect/construct.js
var require_construct3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/reflect/construct.js"(exports, module) {
    module.exports = require_construct2();
  }
});

// node_modules/core-js-pure/internals/freezing.js
var require_freezing = __commonJS({
  "node_modules/core-js-pure/internals/freezing.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
  }
});

// node_modules/core-js-pure/internals/define-built-ins.js
var require_define_built_ins = __commonJS({
  "node_modules/core-js-pure/internals/define-built-ins.js"(exports, module) {
    "use strict";
    var defineBuiltIn = require_define_built_in();
    module.exports = function(target, src, options) {
      for (var key2 in src) {
        if (options && options.unsafe && target[key2])
          target[key2] = src[key2];
        else
          defineBuiltIn(target, key2, src[key2], options);
      }
      return target;
    };
  }
});

// node_modules/core-js-pure/internals/array-buffer-non-extensible.js
var require_array_buffer_non_extensible = __commonJS({
  "node_modules/core-js-pure/internals/array-buffer-non-extensible.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = fails(function() {
      if (typeof ArrayBuffer == "function") {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer))
          Object.defineProperty(buffer, "a", { value: 8 });
      }
    });
  }
});

// node_modules/core-js-pure/internals/object-is-extensible.js
var require_object_is_extensible = __commonJS({
  "node_modules/core-js-pure/internals/object-is-extensible.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
    var $isExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $isExtensible(1);
    });
    module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
      if (!isObject(it))
        return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer")
        return false;
      return $isExtensible ? $isExtensible(it) : true;
    } : $isExtensible;
  }
});

// node_modules/core-js-pure/internals/internal-metadata.js
var require_internal_metadata = __commonJS({
  "node_modules/core-js-pure/internals/internal-metadata.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var hiddenKeys = require_hidden_keys();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var defineProperty = require_object_define_property().f;
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
    var isExtensible = require_object_is_extensible();
    var uid = require_uid();
    var FREEZING = require_freezing();
    var REQUIRED = false;
    var METADATA = uid("meta");
    var id2 = 0;
    var setMetadata = function(it) {
      defineProperty(it, METADATA, { value: {
        objectID: "O" + id2++,
        // object ID
        weakData: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create) {
      if (!isObject(it))
        return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it))
          return "F";
        if (!create)
          return "E";
        setMetadata(it);
      }
      return it[METADATA].objectID;
    };
    var getWeakData = function(it, create) {
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it))
          return true;
        if (!create)
          return false;
        setMetadata(it);
      }
      return it[METADATA].weakData;
    };
    var onFreeze = function(it) {
      if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
        setMetadata(it);
      return it;
    };
    var enable = function() {
      meta.enable = function() {
      };
      REQUIRED = true;
      var getOwnPropertyNames = getOwnPropertyNamesModule.f;
      var splice = uncurryThis([].splice);
      var test = {};
      test[METADATA] = 1;
      if (getOwnPropertyNames(test).length) {
        getOwnPropertyNamesModule.f = function(it) {
          var result = getOwnPropertyNames(it);
          for (var i2 = 0, length = result.length; i2 < length; i2++) {
            if (result[i2] === METADATA) {
              splice(result, i2, 1);
              break;
            }
          }
          return result;
        };
        $({ target: "Object", stat: true, forced: true }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
      }
    };
    var meta = module.exports = {
      enable,
      fastKey,
      getWeakData,
      onFreeze
    };
    hiddenKeys[METADATA] = true;
  }
});

// node_modules/core-js-pure/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js-pure/internals/is-array-iterator-method.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js-pure/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js-pure/internals/get-iterator-method.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (!isNullOrUndefined(it))
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js-pure/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js-pure/internals/get-iterator.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js-pure/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js-pure/internals/iterator-close.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js-pure/internals/iterate.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn2 = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn2(value[0], value[1], stop) : fn2(value[0], value[1]);
        }
        return INTERRUPTED ? fn2(value, stop) : fn2(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js-pure/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js-pure/internals/an-instance.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module.exports = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it))
        return it;
      throw new $TypeError("Incorrect invocation");
    };
  }
});

// node_modules/core-js-pure/internals/collection.js
var require_collection = __commonJS({
  "node_modules/core-js-pure/internals/collection.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var InternalMetadataModule = require_internal_metadata();
    var fails = require_fails();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var iterate = require_iterate();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var setToStringTag = require_set_to_string_tag();
    var defineProperty = require_object_define_property().f;
    var forEach = require_array_iteration().forEach;
    var DESCRIPTORS = require_descriptors();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = global2[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var exported = {};
      var Constructor;
      if (!DESCRIPTORS || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
        new NativeConstructor().entries().next();
      }))) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
      } else {
        Constructor = wrapper(function(target, iterable) {
          setInternalState(anInstance(target, Prototype), {
            type: CONSTRUCTOR_NAME,
            collection: new NativeConstructor()
          });
          if (!isNullOrUndefined(iterable))
            iterate(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        forEach(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function(KEY) {
          var IS_ADDER = KEY === "add" || KEY === "set";
          if (KEY in NativePrototype && !(IS_WEAK && KEY === "clear")) {
            createNonEnumerableProperty(Prototype, KEY, function(a2, b2) {
              var collection = getInternalState(this).collection;
              if (!IS_ADDER && IS_WEAK && !isObject(a2))
                return KEY === "get" ? void 0 : false;
              var result = collection[KEY](a2 === 0 ? 0 : a2, b2);
              return IS_ADDER ? this : result;
            });
          }
        });
        IS_WEAK || defineProperty(Prototype, "size", {
          configurable: true,
          get: function() {
            return getInternalState(this).collection.size;
          }
        });
      }
      setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
      exported[CONSTRUCTOR_NAME] = Constructor;
      $({ global: true, forced: true }, exported);
      if (!IS_WEAK)
        common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
  }
});

// node_modules/core-js-pure/internals/collection-weak.js
var require_collection_weak = __commonJS({
  "node_modules/core-js-pure/internals/collection-weak.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltIns = require_define_built_ins();
    var getWeakData = require_internal_metadata().getWeakData;
    var anInstance = require_an_instance();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isObject = require_is_object();
    var iterate = require_iterate();
    var ArrayIterationModule = require_array_iteration();
    var hasOwn = require_has_own_property();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var splice = uncurryThis([].splice);
    var id2 = 0;
    var uncaughtFrozenStore = function(state) {
      return state.frozen || (state.frozen = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function() {
      this.entries = [];
    };
    var findUncaughtFrozen = function(store, key2) {
      return find(store.entries, function(it) {
        return it[0] === key2;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function(key2) {
        var entry = findUncaughtFrozen(this, key2);
        if (entry)
          return entry[1];
      },
      has: function(key2) {
        return !!findUncaughtFrozen(this, key2);
      },
      set: function(key2, value) {
        var entry = findUncaughtFrozen(this, key2);
        if (entry)
          entry[1] = value;
        else
          this.entries.push([key2, value]);
      },
      "delete": function(key2) {
        var index = findIndex(this.entries, function(it) {
          return it[0] === key2;
        });
        if (~index)
          splice(this.entries, index, 1);
        return !!~index;
      }
    };
    module.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id2++,
            frozen: void 0
          });
          if (!isNullOrUndefined(iterable))
            iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key2, value) {
          var state = getInternalState(that);
          var data = getWeakData(anObject(key2), true);
          if (data === true)
            uncaughtFrozenStore(state).set(key2, value);
          else
            data[state.id] = value;
          return that;
        };
        defineBuiltIns(Prototype, {
          // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
          // https://tc39.es/ecma262/#sec-weakset.prototype.delete
          "delete": function(key2) {
            var state = getInternalState(this);
            if (!isObject(key2))
              return false;
            var data = getWeakData(key2);
            if (data === true)
              return uncaughtFrozenStore(state)["delete"](key2);
            return data && hasOwn(data, state.id) && delete data[state.id];
          },
          // `{ WeakMap, WeakSet }.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.has
          // https://tc39.es/ecma262/#sec-weakset.prototype.has
          has: function has(key2) {
            var state = getInternalState(this);
            if (!isObject(key2))
              return false;
            var data = getWeakData(key2);
            if (data === true)
              return uncaughtFrozenStore(state).has(key2);
            return data && hasOwn(data, state.id);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          // `WeakMap.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.get
          get: function get(key2) {
            var state = getInternalState(this);
            if (isObject(key2)) {
              var data = getWeakData(key2);
              if (data === true)
                return uncaughtFrozenStore(state).get(key2);
              return data ? data[state.id] : void 0;
            }
          },
          // `WeakMap.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.set
          set: function set(key2, value) {
            return define2(this, key2, value);
          }
        } : {
          // `WeakSet.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-weakset.prototype.add
          add: function add3(value) {
            return define2(this, value, true);
          }
        });
        return Constructor;
      }
    };
  }
});

// node_modules/core-js-pure/modules/es.weak-map.constructor.js
var require_es_weak_map_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.weak-map.constructor.js"() {
    "use strict";
    var FREEZING = require_freezing();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltIns = require_define_built_ins();
    var InternalMetadataModule = require_internal_metadata();
    var collection = require_collection();
    var collectionWeak = require_collection_weak();
    var isObject = require_is_object();
    var enforceInternalState = require_internal_state().enforce;
    var fails = require_fails();
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var $Object = Object;
    var isArray = Array.isArray;
    var isExtensible = $Object.isExtensible;
    var isFrozen = $Object.isFrozen;
    var isSealed = $Object.isSealed;
    var freeze = $Object.freeze;
    var seal = $Object.seal;
    var IS_IE11 = !global2.ActiveXObject && "ActiveXObject" in global2;
    var InternalWeakMap;
    var wrapper = function(init2) {
      return function WeakMap() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    };
    var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
    var WeakMapPrototype = $WeakMap.prototype;
    var nativeSet = uncurryThis(WeakMapPrototype.set);
    var hasMSEdgeFreezingBug = function() {
      return FREEZING && fails(function() {
        var frozenArray = freeze([]);
        nativeSet(new $WeakMap(), frozenArray, 1);
        return !isFrozen(frozenArray);
      });
    };
    if (NATIVE_WEAK_MAP) {
      if (IS_IE11) {
        InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
        InternalMetadataModule.enable();
        nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
        nativeHas = uncurryThis(WeakMapPrototype.has);
        nativeGet = uncurryThis(WeakMapPrototype.get);
        defineBuiltIns(WeakMapPrototype, {
          "delete": function(key2) {
            if (isObject(key2) && !isExtensible(key2)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              return nativeDelete(this, key2) || state.frozen["delete"](key2);
            }
            return nativeDelete(this, key2);
          },
          has: function has(key2) {
            if (isObject(key2) && !isExtensible(key2)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              return nativeHas(this, key2) || state.frozen.has(key2);
            }
            return nativeHas(this, key2);
          },
          get: function get(key2) {
            if (isObject(key2) && !isExtensible(key2)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              return nativeHas(this, key2) ? nativeGet(this, key2) : state.frozen.get(key2);
            }
            return nativeGet(this, key2);
          },
          set: function set(key2, value) {
            if (isObject(key2) && !isExtensible(key2)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              nativeHas(this, key2) ? nativeSet(this, key2, value) : state.frozen.set(key2, value);
            } else
              nativeSet(this, key2, value);
            return this;
          }
        });
      } else if (hasMSEdgeFreezingBug()) {
        defineBuiltIns(WeakMapPrototype, {
          set: function set(key2, value) {
            var arrayIntegrityLevel;
            if (isArray(key2)) {
              if (isFrozen(key2))
                arrayIntegrityLevel = freeze;
              else if (isSealed(key2))
                arrayIntegrityLevel = seal;
            }
            nativeSet(this, key2, value);
            if (arrayIntegrityLevel)
              arrayIntegrityLevel(key2);
            return this;
          }
        });
      }
    }
    var nativeDelete;
    var nativeHas;
    var nativeGet;
  }
});

// node_modules/core-js-pure/modules/es.weak-map.js
var require_es_weak_map = __commonJS({
  "node_modules/core-js-pure/modules/es.weak-map.js"() {
    "use strict";
    require_es_weak_map_constructor();
  }
});

// node_modules/core-js-pure/es/weak-map/index.js
var require_weak_map = __commonJS({
  "node_modules/core-js-pure/es/weak-map/index.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_object_to_string();
    require_es_weak_map();
    var path = require_path();
    module.exports = path.WeakMap;
  }
});

// node_modules/core-js-pure/stable/weak-map/index.js
var require_weak_map2 = __commonJS({
  "node_modules/core-js-pure/stable/weak-map/index.js"(exports, module) {
    "use strict";
    var parent = require_weak_map();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/weak-map.js
var require_weak_map3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/weak-map.js"(exports, module) {
    module.exports = require_weak_map2();
  }
});

// node_modules/core-js-pure/modules/es.object.define-property.js
var require_es_object_define_property = __commonJS({
  "node_modules/core-js-pure/modules/es.object.define-property.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var defineProperty = require_object_define_property().f;
    $({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
      defineProperty
    });
  }
});

// node_modules/core-js-pure/es/object/define-property.js
var require_define_property = __commonJS({
  "node_modules/core-js-pure/es/object/define-property.js"(exports, module) {
    "use strict";
    require_es_object_define_property();
    var path = require_path();
    var Object2 = path.Object;
    var defineProperty = module.exports = function defineProperty2(it, key2, desc) {
      return Object2.defineProperty(it, key2, desc);
    };
    if (Object2.defineProperty.sham)
      defineProperty.sham = true;
  }
});

// node_modules/core-js-pure/stable/object/define-property.js
var require_define_property2 = __commonJS({
  "node_modules/core-js-pure/stable/object/define-property.js"(exports, module) {
    "use strict";
    var parent = require_define_property();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js
var require_define_property3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js"(exports, module) {
    module.exports = require_define_property2();
  }
});

// node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js
var require_es_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var toIndexedObject = require_to_indexed_object();
    var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var DESCRIPTORS = require_descriptors();
    var FORCED = !DESCRIPTORS || fails(function() {
      nativeGetOwnPropertyDescriptor(1);
    });
    $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key2) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key2);
      }
    });
  }
});

// node_modules/core-js-pure/es/object/get-own-property-descriptor.js
var require_get_own_property_descriptor = __commonJS({
  "node_modules/core-js-pure/es/object/get-own-property-descriptor.js"(exports, module) {
    "use strict";
    require_es_object_get_own_property_descriptor();
    var path = require_path();
    var Object2 = path.Object;
    var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor2(it, key2) {
      return Object2.getOwnPropertyDescriptor(it, key2);
    };
    if (Object2.getOwnPropertyDescriptor.sham)
      getOwnPropertyDescriptor.sham = true;
  }
});

// node_modules/core-js-pure/stable/object/get-own-property-descriptor.js
var require_get_own_property_descriptor2 = __commonJS({
  "node_modules/core-js-pure/stable/object/get-own-property-descriptor.js"(exports, module) {
    "use strict";
    var parent = require_get_own_property_descriptor();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js
var require_get_own_property_descriptor3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js"(exports, module) {
    module.exports = require_get_own_property_descriptor2();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js-pure/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat2 = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys5(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat2(keys, getOwnPropertySymbols(it)) : keys;
    };
  }
});

// node_modules/core-js-pure/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js-pure/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys5 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys = ownKeys5(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key2 = keys[i2];
        if (!hasOwn(target, key2) && !(exceptions && hasOwn(exceptions, key2))) {
          defineProperty(target, key2, getOwnPropertyDescriptor(source, key2));
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/install-error-cause.js
var require_install_error_cause = __commonJS({
  "node_modules/core-js-pure/internals/install-error-cause.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module.exports = function(O2, options) {
      if (isObject(options) && "cause" in options) {
        createNonEnumerableProperty(O2, "cause", options.cause);
      }
    };
  }
});

// node_modules/core-js-pure/internals/error-stack-clear.js
var require_error_stack_clear = __commonJS({
  "node_modules/core-js-pure/internals/error-stack-clear.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var $Error = Error;
    var replace = uncurryThis("".replace);
    var TEST = function(arg) {
      return String(new $Error(arg).stack);
    }("zxcasd");
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    module.exports = function(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
        while (dropEntries--)
          stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
      }
      return stack;
    };
  }
});

// node_modules/core-js-pure/internals/error-stack-installable.js
var require_error_stack_installable = __commonJS({
  "node_modules/core-js-pure/internals/error-stack-installable.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = !fails(function() {
      var error = new Error("a");
      if (!("stack" in error))
        return true;
      Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
      return error.stack !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/error-stack-install.js
var require_error_stack_install = __commonJS({
  "node_modules/core-js-pure/internals/error-stack-install.js"(exports, module) {
    "use strict";
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var clearErrorStack = require_error_stack_clear();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var captureStackTrace = Error.captureStackTrace;
    module.exports = function(error, C, stack, dropEntries) {
      if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace)
          captureStackTrace(error, C);
        else
          createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
      }
    };
  }
});

// node_modules/core-js-pure/internals/normalize-string-argument.js
var require_normalize_string_argument = __commonJS({
  "node_modules/core-js-pure/internals/normalize-string-argument.js"(exports, module) {
    "use strict";
    var toString2 = require_to_string();
    module.exports = function(argument, $default) {
      return argument === void 0 ? arguments.length < 2 ? "" : $default : toString2(argument);
    };
  }
});

// node_modules/core-js-pure/modules/es.aggregate-error.constructor.js
var require_es_aggregate_error_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.aggregate-error.constructor.js"() {
    "use strict";
    var $ = require_export();
    var isPrototypeOf = require_object_is_prototype_of();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var create = require_object_create();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    var installErrorCause = require_install_error_cause();
    var installErrorStack = require_error_stack_install();
    var iterate = require_iterate();
    var normalizeStringArgument = require_normalize_string_argument();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Error = Error;
    var push = [].push;
    var $AggregateError = function AggregateError(errors, message) {
      var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
      var that;
      if (setPrototypeOf) {
        that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
      } else {
        that = isInstance ? this : create(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
      }
      if (message !== void 0)
        createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
      installErrorStack(that, $AggregateError, that.stack, 1);
      if (arguments.length > 2)
        installErrorCause(that, arguments[2]);
      var errorsArray = [];
      iterate(errors, push, { that: errorsArray });
      createNonEnumerableProperty(that, "errors", errorsArray);
      return that;
    };
    if (setPrototypeOf)
      setPrototypeOf($AggregateError, $Error);
    else
      copyConstructorProperties($AggregateError, $Error, { name: true });
    var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
      constructor: createPropertyDescriptor(1, $AggregateError),
      message: createPropertyDescriptor(1, ""),
      name: createPropertyDescriptor(1, "AggregateError")
    });
    $({ global: true, constructor: true, arity: 2 }, {
      AggregateError: $AggregateError
    });
  }
});

// node_modules/core-js-pure/modules/es.aggregate-error.js
var require_es_aggregate_error = __commonJS({
  "node_modules/core-js-pure/modules/es.aggregate-error.js"() {
    "use strict";
    require_es_aggregate_error_constructor();
  }
});

// node_modules/core-js-pure/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-node.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var classof = require_classof_raw();
    module.exports = classof(global2.process) === "process";
  }
});

// node_modules/core-js-pure/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js-pure/internals/set-species.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js-pure/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js-pure/internals/species-constructor.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(O2, defaultConstructor) {
      var C = anObject(O2).constructor;
      var S2;
      return C === void 0 || isNullOrUndefined(S2 = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S2);
    };
  }
});

// node_modules/core-js-pure/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js-pure/internals/validate-arguments-length.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    module.exports = function(passed, required) {
      if (passed < required)
        throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js-pure/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-ios.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js-pure/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js-pure/internals/task.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set = global2.setImmediate;
    var clear = global2.clearImmediate;
    var process2 = global2.process;
    var Dispatch = global2.Dispatch;
    var Function2 = global2.Function;
    var MessageChannel = global2.MessageChannel;
    var String2 = global2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = global2.location;
    });
    var run = function(id2) {
      if (hasOwn(queue, id2)) {
        var fn2 = queue[id2];
        delete queue[id2];
        fn2();
      }
    };
    var runner = function(id2) {
      return function() {
        run(id2);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id2) {
      global2.postMessage(String2(id2), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn2 = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn2, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id2) {
        delete queue[id2];
      };
      if (IS_NODE) {
        defer = function(id2) {
          process2.nextTick(runner(id2));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id2) {
          Dispatch.now(runner(id2));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id2) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id2);
          };
        };
      } else {
        defer = function(id2) {
          setTimeout(runner(id2), 0);
        };
      }
    }
    module.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js-pure/internals/safe-get-built-in.js
var require_safe_get_built_in = __commonJS({
  "node_modules/core-js-pure/internals/safe-get-built-in.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    module.exports = function(name2) {
      if (!DESCRIPTORS)
        return global2[name2];
      var descriptor = getOwnPropertyDescriptor(global2, name2);
      return descriptor && descriptor.value;
    };
  }
});

// node_modules/core-js-pure/internals/queue.js
var require_queue = __commonJS({
  "node_modules/core-js-pure/internals/queue.js"(exports, module) {
    "use strict";
    var Queue = function() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    module.exports = Queue;
  }
});

// node_modules/core-js-pure/internals/engine-is-ios-pebble.js
var require_engine_is_ios_pebble = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-ios-pebble.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});

// node_modules/core-js-pure/internals/engine-is-webos-webkit.js
var require_engine_is_webos_webkit = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-webos-webkit.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js-pure/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js-pure/internals/microtask.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var safeGetBuiltIn = require_safe_get_built_in();
    var bind = require_function_bind_context();
    var macrotask = require_task().set;
    var Queue = require_queue();
    var IS_IOS = require_engine_is_ios();
    var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE = require_engine_is_node();
    var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
    var document2 = global2.document;
    var process2 = global2.process;
    var Promise2 = global2.Promise;
    var microtask = safeGetBuiltIn("queueMicrotask");
    var notify;
    var toggle;
    var node;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue();
      flush = function() {
        var parent, fn2;
        if (IS_NODE && (parent = process2.domain))
          parent.exit();
        while (fn2 = queue.get())
          try {
            fn2();
          } catch (error) {
            if (queue.head)
              notify();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify = function() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, global2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn2) {
        if (!queue.head)
          notify();
        queue.add(fn2);
      };
    }
    var queue;
    var flush;
    module.exports = microtask;
  }
});

// node_modules/core-js-pure/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js-pure/internals/host-report-errors.js"(exports, module) {
    "use strict";
    module.exports = function(a2, b2) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b2);
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js-pure/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js-pure/internals/perform.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js-pure/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS({
  "node_modules/core-js-pure/internals/promise-native-constructor.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    module.exports = global2.Promise;
  }
});

// node_modules/core-js-pure/internals/engine-is-deno.js
var require_engine_is_deno = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-deno.js"(exports, module) {
    "use strict";
    module.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
  }
});

// node_modules/core-js-pure/internals/engine-is-browser.js
var require_engine_is_browser = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-browser.js"(exports, module) {
    "use strict";
    var IS_DENO = require_engine_is_deno();
    var IS_NODE = require_engine_is_node();
    module.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
  }
});

// node_modules/core-js-pure/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS({
  "node_modules/core-js-pure/internals/promise-constructor-detection.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_BROWSER = require_engine_is_browser();
    var IS_DENO = require_engine_is_deno();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_engine_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});

// node_modules/core-js-pure/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js-pure/internals/new-promise-capability.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw new $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };
    module.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// node_modules/core-js-pure/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_engine_is_node();
    var global2 = require_global();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = global2.TypeError;
    var document2 = global2.document;
    var process2 = global2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = function(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name2, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name2, false, true);
        global2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name2]))
        handler(event);
      else if (name2 === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn2, state, unwrap) {
      return function(value) {
        fn2(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        if (state.state === PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});

// node_modules/core-js-pure/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js-pure/internals/check-correctness-of-iteration.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module.exports = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js-pure/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS({
  "node_modules/core-js-pure/internals/promise-statics-incorrect-iteration.js"(exports, module) {
    "use strict";
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.all.js
var require_es_promise_all = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.all.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.catch.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js-pure/modules/es.promise.race.js
var require_es_promise_race = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.race.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.reject.js"() {
    "use strict";
    var $ = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject(r2) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r2);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js-pure/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js-pure/internals/promise-resolve.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module.exports = function(C, x2) {
      anObject(C);
      if (isObject(x2) && x2.constructor === C)
        return x2;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x2);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js-pure/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.resolve.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x2) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.js"() {
    "use strict";
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});

// node_modules/core-js-pure/modules/es.promise.all-settled.js
var require_es_promise_all_settled = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.all-settled.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call(promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = { status: "fulfilled", value };
              --remaining || resolve(values);
            }, function(error) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = { status: "rejected", reason: error };
              --remaining || resolve(values);
            });
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.any.js
var require_es_promise_any = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.any.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var getBuiltIn = require_get_built_in();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    var PROMISE_ANY_ERROR = "No one promise resolved";
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      any: function any(iterable) {
        var C = this;
        var AggregateError = getBuiltIn("AggregateError");
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aCallable(C.resolve);
          var errors = [];
          var counter = 0;
          var remaining = 1;
          var alreadyResolved = false;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyRejected = false;
            remaining++;
            call(promiseResolve, C, promise).then(function(value) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyResolved = true;
              resolve(value);
            }, function(error) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyRejected = true;
              errors[index] = error;
              --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
            });
          });
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.with-resolvers.js
var require_es_promise_with_resolvers = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.with-resolvers.js"() {
    "use strict";
    var $ = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    $({ target: "Promise", stat: true }, {
      withResolvers: function withResolvers() {
        var promiseCapability = newPromiseCapabilityModule.f(this);
        return {
          promise: promiseCapability.promise,
          resolve: promiseCapability.resolve,
          reject: promiseCapability.reject
        };
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.promise.finally.js
var require_es_promise_finally = __commonJS({
  "node_modules/core-js-pure/modules/es.promise.finally.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var fails = require_fails();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var speciesConstructor = require_species_constructor();
    var promiseResolve = require_promise_resolve();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
      NativePromisePrototype["finally"].call({ then: function() {
      } }, function() {
      });
    });
    $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
      "finally": function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn("Promise"));
        var isFunction = isCallable(onFinally);
        return this.then(
          isFunction ? function(x2) {
            return promiseResolve(C, onFinally()).then(function() {
              return x2;
            });
          } : onFinally,
          isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
              throw e;
            });
          } : onFinally
        );
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["finally"];
      if (NativePromisePrototype["finally"] !== method) {
        defineBuiltIn(NativePromisePrototype, "finally", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js-pure/es/promise/index.js
var require_promise = __commonJS({
  "node_modules/core-js-pure/es/promise/index.js"(exports, module) {
    "use strict";
    require_es_aggregate_error();
    require_es_array_iterator();
    require_es_object_to_string();
    require_es_promise();
    require_es_promise_all_settled();
    require_es_promise_any();
    require_es_promise_with_resolvers();
    require_es_promise_finally();
    require_es_string_iterator();
    var path = require_path();
    module.exports = path.Promise;
  }
});

// node_modules/core-js-pure/stable/promise/index.js
var require_promise2 = __commonJS({
  "node_modules/core-js-pure/stable/promise/index.js"(exports, module) {
    "use strict";
    var parent = require_promise();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/promise.js
var require_promise3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/promise.js"(exports, module) {
    module.exports = require_promise2();
  }
});

// node_modules/@babel/runtime-corejs3/node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/@babel/runtime-corejs3/node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key2, desc) {
        obj[key2] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key2, value) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key2];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key2, value) {
          return obj[key2] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn2, obj, arg) {
        try {
          return { type: "normal", arg: fn2.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a '" + methodName + "' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key2 in object) {
          keys.push(key2);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key3 = keys.pop();
            if (key3 in object) {
              next.value = key3;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              while (++i2 < iterable.length) {
                if (hasOwn.call(iterable, i2)) {
                  next2.value = iterable[i2];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name2 in this) {
              if (name2.charAt(0) === "t" && hasOwn.call(this, name2) && !isNaN(+name2.slice(1))) {
                this[name2] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime-corejs3/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime-corejs3/regenerator/index.js"(exports, module) {
    module.exports = require_runtime();
  }
});

// node_modules/core-js-pure/modules/esnext.promise.with-resolvers.js
var require_esnext_promise_with_resolvers = __commonJS({
  "node_modules/core-js-pure/modules/esnext.promise.with-resolvers.js"() {
    "use strict";
    require_es_promise_with_resolvers();
  }
});

// node_modules/core-js-pure/actual/promise/index.js
var require_promise4 = __commonJS({
  "node_modules/core-js-pure/actual/promise/index.js"(exports, module) {
    "use strict";
    var parent = require_promise2();
    require_esnext_promise_with_resolvers();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/modules/esnext.aggregate-error.js
var require_esnext_aggregate_error = __commonJS({
  "node_modules/core-js-pure/modules/esnext.aggregate-error.js"() {
    "use strict";
    require_es_aggregate_error();
  }
});

// node_modules/core-js-pure/modules/esnext.promise.all-settled.js
var require_esnext_promise_all_settled = __commonJS({
  "node_modules/core-js-pure/modules/esnext.promise.all-settled.js"() {
    "use strict";
    require_es_promise_all_settled();
  }
});

// node_modules/core-js-pure/modules/esnext.promise.try.js
var require_esnext_promise_try = __commonJS({
  "node_modules/core-js-pure/modules/esnext.promise.try.js"() {
    "use strict";
    var $ = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    $({ target: "Promise", stat: true, forced: true }, {
      "try": function(callbackfn) {
        var promiseCapability = newPromiseCapabilityModule.f(this);
        var result = perform(callbackfn);
        (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
        return promiseCapability.promise;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.promise.any.js
var require_esnext_promise_any = __commonJS({
  "node_modules/core-js-pure/modules/esnext.promise.any.js"() {
    "use strict";
    require_es_promise_any();
  }
});

// node_modules/core-js-pure/full/promise/index.js
var require_promise5 = __commonJS({
  "node_modules/core-js-pure/full/promise/index.js"(exports, module) {
    "use strict";
    var parent = require_promise4();
    require_esnext_aggregate_error();
    require_esnext_promise_all_settled();
    require_esnext_promise_try();
    require_esnext_promise_any();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/promise/index.js
var require_promise6 = __commonJS({
  "node_modules/core-js-pure/features/promise/index.js"(exports, module) {
    "use strict";
    module.exports = require_promise5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/promise.js
var require_promise7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/promise.js"(exports, module) {
    module.exports = require_promise6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/asyncToGenerator.js"(exports, module) {
    var _Promise = require_promise7();
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
      try {
        var info = gen[key2](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        _Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn2) {
      return function() {
        var self2 = this, args = arguments;
        return new _Promise(function(resolve, reject) {
          var gen = fn2.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/classCallCheck.js"(exports, module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/actual/object/define-property.js
var require_define_property4 = __commonJS({
  "node_modules/core-js-pure/actual/object/define-property.js"(exports, module) {
    "use strict";
    var parent = require_define_property2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/object/define-property.js
var require_define_property5 = __commonJS({
  "node_modules/core-js-pure/full/object/define-property.js"(exports, module) {
    "use strict";
    var parent = require_define_property4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/object/define-property.js
var require_define_property6 = __commonJS({
  "node_modules/core-js-pure/features/object/define-property.js"(exports, module) {
    "use strict";
    module.exports = require_define_property5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/object/define-property.js
var require_define_property7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/object/define-property.js"(exports, module) {
    module.exports = require_define_property6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/createClass.js"(exports, module) {
    var _Object$defineProperty = require_define_property7();
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      _Object$defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/modules/es.object.create.js
var require_es_object_create = __commonJS({
  "node_modules/core-js-pure/modules/es.object.create.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var create = require_object_create();
    $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
      create
    });
  }
});

// node_modules/core-js-pure/es/object/create.js
var require_create = __commonJS({
  "node_modules/core-js-pure/es/object/create.js"(exports, module) {
    "use strict";
    require_es_object_create();
    var path = require_path();
    var Object2 = path.Object;
    module.exports = function create(P2, D2) {
      return Object2.create(P2, D2);
    };
  }
});

// node_modules/core-js-pure/stable/object/create.js
var require_create2 = __commonJS({
  "node_modules/core-js-pure/stable/object/create.js"(exports, module) {
    "use strict";
    var parent = require_create();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/object/create.js
var require_create3 = __commonJS({
  "node_modules/core-js-pure/actual/object/create.js"(exports, module) {
    "use strict";
    var parent = require_create2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/object/create.js
var require_create4 = __commonJS({
  "node_modules/core-js-pure/full/object/create.js"(exports, module) {
    "use strict";
    var parent = require_create3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/object/create.js
var require_create5 = __commonJS({
  "node_modules/core-js-pure/features/object/create.js"(exports, module) {
    "use strict";
    module.exports = require_create4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/object/create.js
var require_create6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/object/create.js"(exports, module) {
    module.exports = require_create5();
  }
});

// node_modules/core-js-pure/modules/es.object.set-prototype-of.js
var require_es_object_set_prototype_of = __commonJS({
  "node_modules/core-js-pure/modules/es.object.set-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var setPrototypeOf = require_object_set_prototype_of();
    $({ target: "Object", stat: true }, {
      setPrototypeOf
    });
  }
});

// node_modules/core-js-pure/es/object/set-prototype-of.js
var require_set_prototype_of = __commonJS({
  "node_modules/core-js-pure/es/object/set-prototype-of.js"(exports, module) {
    "use strict";
    require_es_object_set_prototype_of();
    var path = require_path();
    module.exports = path.Object.setPrototypeOf;
  }
});

// node_modules/core-js-pure/stable/object/set-prototype-of.js
var require_set_prototype_of2 = __commonJS({
  "node_modules/core-js-pure/stable/object/set-prototype-of.js"(exports, module) {
    "use strict";
    var parent = require_set_prototype_of();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/object/set-prototype-of.js
var require_set_prototype_of3 = __commonJS({
  "node_modules/core-js-pure/actual/object/set-prototype-of.js"(exports, module) {
    "use strict";
    var parent = require_set_prototype_of2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/object/set-prototype-of.js
var require_set_prototype_of4 = __commonJS({
  "node_modules/core-js-pure/full/object/set-prototype-of.js"(exports, module) {
    "use strict";
    var parent = require_set_prototype_of3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/object/set-prototype-of.js
var require_set_prototype_of5 = __commonJS({
  "node_modules/core-js-pure/features/object/set-prototype-of.js"(exports, module) {
    "use strict";
    module.exports = require_set_prototype_of4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/object/set-prototype-of.js
var require_set_prototype_of6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/object/set-prototype-of.js"(exports, module) {
    module.exports = require_set_prototype_of5();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/setPrototypeOf.js"(exports, module) {
    var _Object$setPrototypeOf = require_set_prototype_of6();
    function _setPrototypeOf(o2, p2) {
      module.exports = _setPrototypeOf = _Object$setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o2, p2);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/inherits.js"(exports, module) {
    var _Object$create = require_create6();
    var _Object$defineProperty = require_define_property7();
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = _Object$create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      _Object$defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        setPrototypeOf(subClass, superClass);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/possibleConstructorReturn.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized(self2);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/modules/es.object.get-prototype-of.js
var require_es_object_get_prototype_of = __commonJS({
  "node_modules/core-js-pure/modules/es.object.get-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var toObject = require_to_object();
    var nativeGetPrototypeOf = require_object_get_prototype_of();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var FAILS_ON_PRIMITIVES = fails(function() {
      nativeGetPrototypeOf(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
      getPrototypeOf: function getPrototypeOf(it) {
        return nativeGetPrototypeOf(toObject(it));
      }
    });
  }
});

// node_modules/core-js-pure/es/object/get-prototype-of.js
var require_get_prototype_of = __commonJS({
  "node_modules/core-js-pure/es/object/get-prototype-of.js"(exports, module) {
    "use strict";
    require_es_object_get_prototype_of();
    var path = require_path();
    module.exports = path.Object.getPrototypeOf;
  }
});

// node_modules/core-js-pure/stable/object/get-prototype-of.js
var require_get_prototype_of2 = __commonJS({
  "node_modules/core-js-pure/stable/object/get-prototype-of.js"(exports, module) {
    "use strict";
    var parent = require_get_prototype_of();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/object/get-prototype-of.js
var require_get_prototype_of3 = __commonJS({
  "node_modules/core-js-pure/actual/object/get-prototype-of.js"(exports, module) {
    "use strict";
    var parent = require_get_prototype_of2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/object/get-prototype-of.js
var require_get_prototype_of4 = __commonJS({
  "node_modules/core-js-pure/full/object/get-prototype-of.js"(exports, module) {
    "use strict";
    var parent = require_get_prototype_of3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/object/get-prototype-of.js
var require_get_prototype_of5 = __commonJS({
  "node_modules/core-js-pure/features/object/get-prototype-of.js"(exports, module) {
    "use strict";
    module.exports = require_get_prototype_of4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/object/get-prototype-of.js
var require_get_prototype_of6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/object/get-prototype-of.js"(exports, module) {
    module.exports = require_get_prototype_of5();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/getPrototypeOf.js"(exports, module) {
    var _Object$setPrototypeOf = require_set_prototype_of6();
    var _Object$getPrototypeOf = require_get_prototype_of6();
    function _getPrototypeOf(o2) {
      module.exports = _getPrototypeOf = _Object$setPrototypeOf ? _Object$getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || _Object$getPrototypeOf(o3);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o2);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/modules/es.array.is-array.js
var require_es_array_is_array = __commonJS({
  "node_modules/core-js-pure/modules/es.array.is-array.js"() {
    "use strict";
    var $ = require_export();
    var isArray = require_is_array();
    $({ target: "Array", stat: true }, {
      isArray
    });
  }
});

// node_modules/core-js-pure/es/array/is-array.js
var require_is_array2 = __commonJS({
  "node_modules/core-js-pure/es/array/is-array.js"(exports, module) {
    "use strict";
    require_es_array_is_array();
    var path = require_path();
    module.exports = path.Array.isArray;
  }
});

// node_modules/core-js-pure/stable/array/is-array.js
var require_is_array3 = __commonJS({
  "node_modules/core-js-pure/stable/array/is-array.js"(exports, module) {
    "use strict";
    var parent = require_is_array2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/array/is-array.js
var require_is_array4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/array/is-array.js"(exports, module) {
    module.exports = require_is_array3();
  }
});

// node_modules/core-js-pure/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js-pure/internals/array-method-is-strict.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js-pure/internals/array-for-each.js
var require_array_for_each = __commonJS({
  "node_modules/core-js-pure/internals/array-for-each.js"(exports, module) {
    "use strict";
    var $forEach = require_array_iteration().forEach;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    module.exports = !STRICT_METHOD ? function forEach(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
  }
});

// node_modules/core-js-pure/modules/es.array.for-each.js
var require_es_array_for_each = __commonJS({
  "node_modules/core-js-pure/modules/es.array.for-each.js"() {
    "use strict";
    var $ = require_export();
    var forEach = require_array_for_each();
    $({ target: "Array", proto: true, forced: [].forEach !== forEach }, {
      forEach
    });
  }
});

// node_modules/core-js-pure/internals/get-built-in-prototype-method.js
var require_get_built_in_prototype_method = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in-prototype-method.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var path = require_path();
    module.exports = function(CONSTRUCTOR, METHOD) {
      var Namespace = path[CONSTRUCTOR + "Prototype"];
      var pureMethod = Namespace && Namespace[METHOD];
      if (pureMethod)
        return pureMethod;
      var NativeConstructor = global2[CONSTRUCTOR];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      return NativePrototype && NativePrototype[METHOD];
    };
  }
});

// node_modules/core-js-pure/es/array/virtual/for-each.js
var require_for_each = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/for-each.js"(exports, module) {
    "use strict";
    require_es_array_for_each();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "forEach");
  }
});

// node_modules/core-js-pure/stable/array/virtual/for-each.js
var require_for_each2 = __commonJS({
  "node_modules/core-js-pure/stable/array/virtual/for-each.js"(exports, module) {
    "use strict";
    var parent = require_for_each();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/modules/web.dom-collections.for-each.js
var require_web_dom_collections_for_each = __commonJS({
  "node_modules/core-js-pure/modules/web.dom-collections.for-each.js"() {
  }
});

// node_modules/core-js-pure/stable/instance/for-each.js
var require_for_each3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/for-each.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_for_each2();
    require_web_dom_collections_for_each();
    var ArrayPrototype = Array.prototype;
    var DOMIterables = {
      DOMTokenList: true,
      NodeList: true
    };
    module.exports = function(it) {
      var own = it.forEach;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.forEach || hasOwn(DOMIterables, classof(it)) ? method : own;
    };
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js
var require_for_each4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js"(exports, module) {
    module.exports = require_for_each3();
  }
});

// node_modules/core-js-pure/modules/es.object.keys.js
var require_es_object_keys = __commonJS({
  "node_modules/core-js-pure/modules/es.object.keys.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var nativeKeys = require_object_keys();
    var fails = require_fails();
    var FAILS_ON_PRIMITIVES = fails(function() {
      nativeKeys(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
      keys: function keys(it) {
        return nativeKeys(toObject(it));
      }
    });
  }
});

// node_modules/core-js-pure/es/object/keys.js
var require_keys = __commonJS({
  "node_modules/core-js-pure/es/object/keys.js"(exports, module) {
    "use strict";
    require_es_object_keys();
    var path = require_path();
    module.exports = path.Object.keys;
  }
});

// node_modules/core-js-pure/stable/object/keys.js
var require_keys2 = __commonJS({
  "node_modules/core-js-pure/stable/object/keys.js"(exports, module) {
    "use strict";
    var parent = require_keys();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js
var require_keys3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js"(exports, module) {
    module.exports = require_keys2();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/defineProperty.js"(exports, module) {
    var _Object$defineProperty = require_define_property7();
    function _defineProperty2(obj, key2, value) {
      if (key2 in obj) {
        _Object$defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    module.exports = _defineProperty2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/internals/is-data-descriptor.js
var require_is_data_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/is-data-descriptor.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    module.exports = function(descriptor) {
      return descriptor !== void 0 && (hasOwn(descriptor, "value") || hasOwn(descriptor, "writable"));
    };
  }
});

// node_modules/core-js-pure/modules/es.reflect.get.js
var require_es_reflect_get = __commonJS({
  "node_modules/core-js-pure/modules/es.reflect.get.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var isObject = require_is_object();
    var anObject = require_an_object();
    var isDataDescriptor = require_is_data_descriptor();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var getPrototypeOf = require_object_get_prototype_of();
    function get(target, propertyKey) {
      var receiver = arguments.length < 3 ? target : arguments[2];
      var descriptor, prototype;
      if (anObject(target) === receiver)
        return target[propertyKey];
      descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
      if (descriptor)
        return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
      if (isObject(prototype = getPrototypeOf(target)))
        return get(prototype, propertyKey, receiver);
    }
    $({ target: "Reflect", stat: true }, {
      get
    });
  }
});

// node_modules/core-js-pure/es/reflect/get.js
var require_get = __commonJS({
  "node_modules/core-js-pure/es/reflect/get.js"(exports, module) {
    "use strict";
    require_es_reflect_get();
    var path = require_path();
    module.exports = path.Reflect.get;
  }
});

// node_modules/core-js-pure/stable/reflect/get.js
var require_get2 = __commonJS({
  "node_modules/core-js-pure/stable/reflect/get.js"(exports, module) {
    "use strict";
    var parent = require_get();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/reflect/get.js
var require_get3 = __commonJS({
  "node_modules/core-js-pure/actual/reflect/get.js"(exports, module) {
    "use strict";
    var parent = require_get2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/reflect/get.js
var require_get4 = __commonJS({
  "node_modules/core-js-pure/full/reflect/get.js"(exports, module) {
    "use strict";
    var parent = require_get3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/reflect/get.js
var require_get5 = __commonJS({
  "node_modules/core-js-pure/features/reflect/get.js"(exports, module) {
    "use strict";
    module.exports = require_get4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/reflect/get.js
var require_get6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/reflect/get.js"(exports, module) {
    module.exports = require_get5();
  }
});

// node_modules/core-js-pure/actual/object/get-own-property-descriptor.js
var require_get_own_property_descriptor4 = __commonJS({
  "node_modules/core-js-pure/actual/object/get-own-property-descriptor.js"(exports, module) {
    "use strict";
    var parent = require_get_own_property_descriptor2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/object/get-own-property-descriptor.js
var require_get_own_property_descriptor5 = __commonJS({
  "node_modules/core-js-pure/full/object/get-own-property-descriptor.js"(exports, module) {
    "use strict";
    var parent = require_get_own_property_descriptor4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/object/get-own-property-descriptor.js
var require_get_own_property_descriptor6 = __commonJS({
  "node_modules/core-js-pure/features/object/get-own-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = require_get_own_property_descriptor5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/object/get-own-property-descriptor.js
var require_get_own_property_descriptor7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/object/get-own-property-descriptor.js"(exports, module) {
    module.exports = require_get_own_property_descriptor6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/superPropBase.js
var require_superPropBase = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/superPropBase.js"(exports, module) {
    var getPrototypeOf = require_getPrototypeOf();
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/get.js
var require_get7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/get.js"(exports, module) {
    var _Reflect$get = require_get6();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor7();
    var superPropBase = require_superPropBase();
    function _get() {
      if (typeof Reflect !== "undefined" && _Reflect$get) {
        module.exports = _get = _Reflect$get, module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _get = function _get2(target, property, receiver) {
          var base2 = superPropBase(target, property);
          if (!base2)
            return;
          var desc = _Object$getOwnPropertyDescriptor(base2, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }
      return _get.apply(this, arguments);
    }
    module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/es/array/virtual/concat.js
var require_concat = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/concat.js"(exports, module) {
    "use strict";
    require_es_array_concat();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "concat");
  }
});

// node_modules/core-js-pure/es/instance/concat.js
var require_concat2 = __commonJS({
  "node_modules/core-js-pure/es/instance/concat.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_concat();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.concat;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.concat ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/concat.js
var require_concat3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/concat.js"(exports, module) {
    "use strict";
    var parent = require_concat2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/concat.js
var require_concat4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/concat.js"(exports, module) {
    module.exports = require_concat3();
  }
});

// node_modules/core-js-pure/internals/collection-strong.js
var require_collection_strong = __commonJS({
  "node_modules/core-js-pure/internals/collection-strong.js"(exports, module) {
    "use strict";
    var create = require_object_create();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var defineBuiltIns = require_define_built_ins();
    var bind = require_function_bind_context();
    var anInstance = require_an_instance();
    var isNullOrUndefined = require_is_null_or_undefined();
    var iterate = require_iterate();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var setSpecies = require_set_species();
    var DESCRIPTORS = require_descriptors();
    var fastKey = require_internal_metadata().fastKey;
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    module.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            index: create(null),
            first: void 0,
            last: void 0,
            size: 0
          });
          if (!DESCRIPTORS)
            that.size = 0;
          if (!isNullOrUndefined(iterable))
            iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key2, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key2);
          var previous, index;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index = fastKey(key2, true),
              key: key2,
              value,
              previous: previous = state.last,
              next: void 0,
              removed: false
            };
            if (!state.first)
              state.first = entry;
            if (previous)
              previous.next = entry;
            if (DESCRIPTORS)
              state.size++;
            else
              that.size++;
            if (index !== "F")
              state.index[index] = entry;
          }
          return that;
        };
        var getEntry = function(that, key2) {
          var state = getInternalState(that);
          var index = fastKey(key2);
          var entry;
          if (index !== "F")
            return state.index[index];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key === key2)
              return entry;
          }
        };
        defineBuiltIns(Prototype, {
          // `{ Map, Set }.prototype.clear()` methods
          // https://tc39.es/ecma262/#sec-map.prototype.clear
          // https://tc39.es/ecma262/#sec-set.prototype.clear
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous)
                entry.previous = entry.previous.next = void 0;
              entry = entry.next;
            }
            state.first = state.last = void 0;
            state.index = create(null);
            if (DESCRIPTORS)
              state.size = 0;
            else
              that.size = 0;
          },
          // `{ Map, Set }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.delete
          // https://tc39.es/ecma262/#sec-set.prototype.delete
          "delete": function(key2) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key2);
            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev)
                prev.next = next;
              if (next)
                next.previous = prev;
              if (state.first === entry)
                state.first = next;
              if (state.last === entry)
                state.last = prev;
              if (DESCRIPTORS)
                state.size--;
              else
                that.size--;
            }
            return !!entry;
          },
          // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.foreach
          // https://tc39.es/ecma262/#sec-set.prototype.foreach
          forEach: function forEach(callbackfn) {
            var state = getInternalState(this);
            var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed)
                entry = entry.previous;
            }
          },
          // `{ Map, Set}.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.has
          // https://tc39.es/ecma262/#sec-set.prototype.has
          has: function has(key2) {
            return !!getEntry(this, key2);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          // `Map.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-map.prototype.get
          get: function get(key2) {
            var entry = getEntry(this, key2);
            return entry && entry.value;
          },
          // `Map.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-map.prototype.set
          set: function set(key2, value) {
            return define2(this, key2 === 0 ? 0 : key2, value);
          }
        } : {
          // `Set.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-set.prototype.add
          add: function add3(value) {
            return define2(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS)
          defineBuiltInAccessor(Prototype, "size", {
            configurable: true,
            get: function() {
              return getInternalState(this).size;
            }
          });
        return Constructor;
      },
      setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
          setInternalState(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind,
            last: void 0
          });
        }, function() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed)
            entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = void 0;
            return createIterResultObject(void 0, true);
          }
          if (kind === "keys")
            return createIterResultObject(entry.key, false);
          if (kind === "values")
            return createIterResultObject(entry.value, false);
          return createIterResultObject([entry.key, entry.value], false);
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(CONSTRUCTOR_NAME);
      }
    };
  }
});

// node_modules/core-js-pure/modules/es.map.constructor.js
var require_es_map_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.map.constructor.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Map", function(init2) {
      return function Map2() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js-pure/modules/es.map.js
var require_es_map = __commonJS({
  "node_modules/core-js-pure/modules/es.map.js"() {
    "use strict";
    require_es_map_constructor();
  }
});

// node_modules/core-js-pure/internals/caller.js
var require_caller = __commonJS({
  "node_modules/core-js-pure/internals/caller.js"(exports, module) {
    "use strict";
    module.exports = function(methodName, numArgs) {
      return numArgs === 1 ? function(object, arg) {
        return object[methodName](arg);
      } : function(object, arg1, arg2) {
        return object[methodName](arg1, arg2);
      };
    };
  }
});

// node_modules/core-js-pure/internals/map-helpers.js
var require_map_helpers = __commonJS({
  "node_modules/core-js-pure/internals/map-helpers.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var caller = require_caller();
    var Map2 = getBuiltIn("Map");
    module.exports = {
      Map: Map2,
      set: caller("set", 2),
      get: caller("get", 1),
      has: caller("has", 1),
      remove: caller("delete", 1),
      proto: Map2.prototype
    };
  }
});

// node_modules/core-js-pure/modules/es.map.group-by.js
var require_es_map_group_by = __commonJS({
  "node_modules/core-js-pure/modules/es.map.group-by.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var requireObjectCoercible = require_require_object_coercible();
    var iterate = require_iterate();
    var MapHelpers = require_map_helpers();
    var IS_PURE = require_is_pure();
    var Map2 = MapHelpers.Map;
    var has = MapHelpers.has;
    var get = MapHelpers.get;
    var set = MapHelpers.set;
    var push = uncurryThis([].push);
    $({ target: "Map", stat: true, forced: IS_PURE }, {
      groupBy: function groupBy(items, callbackfn) {
        requireObjectCoercible(items);
        aCallable(callbackfn);
        var map = new Map2();
        var k2 = 0;
        iterate(items, function(value) {
          var key2 = callbackfn(value, k2++);
          if (!has(map, key2))
            set(map, key2, [value]);
          else
            push(get(map, key2), value);
        });
        return map;
      }
    });
  }
});

// node_modules/core-js-pure/es/map/index.js
var require_map = __commonJS({
  "node_modules/core-js-pure/es/map/index.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_map();
    require_es_map_group_by();
    require_es_object_to_string();
    require_es_string_iterator();
    var path = require_path();
    module.exports = path.Map;
  }
});

// node_modules/core-js-pure/stable/map/index.js
var require_map2 = __commonJS({
  "node_modules/core-js-pure/stable/map/index.js"(exports, module) {
    "use strict";
    var parent = require_map();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/modules/esnext.map.group-by.js
var require_esnext_map_group_by = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.group-by.js"() {
    "use strict";
    require_es_map_group_by();
  }
});

// node_modules/core-js-pure/actual/map/index.js
var require_map3 = __commonJS({
  "node_modules/core-js-pure/actual/map/index.js"(exports, module) {
    "use strict";
    var parent = require_map2();
    require_esnext_map_group_by();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/internals/collection-from.js
var require_collection_from = __commonJS({
  "node_modules/core-js-pure/internals/collection-from.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var anObject = require_an_object();
    var toObject = require_to_object();
    var iterate = require_iterate();
    module.exports = function(C, adder, ENTRY) {
      return function from(source) {
        var O2 = toObject(source);
        var length = arguments.length;
        var mapFn = length > 1 ? arguments[1] : void 0;
        var mapping = mapFn !== void 0;
        var boundFunction = mapping ? bind(mapFn, length > 2 ? arguments[2] : void 0) : void 0;
        var result = new C();
        var n2 = 0;
        iterate(O2, function(nextItem) {
          var entry = mapping ? boundFunction(nextItem, n2++) : nextItem;
          if (ENTRY)
            adder(result, anObject(entry)[0], entry[1]);
          else
            adder(result, entry);
        });
        return result;
      };
    };
  }
});

// node_modules/core-js-pure/modules/esnext.map.from.js
var require_esnext_map_from = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.from.js"() {
    "use strict";
    var $ = require_export();
    var MapHelpers = require_map_helpers();
    var createCollectionFrom = require_collection_from();
    $({ target: "Map", stat: true, forced: true }, {
      from: createCollectionFrom(MapHelpers.Map, MapHelpers.set, true)
    });
  }
});

// node_modules/core-js-pure/internals/collection-of.js
var require_collection_of = __commonJS({
  "node_modules/core-js-pure/internals/collection-of.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    module.exports = function(C, adder, ENTRY) {
      return function of() {
        var result = new C();
        var length = arguments.length;
        for (var index = 0; index < length; index++) {
          var entry = arguments[index];
          if (ENTRY)
            adder(result, anObject(entry)[0], entry[1]);
          else
            adder(result, entry);
        }
        return result;
      };
    };
  }
});

// node_modules/core-js-pure/modules/esnext.map.of.js
var require_esnext_map_of = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.of.js"() {
    "use strict";
    var $ = require_export();
    var MapHelpers = require_map_helpers();
    var createCollectionOf = require_collection_of();
    $({ target: "Map", stat: true, forced: true }, {
      of: createCollectionOf(MapHelpers.Map, MapHelpers.set, true)
    });
  }
});

// node_modules/core-js-pure/internals/a-map.js
var require_a_map = __commonJS({
  "node_modules/core-js-pure/internals/a-map.js"(exports, module) {
    "use strict";
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (typeof it == "object" && "size" in it && "has" in it && "get" in it && "set" in it && "delete" in it && "entries" in it)
        return it;
      throw new $TypeError(tryToString(it) + " is not a map");
    };
  }
});

// node_modules/core-js-pure/modules/esnext.map.delete-all.js
var require_esnext_map_delete_all = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.delete-all.js"() {
    "use strict";
    var $ = require_export();
    var aMap = require_a_map();
    var remove = require_map_helpers().remove;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      deleteAll: function deleteAll() {
        var collection = aMap(this);
        var allDeleted = true;
        var wasDeleted;
        for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
          wasDeleted = remove(collection, arguments[k2]);
          allDeleted = allDeleted && wasDeleted;
        }
        return !!allDeleted;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.emplace.js
var require_esnext_map_emplace = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.emplace.js"() {
    "use strict";
    var $ = require_export();
    var aMap = require_a_map();
    var MapHelpers = require_map_helpers();
    var get = MapHelpers.get;
    var has = MapHelpers.has;
    var set = MapHelpers.set;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      emplace: function emplace(key2, handler) {
        var map = aMap(this);
        var value, inserted;
        if (has(map, key2)) {
          value = get(map, key2);
          if ("update" in handler) {
            value = handler.update(value, key2, map);
            set(map, key2, value);
          }
          return value;
        }
        inserted = handler.insert(key2, map);
        set(map, key2, inserted);
        return inserted;
      }
    });
  }
});

// node_modules/core-js-pure/internals/iterate-simple.js
var require_iterate_simple = __commonJS({
  "node_modules/core-js-pure/internals/iterate-simple.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    module.exports = function(record, fn2, ITERATOR_INSTEAD_OF_RECORD) {
      var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
      var next = record.next;
      var step, result;
      while (!(step = call(next, iterator)).done) {
        result = fn2(step.value);
        if (result !== void 0)
          return result;
      }
    };
  }
});

// node_modules/core-js-pure/internals/map-iterate.js
var require_map_iterate = __commonJS({
  "node_modules/core-js-pure/internals/map-iterate.js"(exports, module) {
    "use strict";
    var iterateSimple = require_iterate_simple();
    module.exports = function(map, fn2, interruptible) {
      return interruptible ? iterateSimple(map.entries(), function(entry) {
        return fn2(entry[1], entry[0]);
      }, true) : map.forEach(fn2);
    };
  }
});

// node_modules/core-js-pure/modules/esnext.map.every.js
var require_esnext_map_every = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.every.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      every: function every(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return iterate(map, function(value, key2) {
          if (!boundFunction(value, key2, map))
            return false;
        }, true) !== false;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.filter.js
var require_esnext_map_filter = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.filter.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var MapHelpers = require_map_helpers();
    var iterate = require_map_iterate();
    var Map2 = MapHelpers.Map;
    var set = MapHelpers.set;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      filter: function filter(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var newMap = new Map2();
        iterate(map, function(value, key2) {
          if (boundFunction(value, key2, map))
            set(newMap, key2, value);
        });
        return newMap;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.find.js
var require_esnext_map_find = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.find.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      find: function find(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var result = iterate(map, function(value, key2) {
          if (boundFunction(value, key2, map))
            return { value };
        }, true);
        return result && result.value;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.find-key.js
var require_esnext_map_find_key = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.find-key.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      findKey: function findKey(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var result = iterate(map, function(value, key2) {
          if (boundFunction(value, key2, map))
            return { key: key2 };
        }, true);
        return result && result.key;
      }
    });
  }
});

// node_modules/core-js-pure/internals/same-value-zero.js
var require_same_value_zero = __commonJS({
  "node_modules/core-js-pure/internals/same-value-zero.js"(exports, module) {
    "use strict";
    module.exports = function(x2, y2) {
      return x2 === y2 || x2 !== x2 && y2 !== y2;
    };
  }
});

// node_modules/core-js-pure/modules/esnext.map.includes.js
var require_esnext_map_includes = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.includes.js"() {
    "use strict";
    var $ = require_export();
    var sameValueZero = require_same_value_zero();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      includes: function includes(searchElement) {
        return iterate(aMap(this), function(value) {
          if (sameValueZero(value, searchElement))
            return true;
        }, true) === true;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.key-by.js
var require_esnext_map_key_by = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.key-by.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var iterate = require_iterate();
    var isCallable = require_is_callable();
    var aCallable = require_a_callable();
    var Map2 = require_map_helpers().Map;
    $({ target: "Map", stat: true, forced: true }, {
      keyBy: function keyBy(iterable, keyDerivative) {
        var C = isCallable(this) ? this : Map2;
        var newMap = new C();
        aCallable(keyDerivative);
        var setter = aCallable(newMap.set);
        iterate(iterable, function(element) {
          call(setter, newMap, keyDerivative(element), element);
        });
        return newMap;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.key-of.js
var require_esnext_map_key_of = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.key-of.js"() {
    "use strict";
    var $ = require_export();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      keyOf: function keyOf(searchElement) {
        var result = iterate(aMap(this), function(value, key2) {
          if (value === searchElement)
            return { key: key2 };
        }, true);
        return result && result.key;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.map-keys.js
var require_esnext_map_map_keys = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.map-keys.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var MapHelpers = require_map_helpers();
    var iterate = require_map_iterate();
    var Map2 = MapHelpers.Map;
    var set = MapHelpers.set;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      mapKeys: function mapKeys(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var newMap = new Map2();
        iterate(map, function(value, key2) {
          set(newMap, boundFunction(value, key2, map), value);
        });
        return newMap;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.map-values.js
var require_esnext_map_map_values = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.map-values.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var MapHelpers = require_map_helpers();
    var iterate = require_map_iterate();
    var Map2 = MapHelpers.Map;
    var set = MapHelpers.set;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      mapValues: function mapValues(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var newMap = new Map2();
        iterate(map, function(value, key2) {
          set(newMap, key2, boundFunction(value, key2, map));
        });
        return newMap;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.merge.js
var require_esnext_map_merge = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.merge.js"() {
    "use strict";
    var $ = require_export();
    var aMap = require_a_map();
    var iterate = require_iterate();
    var set = require_map_helpers().set;
    $({ target: "Map", proto: true, real: true, arity: 1, forced: true }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      merge: function merge(iterable) {
        var map = aMap(this);
        var argumentsLength = arguments.length;
        var i2 = 0;
        while (i2 < argumentsLength) {
          iterate(arguments[i2++], function(key2, value) {
            set(map, key2, value);
          }, { AS_ENTRIES: true });
        }
        return map;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.reduce.js
var require_esnext_map_reduce = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.reduce.js"() {
    "use strict";
    var $ = require_export();
    var aCallable = require_a_callable();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    var $TypeError = TypeError;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      reduce: function reduce(callbackfn) {
        var map = aMap(this);
        var noInitial = arguments.length < 2;
        var accumulator = noInitial ? void 0 : arguments[1];
        aCallable(callbackfn);
        iterate(map, function(value, key2) {
          if (noInitial) {
            noInitial = false;
            accumulator = value;
          } else {
            accumulator = callbackfn(accumulator, value, key2, map);
          }
        });
        if (noInitial)
          throw new $TypeError("Reduce of empty map with no initial value");
        return accumulator;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.some.js
var require_esnext_map_some = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.some.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind_context();
    var aMap = require_a_map();
    var iterate = require_map_iterate();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      some: function some(callbackfn) {
        var map = aMap(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return iterate(map, function(value, key2) {
          if (boundFunction(value, key2, map))
            return true;
        }, true) === true;
      }
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.update.js
var require_esnext_map_update = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.update.js"() {
    "use strict";
    var $ = require_export();
    var aCallable = require_a_callable();
    var aMap = require_a_map();
    var MapHelpers = require_map_helpers();
    var $TypeError = TypeError;
    var get = MapHelpers.get;
    var has = MapHelpers.has;
    var set = MapHelpers.set;
    $({ target: "Map", proto: true, real: true, forced: true }, {
      update: function update2(key2, callback) {
        var map = aMap(this);
        var length = arguments.length;
        aCallable(callback);
        var isPresentInMap = has(map, key2);
        if (!isPresentInMap && length < 3) {
          throw new $TypeError("Updating absent value");
        }
        var value = isPresentInMap ? get(map, key2) : aCallable(length > 2 ? arguments[2] : void 0)(key2, map);
        set(map, key2, callback(value, key2, map));
        return map;
      }
    });
  }
});

// node_modules/core-js-pure/internals/map-upsert.js
var require_map_upsert = __commonJS({
  "node_modules/core-js-pure/internals/map-upsert.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var anObject = require_an_object();
    var $TypeError = TypeError;
    module.exports = function upsert(key2, updateFn) {
      var map = anObject(this);
      var get = aCallable(map.get);
      var has = aCallable(map.has);
      var set = aCallable(map.set);
      var insertFn = arguments.length > 2 ? arguments[2] : void 0;
      var value;
      if (!isCallable(updateFn) && !isCallable(insertFn)) {
        throw new $TypeError("At least one callback required");
      }
      if (call(has, map, key2)) {
        value = call(get, map, key2);
        if (isCallable(updateFn)) {
          value = updateFn(value);
          call(set, map, key2, value);
        }
      } else if (isCallable(insertFn)) {
        value = insertFn();
        call(set, map, key2, value);
      }
      return value;
    };
  }
});

// node_modules/core-js-pure/modules/esnext.map.upsert.js
var require_esnext_map_upsert = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.upsert.js"() {
    "use strict";
    var $ = require_export();
    var upsert = require_map_upsert();
    $({ target: "Map", proto: true, real: true, forced: true }, {
      upsert
    });
  }
});

// node_modules/core-js-pure/modules/esnext.map.update-or-insert.js
var require_esnext_map_update_or_insert = __commonJS({
  "node_modules/core-js-pure/modules/esnext.map.update-or-insert.js"() {
    "use strict";
    var $ = require_export();
    var upsert = require_map_upsert();
    $({ target: "Map", proto: true, real: true, name: "upsert", forced: true }, {
      updateOrInsert: upsert
    });
  }
});

// node_modules/core-js-pure/full/map/index.js
var require_map4 = __commonJS({
  "node_modules/core-js-pure/full/map/index.js"(exports, module) {
    "use strict";
    var parent = require_map3();
    require_esnext_map_from();
    require_esnext_map_of();
    require_esnext_map_delete_all();
    require_esnext_map_emplace();
    require_esnext_map_every();
    require_esnext_map_filter();
    require_esnext_map_find();
    require_esnext_map_find_key();
    require_esnext_map_includes();
    require_esnext_map_key_by();
    require_esnext_map_key_of();
    require_esnext_map_map_keys();
    require_esnext_map_map_values();
    require_esnext_map_merge();
    require_esnext_map_reduce();
    require_esnext_map_some();
    require_esnext_map_update();
    require_esnext_map_upsert();
    require_esnext_map_update_or_insert();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/map/index.js
var require_map5 = __commonJS({
  "node_modules/core-js-pure/features/map/index.js"(exports, module) {
    "use strict";
    module.exports = require_map4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/map.js
var require_map6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/map.js"(exports, module) {
    module.exports = require_map5();
  }
});

// node_modules/core-js-pure/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "node_modules/core-js-pure/modules/es.array.index-of.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var $indexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
    $({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/index-of.js
var require_index_of = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/index-of.js"(exports, module) {
    "use strict";
    require_es_array_index_of();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "indexOf");
  }
});

// node_modules/core-js-pure/es/instance/index-of.js
var require_index_of2 = __commonJS({
  "node_modules/core-js-pure/es/instance/index-of.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_index_of();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.indexOf;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.indexOf ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/index-of.js
var require_index_of3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/index-of.js"(exports, module) {
    "use strict";
    var parent = require_index_of2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/instance/index-of.js
var require_index_of4 = __commonJS({
  "node_modules/core-js-pure/actual/instance/index-of.js"(exports, module) {
    "use strict";
    var parent = require_index_of3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/instance/index-of.js
var require_index_of5 = __commonJS({
  "node_modules/core-js-pure/full/instance/index-of.js"(exports, module) {
    "use strict";
    var parent = require_index_of4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/instance/index-of.js
var require_index_of6 = __commonJS({
  "node_modules/core-js-pure/features/instance/index-of.js"(exports, module) {
    "use strict";
    module.exports = require_index_of5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/instance/index-of.js
var require_index_of7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/instance/index-of.js"(exports, module) {
    module.exports = require_index_of6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/isNativeFunction.js
var require_isNativeFunction = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/isNativeFunction.js"(exports, module) {
    var _indexOfInstanceProperty = require_index_of7();
    function _isNativeFunction(fn2) {
      var _context;
      return _indexOfInstanceProperty(_context = Function.toString.call(fn2)).call(_context, "[native code]") !== -1;
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/actual/reflect/construct.js
var require_construct4 = __commonJS({
  "node_modules/core-js-pure/actual/reflect/construct.js"(exports, module) {
    "use strict";
    var parent = require_construct2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/reflect/construct.js
var require_construct5 = __commonJS({
  "node_modules/core-js-pure/full/reflect/construct.js"(exports, module) {
    "use strict";
    var parent = require_construct4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/reflect/construct.js
var require_construct6 = __commonJS({
  "node_modules/core-js-pure/features/reflect/construct.js"(exports, module) {
    "use strict";
    module.exports = require_construct5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/reflect/construct.js
var require_construct7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/reflect/construct.js"(exports, module) {
    module.exports = require_construct6();
  }
});

// node_modules/core-js-pure/modules/es.function.bind.js
var require_es_function_bind = __commonJS({
  "node_modules/core-js-pure/modules/es.function.bind.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind();
    $({ target: "Function", proto: true, forced: Function.bind !== bind }, {
      bind
    });
  }
});

// node_modules/core-js-pure/es/function/virtual/bind.js
var require_bind = __commonJS({
  "node_modules/core-js-pure/es/function/virtual/bind.js"(exports, module) {
    "use strict";
    require_es_function_bind();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Function", "bind");
  }
});

// node_modules/core-js-pure/es/instance/bind.js
var require_bind2 = __commonJS({
  "node_modules/core-js-pure/es/instance/bind.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_bind();
    var FunctionPrototype = Function.prototype;
    module.exports = function(it) {
      var own = it.bind;
      return it === FunctionPrototype || isPrototypeOf(FunctionPrototype, it) && own === FunctionPrototype.bind ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/bind.js
var require_bind3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/bind.js"(exports, module) {
    "use strict";
    var parent = require_bind2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/instance/bind.js
var require_bind4 = __commonJS({
  "node_modules/core-js-pure/actual/instance/bind.js"(exports, module) {
    "use strict";
    var parent = require_bind3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/instance/bind.js
var require_bind5 = __commonJS({
  "node_modules/core-js-pure/full/instance/bind.js"(exports, module) {
    "use strict";
    var parent = require_bind4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/instance/bind.js
var require_bind6 = __commonJS({
  "node_modules/core-js-pure/features/instance/bind.js"(exports, module) {
    "use strict";
    module.exports = require_bind5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/instance/bind.js
var require_bind7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/instance/bind.js"(exports, module) {
    module.exports = require_bind6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/isNativeReflectConstruct.js"(exports, module) {
    var _Reflect$construct = require_construct7();
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/construct.js
var require_construct8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/construct.js"(exports, module) {
    var _Reflect$construct = require_construct7();
    var _bindInstanceProperty = require_bind7();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        module.exports = _construct = _Reflect$construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _construct = function _construct2(Parent2, args2, Class2) {
          var a2 = [null];
          a2.push.apply(a2, args2);
          var Constructor = _bindInstanceProperty(Function).apply(Parent2, a2);
          var instance = new Constructor();
          if (Class2)
            setPrototypeOf(instance, Class2.prototype);
          return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }
      return _construct.apply(null, arguments);
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/wrapNativeSuper.js
var require_wrapNativeSuper = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/wrapNativeSuper.js"(exports, module) {
    var _Map = require_map6();
    var _Object$create = require_create6();
    var getPrototypeOf = require_getPrototypeOf();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeFunction = require_isNativeFunction();
    var construct = require_construct8();
    function _wrapNativeSuper(Class) {
      var _cache = typeof _Map === "function" ? new _Map() : void 0;
      module.exports = _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return construct(Class2, arguments, getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = _Object$create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return setPrototypeOf(Wrapper, Class2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _wrapNativeSuper(Class);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/moralis-v1/lib/browser/ParseError.js
var require_ParseError = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseError.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty2 = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty2(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(require_define_property3());
    var _concat = _interopRequireDefault(require_concat4());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _wrapNativeSuper2 = _interopRequireDefault(require_wrapNativeSuper());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var ParseError = function(_Error) {
      (0, _inherits2.default)(ParseError2, _Error);
      var _super = _createSuper(ParseError2);
      function ParseError2(code, message) {
        var _this;
        (0, _classCallCheck2.default)(this, ParseError2);
        _this = _super.call(this, message);
        _this.code = code;
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "message", {
          enumerable: true,
          value: message
        });
        return _this;
      }
      (0, _createClass2.default)(ParseError2, [{
        key: "toString",
        value: function() {
          var _context;
          return (0, _concat.default)(_context = "ParseError: ".concat(this.code, " ")).call(_context, this.message);
        }
      }]);
      return ParseError2;
    }((0, _wrapNativeSuper2.default)(Error));
    ParseError.OTHER_CAUSE = -1;
    ParseError.INTERNAL_SERVER_ERROR = 1;
    ParseError.CONNECTION_FAILED = 100;
    ParseError.OBJECT_NOT_FOUND = 101;
    ParseError.INVALID_QUERY = 102;
    ParseError.INVALID_CLASS_NAME = 103;
    ParseError.MISSING_OBJECT_ID = 104;
    ParseError.INVALID_KEY_NAME = 105;
    ParseError.INVALID_POINTER = 106;
    ParseError.INVALID_JSON = 107;
    ParseError.COMMAND_UNAVAILABLE = 108;
    ParseError.NOT_INITIALIZED = 109;
    ParseError.INCORRECT_TYPE = 111;
    ParseError.INVALID_CHANNEL_NAME = 112;
    ParseError.PUSH_MISCONFIGURED = 115;
    ParseError.OBJECT_TOO_LARGE = 116;
    ParseError.OPERATION_FORBIDDEN = 119;
    ParseError.CACHE_MISS = 120;
    ParseError.INVALID_NESTED_KEY = 121;
    ParseError.INVALID_FILE_NAME = 122;
    ParseError.INVALID_ACL = 123;
    ParseError.TIMEOUT = 124;
    ParseError.INVALID_EMAIL_ADDRESS = 125;
    ParseError.MISSING_CONTENT_TYPE = 126;
    ParseError.MISSING_CONTENT_LENGTH = 127;
    ParseError.INVALID_CONTENT_LENGTH = 128;
    ParseError.FILE_TOO_LARGE = 129;
    ParseError.FILE_SAVE_ERROR = 130;
    ParseError.DUPLICATE_VALUE = 137;
    ParseError.INVALID_ROLE_NAME = 139;
    ParseError.EXCEEDED_QUOTA = 140;
    ParseError.SCRIPT_FAILED = 141;
    ParseError.VALIDATION_ERROR = 142;
    ParseError.INVALID_IMAGE_DATA = 143;
    ParseError.UNSAVED_FILE_ERROR = 151;
    ParseError.INVALID_PUSH_TIME_ERROR = 152;
    ParseError.FILE_DELETE_ERROR = 153;
    ParseError.FILE_DELETE_UNNAMED_ERROR = 161;
    ParseError.REQUEST_LIMIT_EXCEEDED = 155;
    ParseError.DUPLICATE_REQUEST = 159;
    ParseError.INVALID_EVENT_NAME = 160;
    ParseError.USERNAME_MISSING = 200;
    ParseError.PASSWORD_MISSING = 201;
    ParseError.USERNAME_TAKEN = 202;
    ParseError.EMAIL_TAKEN = 203;
    ParseError.EMAIL_MISSING = 204;
    ParseError.EMAIL_NOT_FOUND = 205;
    ParseError.SESSION_MISSING = 206;
    ParseError.MUST_CREATE_USER_THROUGH_SIGNUP = 207;
    ParseError.ACCOUNT_ALREADY_LINKED = 208;
    ParseError.INVALID_SESSION_TOKEN = 209;
    ParseError.MFA_ERROR = 210;
    ParseError.MFA_TOKEN_REQUIRED = 211;
    ParseError.LINKED_ID_MISSING = 250;
    ParseError.INVALID_LINKED_SESSION = 251;
    ParseError.UNSUPPORTED_SERVICE = 252;
    ParseError.INVALID_SCHEMA_OPERATION = 255;
    ParseError.AGGREGATE_ERROR = 600;
    ParseError.FILE_READ_ERROR = 601;
    ParseError.X_DOMAIN_REQUEST = 602;
    var _default = ParseError;
    exports.default = _default;
  }
});

// node_modules/core-js-pure/es/object/get-own-property-symbols.js
var require_get_own_property_symbols = __commonJS({
  "node_modules/core-js-pure/es/object/get-own-property-symbols.js"(exports, module) {
    "use strict";
    require_es_symbol();
    var path = require_path();
    module.exports = path.Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js-pure/stable/object/get-own-property-symbols.js
var require_get_own_property_symbols2 = __commonJS({
  "node_modules/core-js-pure/stable/object/get-own-property-symbols.js"(exports, module) {
    "use strict";
    var parent = require_get_own_property_symbols();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js
var require_get_own_property_symbols3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js"(exports, module) {
    module.exports = require_get_own_property_symbols2();
  }
});

// node_modules/core-js-pure/modules/es.array.filter.js
var require_es_array_filter = __commonJS({
  "node_modules/core-js-pure/modules/es.array.filter.js"() {
    "use strict";
    var $ = require_export();
    var $filter = require_array_iteration().filter;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/filter.js
var require_filter = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/filter.js"(exports, module) {
    "use strict";
    require_es_array_filter();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "filter");
  }
});

// node_modules/core-js-pure/es/instance/filter.js
var require_filter2 = __commonJS({
  "node_modules/core-js-pure/es/instance/filter.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_filter();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.filter;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.filter ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/filter.js
var require_filter3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/filter.js"(exports, module) {
    "use strict";
    var parent = require_filter2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js
var require_filter4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js"(exports, module) {
    module.exports = require_filter3();
  }
});

// node_modules/core-js-pure/modules/es.object.get-own-property-descriptors.js
var require_es_object_get_own_property_descriptors = __commonJS({
  "node_modules/core-js-pure/modules/es.object.get-own-property-descriptors.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var ownKeys5 = require_own_keys();
    var toIndexedObject = require_to_indexed_object();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var createProperty = require_create_property();
    $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O2 = toIndexedObject(object);
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var keys = ownKeys5(O2);
        var result = {};
        var index = 0;
        var key2, descriptor;
        while (keys.length > index) {
          descriptor = getOwnPropertyDescriptor(O2, key2 = keys[index++]);
          if (descriptor !== void 0)
            createProperty(result, key2, descriptor);
        }
        return result;
      }
    });
  }
});

// node_modules/core-js-pure/es/object/get-own-property-descriptors.js
var require_get_own_property_descriptors = __commonJS({
  "node_modules/core-js-pure/es/object/get-own-property-descriptors.js"(exports, module) {
    "use strict";
    require_es_object_get_own_property_descriptors();
    var path = require_path();
    module.exports = path.Object.getOwnPropertyDescriptors;
  }
});

// node_modules/core-js-pure/stable/object/get-own-property-descriptors.js
var require_get_own_property_descriptors2 = __commonJS({
  "node_modules/core-js-pure/stable/object/get-own-property-descriptors.js"(exports, module) {
    "use strict";
    var parent = require_get_own_property_descriptors();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js
var require_get_own_property_descriptors3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js"(exports, module) {
    module.exports = require_get_own_property_descriptors2();
  }
});

// node_modules/core-js-pure/modules/es.object.define-properties.js
var require_es_object_define_properties = __commonJS({
  "node_modules/core-js-pure/modules/es.object.define-properties.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var defineProperties = require_object_define_properties().f;
    $({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties, sham: !DESCRIPTORS }, {
      defineProperties
    });
  }
});

// node_modules/core-js-pure/es/object/define-properties.js
var require_define_properties = __commonJS({
  "node_modules/core-js-pure/es/object/define-properties.js"(exports, module) {
    "use strict";
    require_es_object_define_properties();
    var path = require_path();
    var Object2 = path.Object;
    var defineProperties = module.exports = function defineProperties2(T, D2) {
      return Object2.defineProperties(T, D2);
    };
    if (Object2.defineProperties.sham)
      defineProperties.sham = true;
  }
});

// node_modules/core-js-pure/stable/object/define-properties.js
var require_define_properties2 = __commonJS({
  "node_modules/core-js-pure/stable/object/define-properties.js"(exports, module) {
    "use strict";
    var parent = require_define_properties();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js
var require_define_properties3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js"(exports, module) {
    module.exports = require_define_properties2();
  }
});

// node_modules/core-js-pure/modules/es.array.slice.js
var require_es_array_slice = __commonJS({
  "node_modules/core-js-pure/modules/es.array.slice.js"() {
    "use strict";
    var $ = require_export();
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIndexedObject = require_to_indexed_object();
    var createProperty = require_create_property();
    var wellKnownSymbol = require_well_known_symbol();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var nativeSlice = require_array_slice();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    var max = Math.max;
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      slice: function slice(start, end) {
        var O2 = toIndexedObject(this);
        var length = lengthOfArrayLike(O2);
        var k2 = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var Constructor, result, n2;
        if (isArray(O2)) {
          Constructor = O2.constructor;
          if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null)
              Constructor = void 0;
          }
          if (Constructor === $Array || Constructor === void 0) {
            return nativeSlice(O2, k2, fin);
          }
        }
        result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k2, 0));
        for (n2 = 0; k2 < fin; k2++, n2++)
          if (k2 in O2)
            createProperty(result, n2, O2[k2]);
        result.length = n2;
        return result;
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/slice.js
var require_slice = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/slice.js"(exports, module) {
    "use strict";
    require_es_array_slice();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "slice");
  }
});

// node_modules/core-js-pure/es/instance/slice.js
var require_slice2 = __commonJS({
  "node_modules/core-js-pure/es/instance/slice.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_slice();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.slice;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.slice ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/slice.js
var require_slice3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/slice.js"(exports, module) {
    "use strict";
    var parent = require_slice2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js
var require_slice4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js"(exports, module) {
    module.exports = require_slice3();
  }
});

// node_modules/core-js-pure/internals/call-with-safe-iteration-closing.js
var require_call_with_safe_iteration_closing = __commonJS({
  "node_modules/core-js-pure/internals/call-with-safe-iteration-closing.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var iteratorClose = require_iterator_close();
    module.exports = function(iterator, fn2, value, ENTRIES) {
      try {
        return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
      } catch (error) {
        iteratorClose(iterator, "throw", error);
      }
    };
  }
});

// node_modules/core-js-pure/internals/array-from.js
var require_array_from = __commonJS({
  "node_modules/core-js-pure/internals/array-from.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var toObject = require_to_object();
    var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var isConstructor = require_is_constructor();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var $Array = Array;
    module.exports = function from(arrayLike) {
      var O2 = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      if (mapping)
        mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
      var iteratorMethod = getIteratorMethod(O2);
      var index = 0;
      var length, result, step, iterator, next, value;
      if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator = getIterator(O2, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];
        for (; !(step = call(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O2);
        result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
        for (; length > index; index++) {
          value = mapping ? mapfn(O2[index], index) : O2[index];
          createProperty(result, index, value);
        }
      }
      result.length = index;
      return result;
    };
  }
});

// node_modules/core-js-pure/modules/es.array.from.js
var require_es_array_from = __commonJS({
  "node_modules/core-js-pure/modules/es.array.from.js"() {
    "use strict";
    var $ = require_export();
    var from = require_array_from();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
      Array.from(iterable);
    });
    $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
      from
    });
  }
});

// node_modules/core-js-pure/es/array/from.js
var require_from = __commonJS({
  "node_modules/core-js-pure/es/array/from.js"(exports, module) {
    "use strict";
    require_es_string_iterator();
    require_es_array_from();
    var path = require_path();
    module.exports = path.Array.from;
  }
});

// node_modules/core-js-pure/stable/array/from.js
var require_from2 = __commonJS({
  "node_modules/core-js-pure/stable/array/from.js"(exports, module) {
    "use strict";
    var parent = require_from();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/array/from.js
var require_from3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/array/from.js"(exports, module) {
    module.exports = require_from2();
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/symbol.js
var require_symbol7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/symbol.js"(exports, module) {
    module.exports = require_symbol2();
  }
});

// node_modules/core-js-pure/es/get-iterator-method.js
var require_get_iterator_method2 = __commonJS({
  "node_modules/core-js-pure/es/get-iterator-method.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_string_iterator();
    var getIteratorMethod = require_get_iterator_method();
    module.exports = getIteratorMethod;
  }
});

// node_modules/core-js-pure/stable/get-iterator-method.js
var require_get_iterator_method3 = __commonJS({
  "node_modules/core-js-pure/stable/get-iterator-method.js"(exports, module) {
    "use strict";
    var parent = require_get_iterator_method2();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/get-iterator-method.js
var require_get_iterator_method4 = __commonJS({
  "node_modules/core-js-pure/actual/get-iterator-method.js"(exports, module) {
    "use strict";
    var parent = require_get_iterator_method3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/get-iterator-method.js
var require_get_iterator_method5 = __commonJS({
  "node_modules/core-js-pure/full/get-iterator-method.js"(exports, module) {
    "use strict";
    var parent = require_get_iterator_method4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/get-iterator-method.js
var require_get_iterator_method6 = __commonJS({
  "node_modules/core-js-pure/features/get-iterator-method.js"(exports, module) {
    "use strict";
    module.exports = require_get_iterator_method5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/get-iterator-method.js
var require_get_iterator_method7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/get-iterator-method.js"(exports, module) {
    module.exports = require_get_iterator_method6();
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js
var require_index_of8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js"(exports, module) {
    module.exports = require_index_of3();
  }
});

// node_modules/core-js-pure/modules/es.object.freeze.js
var require_es_object_freeze = __commonJS({
  "node_modules/core-js-pure/modules/es.object.freeze.js"() {
    "use strict";
    var $ = require_export();
    var FREEZING = require_freezing();
    var fails = require_fails();
    var isObject = require_is_object();
    var onFreeze = require_internal_metadata().onFreeze;
    var $freeze = Object.freeze;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $freeze(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
      freeze: function freeze(it) {
        return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
      }
    });
  }
});

// node_modules/core-js-pure/es/object/freeze.js
var require_freeze = __commonJS({
  "node_modules/core-js-pure/es/object/freeze.js"(exports, module) {
    "use strict";
    require_es_object_freeze();
    var path = require_path();
    module.exports = path.Object.freeze;
  }
});

// node_modules/core-js-pure/stable/object/freeze.js
var require_freeze2 = __commonJS({
  "node_modules/core-js-pure/stable/object/freeze.js"(exports, module) {
    "use strict";
    var parent = require_freeze();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/freeze.js
var require_freeze3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/freeze.js"(exports, module) {
    module.exports = require_freeze2();
  }
});

// node_modules/core-js-pure/internals/string-repeat.js
var require_string_repeat = __commonJS({
  "node_modules/core-js-pure/internals/string-repeat.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var $RangeError = RangeError;
    module.exports = function repeat(count) {
      var str = toString2(requireObjectCoercible(this));
      var result = "";
      var n2 = toIntegerOrInfinity(count);
      if (n2 < 0 || n2 === Infinity)
        throw new $RangeError("Wrong number of repetitions");
      for (; n2 > 0; (n2 >>>= 1) && (str += str))
        if (n2 & 1)
          result += str;
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/string-pad.js
var require_string_pad = __commonJS({
  "node_modules/core-js-pure/internals/string-pad.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var $repeat = require_string_repeat();
    var requireObjectCoercible = require_require_object_coercible();
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis("".slice);
    var ceil = Math.ceil;
    var createMethod = function(IS_END) {
      return function($this, maxLength, fillString) {
        var S2 = toString2(requireObjectCoercible($this));
        var intMaxLength = toLength(maxLength);
        var stringLength = S2.length;
        var fillStr = fillString === void 0 ? " " : toString2(fillString);
        var fillLen, stringFiller;
        if (intMaxLength <= stringLength || fillStr === "")
          return S2;
        fillLen = intMaxLength - stringLength;
        stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen)
          stringFiller = stringSlice(stringFiller, 0, fillLen);
        return IS_END ? S2 + stringFiller : stringFiller + S2;
      };
    };
    module.exports = {
      // `String.prototype.padStart` method
      // https://tc39.es/ecma262/#sec-string.prototype.padstart
      start: createMethod(false),
      // `String.prototype.padEnd` method
      // https://tc39.es/ecma262/#sec-string.prototype.padend
      end: createMethod(true)
    };
  }
});

// node_modules/core-js-pure/internals/date-to-iso-string.js
var require_date_to_iso_string = __commonJS({
  "node_modules/core-js-pure/internals/date-to-iso-string.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var padStart = require_string_pad().start;
    var $RangeError = RangeError;
    var $isFinite = isFinite;
    var abs = Math.abs;
    var DatePrototype = Date.prototype;
    var nativeDateToISOString = DatePrototype.toISOString;
    var thisTimeValue = uncurryThis(DatePrototype.getTime);
    var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
    var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
    var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
    var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
    var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
    var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
    var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
    module.exports = fails(function() {
      return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
    }) || !fails(function() {
      nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
    }) ? function toISOString() {
      if (!$isFinite(thisTimeValue(this)))
        throw new $RangeError("Invalid time value");
      var date = this;
      var year = getUTCFullYear(date);
      var milliseconds = getUTCMilliseconds(date);
      var sign3 = year < 0 ? "-" : year > 9999 ? "+" : "";
      return sign3 + padStart(abs(year), sign3 ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date) + 1, 2, 0) + "-" + padStart(getUTCDate(date), 2, 0) + "T" + padStart(getUTCHours(date), 2, 0) + ":" + padStart(getUTCMinutes(date), 2, 0) + ":" + padStart(getUTCSeconds(date), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
    } : nativeDateToISOString;
  }
});

// node_modules/core-js-pure/modules/es.date.to-json.js
var require_es_date_to_json = __commonJS({
  "node_modules/core-js-pure/modules/es.date.to-json.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var toObject = require_to_object();
    var toPrimitive = require_to_primitive();
    var toISOString = require_date_to_iso_string();
    var classof = require_classof_raw();
    var fails = require_fails();
    var FORCED = fails(function() {
      return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || call(Date.prototype.toJSON, { toISOString: function() {
        return 1;
      } }) !== 1;
    });
    $({ target: "Date", proto: true, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      toJSON: function toJSON2(key2) {
        var O2 = toObject(this);
        var pv = toPrimitive(O2, "number");
        return typeof pv == "number" && !isFinite(pv) ? null : !("toISOString" in O2) && classof(O2) === "Date" ? call(toISOString, O2) : O2.toISOString();
      }
    });
  }
});

// node_modules/core-js-pure/es/json/stringify.js
var require_stringify = __commonJS({
  "node_modules/core-js-pure/es/json/stringify.js"(exports, module) {
    "use strict";
    require_es_date_to_json();
    require_es_json_stringify();
    var path = require_path();
    var apply = require_function_apply();
    if (!path.JSON)
      path.JSON = { stringify: JSON.stringify };
    module.exports = function stringify2(it, replacer, space) {
      return apply(path.JSON.stringify, null, arguments);
    };
  }
});

// node_modules/core-js-pure/stable/json/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/core-js-pure/stable/json/stringify.js"(exports, module) {
    "use strict";
    var parent = require_stringify();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/json/stringify.js
var require_stringify3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/json/stringify.js"(exports, module) {
    module.exports = require_stringify2();
  }
});

// node_modules/core-js-pure/modules/es.array.includes.js
var require_es_array_includes = __commonJS({
  "node_modules/core-js-pure/modules/es.array.includes.js"() {
    "use strict";
    var $ = require_export();
    var $includes = require_array_includes().includes;
    var fails = require_fails();
    var addToUnscopables = require_add_to_unscopables();
    var BROKEN_ON_SPARSE = fails(function() {
      return !Array(1).includes();
    });
    $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables("includes");
  }
});

// node_modules/core-js-pure/es/array/virtual/includes.js
var require_includes = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/includes.js"(exports, module) {
    "use strict";
    require_es_array_includes();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "includes");
  }
});

// node_modules/core-js-pure/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js-pure/internals/is-regexp.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
    };
  }
});

// node_modules/core-js-pure/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "node_modules/core-js-pure/internals/not-a-regexp.js"(exports, module) {
    "use strict";
    var isRegExp = require_is_regexp();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isRegExp(it)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
  }
});

// node_modules/core-js-pure/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "node_modules/core-js-pure/internals/correct-is-regexp-logic.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// node_modules/core-js-pure/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "node_modules/core-js-pure/modules/es.string.includes.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString2 = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString2(requireObjectCoercible(this)),
          toString2(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// node_modules/core-js-pure/es/string/virtual/includes.js
var require_includes2 = __commonJS({
  "node_modules/core-js-pure/es/string/virtual/includes.js"(exports, module) {
    "use strict";
    require_es_string_includes();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("String", "includes");
  }
});

// node_modules/core-js-pure/es/instance/includes.js
var require_includes3 = __commonJS({
  "node_modules/core-js-pure/es/instance/includes.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var arrayMethod = require_includes();
    var stringMethod = require_includes2();
    var ArrayPrototype = Array.prototype;
    var StringPrototype = String.prototype;
    module.exports = function(it) {
      var own = it.includes;
      if (it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.includes)
        return arrayMethod;
      if (typeof it == "string" || it === StringPrototype || isPrototypeOf(StringPrototype, it) && own === StringPrototype.includes) {
        return stringMethod;
      }
      return own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/includes.js
var require_includes4 = __commonJS({
  "node_modules/core-js-pure/stable/instance/includes.js"(exports, module) {
    "use strict";
    var parent = require_includes3();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/includes.js
var require_includes5 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/includes.js"(exports, module) {
    module.exports = require_includes4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/get-prototype-of.js
var require_get_prototype_of7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/get-prototype-of.js"(exports, module) {
    module.exports = require_get_prototype_of2();
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/create.js
var require_create7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/create.js"(exports, module) {
    module.exports = require_create2();
  }
});

// node_modules/core-js-pure/modules/es.array.find.js
var require_es_array_find = __commonJS({
  "node_modules/core-js-pure/modules/es.array.find.js"() {
    "use strict";
    var $ = require_export();
    var $find = require_array_iteration().find;
    var addToUnscopables = require_add_to_unscopables();
    var FIND = "find";
    var SKIPS_HOLES = true;
    if (FIND in [])
      Array(1)[FIND](function() {
        SKIPS_HOLES = false;
      });
    $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
      find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables(FIND);
  }
});

// node_modules/core-js-pure/es/array/virtual/find.js
var require_find = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/find.js"(exports, module) {
    "use strict";
    require_es_array_find();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "find");
  }
});

// node_modules/core-js-pure/es/instance/find.js
var require_find2 = __commonJS({
  "node_modules/core-js-pure/es/instance/find.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_find();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.find;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.find ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/find.js
var require_find3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/find.js"(exports, module) {
    "use strict";
    var parent = require_find2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/find.js
var require_find4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/find.js"(exports, module) {
    module.exports = require_find3();
  }
});

// node_modules/core-js-pure/modules/es.array.map.js
var require_es_array_map = __commonJS({
  "node_modules/core-js-pure/modules/es.array.map.js"() {
    "use strict";
    var $ = require_export();
    var $map = require_array_iteration().map;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/map.js
var require_map7 = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/map.js"(exports, module) {
    "use strict";
    require_es_array_map();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "map");
  }
});

// node_modules/core-js-pure/es/instance/map.js
var require_map8 = __commonJS({
  "node_modules/core-js-pure/es/instance/map.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_map7();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.map;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.map ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/map.js
var require_map9 = __commonJS({
  "node_modules/core-js-pure/stable/instance/map.js"(exports, module) {
    "use strict";
    var parent = require_map8();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js
var require_map10 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js"(exports, module) {
    module.exports = require_map9();
  }
});

// node_modules/moralis-v1/lib/browser/CoreManager.js
var require_CoreManager = __commonJS({
  "node_modules/moralis-v1/lib/browser/CoreManager.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _forEach = _interopRequireDefault(require_for_each4());
    var _concat = _interopRequireDefault(require_concat4());
    var config = {
      // Defaults
      IS_NODE: typeof process !== "undefined" && !!process.versions && !!process.versions.node && !process.versions.electron,
      REQUEST_ATTEMPT_LIMIT: 5,
      REQUEST_BATCH_SIZE: 20,
      REQUEST_HEADERS: {},
      SERVER_URL: "https://api.parse.com/1",
      SERVER_AUTH_TYPE: null,
      SERVER_AUTH_TOKEN: null,
      LIVEQUERY_SERVER_URL: null,
      ENCRYPTED_KEY: null,
      VERSION: "js".concat("1.12.0"),
      APPLICATION_ID: null,
      JAVASCRIPT_KEY: null,
      MASTER_KEY: null,
      USE_MASTER_KEY: false,
      PERFORM_USER_REWRITE: true,
      FORCE_REVOCABLE_SESSION: false,
      ENCRYPTED_USER: false,
      IDEMPOTENCY: false
    };
    function requireMethods(name2, methods, controller) {
      (0, _forEach.default)(methods).call(methods, function(func) {
        if (typeof controller[func] !== "function") {
          var _context;
          throw new Error((0, _concat.default)(_context = "".concat(name2, " must implement ")).call(_context, func, "()"));
        }
      });
    }
    module.exports = {
      get: function(key2) {
        if (config.hasOwnProperty(key2)) {
          return config[key2];
        }
        throw new Error("Configuration key not found: ".concat(key2));
      },
      set: function(key2, value) {
        config[key2] = value;
      },
      /* Specialized Controller Setters/Getters */
      setAnalyticsController: function(controller) {
        requireMethods("AnalyticsController", ["track"], controller);
        config.AnalyticsController = controller;
      },
      getAnalyticsController: function() {
        return config.AnalyticsController;
      },
      setCloudController: function(controller) {
        requireMethods("CloudController", ["run", "getJobsData", "startJob"], controller);
        config.CloudController = controller;
      },
      getCloudController: function() {
        return config.CloudController;
      },
      setConfigController: function(controller) {
        requireMethods("ConfigController", ["current", "get", "save"], controller);
        config.ConfigController = controller;
      },
      getConfigController: function() {
        return config.ConfigController;
      },
      setCryptoController: function(controller) {
        requireMethods("CryptoController", ["encrypt", "decrypt"], controller);
        config.CryptoController = controller;
      },
      getCryptoController: function() {
        return config.CryptoController;
      },
      setFileController: function(controller) {
        requireMethods("FileController", ["saveFile", "saveBase64"], controller);
        config.FileController = controller;
      },
      getFileController: function() {
        return config.FileController;
      },
      setInstallationController: function(controller) {
        requireMethods("InstallationController", ["currentInstallationId"], controller);
        config.InstallationController = controller;
      },
      getInstallationController: function() {
        return config.InstallationController;
      },
      setObjectController: function(controller) {
        requireMethods("ObjectController", ["save", "fetch", "destroy"], controller);
        config.ObjectController = controller;
      },
      getObjectController: function() {
        return config.ObjectController;
      },
      setObjectStateController: function(controller) {
        requireMethods("ObjectStateController", ["getState", "initializeState", "removeState", "getServerData", "setServerData", "getPendingOps", "setPendingOp", "pushPendingState", "popPendingState", "mergeFirstPendingState", "getObjectCache", "estimateAttribute", "estimateAttributes", "commitServerChanges", "enqueueTask", "clearAllState"], controller);
        config.ObjectStateController = controller;
      },
      getObjectStateController: function() {
        return config.ObjectStateController;
      },
      setPushController: function(controller) {
        requireMethods("PushController", ["send"], controller);
        config.PushController = controller;
      },
      getPushController: function() {
        return config.PushController;
      },
      setQueryController: function(controller) {
        requireMethods("QueryController", ["find", "aggregate"], controller);
        config.QueryController = controller;
      },
      getQueryController: function() {
        return config.QueryController;
      },
      setRESTController: function(controller) {
        requireMethods("RESTController", ["request", "ajax"], controller);
        config.RESTController = controller;
      },
      getRESTController: function() {
        return config.RESTController;
      },
      setSchemaController: function(controller) {
        requireMethods("SchemaController", ["get", "create", "update", "delete", "send", "purge"], controller);
        config.SchemaController = controller;
      },
      getSchemaController: function() {
        return config.SchemaController;
      },
      setSessionController: function(controller) {
        requireMethods("SessionController", ["getSession"], controller);
        config.SessionController = controller;
      },
      getSessionController: function() {
        return config.SessionController;
      },
      setStorageController: function(controller) {
        if (controller.async) {
          requireMethods("An async StorageController", ["getItemAsync", "setItemAsync", "removeItemAsync", "getAllKeysAsync"], controller);
        } else {
          requireMethods("A synchronous StorageController", ["getItem", "setItem", "removeItem", "getAllKeys"], controller);
        }
        config.StorageController = controller;
      },
      setLocalDatastoreController: function(controller) {
        requireMethods("LocalDatastoreController", ["pinWithName", "fromPinWithName", "unPinWithName", "getAllContents", "clear"], controller);
        config.LocalDatastoreController = controller;
      },
      getLocalDatastoreController: function() {
        return config.LocalDatastoreController;
      },
      setLocalDatastore: function(store) {
        config.LocalDatastore = store;
      },
      getLocalDatastore: function() {
        return config.LocalDatastore;
      },
      getStorageController: function() {
        return config.StorageController;
      },
      setAsyncStorage: function(storage) {
        config.AsyncStorage = storage;
      },
      getAsyncStorage: function() {
        return config.AsyncStorage;
      },
      setWebSocketController: function(controller) {
        config.WebSocketController = controller;
      },
      getWebSocketController: function() {
        return config.WebSocketController;
      },
      setUserController: function(controller) {
        requireMethods("UserController", ["setCurrentUser", "currentUser", "currentUserAsync", "signUp", "logIn", "become", "logOut", "me", "requestPasswordReset", "upgradeToRevocableSession", "requestEmailVerification", "verifyPassword", "linkWith"], controller);
        config.UserController = controller;
      },
      getUserController: function() {
        return config.UserController;
      },
      setLiveQueryController: function(controller) {
        requireMethods("LiveQueryController", ["setDefaultLiveQueryClient", "getDefaultLiveQueryClient", "_clearCachedDefaultClient"], controller);
        config.LiveQueryController = controller;
      },
      getLiveQueryController: function() {
        return config.LiveQueryController;
      },
      setHooksController: function(controller) {
        requireMethods("HooksController", ["create", "get", "update", "remove"], controller);
        config.HooksController = controller;
      },
      getHooksController: function() {
        return config.HooksController;
      }
    };
  }
});

// node_modules/moralis-v1/lib/browser/ParseFileEncode.js
var require_ParseFileEncode = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseFileEncode.js"(exports, module) {
    "use strict";
    function b64Digit(number) {
      if (number < 26) {
        return String.fromCharCode(65 + number);
      }
      if (number < 52) {
        return String.fromCharCode(97 + (number - 26));
      }
      if (number < 62) {
        return String.fromCharCode(48 + (number - 52));
      }
      if (number === 62) {
        return "+";
      }
      if (number === 63) {
        return "/";
      }
      throw new TypeError("Tried to encode large digit ".concat(number, " in base64."));
    }
    function encodeBase64(bytes) {
      var chunks = [];
      chunks.length = Math.ceil(bytes.length / 3);
      for (var i2 = 0; i2 < chunks.length; i2++) {
        var b1 = bytes[i2 * 3];
        var b2 = bytes[i2 * 3 + 1] || 0;
        var b3 = bytes[i2 * 3 + 2] || 0;
        var has2 = i2 * 3 + 1 < bytes.length;
        var has3 = i2 * 3 + 2 < bytes.length;
        chunks[i2] = [b64Digit(b1 >> 2 & 63), b64Digit(b1 << 4 & 48 | b2 >> 4 & 15), has2 ? b64Digit(b2 << 2 & 60 | b3 >> 6 & 3) : "=", has3 ? b64Digit(b3 & 63) : "="].join("");
      }
      return chunks.join("");
    }
    module.exports = {
      encodeBase64,
      b64Digit
    };
  }
});

// node_modules/core-js-pure/actual/array/is-array.js
var require_is_array5 = __commonJS({
  "node_modules/core-js-pure/actual/array/is-array.js"(exports, module) {
    "use strict";
    var parent = require_is_array3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/array/is-array.js
var require_is_array6 = __commonJS({
  "node_modules/core-js-pure/full/array/is-array.js"(exports, module) {
    "use strict";
    var parent = require_is_array5();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/array/is-array.js
var require_is_array7 = __commonJS({
  "node_modules/core-js-pure/features/array/is-array.js"(exports, module) {
    "use strict";
    module.exports = require_is_array6();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/array/is-array.js
var require_is_array8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/array/is-array.js"(exports, module) {
    module.exports = require_is_array7();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/arrayWithHoles.js"(exports, module) {
    var _Array$isArray = require_is_array8();
    function _arrayWithHoles(arr) {
      if (_Array$isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/iterableToArrayLimit.js"(exports, module) {
    var _Symbol = require_symbol6();
    var _getIteratorMethod = require_get_iterator_method7();
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof _Symbol !== "undefined" && _getIteratorMethod(arr) || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/actual/instance/slice.js
var require_slice5 = __commonJS({
  "node_modules/core-js-pure/actual/instance/slice.js"(exports, module) {
    "use strict";
    var parent = require_slice3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/instance/slice.js
var require_slice6 = __commonJS({
  "node_modules/core-js-pure/full/instance/slice.js"(exports, module) {
    "use strict";
    var parent = require_slice5();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/instance/slice.js
var require_slice7 = __commonJS({
  "node_modules/core-js-pure/features/instance/slice.js"(exports, module) {
    "use strict";
    module.exports = require_slice6();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/instance/slice.js
var require_slice8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/instance/slice.js"(exports, module) {
    module.exports = require_slice7();
  }
});

// node_modules/core-js-pure/actual/array/from.js
var require_from4 = __commonJS({
  "node_modules/core-js-pure/actual/array/from.js"(exports, module) {
    "use strict";
    var parent = require_from2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/array/from.js
var require_from5 = __commonJS({
  "node_modules/core-js-pure/full/array/from.js"(exports, module) {
    "use strict";
    var parent = require_from4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/array/from.js
var require_from6 = __commonJS({
  "node_modules/core-js-pure/features/array/from.js"(exports, module) {
    "use strict";
    module.exports = require_from5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/array/from.js
var require_from7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/array/from.js"(exports, module) {
    module.exports = require_from6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/arrayLikeToArray.js"(exports, module) {
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/unsupportedIterableToArray.js"(exports, module) {
    var _sliceInstanceProperty = require_slice8();
    var _Array$from = require_from7();
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o2, minLen) {
      var _context;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty(_context = Object.prototype.toString.call(o2)).call(_context, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return arrayLikeToArray(o2, minLen);
    }
    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/nonIterableRest.js"(exports, module) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/slicedToArray.js"(exports, module) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(arr, i2) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i2) || unsupportedIterableToArray(arr, i2) || nonIterableRest();
    }
    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/moralis-v1/lib/browser/ParseFileController.default.js
var require_ParseFileController_default = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseFileController.default.js"(exports, module) {
    "use strict";
    var _Object$keys = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _promise = _interopRequireDefault(require_promise3());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _ParseFileEncode = require_ParseFileEncode();
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context2, _context3;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty(_context2 = ownKeys5(Object(source), true)).call(_context2, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context3 = ownKeys5(Object(source))).call(_context3, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    var XHR = null;
    if (typeof XMLHttpRequest !== "undefined") {
      XHR = XMLHttpRequest;
    }
    var DefaultController = {
      saveFile: function() {
        var _saveFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(name2, source, options) {
          var base64Data, _base64Data$split, _base64Data$split2, first, second, data, newSource;
          return _regenerator.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(source.format !== "file")) {
                    _context.next = 2;
                    break;
                  }
                  throw new Error("saveFile can only be used with File-type sources.");
                case 2:
                  _context.next = 4;
                  return new _promise.default(function(res, rej) {
                    var reader = new FileReader();
                    reader.onload = function() {
                      return res(reader.result);
                    };
                    reader.onerror = function(error) {
                      return rej(error);
                    };
                    reader.readAsDataURL(source.file);
                  });
                case 4:
                  base64Data = _context.sent;
                  _base64Data$split = base64Data.split(","), _base64Data$split2 = (0, _slicedToArray2.default)(_base64Data$split, 2), first = _base64Data$split2[0], second = _base64Data$split2[1];
                  data = second ? second : first;
                  newSource = {
                    format: "base64",
                    base64: data,
                    type: source.type || (source.file ? source.file.type : null)
                  };
                  _context.next = 10;
                  return DefaultController.saveBase64(name2, newSource, options);
                case 10:
                  return _context.abrupt("return", _context.sent);
                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function() {
          return _saveFile.apply(this, arguments);
        };
      }(),
      saveBase64: function(name2, source, options) {
        if (source.format !== "base64") {
          throw new Error("saveBase64 can only be used with Base64-type sources.");
        }
        var data = {
          base64: source.base64,
          fileData: {
            ipfs: options.ipfs,
            metadata: _objectSpread5({}, options.metadata),
            tags: _objectSpread5({}, options.tags)
          }
        };
        delete options.metadata;
        delete options.tags;
        if (source.type) {
          data._ContentType = source.type;
        }
        var path = "files/".concat(name2);
        return _CoreManager.default.getRESTController().request("POST", path, data, options);
      },
      download: function(uri, options) {
        if (XHR) {
          return this.downloadAjax(uri, options);
        }
        return _promise.default.reject("Cannot make a request: No definition of XMLHttpRequest was found.");
      },
      downloadAjax: function(uri, options) {
        return new _promise.default(function(resolve, reject) {
          var xhr = new XHR();
          xhr.open("GET", uri, true);
          xhr.responseType = "arraybuffer";
          xhr.onerror = function(e) {
            reject(e);
          };
          xhr.onreadystatechange = function() {
            if (xhr.readyState !== xhr.DONE) {
              return;
            }
            if (!this.response) {
              return resolve({});
            }
            var bytes = new Uint8Array(this.response);
            resolve({
              base64: (0, _ParseFileEncode.encodeBase64)(bytes),
              contentType: xhr.getResponseHeader("content-type")
            });
          };
          options.requestTask(xhr);
          xhr.send();
        });
      },
      deleteFile: function(name2, options) {
        var headers = {
          "X-Parse-Application-ID": _CoreManager.default.get("APPLICATION_ID")
        };
        if (options.useMasterKey) {
          headers["X-Parse-Master-Key"] = _CoreManager.default.get("MASTER_KEY");
        }
        var url = _CoreManager.default.get("SERVER_URL");
        if (url[url.length - 1] !== "/") {
          url += "/";
        }
        url += "files/".concat(name2);
        return _CoreManager.default.getRESTController().ajax("DELETE", url, "", headers).catch(function(response) {
          if (!response || response === "SyntaxError: Unexpected end of JSON input") {
            return _promise.default.resolve();
          }
          return _CoreManager.default.getRESTController().handleError(response);
        });
      },
      _setXHR: function(xhr) {
        XHR = xhr;
      },
      _getXHR: function() {
        return XHR;
      }
    };
    module.exports = DefaultController;
  }
});

// node_modules/moralis-v1/lib/browser/ParseFile.js
var require_ParseFile = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseFile.js"(exports) {
    "use strict";
    var _Object$keys2 = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty2 = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _slice = _interopRequireDefault(require_slice4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _keys = _interopRequireDefault(require_keys3());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _ParseFileEncode = require_ParseFileEncode();
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys2(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context4, _context5;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty2(_context4 = ownKeys5(Object(source), true)).call(_context4, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty2(_context5 = ownKeys5(Object(source))).call(_context5, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    var ParseError = require_ParseError().default;
    var dataUriRegexp = /^data:([a-zA-Z]+\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\-/]*)?;base64,/;
    var ParseFile = function() {
      function ParseFile2(name2, data, type, metadata, tags) {
        (0, _classCallCheck2.default)(this, ParseFile2);
        (0, _defineProperty2.default)(this, "_name", void 0);
        (0, _defineProperty2.default)(this, "_url", void 0);
        (0, _defineProperty2.default)(this, "_hash", void 0);
        (0, _defineProperty2.default)(this, "_ipfs", void 0);
        (0, _defineProperty2.default)(this, "_source", void 0);
        (0, _defineProperty2.default)(this, "_previousSave", void 0);
        (0, _defineProperty2.default)(this, "_data", void 0);
        (0, _defineProperty2.default)(this, "_requestTask", void 0);
        (0, _defineProperty2.default)(this, "_metadata", void 0);
        (0, _defineProperty2.default)(this, "_tags", void 0);
        var specifiedType = type || "";
        this._name = name2;
        this._metadata = metadata || {};
        this._tags = tags || {};
        if (data !== void 0) {
          if ((0, _isArray.default)(data)) {
            this._data = ParseFile2.encodeBase64(data);
            this._source = {
              format: "base64",
              base64: this._data,
              type: specifiedType
            };
          } else if (typeof Blob !== "undefined" && data instanceof Blob) {
            this._source = {
              format: "file",
              file: data,
              type: specifiedType
            };
          } else if (data && typeof data.uri === "string" && data.uri !== void 0) {
            this._source = {
              format: "uri",
              uri: data.uri,
              type: specifiedType
            };
          } else if (data && typeof data.base64 === "string") {
            var base64 = data.base64;
            var commaIndex = (0, _indexOf.default)(base64).call(base64, ",");
            if (commaIndex !== -1) {
              var matches = dataUriRegexp.exec((0, _slice.default)(base64).call(base64, 0, commaIndex + 1));
              this._data = (0, _slice.default)(base64).call(base64, commaIndex + 1);
              this._source = {
                format: "base64",
                base64: this._data,
                type: matches[1]
              };
            } else {
              this._data = base64;
              this._source = {
                format: "base64",
                base64,
                type: specifiedType
              };
            }
          } else {
            throw new TypeError("Cannot create a Parse.File with that data.");
          }
        }
      }
      (0, _createClass2.default)(ParseFile2, [{
        key: "getData",
        value: function() {
          var _getData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var _this = this;
            var options, controller, result;
            return _regenerator.default.wrap(function(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._data) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", this._data);
                  case 2:
                    if (this._url) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("Cannot retrieve data for unsaved ParseFile.");
                  case 4:
                    options = {
                      requestTask: function(task) {
                        return _this._requestTask = task;
                      }
                    };
                    controller = _CoreManager.default.getFileController();
                    _context.next = 8;
                    return controller.download(this._url, options);
                  case 8:
                    result = _context.sent;
                    this._data = result.base64;
                    return _context.abrupt("return", this._data);
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _getData.apply(this, arguments);
          };
        }()
        /**
         * Gets the name of the file. Before save is called, this is the filename
         * given by the user. After save is called, that name gets prefixed with a
         * unique identifier.
         *
         * @returns {string}
         */
      }, {
        key: "name",
        value: function() {
          return this._name;
        }
        /**
         * Gets the url of the file. It is only available after you save the file or
         * after you get the file from a Parse.Object.
         *
         * @param {object} options An object to specify url options
         * @returns {string}
         */
      }, {
        key: "url",
        value: function(options) {
          options = options || {};
          if (!this._url) {
            return;
          }
          if (options.forceSecure) {
            return this._url.replace(/^http:\/\//i, "https://");
          }
          return this._url;
        }
      }, {
        key: "ipfs",
        value: function() {
          return this._ipfs;
        }
      }, {
        key: "hash",
        value: function() {
          return this._hash;
        }
        /**
         * Gets the metadata of the file.
         *
         * @returns {object}
         */
      }, {
        key: "metadata",
        value: function() {
          return this._metadata;
        }
        /**
         * Gets the tags of the file.
         *
         * @returns {object}
         */
      }, {
        key: "tags",
        value: function() {
          return this._tags;
        }
        /**
         * Saves the file to the Parse cloud.
         *
         * @param {object} options
         *  * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *     behalf of a specific user.
         *   <li>progress: In Browser only, callback for upload progress. For example:
         * <pre>
         * let parseFile = new Parse.File(name, file);
         * parseFile.save({
         *   progress: (progressValue, loaded, total, { type }) => {
         *     if (type === "upload" && progressValue !== null) {
         *       // Update the UI using progressValue
         *     }
         *   }
         * });
         * </pre>
         * </ul>
         * @returns {Promise} Promise that is resolved when the save finishes.
         */
      }, {
        key: "save",
        value: function(options) {
          var _this2 = this;
          options = options || {};
          options.requestTask = function(task) {
            return _this2._requestTask = task;
          };
          options.metadata = this._metadata;
          options.tags = this._tags;
          var controller = _CoreManager.default.getFileController();
          if (!this._previousSave) {
            if (this._source.format === "file") {
              this._previousSave = controller.saveFile(this._name, this._source, options).then(function(res) {
                _this2._name = res.name;
                _this2._url = res.url;
                _this2._hash = res.hash;
                _this2._ipfs = res.ipfs;
                _this2._data = null;
                _this2._requestTask = null;
                return _this2;
              });
            } else if (this._source.format === "uri") {
              this._previousSave = controller.download(this._source.uri, options).then(function(result) {
                if (!(result && result.base64)) {
                  return {};
                }
                var newSource = {
                  format: "base64",
                  base64: result.base64,
                  type: result.contentType
                };
                _this2._data = result.base64;
                _this2._requestTask = null;
                return controller.saveBase64(_this2._name, newSource, options);
              }).then(function(res) {
                _this2._name = res.name;
                _this2._url = res.url;
                _this2._hash = res.hash;
                _this2._ipfs = res.ipfs;
                _this2._requestTask = null;
                return _this2;
              });
            } else {
              this._previousSave = controller.saveBase64(this._name, this._source, options).then(function(res) {
                _this2._name = res.name;
                _this2._url = res.url;
                _this2._hash = res.hash;
                _this2._ipfs = res.ipfs;
                _this2._requestTask = null;
                return _this2;
              });
            }
          }
          if (this._previousSave) {
            return this._previousSave;
          }
        }
      }, {
        key: "saveIPFS",
        value: function(options) {
          return this.save(_objectSpread5(_objectSpread5({}, options), {}, {
            ipfs: true
          }));
        }
        /**
         * Aborts the request if it has already been sent.
         */
      }, {
        key: "cancel",
        value: function() {
          if (this._requestTask && typeof this._requestTask.abort === "function") {
            this._requestTask.abort();
          }
          this._requestTask = null;
        }
        /**
         * Deletes the file from the Parse cloud.
         * In Cloud Code and Node only with Master Key.
         *
         * @param {object} options
         *  * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         * <pre>
         * @returns {Promise} Promise that is resolved when the delete finishes.
         */
      }, {
        key: "destroy",
        value: function() {
          var _this3 = this;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!this._name) {
            throw new ParseError(ParseError.FILE_DELETE_UNNAMED_ERROR, "Cannot delete an unnamed file.");
          }
          var destroyOptions = {
            useMasterKey: true
          };
          if (options.hasOwnProperty("useMasterKey")) {
            destroyOptions.useMasterKey = options.useMasterKey;
          }
          var controller = _CoreManager.default.getFileController();
          return controller.deleteFile(this._name, destroyOptions).then(function() {
            _this3._data = null;
            _this3._requestTask = null;
            return _this3;
          });
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            __type: "File",
            name: this._name,
            url: this._url,
            ipfs: this._ipfs,
            hash: this._hash
          };
        }
      }, {
        key: "equals",
        value: function(other) {
          if (this === other) {
            return true;
          }
          return other instanceof ParseFile2 && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== "undefined";
        }
        /**
         * Sets metadata to be saved with file object. Overwrites existing metadata
         *
         * @param {object} metadata Key value pairs to be stored with file object
         */
      }, {
        key: "setMetadata",
        value: function(metadata) {
          var _this4 = this;
          if (metadata && (0, _typeof2.default)(metadata) === "object") {
            var _context2;
            (0, _forEach.default)(_context2 = (0, _keys.default)(metadata)).call(_context2, function(key2) {
              _this4.addMetadata(key2, metadata[key2]);
            });
          }
        }
        /**
         * Sets metadata to be saved with file object. Adds to existing metadata.
         *
         * @param {string} key key to store the metadata
         * @param {*} value metadata
         */
      }, {
        key: "addMetadata",
        value: function(key2, value) {
          if (typeof key2 === "string") {
            this._metadata[key2] = value;
          }
        }
        /**
         * Sets tags to be saved with file object. Overwrites existing tags
         *
         * @param {object} tags Key value pairs to be stored with file object
         */
      }, {
        key: "setTags",
        value: function(tags) {
          var _this5 = this;
          if (tags && (0, _typeof2.default)(tags) === "object") {
            var _context3;
            (0, _forEach.default)(_context3 = (0, _keys.default)(tags)).call(_context3, function(key2) {
              _this5.addTag(key2, tags[key2]);
            });
          }
        }
        /**
         * Sets tags to be saved with file object. Adds to existing tags.
         *
         * @param {string} key key to store tags
         * @param {*} value tag
         */
      }, {
        key: "addTag",
        value: function(key2, value) {
          if (typeof key2 === "string") {
            this._tags[key2] = value;
          }
        }
      }], [{
        key: "fromJSON",
        value: function(obj) {
          if (obj.__type !== "File") {
            throw new TypeError("JSON object does not represent a ParseFile");
          }
          var file = new ParseFile2(obj.name);
          file._url = obj.url;
          file._hash = obj.hash;
          file._ipfs = obj.ipfs;
          return file;
        }
      }, {
        key: "encodeBase64",
        value: function(bytes) {
          return (0, _ParseFileEncode.encodeBase64)(bytes);
        }
      }]);
      return ParseFile2;
    }();
    _CoreManager.default.setFileController(require_ParseFileController_default());
    var _default = ParseFile;
    exports.default = _default;
    exports.b64Digit = _ParseFileEncode.b64Digit;
  }
});

// node_modules/core-js-pure/internals/array-set-length.js
var require_array_set_length = __commonJS({
  "node_modules/core-js-pure/internals/array-set-length.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var isArray = require_is_array();
    var $TypeError = TypeError;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
      if (this !== void 0)
        return true;
      try {
        Object.defineProperty([], "length", { writable: false }).length = 1;
      } catch (error) {
        return error instanceof TypeError;
      }
    }();
    module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O2, length) {
      if (isArray(O2) && !getOwnPropertyDescriptor(O2, "length").writable) {
        throw new $TypeError("Cannot set read only .length");
      }
      return O2.length = length;
    } : function(O2, length) {
      return O2.length = length;
    };
  }
});

// node_modules/core-js-pure/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js-pure/internals/delete-property-or-throw.js"(exports, module) {
    "use strict";
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(O2, P2) {
      if (!delete O2[P2])
        throw new $TypeError("Cannot delete property " + tryToString(P2) + " of " + tryToString(O2));
    };
  }
});

// node_modules/core-js-pure/modules/es.array.splice.js
var require_es_array_splice = __commonJS({
  "node_modules/core-js-pure/modules/es.array.splice.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var lengthOfArrayLike = require_length_of_array_like();
    var setArrayLength = require_array_set_length();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var arraySpeciesCreate = require_array_species_create();
    var createProperty = require_create_property();
    var deletePropertyOrThrow = require_delete_property_or_throw();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
    var max = Math.max;
    var min = Math.min;
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      splice: function splice(start, deleteCount) {
        var O2 = toObject(this);
        var len = lengthOfArrayLike(O2);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A2, k2, from, to;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
        }
        doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
        A2 = arraySpeciesCreate(O2, actualDeleteCount);
        for (k2 = 0; k2 < actualDeleteCount; k2++) {
          from = actualStart + k2;
          if (from in O2)
            createProperty(A2, k2, O2[from]);
        }
        A2.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
          for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
            from = k2 + actualDeleteCount;
            to = k2 + insertCount;
            if (from in O2)
              O2[to] = O2[from];
            else
              deletePropertyOrThrow(O2, to);
          }
          for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
            deletePropertyOrThrow(O2, k2 - 1);
        } else if (insertCount > actualDeleteCount) {
          for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
            from = k2 + actualDeleteCount - 1;
            to = k2 + insertCount - 1;
            if (from in O2)
              O2[to] = O2[from];
            else
              deletePropertyOrThrow(O2, to);
          }
        }
        for (k2 = 0; k2 < insertCount; k2++) {
          O2[k2 + actualStart] = arguments[k2 + 2];
        }
        setArrayLength(O2, len - actualDeleteCount + insertCount);
        return A2;
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/splice.js
var require_splice = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/splice.js"(exports, module) {
    "use strict";
    require_es_array_splice();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "splice");
  }
});

// node_modules/core-js-pure/es/instance/splice.js
var require_splice2 = __commonJS({
  "node_modules/core-js-pure/es/instance/splice.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_splice();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.splice;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.splice ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/splice.js
var require_splice3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/splice.js"(exports, module) {
    "use strict";
    var parent = require_splice2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/splice.js
var require_splice4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/splice.js"(exports, module) {
    module.exports = require_splice3();
  }
});

// node_modules/moralis-v1/lib/browser/arrayContainsObject.js
var require_arrayContainsObject = __commonJS({
  "node_modules/moralis-v1/lib/browser/arrayContainsObject.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = arrayContainsObject;
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    function arrayContainsObject(array, object) {
      if ((0, _indexOf.default)(array).call(array, object) > -1) {
        return true;
      }
      for (var i2 = 0; i2 < array.length; i2++) {
        if (array[i2] instanceof _ParseObject.default && array[i2].className === object.className && array[i2]._getId() === object._getId()) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/core-js-pure/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "node_modules/core-js-pure/modules/es.string.starts-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var stringSlice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString2(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString2(searchString);
        return stringSlice(that, index, index + search.length) === search;
      }
    });
  }
});

// node_modules/core-js-pure/es/string/virtual/starts-with.js
var require_starts_with = __commonJS({
  "node_modules/core-js-pure/es/string/virtual/starts-with.js"(exports, module) {
    "use strict";
    require_es_string_starts_with();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("String", "startsWith");
  }
});

// node_modules/core-js-pure/es/instance/starts-with.js
var require_starts_with2 = __commonJS({
  "node_modules/core-js-pure/es/instance/starts-with.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_starts_with();
    var StringPrototype = String.prototype;
    module.exports = function(it) {
      var own = it.startsWith;
      return typeof it == "string" || it === StringPrototype || isPrototypeOf(StringPrototype, it) && own === StringPrototype.startsWith ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/starts-with.js
var require_starts_with3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/starts-with.js"(exports, module) {
    "use strict";
    var parent = require_starts_with2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/starts-with.js
var require_starts_with4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/starts-with.js"(exports, module) {
    module.exports = require_starts_with3();
  }
});

// node_modules/moralis-v1/lib/browser/ParseGeoPoint.js
var require_ParseGeoPoint = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseGeoPoint.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isArray = _interopRequireDefault(require_is_array4());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var ParseGeoPoint = function() {
      function ParseGeoPoint2(arg1, arg2) {
        (0, _classCallCheck2.default)(this, ParseGeoPoint2);
        (0, _defineProperty2.default)(this, "_latitude", void 0);
        (0, _defineProperty2.default)(this, "_longitude", void 0);
        if ((0, _isArray.default)(arg1)) {
          ParseGeoPoint2._validate(arg1[0], arg1[1]);
          this._latitude = arg1[0];
          this._longitude = arg1[1];
        } else if ((0, _typeof2.default)(arg1) === "object") {
          ParseGeoPoint2._validate(arg1.latitude, arg1.longitude);
          this._latitude = arg1.latitude;
          this._longitude = arg1.longitude;
        } else if (arg1 !== void 0 && arg2 !== void 0) {
          ParseGeoPoint2._validate(arg1, arg2);
          this._latitude = arg1;
          this._longitude = arg2;
        } else {
          this._latitude = 0;
          this._longitude = 0;
        }
      }
      (0, _createClass2.default)(ParseGeoPoint2, [{
        key: "latitude",
        get: function() {
          return this._latitude;
        },
        set: function(val) {
          ParseGeoPoint2._validate(val, this.longitude);
          this._latitude = val;
        }
        /**
         * East-west portion of the coordinate, in range [-180, 180].
         * Throws if set out of range in a modern browser.
         *
         * @property {number} longitude
         * @returns {number}
         */
      }, {
        key: "longitude",
        get: function() {
          return this._longitude;
        },
        set: function(val) {
          ParseGeoPoint2._validate(this.latitude, val);
          this._longitude = val;
        }
        /**
         * Returns a JSON representation of the GeoPoint, suitable for Parse.
         *
         * @returns {object}
         */
      }, {
        key: "toJSON",
        value: function() {
          ParseGeoPoint2._validate(this._latitude, this._longitude);
          return {
            __type: "GeoPoint",
            latitude: this._latitude,
            longitude: this._longitude
          };
        }
      }, {
        key: "equals",
        value: function(other) {
          return other instanceof ParseGeoPoint2 && this.latitude === other.latitude && this.longitude === other.longitude;
        }
        /**
         * Returns the distance from this GeoPoint to another in radians.
         *
         * @param {Parse.GeoPoint} point the other Parse.GeoPoint.
         * @returns {number}
         */
      }, {
        key: "radiansTo",
        value: function(point3) {
          var d2r = Math.PI / 180;
          var lat1rad = this.latitude * d2r;
          var long1rad = this.longitude * d2r;
          var lat2rad = point3.latitude * d2r;
          var long2rad = point3.longitude * d2r;
          var sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);
          var sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2);
          var a2 = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;
          a2 = Math.min(1, a2);
          return 2 * Math.asin(Math.sqrt(a2));
        }
        /**
         * Returns the distance from this GeoPoint to another in kilometers.
         *
         * @param {Parse.GeoPoint} point the other Parse.GeoPoint.
         * @returns {number}
         */
      }, {
        key: "kilometersTo",
        value: function(point3) {
          return this.radiansTo(point3) * 6371;
        }
        /**
         * Returns the distance from this GeoPoint to another in miles.
         *
         * @param {Parse.GeoPoint} point the other Parse.GeoPoint.
         * @returns {number}
         */
      }, {
        key: "milesTo",
        value: function(point3) {
          return this.radiansTo(point3) * 3958.8;
        }
        /*
         * Throws an exception if the given lat-long is out of bounds.
         */
      }], [{
        key: "_validate",
        value: function(latitude, longitude) {
          if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== "number" || typeof longitude !== "number") {
            throw new TypeError("GeoPoint latitude and longitude must be valid numbers");
          }
          if (latitude < -90) {
            throw new TypeError("GeoPoint latitude out of bounds: ".concat(latitude, " < -90.0."));
          }
          if (latitude > 90) {
            throw new TypeError("GeoPoint latitude out of bounds: ".concat(latitude, " > 90.0."));
          }
          if (longitude < -180) {
            throw new TypeError("GeoPoint longitude out of bounds: ".concat(longitude, " < -180.0."));
          }
          if (longitude > 180) {
            throw new TypeError("GeoPoint longitude out of bounds: ".concat(longitude, " > 180.0."));
          }
        }
        /**
         * Creates a GeoPoint with the user's current location, if available.
         *
         * @static
         * @returns {Parse.GeoPoint} User's current location
         */
      }, {
        key: "current",
        value: function() {
          return navigator.geolocation.getCurrentPosition(function(location) {
            return new ParseGeoPoint2(location.coords.latitude, location.coords.longitude);
          });
        }
      }]);
      return ParseGeoPoint2;
    }();
    var _default = ParseGeoPoint;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParsePolygon.js
var require_ParsePolygon = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParsePolygon.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isArray = _interopRequireDefault(require_is_array4());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _ParseGeoPoint = _interopRequireDefault(require_ParseGeoPoint());
    var ParsePolygon = function() {
      function ParsePolygon2(coordinates) {
        (0, _classCallCheck2.default)(this, ParsePolygon2);
        (0, _defineProperty2.default)(this, "_coordinates", void 0);
        this._coordinates = ParsePolygon2._validate(coordinates);
      }
      (0, _createClass2.default)(ParsePolygon2, [{
        key: "coordinates",
        get: function() {
          return this._coordinates;
        },
        set: function(coords) {
          this._coordinates = ParsePolygon2._validate(coords);
        }
        /**
         * Returns a JSON representation of the Polygon, suitable for Parse.
         *
         * @returns {object}
         */
      }, {
        key: "toJSON",
        value: function() {
          ParsePolygon2._validate(this._coordinates);
          return {
            __type: "Polygon",
            coordinates: this._coordinates
          };
        }
        /**
         * Checks if two polygons are equal
         *
         * @param {(Parse.Polygon | object)} other
         * @returns {boolean}
         */
      }, {
        key: "equals",
        value: function(other) {
          if (!(other instanceof ParsePolygon2) || this.coordinates.length !== other.coordinates.length) {
            return false;
          }
          var isEqual = true;
          for (var i2 = 1; i2 < this._coordinates.length; i2 += 1) {
            if (this._coordinates[i2][0] !== other.coordinates[i2][0] || this._coordinates[i2][1] !== other.coordinates[i2][1]) {
              isEqual = false;
              break;
            }
          }
          return isEqual;
        }
        /**
         *
         * @param {Parse.GeoPoint} point
         * @returns {boolean} Returns if the point is contained in the polygon
         */
      }, {
        key: "containsPoint",
        value: function(point3) {
          var minX = this._coordinates[0][0];
          var maxX = this._coordinates[0][0];
          var minY = this._coordinates[0][1];
          var maxY = this._coordinates[0][1];
          for (var i2 = 1; i2 < this._coordinates.length; i2 += 1) {
            var p2 = this._coordinates[i2];
            minX = Math.min(p2[0], minX);
            maxX = Math.max(p2[0], maxX);
            minY = Math.min(p2[1], minY);
            maxY = Math.max(p2[1], maxY);
          }
          var outside = point3.latitude < minX || point3.latitude > maxX || point3.longitude < minY || point3.longitude > maxY;
          if (outside) {
            return false;
          }
          var inside = false;
          for (var _i = 0, j2 = this._coordinates.length - 1; _i < this._coordinates.length; j2 = _i++) {
            var startX = this._coordinates[_i][0];
            var startY = this._coordinates[_i][1];
            var endX = this._coordinates[j2][0];
            var endY = this._coordinates[j2][1];
            var intersect = startY > point3.longitude !== endY > point3.longitude && point3.latitude < (endX - startX) * (point3.longitude - startY) / (endY - startY) + startX;
            if (intersect) {
              inside = !inside;
            }
          }
          return inside;
        }
        /**
         * Validates that the list of coordinates can form a valid polygon
         *
         * @param {Array} coords the list of coordinates to validate as a polygon
         * @throws {TypeError}
         * @returns {number[][]} Array of coordinates if validated.
         */
      }], [{
        key: "_validate",
        value: function(coords) {
          if (!(0, _isArray.default)(coords)) {
            throw new TypeError("Coordinates must be an Array");
          }
          if (coords.length < 3) {
            throw new TypeError("Polygon must have at least 3 GeoPoints or Points");
          }
          var points = [];
          for (var i2 = 0; i2 < coords.length; i2 += 1) {
            var coord = coords[i2];
            var geoPoint = void 0;
            if (coord instanceof _ParseGeoPoint.default) {
              geoPoint = coord;
            } else if ((0, _isArray.default)(coord) && coord.length === 2) {
              geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);
            } else {
              throw new TypeError("Coordinates must be an Array of GeoPoints or Points");
            }
            points.push([geoPoint.latitude, geoPoint.longitude]);
          }
          return points;
        }
      }]);
      return ParsePolygon2;
    }();
    var _default = ParsePolygon;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/encode.js
var require_encode = __commonJS({
  "node_modules/moralis-v1/lib/browser/encode.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _concat = _interopRequireDefault(require_concat4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _keys = _interopRequireDefault(require_keys3());
    var _startsWith = _interopRequireDefault(require_starts_with4());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _map = _interopRequireDefault(require_map10());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _ParseGeoPoint = _interopRequireDefault(require_ParseGeoPoint());
    var _ParsePolygon = _interopRequireDefault(require_ParsePolygon());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseOp = require_ParseOp();
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    function encode4(value, disallowObjects, forcePointers, seen, offline) {
      if (value instanceof _ParseObject.default) {
        var _context;
        if (disallowObjects) {
          throw new Error("Parse Objects not allowed here");
        }
        var seenEntry = value.id ? (0, _concat.default)(_context = "".concat(value.className, ":")).call(_context, value.id) : value;
        if (forcePointers || !seen || (0, _indexOf.default)(seen).call(seen, seenEntry) > -1 || value.dirty() || (0, _keys.default)(value._getServerData()).length < 1) {
          var _context2;
          if (offline && (0, _startsWith.default)(_context2 = value._getId()).call(_context2, "local")) {
            return value.toOfflinePointer();
          }
          return value.toPointer();
        }
        seen = (0, _concat.default)(seen).call(seen, seenEntry);
        return value._toFullJSON(seen, offline);
      }
      if (value instanceof _ParseOp.Op || value instanceof _ParseACL.default || value instanceof _ParseGeoPoint.default || value instanceof _ParsePolygon.default || value instanceof _ParseRelation.default) {
        return value.toJSON();
      }
      if (value instanceof _ParseFile.default) {
        if (!value.url()) {
          throw new Error("Tried to encode an unsaved file.");
        }
        return value.toJSON();
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        if (isNaN(value)) {
          throw new Error("Tried to encode an invalid date.");
        }
        return {
          __type: "Date",
          iso: value.toJSON()
        };
      }
      if (Object.prototype.toString.call(value) === "[object RegExp]" && typeof value.source === "string") {
        return value.source;
      }
      if ((0, _isArray.default)(value)) {
        return (0, _map.default)(value).call(value, function(v2) {
          return encode4(v2, disallowObjects, forcePointers, seen, offline);
        });
      }
      if (value && (0, _typeof2.default)(value) === "object") {
        var output = {};
        for (var k2 in value) {
          output[k2] = encode4(value[k2], disallowObjects, forcePointers, seen, offline);
        }
        return output;
      }
      return value;
    }
    function _default(value, disallowObjects, forcePointers, seen, offline) {
      return encode4(value, !!disallowObjects, !!forcePointers, seen || [], offline);
    }
  }
});

// node_modules/moralis-v1/lib/browser/unique.js
var require_unique = __commonJS({
  "node_modules/moralis-v1/lib/browser/unique.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = unique;
    var _forEach = _interopRequireDefault(require_for_each4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _arrayContainsObject = _interopRequireDefault(require_arrayContainsObject());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    function unique(arr) {
      var uniques = [];
      (0, _forEach.default)(arr).call(arr, function(value) {
        if (value instanceof _ParseObject.default) {
          if (!(0, _arrayContainsObject.default)(uniques, value)) {
            uniques.push(value);
          }
        } else {
          if ((0, _indexOf.default)(uniques).call(uniques, value) < 0) {
            uniques.push(value);
          }
        }
      });
      return uniques;
    }
  }
});

// node_modules/moralis-v1/lib/browser/ParseOp.js
var require_ParseOp = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseOp.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;
    exports.opFromJSON = opFromJSON;
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _concat = _interopRequireDefault(require_concat4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _splice = _interopRequireDefault(require_splice4());
    var _map = _interopRequireDefault(require_map10());
    var _arrayContainsObject = _interopRequireDefault(require_arrayContainsObject());
    var _decode2 = _interopRequireDefault(require_decode());
    var _encode3 = _interopRequireDefault(require_encode());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    var _unique = _interopRequireDefault(require_unique());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function opFromJSON(json) {
      if (!json || !json.__op) {
        return null;
      }
      switch (json.__op) {
        case "Delete":
          return new UnsetOp();
        case "Increment":
          return new IncrementOp(json.amount);
        case "Add":
          return new AddOp((0, _decode2.default)(json.objects));
        case "AddUnique":
          return new AddUniqueOp((0, _decode2.default)(json.objects));
        case "Remove":
          return new RemoveOp((0, _decode2.default)(json.objects));
        case "AddRelation": {
          var toAdd = (0, _decode2.default)(json.objects);
          if (!(0, _isArray.default)(toAdd)) {
            return new RelationOp([], []);
          }
          return new RelationOp(toAdd, []);
        }
        case "RemoveRelation": {
          var toRemove = (0, _decode2.default)(json.objects);
          if (!(0, _isArray.default)(toRemove)) {
            return new RelationOp([], []);
          }
          return new RelationOp([], toRemove);
        }
        case "Batch": {
          var _toAdd = [];
          var _toRemove = [];
          for (var i2 = 0; i2 < json.ops.length; i2++) {
            if (json.ops[i2].__op === "AddRelation") {
              _toAdd = (0, _concat.default)(_toAdd).call(_toAdd, (0, _decode2.default)(json.ops[i2].objects));
            } else if (json.ops[i2].__op === "RemoveRelation") {
              _toRemove = (0, _concat.default)(_toRemove).call(_toRemove, (0, _decode2.default)(json.ops[i2].objects));
            }
          }
          return new RelationOp(_toAdd, _toRemove);
        }
        default:
          return null;
      }
    }
    var Op = function() {
      function Op2() {
        (0, _classCallCheck2.default)(this, Op2);
      }
      (0, _createClass2.default)(Op2, [{
        key: "applyTo",
        value: (
          // Empty parent class
          function() {
          }
        )
        /* eslint-disable-line no-unused-vars */
      }, {
        key: "mergeWith",
        value: function() {
        }
        /* eslint-disable-line no-unused-vars */
      }, {
        key: "toJSON",
        value: function() {
        }
      }]);
      return Op2;
    }();
    exports.Op = Op;
    var SetOp = function(_Op) {
      (0, _inherits2.default)(SetOp2, _Op);
      var _super = _createSuper(SetOp2);
      function SetOp2(value) {
        var _this;
        (0, _classCallCheck2.default)(this, SetOp2);
        _this = _super.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_value", void 0);
        _this._value = value;
        return _this;
      }
      (0, _createClass2.default)(SetOp2, [{
        key: "applyTo",
        value: function() {
          return this._value;
        }
      }, {
        key: "mergeWith",
        value: function() {
          return new SetOp2(this._value);
        }
      }, {
        key: "toJSON",
        value: function(offline) {
          return (0, _encode3.default)(this._value, false, true, void 0, offline);
        }
      }]);
      return SetOp2;
    }(Op);
    exports.SetOp = SetOp;
    var UnsetOp = function(_Op2) {
      (0, _inherits2.default)(UnsetOp2, _Op2);
      var _super2 = _createSuper(UnsetOp2);
      function UnsetOp2() {
        (0, _classCallCheck2.default)(this, UnsetOp2);
        return _super2.apply(this, arguments);
      }
      (0, _createClass2.default)(UnsetOp2, [{
        key: "applyTo",
        value: function() {
          return void 0;
        }
      }, {
        key: "mergeWith",
        value: function() {
          return new UnsetOp2();
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            __op: "Delete"
          };
        }
      }]);
      return UnsetOp2;
    }(Op);
    exports.UnsetOp = UnsetOp;
    var IncrementOp = function(_Op3) {
      (0, _inherits2.default)(IncrementOp2, _Op3);
      var _super3 = _createSuper(IncrementOp2);
      function IncrementOp2(amount) {
        var _this2;
        (0, _classCallCheck2.default)(this, IncrementOp2);
        _this2 = _super3.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "_amount", void 0);
        if (typeof amount !== "number") {
          throw new TypeError("Increment Op must be initialized with a numeric amount.");
        }
        _this2._amount = amount;
        return _this2;
      }
      (0, _createClass2.default)(IncrementOp2, [{
        key: "applyTo",
        value: function(value) {
          if (typeof value === "undefined") {
            return this._amount;
          }
          if (typeof value !== "number") {
            throw new TypeError("Cannot increment a non-numeric value.");
          }
          return this._amount + value;
        }
      }, {
        key: "mergeWith",
        value: function(previous) {
          if (!previous) {
            return this;
          }
          if (previous instanceof SetOp) {
            return new SetOp(this.applyTo(previous._value));
          }
          if (previous instanceof UnsetOp) {
            return new SetOp(this._amount);
          }
          if (previous instanceof IncrementOp2) {
            return new IncrementOp2(this.applyTo(previous._amount));
          }
          throw new Error("Cannot merge Increment Op with the previous Op");
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            __op: "Increment",
            amount: this._amount
          };
        }
      }]);
      return IncrementOp2;
    }(Op);
    exports.IncrementOp = IncrementOp;
    var AddOp = function(_Op4) {
      (0, _inherits2.default)(AddOp2, _Op4);
      var _super4 = _createSuper(AddOp2);
      function AddOp2(value) {
        var _this3;
        (0, _classCallCheck2.default)(this, AddOp2);
        _this3 = _super4.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), "_value", void 0);
        _this3._value = (0, _isArray.default)(value) ? value : [value];
        return _this3;
      }
      (0, _createClass2.default)(AddOp2, [{
        key: "applyTo",
        value: function(value) {
          if (value == null) {
            return this._value;
          }
          if ((0, _isArray.default)(value)) {
            return (0, _concat.default)(value).call(value, this._value);
          }
          throw new Error("Cannot add elements to a non-array value");
        }
      }, {
        key: "mergeWith",
        value: function(previous) {
          if (!previous) {
            return this;
          }
          if (previous instanceof SetOp) {
            return new SetOp(this.applyTo(previous._value));
          }
          if (previous instanceof UnsetOp) {
            return new SetOp(this._value);
          }
          if (previous instanceof AddOp2) {
            return new AddOp2(this.applyTo(previous._value));
          }
          throw new Error("Cannot merge Add Op with the previous Op");
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            __op: "Add",
            objects: (0, _encode3.default)(this._value, false, true)
          };
        }
      }]);
      return AddOp2;
    }(Op);
    exports.AddOp = AddOp;
    var AddUniqueOp = function(_Op5) {
      (0, _inherits2.default)(AddUniqueOp2, _Op5);
      var _super5 = _createSuper(AddUniqueOp2);
      function AddUniqueOp2(value) {
        var _this4;
        (0, _classCallCheck2.default)(this, AddUniqueOp2);
        _this4 = _super5.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "_value", void 0);
        _this4._value = (0, _unique.default)((0, _isArray.default)(value) ? value : [value]);
        return _this4;
      }
      (0, _createClass2.default)(AddUniqueOp2, [{
        key: "applyTo",
        value: function(value) {
          if (value == null) {
            return this._value || [];
          }
          if ((0, _isArray.default)(value)) {
            var _context;
            var toAdd = [];
            (0, _forEach.default)(_context = this._value).call(_context, function(v2) {
              if (v2 instanceof _ParseObject.default) {
                if (!(0, _arrayContainsObject.default)(value, v2)) {
                  toAdd.push(v2);
                }
              } else {
                if ((0, _indexOf.default)(value).call(value, v2) < 0) {
                  toAdd.push(v2);
                }
              }
            });
            return (0, _concat.default)(value).call(value, toAdd);
          }
          throw new Error("Cannot add elements to a non-array value");
        }
      }, {
        key: "mergeWith",
        value: function(previous) {
          if (!previous) {
            return this;
          }
          if (previous instanceof SetOp) {
            return new SetOp(this.applyTo(previous._value));
          }
          if (previous instanceof UnsetOp) {
            return new SetOp(this._value);
          }
          if (previous instanceof AddUniqueOp2) {
            return new AddUniqueOp2(this.applyTo(previous._value));
          }
          throw new Error("Cannot merge AddUnique Op with the previous Op");
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            __op: "AddUnique",
            objects: (0, _encode3.default)(this._value, false, true)
          };
        }
      }]);
      return AddUniqueOp2;
    }(Op);
    exports.AddUniqueOp = AddUniqueOp;
    var RemoveOp = function(_Op6) {
      (0, _inherits2.default)(RemoveOp2, _Op6);
      var _super6 = _createSuper(RemoveOp2);
      function RemoveOp2(value) {
        var _this5;
        (0, _classCallCheck2.default)(this, RemoveOp2);
        _this5 = _super6.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "_value", void 0);
        _this5._value = (0, _unique.default)((0, _isArray.default)(value) ? value : [value]);
        return _this5;
      }
      (0, _createClass2.default)(RemoveOp2, [{
        key: "applyTo",
        value: function(value) {
          if (value == null) {
            return [];
          }
          if ((0, _isArray.default)(value)) {
            var removed = (0, _concat.default)(value).call(value, []);
            for (var i2 = 0; i2 < this._value.length; i2++) {
              var index = (0, _indexOf.default)(removed).call(removed, this._value[i2]);
              while (index > -1) {
                (0, _splice.default)(removed).call(removed, index, 1);
                index = (0, _indexOf.default)(removed).call(removed, this._value[i2]);
              }
              if (this._value[i2] instanceof _ParseObject.default && this._value[i2].id) {
                for (var j2 = 0; j2 < removed.length; j2++) {
                  if (removed[j2] instanceof _ParseObject.default && this._value[i2].id === removed[j2].id) {
                    (0, _splice.default)(removed).call(removed, j2, 1);
                    j2--;
                  }
                }
              }
            }
            return removed;
          }
          throw new Error("Cannot remove elements from a non-array value");
        }
      }, {
        key: "mergeWith",
        value: function(previous) {
          if (!previous) {
            return this;
          }
          if (previous instanceof SetOp) {
            return new SetOp(this.applyTo(previous._value));
          }
          if (previous instanceof UnsetOp) {
            return new UnsetOp();
          }
          if (previous instanceof RemoveOp2) {
            var _context2;
            var uniques = (0, _concat.default)(_context2 = previous._value).call(_context2, []);
            for (var i2 = 0; i2 < this._value.length; i2++) {
              if (this._value[i2] instanceof _ParseObject.default) {
                if (!(0, _arrayContainsObject.default)(uniques, this._value[i2])) {
                  uniques.push(this._value[i2]);
                }
              } else {
                if ((0, _indexOf.default)(uniques).call(uniques, this._value[i2]) < 0) {
                  uniques.push(this._value[i2]);
                }
              }
            }
            return new RemoveOp2(uniques);
          }
          throw new Error("Cannot merge Remove Op with the previous Op");
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            __op: "Remove",
            objects: (0, _encode3.default)(this._value, false, true)
          };
        }
      }]);
      return RemoveOp2;
    }(Op);
    exports.RemoveOp = RemoveOp;
    var RelationOp = function(_Op7) {
      (0, _inherits2.default)(RelationOp2, _Op7);
      var _super7 = _createSuper(RelationOp2);
      function RelationOp2(adds, removes) {
        var _this6;
        (0, _classCallCheck2.default)(this, RelationOp2);
        _this6 = _super7.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "_targetClassName", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "relationsToAdd", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "relationsToRemove", void 0);
        _this6._targetClassName = null;
        if ((0, _isArray.default)(adds)) {
          _this6.relationsToAdd = (0, _unique.default)((0, _map.default)(adds).call(adds, _this6._extractId, (0, _assertThisInitialized2.default)(_this6)));
        }
        if ((0, _isArray.default)(removes)) {
          _this6.relationsToRemove = (0, _unique.default)((0, _map.default)(removes).call(removes, _this6._extractId, (0, _assertThisInitialized2.default)(_this6)));
        }
        return _this6;
      }
      (0, _createClass2.default)(RelationOp2, [{
        key: "_extractId",
        value: function(obj) {
          if (typeof obj === "string") {
            return obj;
          }
          if (!obj.id) {
            throw new Error("You cannot add or remove an unsaved Parse Object from a relation");
          }
          if (!this._targetClassName) {
            this._targetClassName = obj.className;
          }
          if (this._targetClassName !== obj.className) {
            var _context3;
            throw new Error((0, _concat.default)(_context3 = "Tried to create a Relation with 2 different object types: ".concat(this._targetClassName, " and ")).call(_context3, obj.className, "."));
          }
          return obj.id;
        }
      }, {
        key: "applyTo",
        value: function(value, object, key2) {
          if (!value) {
            var _context4;
            if (!object || !key2) {
              throw new Error("Cannot apply a RelationOp without either a previous value, or an object and a key");
            }
            var parent = new _ParseObject.default(object.className);
            if (object.id && (0, _indexOf.default)(_context4 = object.id).call(_context4, "local") === 0) {
              parent._localId = object.id;
            } else if (object.id) {
              parent.id = object.id;
            }
            var relation = new _ParseRelation.default(parent, key2);
            relation.targetClassName = this._targetClassName;
            return relation;
          }
          if (value instanceof _ParseRelation.default) {
            if (this._targetClassName) {
              if (value.targetClassName) {
                if (this._targetClassName !== value.targetClassName) {
                  var _context5;
                  throw new Error((0, _concat.default)(_context5 = "Related object must be a ".concat(value.targetClassName, ", but a ")).call(_context5, this._targetClassName, " was passed in."));
                }
              } else {
                value.targetClassName = this._targetClassName;
              }
            }
            return value;
          }
          throw new Error("Relation cannot be applied to a non-relation field");
        }
      }, {
        key: "mergeWith",
        value: function(previous) {
          if (!previous) {
            return this;
          }
          if (previous instanceof UnsetOp) {
            throw new Error("You cannot modify a relation after deleting it.");
          }
          if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {
            return this;
          }
          if (previous instanceof RelationOp2) {
            var _context7, _context8, _context9, _context10, _context11, _context12;
            if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {
              var _context6;
              throw new Error((0, _concat.default)(_context6 = "Related object must be of class ".concat(previous._targetClassName, ", but ")).call(_context6, this._targetClassName || "null", " was passed in."));
            }
            var newAdd = (0, _concat.default)(_context7 = previous.relationsToAdd).call(_context7, []);
            (0, _forEach.default)(_context8 = this.relationsToRemove).call(_context8, function(r2) {
              var index = (0, _indexOf.default)(newAdd).call(newAdd, r2);
              if (index > -1) {
                (0, _splice.default)(newAdd).call(newAdd, index, 1);
              }
            });
            (0, _forEach.default)(_context9 = this.relationsToAdd).call(_context9, function(r2) {
              var index = (0, _indexOf.default)(newAdd).call(newAdd, r2);
              if (index < 0) {
                newAdd.push(r2);
              }
            });
            var newRemove = (0, _concat.default)(_context10 = previous.relationsToRemove).call(_context10, []);
            (0, _forEach.default)(_context11 = this.relationsToAdd).call(_context11, function(r2) {
              var index = (0, _indexOf.default)(newRemove).call(newRemove, r2);
              if (index > -1) {
                (0, _splice.default)(newRemove).call(newRemove, index, 1);
              }
            });
            (0, _forEach.default)(_context12 = this.relationsToRemove).call(_context12, function(r2) {
              var index = (0, _indexOf.default)(newRemove).call(newRemove, r2);
              if (index < 0) {
                newRemove.push(r2);
              }
            });
            var newRelation = new RelationOp2(newAdd, newRemove);
            newRelation._targetClassName = this._targetClassName;
            return newRelation;
          }
          throw new Error("Cannot merge Relation Op with the previous Op");
        }
      }, {
        key: "toJSON",
        value: function() {
          var _this7 = this;
          var idToPointer = function(id2) {
            return {
              __type: "Pointer",
              className: _this7._targetClassName,
              objectId: id2
            };
          };
          var adds = null;
          var removes = null;
          var pointers = null;
          if (this.relationsToAdd.length > 0) {
            var _context13;
            pointers = (0, _map.default)(_context13 = this.relationsToAdd).call(_context13, idToPointer);
            adds = {
              __op: "AddRelation",
              objects: pointers
            };
          }
          if (this.relationsToRemove.length > 0) {
            var _context14;
            pointers = (0, _map.default)(_context14 = this.relationsToRemove).call(_context14, idToPointer);
            removes = {
              __op: "RemoveRelation",
              objects: pointers
            };
          }
          if (adds && removes) {
            return {
              __op: "Batch",
              ops: [adds, removes]
            };
          }
          return adds || removes || {};
        }
      }]);
      return RelationOp2;
    }(Op);
    exports.RelationOp = RelationOp;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/arrayWithoutHoles.js"(exports, module) {
    var _Array$isArray = require_is_array8();
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(arr) {
      if (_Array$isArray(arr))
        return arrayLikeToArray(arr);
    }
    module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/iterableToArray.js"(exports, module) {
    var _Symbol = require_symbol6();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$from = require_from7();
    function _iterableToArray(iter) {
      if (typeof _Symbol !== "undefined" && _getIteratorMethod(iter) != null || iter["@@iterator"] != null)
        return _Array$from(iter);
    }
    module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/nonIterableSpread.js"(exports, module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/toConsumableArray.js"(exports, module) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }
    module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/es/array/virtual/keys.js
var require_keys4 = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/keys.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_object_to_string();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "keys");
  }
});

// node_modules/core-js-pure/stable/array/virtual/keys.js
var require_keys5 = __commonJS({
  "node_modules/core-js-pure/stable/array/virtual/keys.js"(exports, module) {
    "use strict";
    var parent = require_keys4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/stable/instance/keys.js
var require_keys6 = __commonJS({
  "node_modules/core-js-pure/stable/instance/keys.js"(exports, module) {
    "use strict";
    require_web_dom_collections_iterator();
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_keys5();
    var ArrayPrototype = Array.prototype;
    var DOMIterables = {
      DOMTokenList: true,
      NodeList: true
    };
    module.exports = function(it) {
      var own = it.keys;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.keys || hasOwn(DOMIterables, classof(it)) ? method : own;
    };
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/keys.js
var require_keys7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/keys.js"(exports, module) {
    module.exports = require_keys6();
  }
});

// node_modules/core-js-pure/internals/array-sort.js
var require_array_sort = __commonJS({
  "node_modules/core-js-pure/internals/array-sort.js"(exports, module) {
    "use strict";
    var arraySlice = require_array_slice();
    var floor = Math.floor;
    var sort = function(array, comparefn) {
      var length = array.length;
      if (length < 8) {
        var i2 = 1;
        var element, j2;
        while (i2 < length) {
          j2 = i2;
          element = array[i2];
          while (j2 && comparefn(array[j2 - 1], element) > 0) {
            array[j2] = array[--j2];
          }
          if (j2 !== i2++)
            array[j2] = element;
        }
      } else {
        var middle = floor(length / 2);
        var left = sort(arraySlice(array, 0, middle), comparefn);
        var right = sort(arraySlice(array, middle), comparefn);
        var llength = left.length;
        var rlength = right.length;
        var lindex = 0;
        var rindex = 0;
        while (lindex < llength || rindex < rlength) {
          array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
        }
      }
      return array;
    };
    module.exports = sort;
  }
});

// node_modules/core-js-pure/internals/engine-ff-version.js
var require_engine_ff_version = __commonJS({
  "node_modules/core-js-pure/internals/engine-ff-version.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    var firefox = userAgent.match(/firefox\/(\d+)/i);
    module.exports = !!firefox && +firefox[1];
  }
});

// node_modules/core-js-pure/internals/engine-is-ie-or-edge.js
var require_engine_is_ie_or_edge = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-ie-or-edge.js"(exports, module) {
    "use strict";
    var UA = require_engine_user_agent();
    module.exports = /MSIE|Trident/.test(UA);
  }
});

// node_modules/core-js-pure/internals/engine-webkit-version.js
var require_engine_webkit_version = __commonJS({
  "node_modules/core-js-pure/internals/engine-webkit-version.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
    module.exports = !!webkit && +webkit[1];
  }
});

// node_modules/core-js-pure/modules/es.array.sort.js
var require_es_array_sort = __commonJS({
  "node_modules/core-js-pure/modules/es.array.sort.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var deletePropertyOrThrow = require_delete_property_or_throw();
    var toString2 = require_to_string();
    var fails = require_fails();
    var internalSort = require_array_sort();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var FF = require_engine_ff_version();
    var IE_OR_EDGE = require_engine_is_ie_or_edge();
    var V8 = require_engine_v8_version();
    var WEBKIT = require_engine_webkit_version();
    var test = [];
    var nativeSort = uncurryThis(test.sort);
    var push = uncurryThis(test.push);
    var FAILS_ON_UNDEFINED = fails(function() {
      test.sort(void 0);
    });
    var FAILS_ON_NULL = fails(function() {
      test.sort(null);
    });
    var STRICT_METHOD = arrayMethodIsStrict("sort");
    var STABLE_SORT = !fails(function() {
      if (V8)
        return V8 < 70;
      if (FF && FF > 3)
        return;
      if (IE_OR_EDGE)
        return true;
      if (WEBKIT)
        return WEBKIT < 603;
      var result = "";
      var code, chr, value, index;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index = 0; index < 47; index++) {
          test.push({ k: chr + index, v: value });
        }
      }
      test.sort(function(a2, b2) {
        return b2.v - a2.v;
      });
      for (index = 0; index < test.length; index++) {
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr)
          result += chr;
      }
      return result !== "DGBEFHACIJK";
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function(comparefn) {
      return function(x2, y2) {
        if (y2 === void 0)
          return -1;
        if (x2 === void 0)
          return 1;
        if (comparefn !== void 0)
          return +comparefn(x2, y2) || 0;
        return toString2(x2) > toString2(y2) ? 1 : -1;
      };
    };
    $({ target: "Array", proto: true, forced: FORCED }, {
      sort: function sort(comparefn) {
        if (comparefn !== void 0)
          aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT)
          return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index;
        for (index = 0; index < arrayLength; index++) {
          if (index in array)
            push(items, array[index]);
        }
        internalSort(items, getSortCompare(comparefn));
        itemsLength = lengthOfArrayLike(items);
        index = 0;
        while (index < itemsLength)
          array[index] = items[index++];
        while (index < arrayLength)
          deletePropertyOrThrow(array, index++);
        return array;
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/sort.js
var require_sort = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/sort.js"(exports, module) {
    "use strict";
    require_es_array_sort();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "sort");
  }
});

// node_modules/core-js-pure/es/instance/sort.js
var require_sort2 = __commonJS({
  "node_modules/core-js-pure/es/instance/sort.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_sort();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.sort;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.sort ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/sort.js
var require_sort3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/sort.js"(exports, module) {
    "use strict";
    var parent = require_sort2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/sort.js
var require_sort4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/sort.js"(exports, module) {
    module.exports = require_sort3();
  }
});

// node_modules/core-js-pure/internals/object-to-array.js
var require_object_to_array = __commonJS({
  "node_modules/core-js-pure/internals/object-to-array.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var objectGetPrototypeOf = require_object_get_prototype_of();
    var objectKeys = require_object_keys();
    var toIndexedObject = require_to_indexed_object();
    var $propertyIsEnumerable = require_object_property_is_enumerable().f;
    var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
    var push = uncurryThis([].push);
    var IE_BUG = DESCRIPTORS && fails(function() {
      var O2 = /* @__PURE__ */ Object.create(null);
      O2[2] = 2;
      return !propertyIsEnumerable(O2, 2);
    });
    var createMethod = function(TO_ENTRIES) {
      return function(it) {
        var O2 = toIndexedObject(it);
        var keys = objectKeys(O2);
        var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O2) === null;
        var length = keys.length;
        var i2 = 0;
        var result = [];
        var key2;
        while (length > i2) {
          key2 = keys[i2++];
          if (!DESCRIPTORS || (IE_WORKAROUND ? key2 in O2 : propertyIsEnumerable(O2, key2))) {
            push(result, TO_ENTRIES ? [key2, O2[key2]] : O2[key2]);
          }
        }
        return result;
      };
    };
    module.exports = {
      // `Object.entries` method
      // https://tc39.es/ecma262/#sec-object.entries
      entries: createMethod(true),
      // `Object.values` method
      // https://tc39.es/ecma262/#sec-object.values
      values: createMethod(false)
    };
  }
});

// node_modules/core-js-pure/modules/es.object.entries.js
var require_es_object_entries = __commonJS({
  "node_modules/core-js-pure/modules/es.object.entries.js"() {
    "use strict";
    var $ = require_export();
    var $entries = require_object_to_array().entries;
    $({ target: "Object", stat: true }, {
      entries: function entries(O2) {
        return $entries(O2);
      }
    });
  }
});

// node_modules/core-js-pure/es/object/entries.js
var require_entries = __commonJS({
  "node_modules/core-js-pure/es/object/entries.js"(exports, module) {
    "use strict";
    require_es_object_entries();
    var path = require_path();
    module.exports = path.Object.entries;
  }
});

// node_modules/core-js-pure/stable/object/entries.js
var require_entries2 = __commonJS({
  "node_modules/core-js-pure/stable/object/entries.js"(exports, module) {
    "use strict";
    var parent = require_entries();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/entries.js
var require_entries3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/entries.js"(exports, module) {
    module.exports = require_entries2();
  }
});

// node_modules/moralis-v1/lib/browser/promiseUtils.js
var require_promiseUtils = __commonJS({
  "node_modules/moralis-v1/lib/browser/promiseUtils.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.continueWhile = continueWhile;
    exports.resolvingPromise = resolvingPromise;
    exports.when = when;
    var _promise = _interopRequireDefault(require_promise3());
    var _isArray = _interopRequireDefault(require_is_array4());
    function resolvingPromise() {
      var res;
      var rej;
      var promise = new _promise.default(function(resolve, reject) {
        res = resolve;
        rej = reject;
      });
      promise.resolve = res;
      promise.reject = rej;
      return promise;
    }
    function when(promises) {
      var objects;
      var arrayArgument = (0, _isArray.default)(promises);
      if (arrayArgument) {
        objects = promises;
      } else {
        objects = arguments;
      }
      var total = objects.length;
      var hadError = false;
      var results = [];
      var returnValue = arrayArgument ? [results] : results;
      var errors = [];
      results.length = objects.length;
      errors.length = objects.length;
      if (total === 0) {
        return _promise.default.resolve(returnValue);
      }
      var promise = new resolvingPromise();
      var resolveOne = function() {
        total--;
        if (total <= 0) {
          if (hadError) {
            promise.reject(errors);
          } else {
            promise.resolve(returnValue);
          }
        }
      };
      var chain = function(object, index) {
        if (object && typeof object.then === "function") {
          object.then(function(result) {
            results[index] = result;
            resolveOne();
          }, function(error) {
            errors[index] = error;
            hadError = true;
            resolveOne();
          });
        } else {
          results[index] = object;
          resolveOne();
        }
      };
      for (var i2 = 0; i2 < objects.length; i2++) {
        chain(objects[i2], i2);
      }
      return promise;
    }
    function continueWhile(test, emitter) {
      if (test()) {
        return emitter().then(function() {
          return continueWhile(test, emitter);
        });
      }
      return _promise.default.resolve();
    }
  }
});

// node_modules/moralis-v1/lib/browser/equals.js
var require_equals = __commonJS({
  "node_modules/moralis-v1/lib/browser/equals.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = equals;
    var _isArray = _interopRequireDefault(require_is_array4());
    var _keys = _interopRequireDefault(require_keys3());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _ParseGeoPoint = _interopRequireDefault(require_ParseGeoPoint());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    function equals(a2, b2) {
      var toString2 = Object.prototype.toString;
      if (toString2.call(a2) === "[object Date]" || toString2.call(b2) === "[object Date]") {
        var dateA = new Date(a2);
        var dateB = new Date(b2);
        return +dateA === +dateB;
      }
      if ((0, _typeof2.default)(a2) !== (0, _typeof2.default)(b2)) {
        return false;
      }
      if (!a2 || (0, _typeof2.default)(a2) !== "object") {
        return a2 === b2;
      }
      if ((0, _isArray.default)(a2) || (0, _isArray.default)(b2)) {
        if (!(0, _isArray.default)(a2) || !(0, _isArray.default)(b2)) {
          return false;
        }
        if (a2.length !== b2.length) {
          return false;
        }
        for (var i2 = a2.length; i2--; ) {
          if (!equals(a2[i2], b2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (a2 instanceof _ParseACL.default || a2 instanceof _ParseFile.default || a2 instanceof _ParseGeoPoint.default || a2 instanceof _ParseObject.default) {
        return a2.equals(b2);
      }
      if (b2 instanceof _ParseObject.default) {
        if (a2.__type === "Object" || a2.__type === "Pointer") {
          return a2.objectId === b2.id && a2.className === b2.className;
        }
      }
      if ((0, _keys.default)(a2).length !== (0, _keys.default)(b2).length) {
        return false;
      }
      for (var k2 in a2) {
        if (!equals(a2[k2], b2[k2])) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/moralis-v1/lib/browser/OfflineQuery.js
var require_OfflineQuery = __commonJS({
  "node_modules/moralis-v1/lib/browser/OfflineQuery.js"(exports, module) {
    "use strict";
    var _sliceInstanceProperty2 = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray2 = require_is_array4();
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _slice = _interopRequireDefault(require_slice4());
    var _filter = _interopRequireDefault(require_filter4());
    var _map = _interopRequireDefault(require_map10());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _keys = _interopRequireDefault(require_keys3());
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray2(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context5;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty2(_context5 = Object.prototype.toString.call(o2)).call(_context5, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var equalObjects = require_equals().default;
    var decode3 = require_decode().default;
    var ParseError = require_ParseError().default;
    var ParsePolygon = require_ParsePolygon().default;
    var ParseGeoPoint = require_ParseGeoPoint().default;
    function contains(haystack, needle) {
      if (needle && needle.__type && (needle.__type === "Pointer" || needle.__type === "Object")) {
        for (var i2 in haystack) {
          var ptr = haystack[i2];
          if (typeof ptr === "string" && ptr === needle.objectId) {
            return true;
          }
          if (ptr.className === needle.className && ptr.objectId === needle.objectId) {
            return true;
          }
        }
        return false;
      }
      return (0, _indexOf.default)(haystack).call(haystack, needle) > -1;
    }
    function transformObject(object) {
      if (object._toFullJSON) {
        return object._toFullJSON();
      }
      return object;
    }
    function matchesQuery(className, object, objects, query) {
      if (object.className !== className) {
        return false;
      }
      var obj = object;
      var q2 = query;
      if (object.toJSON) {
        obj = object.toJSON();
      }
      if (query.toJSON) {
        q2 = query.toJSON().where;
      }
      obj.className = className;
      for (var field in q2) {
        if (!matchesKeyConstraints(className, obj, objects, field, q2[field])) {
          return false;
        }
      }
      return true;
    }
    function equalObjectsGeneric(obj, compareTo, eqlFn) {
      if ((0, _isArray.default)(obj)) {
        for (var i2 = 0; i2 < obj.length; i2++) {
          if (eqlFn(obj[i2], compareTo)) {
            return true;
          }
        }
        return false;
      }
      return eqlFn(obj, compareTo);
    }
    function matchesKeyConstraints(className, object, objects, key2, constraints) {
      if (constraints === null) {
        return false;
      }
      if ((0, _indexOf.default)(key2).call(key2, ".") >= 0) {
        var keyComponents = key2.split(".");
        var subObjectKey = keyComponents[0];
        var keyRemainder = (0, _slice.default)(keyComponents).call(keyComponents, 1).join(".");
        return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);
      }
      var i2;
      if (key2 === "$or") {
        for (i2 = 0; i2 < constraints.length; i2++) {
          if (matchesQuery(className, object, objects, constraints[i2])) {
            return true;
          }
        }
        return false;
      }
      if (key2 === "$and") {
        for (i2 = 0; i2 < constraints.length; i2++) {
          if (!matchesQuery(className, object, objects, constraints[i2])) {
            return false;
          }
        }
        return true;
      }
      if (key2 === "$nor") {
        for (i2 = 0; i2 < constraints.length; i2++) {
          if (matchesQuery(className, object, objects, constraints[i2])) {
            return false;
          }
        }
        return true;
      }
      if (key2 === "$relatedTo") {
        return false;
      }
      if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key2)) {
        throw new ParseError(ParseError.INVALID_KEY_NAME, "Invalid Key: ".concat(key2));
      }
      if ((0, _typeof2.default)(constraints) !== "object") {
        if ((0, _isArray.default)(object[key2])) {
          var _context;
          return (0, _indexOf.default)(_context = object[key2]).call(_context, constraints) > -1;
        }
        return object[key2] === constraints;
      }
      var compareTo;
      if (constraints.__type) {
        if (constraints.__type === "Pointer") {
          return equalObjectsGeneric(object[key2], constraints, function(obj, ptr) {
            return typeof obj !== "undefined" && ptr.className === obj.className && ptr.objectId === obj.objectId;
          });
        }
        return equalObjectsGeneric(decode3(object[key2]), decode3(constraints), equalObjects);
      }
      for (var condition in constraints) {
        compareTo = constraints[condition];
        if (compareTo.__type) {
          compareTo = decode3(compareTo);
        }
        if (toString.call(compareTo) === "[object Date]" || typeof compareTo === "string" && new Date(compareTo) !== "Invalid Date" && !isNaN(new Date(compareTo))) {
          object[key2] = new Date(object[key2].iso ? object[key2].iso : object[key2]);
        }
        switch (condition) {
          case "$lt":
            if (object[key2] >= compareTo) {
              return false;
            }
            break;
          case "$lte":
            if (object[key2] > compareTo) {
              return false;
            }
            break;
          case "$gt":
            if (object[key2] <= compareTo) {
              return false;
            }
            break;
          case "$gte":
            if (object[key2] < compareTo) {
              return false;
            }
            break;
          case "$ne":
            if (equalObjects(object[key2], compareTo)) {
              return false;
            }
            break;
          case "$in":
            if (!contains(compareTo, object[key2])) {
              return false;
            }
            break;
          case "$nin":
            if (contains(compareTo, object[key2])) {
              return false;
            }
            break;
          case "$all":
            for (i2 = 0; i2 < compareTo.length; i2++) {
              var _context2;
              if ((0, _indexOf.default)(_context2 = object[key2]).call(_context2, compareTo[i2]) < 0) {
                return false;
              }
            }
            break;
          case "$exists": {
            var propertyExists = typeof object[key2] !== "undefined";
            var existenceIsRequired = constraints.$exists;
            if (typeof constraints.$exists !== "boolean") {
              break;
            }
            if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {
              return false;
            }
            break;
          }
          case "$regex": {
            if ((0, _typeof2.default)(compareTo) === "object") {
              return compareTo.test(object[key2]);
            }
            var expString = "";
            var escapeEnd = -2;
            var escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, "\\Q");
            while (escapeStart > -1) {
              expString += compareTo.substring(escapeEnd + 2, escapeStart);
              escapeEnd = (0, _indexOf.default)(compareTo).call(compareTo, "\\E", escapeStart);
              if (escapeEnd > -1) {
                expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\E/g, "\\E").replace(/\W/g, "\\$&");
              }
              escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, "\\Q", escapeEnd);
            }
            expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));
            var modifiers = constraints.$options || "";
            modifiers = modifiers.replace("x", "").replace("s", "");
            var exp = new RegExp(expString, modifiers);
            if (!exp.test(object[key2])) {
              return false;
            }
            break;
          }
          case "$nearSphere": {
            if (!compareTo || !object[key2]) {
              return false;
            }
            var distance = compareTo.radiansTo(object[key2]);
            var max = constraints.$maxDistance || Infinity;
            return distance <= max;
          }
          case "$within": {
            if (!compareTo || !object[key2]) {
              return false;
            }
            var southWest = compareTo.$box[0];
            var northEast = compareTo.$box[1];
            if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {
              return false;
            }
            return object[key2].latitude > southWest.latitude && object[key2].latitude < northEast.latitude && object[key2].longitude > southWest.longitude && object[key2].longitude < northEast.longitude;
          }
          case "$options":
            break;
          case "$maxDistance":
            break;
          case "$select": {
            var subQueryObjects = (0, _filter.default)(objects).call(objects, function(obj, index, arr) {
              return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);
            });
            for (var _i = 0; _i < subQueryObjects.length; _i += 1) {
              var subObject = transformObject(subQueryObjects[_i]);
              return equalObjects(object[key2], subObject[compareTo.key]);
            }
            return false;
          }
          case "$dontSelect": {
            var _subQueryObjects = (0, _filter.default)(objects).call(objects, function(obj, index, arr) {
              return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);
            });
            for (var _i2 = 0; _i2 < _subQueryObjects.length; _i2 += 1) {
              var _subObject = transformObject(_subQueryObjects[_i2]);
              return !equalObjects(object[key2], _subObject[compareTo.key]);
            }
            return false;
          }
          case "$inQuery": {
            var _subQueryObjects2 = (0, _filter.default)(objects).call(objects, function(obj, index, arr) {
              return matchesQuery(compareTo.className, obj, arr, compareTo.where);
            });
            for (var _i3 = 0; _i3 < _subQueryObjects2.length; _i3 += 1) {
              var _subObject2 = transformObject(_subQueryObjects2[_i3]);
              if (object[key2].className === _subObject2.className && object[key2].objectId === _subObject2.objectId) {
                return true;
              }
            }
            return false;
          }
          case "$notInQuery": {
            var _subQueryObjects3 = (0, _filter.default)(objects).call(objects, function(obj, index, arr) {
              return matchesQuery(compareTo.className, obj, arr, compareTo.where);
            });
            for (var _i4 = 0; _i4 < _subQueryObjects3.length; _i4 += 1) {
              var _subObject3 = transformObject(_subQueryObjects3[_i4]);
              if (object[key2].className === _subObject3.className && object[key2].objectId === _subObject3.objectId) {
                return false;
              }
            }
            return true;
          }
          case "$containedBy": {
            var _iterator = _createForOfIteratorHelper(object[key2]), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var value = _step.value;
                if (!contains(compareTo, value)) {
                  return false;
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            return true;
          }
          case "$geoWithin": {
            var _context3;
            var points = (0, _map.default)(_context3 = compareTo.$polygon).call(_context3, function(geoPoint) {
              return [geoPoint.latitude, geoPoint.longitude];
            });
            var polygon = new ParsePolygon(points);
            return polygon.containsPoint(object[key2]);
          }
          case "$geoIntersects": {
            var _polygon = new ParsePolygon(object[key2].coordinates);
            var point3 = new ParseGeoPoint(compareTo.$point);
            return _polygon.containsPoint(point3);
          }
          default:
            return false;
        }
      }
      return true;
    }
    function validateQuery(query) {
      var _context4;
      var q2 = query;
      if (query.toJSON) {
        q2 = query.toJSON().where;
      }
      var specialQuerykeys = ["$and", "$or", "$nor", "_rperm", "_wperm", "_perishable_token", "_email_verify_token", "_email_verify_token_expires_at", "_account_lockout_expires_at", "_failed_login_count"];
      (0, _forEach.default)(_context4 = (0, _keys.default)(q2)).call(_context4, function(key2) {
        if (q2 && q2[key2] && q2[key2].$regex) {
          if (typeof q2[key2].$options === "string") {
            if (!q2[key2].$options.match(/^[imxs]+$/)) {
              throw new ParseError(ParseError.INVALID_QUERY, "Bad $options value for query: ".concat(q2[key2].$options));
            }
          }
        }
        if ((0, _indexOf.default)(specialQuerykeys).call(specialQuerykeys, key2) < 0 && !key2.match(/^[a-zA-Z][a-zA-Z0-9_.]*$/)) {
          throw new ParseError(ParseError.INVALID_KEY_NAME, "Invalid key name: ".concat(key2));
        }
      });
    }
    var OfflineQuery = {
      matchesQuery,
      validateQuery
    };
    module.exports = OfflineQuery;
  }
});

// node_modules/moralis-v1/lib/browser/LocalDatastoreUtils.js
var require_LocalDatastoreUtils = __commonJS({
  "node_modules/moralis-v1/lib/browser/LocalDatastoreUtils.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PIN_PREFIX = exports.OBJECT_PREFIX = exports.DEFAULT_PIN = void 0;
    exports.isLocalDatastoreKey = isLocalDatastoreKey;
    var _startsWith = _interopRequireDefault(require_starts_with4());
    var DEFAULT_PIN = "_default";
    exports.DEFAULT_PIN = DEFAULT_PIN;
    var PIN_PREFIX = "parsePin_";
    exports.PIN_PREFIX = PIN_PREFIX;
    var OBJECT_PREFIX = "Parse_LDS_";
    exports.OBJECT_PREFIX = OBJECT_PREFIX;
    function isLocalDatastoreKey(key2) {
      return !!(key2 && (key2 === DEFAULT_PIN || (0, _startsWith.default)(key2).call(key2, PIN_PREFIX) || (0, _startsWith.default)(key2).call(key2, OBJECT_PREFIX)));
    }
  }
});

// node_modules/moralis-v1/lib/browser/ParseQuery.js
var require_ParseQuery = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseQuery.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _keys = _interopRequireDefault(require_keys3());
    var _slice = _interopRequireDefault(require_slice4());
    var _map2 = _interopRequireDefault(require_map10());
    var _filter2 = _interopRequireDefault(require_filter4());
    var _keys2 = _interopRequireDefault(require_keys7());
    var _concat = _interopRequireDefault(require_concat4());
    var _includes = _interopRequireDefault(require_includes5());
    var _sort = _interopRequireDefault(require_sort4());
    var _splice = _interopRequireDefault(require_splice4());
    var _promise = _interopRequireDefault(require_promise3());
    var _find = _interopRequireDefault(require_find4());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _entries = _interopRequireDefault(require_entries3());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _encode3 = _interopRequireDefault(require_encode());
    var _promiseUtils = require_promiseUtils();
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _ParseGeoPoint = _interopRequireDefault(require_ParseGeoPoint());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _OfflineQuery = _interopRequireDefault(require_OfflineQuery());
    var _LocalDatastoreUtils = require_LocalDatastoreUtils();
    function quote(s2) {
      return "\\Q".concat(s2.replace("\\E", "\\E\\\\E\\Q"), "\\E");
    }
    function _getClassNameFromQueries(queries) {
      var className = null;
      (0, _forEach.default)(queries).call(queries, function(q2) {
        if (!className) {
          className = q2.className;
        }
        if (className !== q2.className) {
          throw new Error("All queries must be for the same class.");
        }
      });
      return className;
    }
    function handleSelectResult(data, select) {
      var serverDataMask = {};
      (0, _forEach.default)(select).call(select, function(field) {
        var hasSubObjectSelect = (0, _indexOf.default)(field).call(field, ".") !== -1;
        if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {
          data[field] = void 0;
        } else if (hasSubObjectSelect) {
          var pathComponents = field.split(".");
          var _obj = data;
          var serverMask = serverDataMask;
          (0, _forEach.default)(pathComponents).call(pathComponents, function(component, index, arr) {
            if (_obj && !_obj.hasOwnProperty(component)) {
              _obj[component] = void 0;
            }
            if (_obj && (0, _typeof2.default)(_obj) === "object") {
              _obj = _obj[component];
            }
            if (index < arr.length - 1) {
              if (!serverMask[component]) {
                serverMask[component] = {};
              }
              serverMask = serverMask[component];
            }
          });
        }
      });
      if ((0, _keys.default)(serverDataMask).length > 0) {
        var serverData = _CoreManager.default.getObjectStateController().getServerData({
          id: data.objectId,
          className: data.className
        });
        copyMissingDataWithMask(serverData, data, serverDataMask, false);
      }
    }
    function copyMissingDataWithMask(src, dest, mask, copyThisLevel) {
      if (copyThisLevel) {
        for (var _key in src) {
          if (src.hasOwnProperty(_key) && !dest.hasOwnProperty(_key)) {
            dest[_key] = src[_key];
          }
        }
      }
      for (var _key2 in mask) {
        if (dest[_key2] !== void 0 && dest[_key2] !== null && src !== void 0 && src !== null) {
          copyMissingDataWithMask(src[_key2], dest[_key2], mask[_key2], true);
        }
      }
    }
    function handleOfflineSort(a2, b2, sorts) {
      var order = sorts[0];
      var operator = (0, _slice.default)(order).call(order, 0, 1);
      var isDescending = operator === "-";
      if (isDescending) {
        order = order.substring(1);
      }
      if (order === "_created_at") {
        order = "createdAt";
      }
      if (order === "_updated_at") {
        order = "updatedAt";
      }
      if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === "password") {
        throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, "Invalid Key: ".concat(order));
      }
      var field1 = a2.get(order);
      var field2 = b2.get(order);
      if (field1 < field2) {
        return isDescending ? 1 : -1;
      }
      if (field1 > field2) {
        return isDescending ? -1 : 1;
      }
      if (sorts.length > 1) {
        var remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);
        return handleOfflineSort(a2, b2, remainingSorts);
      }
      return 0;
    }
    var ParseQuery = function() {
      function ParseQuery2(objectClass) {
        (0, _classCallCheck2.default)(this, ParseQuery2);
        (0, _defineProperty2.default)(this, "className", void 0);
        (0, _defineProperty2.default)(this, "_where", void 0);
        (0, _defineProperty2.default)(this, "_include", void 0);
        (0, _defineProperty2.default)(this, "_exclude", void 0);
        (0, _defineProperty2.default)(this, "_select", void 0);
        (0, _defineProperty2.default)(this, "_limit", void 0);
        (0, _defineProperty2.default)(this, "_skip", void 0);
        (0, _defineProperty2.default)(this, "_count", void 0);
        (0, _defineProperty2.default)(this, "_order", void 0);
        (0, _defineProperty2.default)(this, "_readPreference", void 0);
        (0, _defineProperty2.default)(this, "_includeReadPreference", void 0);
        (0, _defineProperty2.default)(this, "_subqueryReadPreference", void 0);
        (0, _defineProperty2.default)(this, "_queriesLocalDatastore", void 0);
        (0, _defineProperty2.default)(this, "_localDatastorePinName", void 0);
        (0, _defineProperty2.default)(this, "_extraOptions", void 0);
        (0, _defineProperty2.default)(this, "_hint", void 0);
        (0, _defineProperty2.default)(this, "_explain", void 0);
        (0, _defineProperty2.default)(this, "_xhrRequest", void 0);
        if (typeof objectClass === "string") {
          if (objectClass === "User" && _CoreManager.default.get("PERFORM_USER_REWRITE")) {
            this.className = "_User";
          } else {
            this.className = objectClass;
          }
        } else if (objectClass instanceof _ParseObject.default) {
          this.className = objectClass.className;
        } else if (typeof objectClass === "function") {
          if (typeof objectClass.className === "string") {
            this.className = objectClass.className;
          } else {
            var _obj2 = new objectClass();
            this.className = _obj2.className;
          }
        } else {
          throw new TypeError("A ParseQuery must be constructed with a ParseObject or class name.");
        }
        this._where = {};
        this._include = [];
        this._exclude = [];
        this._count = false;
        this._limit = -1;
        this._skip = 0;
        this._readPreference = null;
        this._includeReadPreference = null;
        this._subqueryReadPreference = null;
        this._queriesLocalDatastore = false;
        this._localDatastorePinName = null;
        this._extraOptions = {};
        this._xhrRequest = {
          task: null,
          onchange: function() {
          }
        };
      }
      (0, _createClass2.default)(ParseQuery2, [{
        key: "_orQuery",
        value: function(queries) {
          var queryJSON = (0, _map2.default)(queries).call(queries, function(q2) {
            return q2.toJSON().where;
          });
          this._where.$or = queryJSON;
          return this;
        }
        /**
         * Adds constraint that all of the passed in queries match.
         *
         * @param {Array} queries
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "_andQuery",
        value: function(queries) {
          var queryJSON = (0, _map2.default)(queries).call(queries, function(q2) {
            return q2.toJSON().where;
          });
          this._where.$and = queryJSON;
          return this;
        }
        /**
         * Adds constraint that none of the passed in queries match.
         *
         * @param {Array} queries
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "_norQuery",
        value: function(queries) {
          var queryJSON = (0, _map2.default)(queries).call(queries, function(q2) {
            return q2.toJSON().where;
          });
          this._where.$nor = queryJSON;
          return this;
        }
        /**
         * Helper for condition queries
         *
         * @param key
         * @param condition
         * @param value
         * @returns {Parse.Query}
         */
      }, {
        key: "_addCondition",
        value: function(key2, condition, value) {
          if (!this._where[key2] || typeof this._where[key2] === "string") {
            this._where[key2] = {};
          }
          this._where[key2][condition] = (0, _encode3.default)(value, false, true);
          return this;
        }
        /**
         * Converts string for regular expression at the beginning
         *
         * @param string
         * @returns {string}
         */
      }, {
        key: "_regexStartWith",
        value: function(string) {
          return "^".concat(quote(string));
        }
      }, {
        key: "_handleOfflineQuery",
        value: function() {
          var _handleOfflineQuery2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(params) {
            var _context, _this2 = this;
            var localDatastore, objects, results, keys, alwaysSelectedKeys, sorts, count, limit;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _OfflineQuery.default.validateQuery(this);
                    localDatastore = _CoreManager.default.getLocalDatastore();
                    _context3.next = 4;
                    return localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);
                  case 4:
                    objects = _context3.sent;
                    results = (0, _filter2.default)(_context = (0, _map2.default)(objects).call(objects, function(json, index, arr) {
                      var object = _ParseObject.default.fromJSON(json, false);
                      if (json._localId && !json.objectId) {
                        object._localId = json._localId;
                      }
                      if (!_OfflineQuery.default.matchesQuery(_this2.className, object, arr, _this2)) {
                        return null;
                      }
                      return object;
                    })).call(_context, function(object) {
                      return object !== null;
                    });
                    if ((0, _keys2.default)(params)) {
                      keys = (0, _keys2.default)(params).split(",");
                      alwaysSelectedKeys = ["className", "objectId", "createdAt", "updatedAt", "ACL"];
                      keys = (0, _concat.default)(keys).call(keys, alwaysSelectedKeys);
                      results = (0, _map2.default)(results).call(results, function(object) {
                        var _context2;
                        var json = object._toFullJSON();
                        (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, function(key2) {
                          if (!(0, _includes.default)(keys).call(keys, key2)) {
                            delete json[key2];
                          }
                        });
                        return _ParseObject.default.fromJSON(json, false);
                      });
                    }
                    if (params.order) {
                      sorts = params.order.split(",");
                      (0, _sort.default)(results).call(results, function(a2, b2) {
                        return handleOfflineSort(a2, b2, sorts);
                      });
                    }
                    if (params.count) {
                      count = results.length;
                    }
                    if (params.skip) {
                      if (params.skip >= results.length) {
                        results = [];
                      } else {
                        results = (0, _splice.default)(results).call(results, params.skip, results.length);
                      }
                    }
                    limit = results.length;
                    if (params.limit !== 0 && params.limit < results.length) {
                      limit = params.limit;
                    }
                    results = (0, _splice.default)(results).call(results, 0, limit);
                    if (!(typeof count === "number")) {
                      _context3.next = 15;
                      break;
                    }
                    return _context3.abrupt("return", {
                      results,
                      count
                    });
                  case 15:
                    return _context3.abrupt("return", results);
                  case 16:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _handleOfflineQuery2.apply(this, arguments);
          };
        }()
        /**
         * Returns a JSON representation of this query.
         *
         * @returns {object} The JSON representation of the query.
         */
      }, {
        key: "toJSON",
        value: function() {
          var params = {
            where: this._where
          };
          if (this._include.length) {
            params.include = this._include.join(",");
          }
          if (this._exclude.length) {
            params.excludeKeys = this._exclude.join(",");
          }
          if (this._select) {
            params.keys = this._select.join(",");
          }
          if (this._count) {
            params.count = 1;
          }
          if (this._limit >= 0) {
            params.limit = this._limit;
          }
          if (this._skip > 0) {
            params.skip = this._skip;
          }
          if (this._order) {
            params.order = this._order.join(",");
          }
          if (this._readPreference) {
            params.readPreference = this._readPreference;
          }
          if (this._includeReadPreference) {
            params.includeReadPreference = this._includeReadPreference;
          }
          if (this._subqueryReadPreference) {
            params.subqueryReadPreference = this._subqueryReadPreference;
          }
          if (this._hint) {
            params.hint = this._hint;
          }
          if (this._explain) {
            params.explain = true;
          }
          for (var _key3 in this._extraOptions) {
            params[_key3] = this._extraOptions[_key3];
          }
          return params;
        }
        /**
         * Return a query with conditions from json, can be useful to send query from server side to client
         * Not static, all query conditions was set before calling this method will be deleted.
         * For example on the server side we have
         * var query = new Parse.Query("className");
         * query.equalTo(key: value);
         * query.limit(100);
         * ... (others queries)
         * Create JSON representation of Query Object
         * var jsonFromServer = query.fromJSON();
         *
         * On client side getting query:
         * var query = new Parse.Query("className");
         * query.fromJSON(jsonFromServer);
         *
         * and continue to query...
         * query.skip(100).find().then(...);
         *
         * @param {QueryJSON} json from Parse.Query.toJSON() method
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withJSON",
        value: function(json) {
          if (json.where) {
            this._where = json.where;
          }
          if (json.include) {
            this._include = json.include.split(",");
          }
          if ((0, _keys2.default)(json)) {
            this._select = (0, _keys2.default)(json).split(",");
          }
          if (json.excludeKeys) {
            this._exclude = json.excludeKeys.split(",");
          }
          if (json.count) {
            this._count = json.count === 1;
          }
          if (json.limit) {
            this._limit = json.limit;
          }
          if (json.skip) {
            this._skip = json.skip;
          }
          if (json.order) {
            this._order = json.order.split(",");
          }
          if (json.readPreference) {
            this._readPreference = json.readPreference;
          }
          if (json.includeReadPreference) {
            this._includeReadPreference = json.includeReadPreference;
          }
          if (json.subqueryReadPreference) {
            this._subqueryReadPreference = json.subqueryReadPreference;
          }
          if (json.hint) {
            this._hint = json.hint;
          }
          if (json.explain) {
            this._explain = !!json.explain;
          }
          for (var _key4 in json) {
            if (json.hasOwnProperty(_key4)) {
              var _context4;
              if ((0, _indexOf.default)(_context4 = ["where", "include", "keys", "count", "limit", "skip", "order", "readPreference", "includeReadPreference", "subqueryReadPreference", "hint", "explain"]).call(_context4, _key4) === -1) {
                this._extraOptions[_key4] = json[_key4];
              }
            }
          }
          return this;
        }
        /**
         * Static method to restore Parse.Query by json representation
         * Internally calling Parse.Query.withJSON
         *
         * @param {string} className
         * @param {QueryJSON} json from Parse.Query.toJSON() method
         * @returns {Parse.Query} new created query
         */
      }, {
        key: "get",
        value: (
          /**
           * Constructs a Parse.Object whose id is already known by fetching data from
           * the server. Unlike the <code>first</code> method, it never returns undefined.
           *
           * @param {string} objectId The id of the object to be fetched.
           * @param {object} options
           * Valid options are:<ul>
           *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
           *     be used for this request.
           *   <li>sessionToken: A valid session token, used for making a request on
           *       behalf of a specific user.
           *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.
           * </ul>
           *
           * @returns {Promise} A promise that is resolved with the result when
           * the query completes.
           */
          function(objectId, options) {
            this.equalTo("objectId", objectId);
            var firstOptions = {};
            if (options && options.hasOwnProperty("useMasterKey")) {
              firstOptions.useMasterKey = options.useMasterKey;
            }
            if (options && options.hasOwnProperty("sessionToken")) {
              firstOptions.sessionToken = options.sessionToken;
            }
            if (options && options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
              firstOptions.context = options.context;
            }
            return this.first(firstOptions).then(function(response) {
              if (response) {
                return response;
              }
              var errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, "Object not found.");
              return _promise.default.reject(errorObject);
            });
          }
        )
        /**
         * Retrieves a list of ParseObjects that satisfy this query.
         *
         * @param {object} options Valid options
         * are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.
         * </ul>
         *
         * @returns {Promise} A promise that is resolved with the results when
         * the query completes.
         */
      }, {
        key: "find",
        value: function(options) {
          var _this3 = this;
          options = options || {};
          var findOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            findOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            findOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            findOptions.context = options.context;
          }
          this._setRequestTask(findOptions);
          var controller = _CoreManager.default.getQueryController();
          var select = this._select;
          if (this._queriesLocalDatastore) {
            return this._handleOfflineQuery(this.toJSON());
          }
          return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(function(response) {
            var _context5;
            if (_this3._explain) {
              return response.results;
            }
            var results = (0, _map2.default)(_context5 = response.results).call(_context5, function(data) {
              var override = response.className || _this3.className;
              if (!data.className) {
                data.className = override;
              }
              if (select) {
                handleSelectResult(data, select);
              }
              return _ParseObject.default.fromJSON(data, !select);
            });
            var count = response.count;
            if (typeof count === "number") {
              return {
                results,
                count
              };
            }
            return results;
          });
        }
        /**
         * Retrieves a complete list of ParseObjects that satisfy this query.
         * Using `eachBatch` under the hood to fetch all the valid objects.
         *
         * @param {object} options Valid options are:<ul>
         *   <li>batchSize: How many objects to yield in each batch (default: 100)
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise} A promise that is resolved with the results when
         * the query completes.
         */
      }, {
        key: "findAll",
        value: function() {
          var _findAll = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(options) {
            var result;
            return _regenerator.default.wrap(function(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    result = [];
                    _context7.next = 3;
                    return this.eachBatch(function(objects) {
                      var _context6;
                      result = (0, _concat.default)(_context6 = []).call(_context6, (0, _toConsumableArray2.default)(result), (0, _toConsumableArray2.default)(objects));
                    }, options);
                  case 3:
                    return _context7.abrupt("return", result);
                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _findAll.apply(this, arguments);
          };
        }()
        /**
         * Counts the number of objects that match this query.
         *
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         *
         * @returns {Promise} A promise that is resolved with the count when
         * the query completes.
         */
      }, {
        key: "count",
        value: function(options) {
          options = options || {};
          var findOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            findOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            findOptions.sessionToken = options.sessionToken;
          }
          this._setRequestTask(findOptions);
          var controller = _CoreManager.default.getQueryController();
          var params = this.toJSON();
          params.limit = 0;
          params.count = 1;
          return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(function(result) {
            return result.count;
          });
        }
        /**
         * Executes a distinct query and returns unique values
         *
         * @param {string} key A field to find distinct values
         * @param {object} options
         * Valid options are:<ul>
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         *
         * @returns {Promise} A promise that is resolved with the query completes.
         */
      }, {
        key: "distinct",
        value: function(key2, options) {
          options = options || {};
          var distinctOptions = {};
          distinctOptions.useMasterKey = true;
          if (options.hasOwnProperty("sessionToken")) {
            distinctOptions.sessionToken = options.sessionToken;
          }
          this._setRequestTask(distinctOptions);
          var controller = _CoreManager.default.getQueryController();
          var params = {
            distinct: key2,
            where: this._where,
            hint: this._hint
          };
          return controller.aggregate(this.className, params, distinctOptions).then(function(results) {
            return results.results;
          });
        }
        /**
         * Executes an aggregate query and returns aggregate results
         *
         * @param {(Array|object)} pipeline Array or Object of stages to process query
         * @param {object} options Valid options are:<ul>
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         *
         * @returns {Promise} A promise that is resolved with the query completes.
         */
      }, {
        key: "aggregate",
        value: function(pipeline, options) {
          options = options || {};
          var aggregateOptions = {};
          aggregateOptions.useMasterKey = true;
          if (options.hasOwnProperty("sessionToken")) {
            aggregateOptions.sessionToken = options.sessionToken;
          }
          this._setRequestTask(aggregateOptions);
          var controller = _CoreManager.default.getQueryController();
          if (!(0, _isArray.default)(pipeline) && (0, _typeof2.default)(pipeline) !== "object") {
            throw new Error("Invalid pipeline must be Array or Object");
          }
          if ((0, _keys.default)(this._where || {}).length) {
            if (!(0, _isArray.default)(pipeline)) {
              pipeline = [pipeline];
            }
            pipeline.unshift({
              match: this._where
            });
          }
          var params = {
            pipeline,
            hint: this._hint,
            explain: this._explain,
            readPreference: this._readPreference
          };
          return controller.aggregate(this.className, params, aggregateOptions).then(function(results) {
            return results.results;
          });
        }
        /**
         * Retrieves at most one Parse.Object that satisfies this query.
         *
         * Returns the object if there is one, otherwise undefined.
         *
         * @param {object} options Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.
         * </ul>
         *
         * @returns {Promise} A promise that is resolved with the object when
         * the query completes.
         */
      }, {
        key: "first",
        value: function(options) {
          var _this4 = this;
          options = options || {};
          var findOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            findOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            findOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            findOptions.context = options.context;
          }
          this._setRequestTask(findOptions);
          var controller = _CoreManager.default.getQueryController();
          var params = this.toJSON();
          params.limit = 1;
          var select = this._select;
          if (this._queriesLocalDatastore) {
            return this._handleOfflineQuery(params).then(function(objects) {
              if (!objects[0]) {
                return void 0;
              }
              return objects[0];
            });
          }
          return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(function(response) {
            var objects = response.results;
            if (!objects[0]) {
              return void 0;
            }
            if (!objects[0].className) {
              objects[0].className = _this4.className;
            }
            if (select) {
              handleSelectResult(objects[0], select);
            }
            return _ParseObject.default.fromJSON(objects[0], !select);
          });
        }
        /**
         * Iterates over objects matching a query, calling a callback for each batch.
         * If the callback returns a promise, the iteration will not continue until
         * that promise has been fulfilled. If the callback returns a rejected
         * promise, then iteration will stop with that error. The items are processed
         * in an unspecified order. The query may not have any sort order, and may
         * not use limit or skip.
         *
         * @param {Function} callback Callback that will be called with each result
         *     of the query.
         * @param {object} options Valid options are:<ul>
         *   <li>batchSize: How many objects to yield in each batch (default: 100)
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.
         * </ul>
         * @returns {Promise} A promise that will be fulfilled once the
         *     iteration has completed.
         */
      }, {
        key: "eachBatch",
        value: function(callback, options) {
          var _context8;
          options = options || {};
          if (this._order || this._skip || this._limit >= 0) {
            return _promise.default.reject("Cannot iterate on a query with sort, skip, or limit.");
          }
          var query = new ParseQuery2(this.className);
          query._limit = options.batchSize || 100;
          query._include = (0, _map2.default)(_context8 = this._include).call(_context8, function(i2) {
            return i2;
          });
          if (this._select) {
            var _context9;
            query._select = (0, _map2.default)(_context9 = this._select).call(_context9, function(s2) {
              return s2;
            });
          }
          query._hint = this._hint;
          query._where = {};
          for (var _attr in this._where) {
            var val = this._where[_attr];
            if ((0, _isArray.default)(val)) {
              query._where[_attr] = (0, _map2.default)(val).call(val, function(v2) {
                return v2;
              });
            } else if (val && (0, _typeof2.default)(val) === "object") {
              var conditionMap = {};
              query._where[_attr] = conditionMap;
              for (var cond in val) {
                conditionMap[cond] = val[cond];
              }
            } else {
              query._where[_attr] = val;
            }
          }
          query.ascending("objectId");
          var findOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            findOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            findOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            findOptions.context = options.context;
          }
          var finished = false;
          var previousResults = [];
          return (0, _promiseUtils.continueWhile)(function() {
            return !finished;
          }, (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
            var _yield$Promise$all, _yield$Promise$all2, results;
            return _regenerator.default.wrap(function(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);
                  case 2:
                    _yield$Promise$all = _context10.sent;
                    _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 1);
                    results = _yield$Promise$all2[0];
                    if (!(results.length >= query._limit)) {
                      _context10.next = 10;
                      break;
                    }
                    query.greaterThan("objectId", results[results.length - 1].id);
                    previousResults = results;
                    _context10.next = 17;
                    break;
                  case 10:
                    if (!(results.length > 0)) {
                      _context10.next = 16;
                      break;
                    }
                    _context10.next = 13;
                    return _promise.default.resolve(callback(results));
                  case 13:
                    finished = true;
                    _context10.next = 17;
                    break;
                  case 16:
                    finished = true;
                  case 17:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee3);
          })));
        }
        /**
         * Iterates over each result of a query, calling a callback for each one. If
         * the callback returns a promise, the iteration will not continue until
         * that promise has been fulfilled. If the callback returns a rejected
         * promise, then iteration will stop with that error. The items are
         * processed in an unspecified order. The query may not have any sort order,
         * and may not use limit or skip.
         *
         * @param {Function} callback Callback that will be called with each result
         *     of the query.
         * @param {object} options Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise} A promise that will be fulfilled once the
         *     iteration has completed.
         */
      }, {
        key: "each",
        value: function(callback, options) {
          return this.eachBatch(function(results) {
            var callbacksDone = _promise.default.resolve();
            (0, _forEach.default)(results).call(results, function(result) {
              callbacksDone = callbacksDone.then(function() {
                return callback(result);
              });
            });
            return callbacksDone;
          }, options);
        }
        /**
         * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)
         *
         * @param {(string|object)} value String or Object of index that should be used when executing query
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "hint",
        value: function(value) {
          if (typeof value === "undefined") {
            delete this._hint;
          }
          this._hint = value;
          return this;
        }
        /**
         * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)
         *
         * @param {boolean} explain Used to toggle the information on the query plan.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "explain",
        value: function() {
          var _explain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (typeof _explain !== "boolean") {
            throw new Error("You can only set explain to a boolean value");
          }
          this._explain = _explain;
          return this;
        }
        /**
         * Iterates over each result of a query, calling a callback for each one. If
         * the callback returns a promise, the iteration will not continue until
         * that promise has been fulfilled. If the callback returns a rejected
         * promise, then iteration will stop with that error. The items are
         * processed in an unspecified order. The query may not have any sort order,
         * and may not use limit or skip.
         *
         * @param {Function} callback Callback <ul>
         *   <li>currentObject: The current Parse.Object being processed in the array.</li>
         *   <li>index: The index of the current Parse.Object being processed in the array.</li>
         *   <li>query: The query map was called upon.</li>
         * </ul>
         *
         * @param {object} options Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise} A promise that will be fulfilled once the
         *     iteration has completed.
         */
      }, {
        key: "map",
        value: function() {
          var _map = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(callback, options) {
            var _this5 = this;
            var array, index;
            return _regenerator.default.wrap(function(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    array = [];
                    index = 0;
                    _context11.next = 4;
                    return this.each(function(object) {
                      return _promise.default.resolve(callback(object, index, _this5)).then(function(result) {
                        array.push(result);
                        index += 1;
                      });
                    }, options);
                  case 4:
                    return _context11.abrupt("return", array);
                  case 5:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee4, this);
          }));
          return function() {
            return _map.apply(this, arguments);
          };
        }()
        /**
         * Iterates over each result of a query, calling a callback for each one. If
         * the callback returns a promise, the iteration will not continue until
         * that promise has been fulfilled. If the callback returns a rejected
         * promise, then iteration will stop with that error. The items are
         * processed in an unspecified order. The query may not have any sort order,
         * and may not use limit or skip.
         *
         * @param {Function} callback Callback <ul>
         *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>
         *   <li>currentObject: The current Parse.Object being processed in the array.</li>
         *   <li>index: The index of the current Parse.Object being processed in the array.</li>
         * </ul>
         * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.
         * @param {object} options Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise} A promise that will be fulfilled once the
         *     iteration has completed.
         */
      }, {
        key: "reduce",
        value: function() {
          var _reduce = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(callback, initialValue, options) {
            var accumulator, index;
            return _regenerator.default.wrap(function(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    accumulator = initialValue;
                    index = 0;
                    _context12.next = 4;
                    return this.each(function(object) {
                      if (index === 0 && initialValue === void 0) {
                        accumulator = object;
                        index += 1;
                        return;
                      }
                      return _promise.default.resolve(callback(accumulator, object, index)).then(function(result) {
                        accumulator = result;
                        index += 1;
                      });
                    }, options);
                  case 4:
                    if (!(index === 0 && initialValue === void 0)) {
                      _context12.next = 6;
                      break;
                    }
                    throw new TypeError("Reducing empty query result set with no initial value");
                  case 6:
                    return _context12.abrupt("return", accumulator);
                  case 7:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee5, this);
          }));
          return function() {
            return _reduce.apply(this, arguments);
          };
        }()
        /**
         * Iterates over each result of a query, calling a callback for each one. If
         * the callback returns a promise, the iteration will not continue until
         * that promise has been fulfilled. If the callback returns a rejected
         * promise, then iteration will stop with that error. The items are
         * processed in an unspecified order. The query may not have any sort order,
         * and may not use limit or skip.
         *
         * @param {Function} callback Callback <ul>
         *   <li>currentObject: The current Parse.Object being processed in the array.</li>
         *   <li>index: The index of the current Parse.Object being processed in the array.</li>
         *   <li>query: The query filter was called upon.</li>
         * </ul>
         *
         * @param {object} options Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise} A promise that will be fulfilled once the
         *     iteration has completed.
         */
      }, {
        key: "filter",
        value: function() {
          var _filter = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(callback, options) {
            var _this6 = this;
            var array, index;
            return _regenerator.default.wrap(function(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    array = [];
                    index = 0;
                    _context13.next = 4;
                    return this.each(function(object) {
                      return _promise.default.resolve(callback(object, index, _this6)).then(function(flag) {
                        if (flag) {
                          array.push(object);
                        }
                        index += 1;
                      });
                    }, options);
                  case 4:
                    return _context13.abrupt("return", array);
                  case 5:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee6, this);
          }));
          return function() {
            return _filter.apply(this, arguments);
          };
        }()
        /** Query Conditions * */
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be equal to the provided value.
         *
         * @param {string} key The key to check.
         * @param value The value that the Parse.Object must contain.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "equalTo",
        value: function(key2, value) {
          var _this7 = this;
          if (key2 && (0, _typeof2.default)(key2) === "object") {
            var _context14;
            (0, _forEach.default)(_context14 = (0, _entries.default)(key2)).call(_context14, function(_ref2) {
              var _ref3 = (0, _slicedToArray2.default)(_ref2, 2), k2 = _ref3[0], val = _ref3[1];
              return _this7.equalTo(k2, val);
            });
            return this;
          }
          if (typeof value === "undefined") {
            return this.doesNotExist(key2);
          }
          this._where[key2] = (0, _encode3.default)(value, false, true);
          return this;
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be not equal to the provided value.
         *
         * @param {string} key The key to check.
         * @param value The value that must not be equalled.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "notEqualTo",
        value: function(key2, value) {
          var _this8 = this;
          if (key2 && (0, _typeof2.default)(key2) === "object") {
            var _context15;
            (0, _forEach.default)(_context15 = (0, _entries.default)(key2)).call(_context15, function(_ref4) {
              var _ref5 = (0, _slicedToArray2.default)(_ref4, 2), k2 = _ref5[0], val = _ref5[1];
              return _this8.notEqualTo(k2, val);
            });
            return this;
          }
          return this._addCondition(key2, "$ne", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be less than the provided value.
         *
         * @param {string} key The key to check.
         * @param value The value that provides an upper bound.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "lessThan",
        value: function(key2, value) {
          return this._addCondition(key2, "$lt", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be greater than the provided value.
         *
         * @param {string} key The key to check.
         * @param value The value that provides an lower bound.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "greaterThan",
        value: function(key2, value) {
          return this._addCondition(key2, "$gt", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be less than or equal to the provided value.
         *
         * @param {string} key The key to check.
         * @param value The value that provides an upper bound.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "lessThanOrEqualTo",
        value: function(key2, value) {
          return this._addCondition(key2, "$lte", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be greater than or equal to the provided value.
         *
         * @param {string} key The key to check.
         * @param {*} value The value that provides an lower bound.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "greaterThanOrEqualTo",
        value: function(key2, value) {
          return this._addCondition(key2, "$gte", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be contained in the provided list of values.
         *
         * @param {string} key The key to check.
         * @param {*} value The values that will match.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "containedIn",
        value: function(key2, value) {
          return this._addCondition(key2, "$in", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * not be contained in the provided list of values.
         *
         * @param {string} key The key to check.
         * @param {*} value The values that will not match.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "notContainedIn",
        value: function(key2, value) {
          return this._addCondition(key2, "$nin", value);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * be contained by the provided list of values. Get objects where all array elements match.
         *
         * @param {string} key The key to check.
         * @param {Array} values The values that will match.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "containedBy",
        value: function(key2, values) {
          return this._addCondition(key2, "$containedBy", values);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * contain each one of the provided list of values.
         *
         * @param {string} key The key to check.  This key's value must be an array.
         * @param {Array} values The values that will match.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "containsAll",
        value: function(key2, values) {
          return this._addCondition(key2, "$all", values);
        }
        /**
         * Adds a constraint to the query that requires a particular key's value to
         * contain each one of the provided list of values starting with given strings.
         *
         * @param {string} key The key to check.  This key's value must be an array.
         * @param {Array<string>} values The string values that will match as starting string.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "containsAllStartingWith",
        value: function(key2, values) {
          var _this = this;
          if (!(0, _isArray.default)(values)) {
            values = [values];
          }
          var regexObject = (0, _map2.default)(values).call(values, function(value) {
            return {
              $regex: _this._regexStartWith(value)
            };
          });
          return this.containsAll(key2, regexObject);
        }
        /**
         * Adds a constraint for finding objects that contain the given key.
         *
         * @param {string} key The key that should exist.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "exists",
        value: function(key2) {
          return this._addCondition(key2, "$exists", true);
        }
        /**
         * Adds a constraint for finding objects that do not contain a given key.
         *
         * @param {string} key The key that should not exist
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "doesNotExist",
        value: function(key2) {
          return this._addCondition(key2, "$exists", false);
        }
        /**
         * Adds a regular expression constraint for finding string values that match
         * the provided regular expression.
         * This may be slow for large datasets.
         *
         * @param {string} key The key that the string to match is stored in.
         * @param {RegExp} regex The regular expression pattern to match.
         * @param {string} modifiers The regular expression mode.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "matches",
        value: function(key2, regex, modifiers) {
          this._addCondition(key2, "$regex", regex);
          if (!modifiers) {
            modifiers = "";
          }
          if (regex.ignoreCase) {
            modifiers += "i";
          }
          if (regex.multiline) {
            modifiers += "m";
          }
          if (modifiers.length) {
            this._addCondition(key2, "$options", modifiers);
          }
          return this;
        }
        /**
         * Adds a constraint that requires that a key's value matches a Parse.Query
         * constraint.
         *
         * @param {string} key The key that the contains the object to match the
         *                     query.
         * @param {Parse.Query} query The query that should match.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "matchesQuery",
        value: function(key2, query) {
          var queryJSON = query.toJSON();
          queryJSON.className = query.className;
          return this._addCondition(key2, "$inQuery", queryJSON);
        }
        /**
         * Adds a constraint that requires that a key's value not matches a
         * Parse.Query constraint.
         *
         * @param {string} key The key that the contains the object to match the
         *                     query.
         * @param {Parse.Query} query The query that should not match.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "doesNotMatchQuery",
        value: function(key2, query) {
          var queryJSON = query.toJSON();
          queryJSON.className = query.className;
          return this._addCondition(key2, "$notInQuery", queryJSON);
        }
        /**
         * Adds a constraint that requires that a key's value matches a value in
         * an object returned by a different Parse.Query.
         *
         * @param {string} key The key that contains the value that is being
         *                     matched.
         * @param {string} queryKey The key in the objects returned by the query to
         *                          match against.
         * @param {Parse.Query} query The query to run.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "matchesKeyInQuery",
        value: function(key2, queryKey, query) {
          var queryJSON = query.toJSON();
          queryJSON.className = query.className;
          return this._addCondition(key2, "$select", {
            key: queryKey,
            query: queryJSON
          });
        }
        /**
         * Adds a constraint that requires that a key's value not match a value in
         * an object returned by a different Parse.Query.
         *
         * @param {string} key The key that contains the value that is being
         *                     excluded.
         * @param {string} queryKey The key in the objects returned by the query to
         *                          match against.
         * @param {Parse.Query} query The query to run.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "doesNotMatchKeyInQuery",
        value: function(key2, queryKey, query) {
          var queryJSON = query.toJSON();
          queryJSON.className = query.className;
          return this._addCondition(key2, "$dontSelect", {
            key: queryKey,
            query: queryJSON
          });
        }
        /**
         * Adds a constraint for finding string values that contain a provided
         * string.  This may be slow for large datasets.
         *
         * @param {string} key The key that the string to match is stored in.
         * @param {string} substring The substring that the value must contain.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "contains",
        value: function(key2, substring) {
          if (typeof substring !== "string") {
            throw new Error("The value being searched for must be a string.");
          }
          return this._addCondition(key2, "$regex", quote(substring));
        }
        /**
         * Adds a constraint for finding string values that contain a provided
         * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0
         *
         * In order to sort you must use select and ascending ($score is required)
         *  <pre>
         *   query.fullText('field', 'term');
         *   query.ascending('$score');
         *   query.select('$score');
         *  </pre>
         *
         * To retrieve the weight / rank
         *  <pre>
         *   object->get('score');
         *  </pre>
         *
         * You can define optionals by providing an object as a third parameter
         *  <pre>
         *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });
         *  </pre>
         *
         * @param {string} key The key that the string to match is stored in.
         * @param {string} value The string to search
         * @param {object} options (Optional)
         * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.
         * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.
         * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "fullText",
        value: function(key2, value, options) {
          options = options || {};
          if (!key2) {
            throw new Error("A key is required.");
          }
          if (!value) {
            throw new Error("A search term is required");
          }
          if (typeof value !== "string") {
            throw new Error("The value being searched for must be a string.");
          }
          var fullOptions = {};
          fullOptions.$term = value;
          for (var option in options) {
            switch (option) {
              case "language":
                fullOptions.$language = options[option];
                break;
              case "caseSensitive":
                fullOptions.$caseSensitive = options[option];
                break;
              case "diacriticSensitive":
                fullOptions.$diacriticSensitive = options[option];
                break;
              default:
                throw new Error("Unknown option: ".concat(option));
            }
          }
          return this._addCondition(key2, "$text", {
            $search: fullOptions
          });
        }
        /**
         * Method to sort the full text search by text score
         *
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "sortByTextScore",
        value: function() {
          this.ascending("$score");
          this.select(["$score"]);
          return this;
        }
        /**
         * Adds a constraint for finding string values that start with a provided
         * string.  This query will use the backend index, so it will be fast even
         * for large datasets.
         *
         * @param {string} key The key that the string to match is stored in.
         * @param {string} prefix The substring that the value must start with.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "startsWith",
        value: function(key2, prefix) {
          if (typeof prefix !== "string") {
            throw new Error("The value being searched for must be a string.");
          }
          return this._addCondition(key2, "$regex", this._regexStartWith(prefix));
        }
        /**
         * Adds a constraint for finding string values that end with a provided
         * string.  This will be slow for large datasets.
         *
         * @param {string} key The key that the string to match is stored in.
         * @param {string} suffix The substring that the value must end with.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "endsWith",
        value: function(key2, suffix) {
          if (typeof suffix !== "string") {
            throw new Error("The value being searched for must be a string.");
          }
          return this._addCondition(key2, "$regex", "".concat(quote(suffix), "$"));
        }
        /**
         * Adds a proximity based constraint for finding objects with key point
         * values near the point given.
         *
         * @param {string} key The key that the Parse.GeoPoint is stored in.
         * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "near",
        value: function(key2, point3) {
          if (!(point3 instanceof _ParseGeoPoint.default)) {
            point3 = new _ParseGeoPoint.default(point3);
          }
          return this._addCondition(key2, "$nearSphere", point3);
        }
        /**
         * Adds a proximity based constraint for finding objects with key point
         * values near the point given and within the maximum distance given.
         *
         * @param {string} key The key that the Parse.GeoPoint is stored in.
         * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.
         * @param {number} maxDistance Maximum distance (in radians) of results to return.
         * @param {boolean} sorted A Bool value that is true if results should be
         * sorted by distance ascending, false is no sorting is required,
         * defaults to true.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withinRadians",
        value: function(key2, point3, maxDistance, sorted) {
          if (sorted || sorted === void 0) {
            this.near(key2, point3);
            return this._addCondition(key2, "$maxDistance", maxDistance);
          }
          return this._addCondition(key2, "$geoWithin", {
            $centerSphere: [[point3.longitude, point3.latitude], maxDistance]
          });
        }
        /**
         * Adds a proximity based constraint for finding objects with key point
         * values near the point given and within the maximum distance given.
         * Radius of earth used is 3958.8 miles.
         *
         * @param {string} key The key that the Parse.GeoPoint is stored in.
         * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.
         * @param {number} maxDistance Maximum distance (in miles) of results to return.
         * @param {boolean} sorted A Bool value that is true if results should be
         * sorted by distance ascending, false is no sorting is required,
         * defaults to true.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withinMiles",
        value: function(key2, point3, maxDistance, sorted) {
          return this.withinRadians(key2, point3, maxDistance / 3958.8, sorted);
        }
        /**
         * Adds a proximity based constraint for finding objects with key point
         * values near the point given and within the maximum distance given.
         * Radius of earth used is 6371.0 kilometers.
         *
         * @param {string} key The key that the Parse.GeoPoint is stored in.
         * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.
         * @param {number} maxDistance Maximum distance (in kilometers) of results to return.
         * @param {boolean} sorted A Bool value that is true if results should be
         * sorted by distance ascending, false is no sorting is required,
         * defaults to true.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withinKilometers",
        value: function(key2, point3, maxDistance, sorted) {
          return this.withinRadians(key2, point3, maxDistance / 6371, sorted);
        }
        /**
         * Adds a constraint to the query that requires a particular key's
         * coordinates be contained within a given rectangular geographic bounding
         * box.
         *
         * @param {string} key The key to be constrained.
         * @param {Parse.GeoPoint} southwest
         *     The lower-left inclusive corner of the box.
         * @param {Parse.GeoPoint} northeast
         *     The upper-right inclusive corner of the box.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withinGeoBox",
        value: function(key2, southwest, northeast) {
          if (!(southwest instanceof _ParseGeoPoint.default)) {
            southwest = new _ParseGeoPoint.default(southwest);
          }
          if (!(northeast instanceof _ParseGeoPoint.default)) {
            northeast = new _ParseGeoPoint.default(northeast);
          }
          this._addCondition(key2, "$within", {
            $box: [southwest, northeast]
          });
          return this;
        }
        /**
         * Adds a constraint to the query that requires a particular key's
         * coordinates be contained within and on the bounds of a given polygon.
         * Supports closed and open (last point is connected to first) paths
         *
         * Polygon must have at least 3 points
         *
         * @param {string} key The key to be constrained.
         * @param {Array} points Array of Coordinates / GeoPoints
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withinPolygon",
        value: function(key2, points) {
          return this._addCondition(key2, "$geoWithin", {
            $polygon: points
          });
        }
        /**
         * Add a constraint to the query that requires a particular key's
         * coordinates that contains a ParseGeoPoint
         *
         * @param {string} key The key to be constrained.
         * @param {Parse.GeoPoint} point
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "polygonContains",
        value: function(key2, point3) {
          return this._addCondition(key2, "$geoIntersects", {
            $point: point3
          });
        }
        /** Query Orderings * */
        /**
         * Sorts the results in ascending order by the given key.
         *
         * @param {(string|string[])} keys The key to order by, which is a
         * string of comma separated values, or an Array of keys, or multiple keys.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "ascending",
        value: function() {
          this._order = [];
          for (var _len = arguments.length, keys = new Array(_len), _key5 = 0; _key5 < _len; _key5++) {
            keys[_key5] = arguments[_key5];
          }
          return this.addAscending.apply(this, keys);
        }
        /**
         * Sorts the results in ascending order by the given key,
         * but can also add secondary sort descriptors without overwriting _order.
         *
         * @param {(string|string[])} keys The key to order by, which is a
         * string of comma separated values, or an Array of keys, or multiple keys.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "addAscending",
        value: function() {
          var _this9 = this;
          if (!this._order) {
            this._order = [];
          }
          for (var _len2 = arguments.length, keys = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {
            keys[_key6] = arguments[_key6];
          }
          (0, _forEach.default)(keys).call(keys, function(key2) {
            var _context16;
            if ((0, _isArray.default)(key2)) {
              key2 = key2.join();
            }
            _this9._order = (0, _concat.default)(_context16 = _this9._order).call(_context16, key2.replace(/\s/g, "").split(","));
          });
          return this;
        }
        /**
         * Sorts the results in descending order by the given key.
         *
         * @param {(string|string[])} keys The key to order by, which is a
         * string of comma separated values, or an Array of keys, or multiple keys.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "descending",
        value: function() {
          this._order = [];
          for (var _len3 = arguments.length, keys = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {
            keys[_key7] = arguments[_key7];
          }
          return this.addDescending.apply(this, keys);
        }
        /**
         * Sorts the results in descending order by the given key,
         * but can also add secondary sort descriptors without overwriting _order.
         *
         * @param {(string|string[])} keys The key to order by, which is a
         * string of comma separated values, or an Array of keys, or multiple keys.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "addDescending",
        value: function() {
          var _this10 = this;
          if (!this._order) {
            this._order = [];
          }
          for (var _len4 = arguments.length, keys = new Array(_len4), _key8 = 0; _key8 < _len4; _key8++) {
            keys[_key8] = arguments[_key8];
          }
          (0, _forEach.default)(keys).call(keys, function(key2) {
            var _context17, _context18;
            if ((0, _isArray.default)(key2)) {
              key2 = key2.join();
            }
            _this10._order = (0, _concat.default)(_context17 = _this10._order).call(_context17, (0, _map2.default)(_context18 = key2.replace(/\s/g, "").split(",")).call(_context18, function(k2) {
              return "-".concat(k2);
            }));
          });
          return this;
        }
        /** Query Options * */
        /**
         * Sets the number of results to skip before returning any results.
         * This is useful for pagination.
         * Default is to skip zero results.
         *
         * @param {number} n the number of results to skip.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "skip",
        value: function(n2) {
          if (typeof n2 !== "number" || n2 < 0) {
            throw new Error("You can only skip by a positive number");
          }
          this._skip = n2;
          return this;
        }
        /**
         * Sets the limit of the number of results to return. The default limit is 100.
         *
         * @param {number} n the number of results to limit to.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "limit",
        value: function(n2) {
          if (typeof n2 !== "number") {
            throw new Error("You can only set the limit to a numeric value");
          }
          this._limit = n2;
          return this;
        }
        /**
         * Sets the flag to include with response the total number of objects satisfying this query,
         * despite limits/skip. Might be useful for pagination.
         * Note that result of this query will be wrapped as an object with
         * `results`: holding {ParseObject} array and `count`: integer holding total number
         *
         * @param {boolean} includeCount false - disable, true - enable.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "withCount",
        value: function() {
          var includeCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (typeof includeCount !== "boolean") {
            throw new Error("You can only set withCount to a boolean value");
          }
          this._count = includeCount;
          return this;
        }
        /**
         * Includes nested Parse.Objects for the provided key.  You can use dot
         * notation to specify which fields in the included object are also fetched.
         *
         * You can include all nested Parse.Objects by passing in '*'.
         * Requires Parse Server 3.0.0+
         * <pre>query.include('*');</pre>
         *
         * @param {...string|Array<string>} keys The name(s) of the key(s) to include.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "include",
        value: function() {
          var _this11 = this;
          for (var _len5 = arguments.length, keys = new Array(_len5), _key9 = 0; _key9 < _len5; _key9++) {
            keys[_key9] = arguments[_key9];
          }
          (0, _forEach.default)(keys).call(keys, function(key2) {
            if ((0, _isArray.default)(key2)) {
              var _context19;
              _this11._include = (0, _concat.default)(_context19 = _this11._include).call(_context19, key2);
            } else {
              _this11._include.push(key2);
            }
          });
          return this;
        }
        /**
         * Includes all nested Parse.Objects.
         *
         * Requires Parse Server 3.0.0+
         *
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "includeAll",
        value: function() {
          return this.include("*");
        }
        /**
         * Restricts the fields of the returned Parse.Objects to include only the
         * provided keys.  If this is called multiple times, then all of the keys
         * specified in each of the calls will be included.
         *
         * @param {...string|Array<string>} keys The name(s) of the key(s) to include.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "select",
        value: function() {
          var _this12 = this;
          if (!this._select) {
            this._select = [];
          }
          for (var _len6 = arguments.length, keys = new Array(_len6), _key10 = 0; _key10 < _len6; _key10++) {
            keys[_key10] = arguments[_key10];
          }
          (0, _forEach.default)(keys).call(keys, function(key2) {
            if ((0, _isArray.default)(key2)) {
              var _context20;
              _this12._select = (0, _concat.default)(_context20 = _this12._select).call(_context20, key2);
            } else {
              _this12._select.push(key2);
            }
          });
          return this;
        }
        /**
         * Restricts the fields of the returned Parse.Objects to all keys except the
         * provided keys. Exclude takes precedence over select and include.
         *
         * Requires Parse Server 3.6.0+
         *
         * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "exclude",
        value: function() {
          var _this13 = this;
          for (var _len7 = arguments.length, keys = new Array(_len7), _key11 = 0; _key11 < _len7; _key11++) {
            keys[_key11] = arguments[_key11];
          }
          (0, _forEach.default)(keys).call(keys, function(key2) {
            if ((0, _isArray.default)(key2)) {
              var _context21;
              _this13._exclude = (0, _concat.default)(_context21 = _this13._exclude).call(_context21, key2);
            } else {
              _this13._exclude.push(key2);
            }
          });
          return this;
        }
        /**
         * Changes the read preference that the backend will use when performing the query to the database.
         *
         * @param {string} readPreference The read preference for the main query.
         * @param {string} includeReadPreference The read preference for the queries to include pointers.
         * @param {string} subqueryReadPreference The read preference for the sub queries.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "readPreference",
        value: function(_readPreference, includeReadPreference, subqueryReadPreference) {
          this._readPreference = _readPreference;
          this._includeReadPreference = includeReadPreference;
          this._subqueryReadPreference = subqueryReadPreference;
          return this;
        }
      }, {
        key: "onChange",
        value: function(onUpdate, onError) {
          var sub = null;
          this.subscribe().then(function(subscription) {
            sub = subscription;
            subscription.on("create", function(object) {
              onUpdate(object);
            });
            subscription.on("update", function(object) {
              onUpdate(object);
            });
            subscription.on("error", function(err) {
              if (onError) {
                onError(err);
              } else {
                console.warn("Moralis: Subscription error", err);
              }
            });
          }).catch(function(err) {
            if (onError) {
              onError(err);
            } else {
              console.warn("Moralis: Subscription connection error", err);
            }
          });
          return function() {
            if (sub) {
              sub.unsubscribe();
            }
          };
        }
        /**
         * Subscribe this query to get liveQuery updates
         *
         * @param {string} sessionToken (optional) Defaults to the currentUser
         * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter
         * which can be used to get liveQuery updates.
         */
      }, {
        key: "subscribe",
        value: function() {
          var _subscribe = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7(sessionToken) {
            var currentUser, liveQueryClient, subscription;
            return _regenerator.default.wrap(function(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    _context22.next = 2;
                    return _CoreManager.default.getUserController().currentUserAsync();
                  case 2:
                    currentUser = _context22.sent;
                    if (!sessionToken) {
                      sessionToken = currentUser ? currentUser.getSessionToken() : void 0;
                    }
                    _context22.next = 6;
                    return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();
                  case 6:
                    liveQueryClient = _context22.sent;
                    if (liveQueryClient.shouldOpen()) {
                      liveQueryClient.open();
                    }
                    subscription = liveQueryClient.subscribe(this, sessionToken);
                    return _context22.abrupt("return", subscription.subscribePromise.then(function() {
                      return subscription;
                    }));
                  case 10:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee7, this);
          }));
          return function() {
            return _subscribe.apply(this, arguments);
          };
        }()
        /**
         * Constructs a Parse.Query that is the OR of the passed in queries.  For
         * example:
         * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>
         *
         * will create a compoundQuery that is an or of the query1, query2, and
         * query3.
         *
         * @param {...Parse.Query} queries The list of queries to OR.
         * @static
         * @returns {Parse.Query} The query that is the OR of the passed in queries.
         */
      }, {
        key: "fromNetwork",
        value: (
          /**
           * Change the source of this query to the server.
           *
           * @returns {Parse.Query} Returns the query, so you can chain this call.
           */
          function() {
            this._queriesLocalDatastore = false;
            this._localDatastorePinName = null;
            return this;
          }
        )
        /**
         * Changes the source of this query to all pinned objects.
         *
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "fromLocalDatastore",
        value: function() {
          return this.fromPinWithName(null);
        }
        /**
         * Changes the source of this query to the default group of pinned objects.
         *
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "fromPin",
        value: function() {
          return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);
        }
        /**
         * Changes the source of this query to a specific group of pinned objects.
         *
         * @param {string} name The name of query source.
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "fromPinWithName",
        value: function(name2) {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (localDatastore.checkIfEnabled()) {
            this._queriesLocalDatastore = true;
            this._localDatastorePinName = name2;
          }
          return this;
        }
        /**
         * Cancels the current network request (if any is running).
         *
         * @returns {Parse.Query} Returns the query, so you can chain this call.
         */
      }, {
        key: "cancel",
        value: function() {
          var _this14 = this;
          if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === "function") {
            this._xhrRequest.task._aborted = true;
            this._xhrRequest.task.abort();
            this._xhrRequest.task = null;
            this._xhrRequest.onchange = function() {
            };
            return this;
          }
          return this._xhrRequest.onchange = function() {
            return _this14.cancel();
          };
        }
      }, {
        key: "_setRequestTask",
        value: function(options) {
          var _this15 = this;
          options.requestTask = function(task) {
            _this15._xhrRequest.task = task;
            _this15._xhrRequest.onchange();
          };
        }
      }], [{
        key: "fromJSON",
        value: function(className, json) {
          var query = new ParseQuery2(className);
          return query.withJSON(json);
        }
      }, {
        key: "or",
        value: function() {
          for (var _len8 = arguments.length, queries = new Array(_len8), _key12 = 0; _key12 < _len8; _key12++) {
            queries[_key12] = arguments[_key12];
          }
          var className = _getClassNameFromQueries(queries);
          var query = new ParseQuery2(className);
          query._orQuery(queries);
          return query;
        }
        /**
         * Constructs a Parse.Query that is the AND of the passed in queries.  For
         * example:
         * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>
         *
         * will create a compoundQuery that is an and of the query1, query2, and
         * query3.
         *
         * @param {...Parse.Query} queries The list of queries to AND.
         * @static
         * @returns {Parse.Query} The query that is the AND of the passed in queries.
         */
      }, {
        key: "and",
        value: function() {
          for (var _len9 = arguments.length, queries = new Array(_len9), _key13 = 0; _key13 < _len9; _key13++) {
            queries[_key13] = arguments[_key13];
          }
          var className = _getClassNameFromQueries(queries);
          var query = new ParseQuery2(className);
          query._andQuery(queries);
          return query;
        }
        /**
         * Constructs a Parse.Query that is the NOR of the passed in queries.  For
         * example:
         * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>
         *
         * will create a compoundQuery that is a nor of the query1, query2, and
         * query3.
         *
         * @param {...Parse.Query} queries The list of queries to NOR.
         * @static
         * @returns {Parse.Query} The query that is the NOR of the passed in queries.
         */
      }, {
        key: "nor",
        value: function() {
          for (var _len10 = arguments.length, queries = new Array(_len10), _key14 = 0; _key14 < _len10; _key14++) {
            queries[_key14] = arguments[_key14];
          }
          var className = _getClassNameFromQueries(queries);
          var query = new ParseQuery2(className);
          query._norQuery(queries);
          return query;
        }
      }]);
      return ParseQuery2;
    }();
    var DefaultController = {
      find: function(className, params, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "classes/".concat(className), params, options);
      },
      aggregate: function(className, params, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "aggregate/".concat(className), params, options);
      }
    };
    _CoreManager.default.setQueryController(DefaultController);
    var _default = ParseQuery;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParseRelation.js
var require_ParseRelation = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseRelation.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isArray = _interopRequireDefault(require_is_array4());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _ParseOp = require_ParseOp();
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var ParseRelation = function() {
      function ParseRelation2(parent, key2) {
        (0, _classCallCheck2.default)(this, ParseRelation2);
        (0, _defineProperty2.default)(this, "parent", void 0);
        (0, _defineProperty2.default)(this, "key", void 0);
        (0, _defineProperty2.default)(this, "targetClassName", void 0);
        this.parent = parent;
        this.key = key2;
        this.targetClassName = null;
      }
      (0, _createClass2.default)(ParseRelation2, [{
        key: "_ensureParentAndKey",
        value: function(parent, key2) {
          this.key = this.key || key2;
          if (this.key !== key2) {
            throw new Error("Internal Error. Relation retrieved from two different keys.");
          }
          if (this.parent) {
            if (this.parent.className !== parent.className) {
              throw new Error("Internal Error. Relation retrieved from two different Objects.");
            }
            if (this.parent.id) {
              if (this.parent.id !== parent.id) {
                throw new Error("Internal Error. Relation retrieved from two different Objects.");
              }
            } else if (parent.id) {
              this.parent = parent;
            }
          } else {
            this.parent = parent;
          }
        }
        /**
         * Adds a Parse.Object or an array of Parse.Objects to the relation.
         *
         * @param {(Parse.Object|Array)} objects The item or items to add.
         * @returns {Parse.Object} The parent of the relation.
         */
      }, {
        key: "add",
        value: function(objects) {
          if (!(0, _isArray.default)(objects)) {
            objects = [objects];
          }
          var change = new _ParseOp.RelationOp(objects, []);
          var parent = this.parent;
          if (!parent) {
            throw new Error("Cannot add to a Relation without a parent");
          }
          if (objects.length === 0) {
            return parent;
          }
          parent.set(this.key, change);
          this.targetClassName = change._targetClassName;
          return parent;
        }
        /**
         * Removes a Parse.Object or an array of Parse.Objects from this relation.
         *
         * @param {(Parse.Object|Array)} objects The item or items to remove.
         */
      }, {
        key: "remove",
        value: function(objects) {
          if (!(0, _isArray.default)(objects)) {
            objects = [objects];
          }
          var change = new _ParseOp.RelationOp([], objects);
          if (!this.parent) {
            throw new Error("Cannot remove from a Relation without a parent");
          }
          if (objects.length === 0) {
            return;
          }
          this.parent.set(this.key, change);
          this.targetClassName = change._targetClassName;
        }
        /**
         * Returns a JSON version of the object suitable for saving to disk.
         *
         * @returns {object} JSON representation of Relation
         */
      }, {
        key: "toJSON",
        value: function() {
          return {
            __type: "Relation",
            className: this.targetClassName
          };
        }
        /**
         * Returns a Parse.Query that is limited to objects in this
         * relation.
         *
         * @returns {Parse.Query} Relation Query
         */
      }, {
        key: "query",
        value: function query() {
          var query2;
          var parent = this.parent;
          if (!parent) {
            throw new Error("Cannot construct a query for a Relation without a parent");
          }
          if (!this.targetClassName) {
            query2 = new _ParseQuery.default(parent.className);
            query2._extraOptions.redirectClassNameForKey = this.key;
          } else {
            query2 = new _ParseQuery.default(this.targetClassName);
          }
          query2._addCondition("$relatedTo", "object", {
            __type: "Pointer",
            className: parent.className,
            objectId: parent.id
          });
          query2._addCondition("$relatedTo", "key", this.key);
          return query2;
        }
      }]);
      return ParseRelation2;
    }();
    var _default = ParseRelation;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/canBeSerialized.js
var require_canBeSerialized = __commonJS({
  "node_modules/moralis-v1/lib/browser/canBeSerialized.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = canBeSerialized;
    var _isArray = _interopRequireDefault(require_is_array4());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    function canBeSerialized(obj) {
      if (!(obj instanceof _ParseObject.default)) {
        return true;
      }
      var attributes = obj.attributes;
      for (var attr in attributes) {
        var val = attributes[attr];
        if (!canBeSerializedHelper(val)) {
          return false;
        }
      }
      return true;
    }
    function canBeSerializedHelper(value) {
      if ((0, _typeof2.default)(value) !== "object") {
        return true;
      }
      if (value instanceof _ParseRelation.default) {
        return true;
      }
      if (value instanceof _ParseObject.default) {
        return !!value.id;
      }
      if (value instanceof _ParseFile.default) {
        if (value.url()) {
          return true;
        }
        return false;
      }
      if ((0, _isArray.default)(value)) {
        for (var i2 = 0; i2 < value.length; i2++) {
          if (!canBeSerializedHelper(value[i2])) {
            return false;
          }
        }
        return true;
      }
      for (var k2 in value) {
        if (!canBeSerializedHelper(value[k2])) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/moralis-v1/lib/browser/escape.js
var require_escape = __commonJS({
  "node_modules/moralis-v1/lib/browser/escape.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = escape2;
    var encoded = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "/": "&#x2F;",
      "'": "&#x27;",
      '"': "&quot;"
    };
    function escape2(str) {
      return str.replace(/[&<>/'"]/g, function(char) {
        return encoded[char];
      });
    }
  }
});

// node_modules/core-js-pure/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js-pure/internals/whitespaces.js"(exports, module) {
    "use strict";
    module.exports = "	\n\v\f\r                　\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js-pure/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js-pure/internals/string-trim.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString2 = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = function(TYPE) {
      return function($this) {
        var string = toString2(requireObjectCoercible($this));
        if (TYPE & 1)
          string = replace(string, ltrim, "");
        if (TYPE & 2)
          string = replace(string, rtrim, "$1");
        return string;
      };
    };
    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js-pure/internals/number-parse-int.js
var require_number_parse_int = __commonJS({
  "node_modules/core-js-pure/internals/number-parse-int.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var toString2 = require_to_string();
    var trim = require_string_trim().trim;
    var whitespaces = require_whitespaces();
    var $parseInt = global2.parseInt;
    var Symbol2 = global2.Symbol;
    var ITERATOR = Symbol2 && Symbol2.iterator;
    var hex = /^[+-]?0x/i;
    var exec = uncurryThis(hex.exec);
    var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
      $parseInt(Object(ITERATOR));
    });
    module.exports = FORCED ? function parseInt2(string, radix) {
      var S2 = trim(toString2(string));
      return $parseInt(S2, radix >>> 0 || (exec(hex, S2) ? 16 : 10));
    } : $parseInt;
  }
});

// node_modules/core-js-pure/modules/es.parse-int.js
var require_es_parse_int = __commonJS({
  "node_modules/core-js-pure/modules/es.parse-int.js"() {
    "use strict";
    var $ = require_export();
    var $parseInt = require_number_parse_int();
    $({ global: true, forced: parseInt !== $parseInt }, {
      parseInt: $parseInt
    });
  }
});

// node_modules/core-js-pure/es/parse-int.js
var require_parse_int = __commonJS({
  "node_modules/core-js-pure/es/parse-int.js"(exports, module) {
    "use strict";
    require_es_parse_int();
    var path = require_path();
    module.exports = path.parseInt;
  }
});

// node_modules/core-js-pure/stable/parse-int.js
var require_parse_int2 = __commonJS({
  "node_modules/core-js-pure/stable/parse-int.js"(exports, module) {
    "use strict";
    var parent = require_parse_int();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js
var require_parse_int3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js"(exports, module) {
    module.exports = require_parse_int2();
  }
});

// node_modules/moralis-v1/lib/browser/parseDate.js
var require_parseDate = __commonJS({
  "node_modules/moralis-v1/lib/browser/parseDate.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parseDate;
    var _parseInt2 = _interopRequireDefault(require_parse_int3());
    function parseDate(iso8601) {
      var regexp = new RegExp("^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$");
      var match = regexp.exec(iso8601);
      if (!match) {
        return null;
      }
      var year = (0, _parseInt2.default)(match[1]) || 0;
      var month = ((0, _parseInt2.default)(match[2]) || 1) - 1;
      var day = (0, _parseInt2.default)(match[3]) || 0;
      var hour = (0, _parseInt2.default)(match[4]) || 0;
      var minute = (0, _parseInt2.default)(match[5]) || 0;
      var second = (0, _parseInt2.default)(match[6]) || 0;
      var milli = (0, _parseInt2.default)(match[8]) || 0;
      return new Date(Date.UTC(year, month, day, hour, minute, second, milli));
    }
  }
});

// node_modules/moralis-v1/lib/browser/TaskQueue.js
var require_TaskQueue = __commonJS({
  "node_modules/moralis-v1/lib/browser/TaskQueue.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _promiseUtils = require_promiseUtils();
    var TaskQueue = function() {
      function TaskQueue2() {
        (0, _classCallCheck2.default)(this, TaskQueue2);
        (0, _defineProperty2.default)(this, "queue", void 0);
        this.queue = [];
      }
      (0, _createClass2.default)(TaskQueue2, [{
        key: "enqueue",
        value: function(task) {
          var _this = this;
          var taskComplete = new _promiseUtils.resolvingPromise();
          this.queue.push({
            task,
            _completion: taskComplete
          });
          if (this.queue.length === 1) {
            task().then(function() {
              _this._dequeue();
              taskComplete.resolve();
            }, function(error) {
              _this._dequeue();
              taskComplete.reject(error);
            });
          }
          return taskComplete;
        }
      }, {
        key: "_dequeue",
        value: function() {
          var _this2 = this;
          this.queue.shift();
          if (this.queue.length) {
            var next = this.queue[0];
            next.task().then(function() {
              _this2._dequeue();
              next._completion.resolve();
            }, function(error) {
              _this2._dequeue();
              next._completion.reject(error);
            });
          }
        }
      }]);
      return TaskQueue2;
    }();
    module.exports = TaskQueue;
  }
});

// node_modules/moralis-v1/lib/browser/ObjectStateMutations.js
var require_ObjectStateMutations = __commonJS({
  "node_modules/moralis-v1/lib/browser/ObjectStateMutations.js"(exports) {
    "use strict";
    var _Object$keys = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commitServerChanges = commitServerChanges;
    exports.defaultState = defaultState;
    exports.estimateAttribute = estimateAttribute;
    exports.estimateAttributes = estimateAttributes;
    exports.mergeFirstPendingState = mergeFirstPendingState;
    exports.popPendingState = popPendingState;
    exports.pushPendingState = pushPendingState;
    exports.setPendingOp = setPendingOp;
    exports.setServerData = setServerData;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _includes = _interopRequireDefault(require_includes5());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _encode3 = _interopRequireDefault(require_encode());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    var _TaskQueue = _interopRequireDefault(require_TaskQueue());
    var _ParseOp = require_ParseOp();
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context, _context2;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty(_context = ownKeys5(Object(source), true)).call(_context, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys5(Object(source))).call(_context2, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function defaultState() {
      return {
        serverData: {},
        pendingOps: [{}],
        objectCache: {},
        tasks: new _TaskQueue.default(),
        existed: false
      };
    }
    function setServerData(serverData, attributes) {
      for (var _attr in attributes) {
        if (typeof attributes[_attr] !== "undefined") {
          serverData[_attr] = attributes[_attr];
        } else {
          delete serverData[_attr];
        }
      }
    }
    function setPendingOp(pendingOps, attr, op) {
      var last = pendingOps.length - 1;
      if (op) {
        pendingOps[last][attr] = op;
      } else {
        delete pendingOps[last][attr];
      }
    }
    function pushPendingState(pendingOps) {
      pendingOps.push({});
    }
    function popPendingState(pendingOps) {
      var first = pendingOps.shift();
      if (!pendingOps.length) {
        pendingOps[0] = {};
      }
      return first;
    }
    function mergeFirstPendingState(pendingOps) {
      var first = popPendingState(pendingOps);
      var next = pendingOps[0];
      for (var _attr2 in first) {
        if (next[_attr2] && first[_attr2]) {
          var merged = next[_attr2].mergeWith(first[_attr2]);
          if (merged) {
            next[_attr2] = merged;
          }
        } else {
          next[_attr2] = first[_attr2];
        }
      }
    }
    function estimateAttribute(serverData, pendingOps, className, id2, attr) {
      var value = serverData[attr];
      for (var i2 = 0; i2 < pendingOps.length; i2++) {
        if (pendingOps[i2][attr]) {
          if (pendingOps[i2][attr] instanceof _ParseOp.RelationOp) {
            if (id2) {
              value = pendingOps[i2][attr].applyTo(value, {
                className,
                id: id2
              }, attr);
            }
          } else {
            value = pendingOps[i2][attr].applyTo(value);
          }
        }
      }
      return value;
    }
    function estimateAttributes(serverData, pendingOps, className, id2) {
      var data = {};
      for (var attr in serverData) {
        data[attr] = serverData[attr];
      }
      for (var i2 = 0; i2 < pendingOps.length; i2++) {
        for (attr in pendingOps[i2]) {
          if (pendingOps[i2][attr] instanceof _ParseOp.RelationOp) {
            if (id2) {
              data[attr] = pendingOps[i2][attr].applyTo(data[attr], {
                className,
                id: id2
              }, attr);
            }
          } else {
            if ((0, _includes.default)(attr).call(attr, ".")) {
              var fields = attr.split(".");
              var first = fields[0];
              var last = fields[fields.length - 1];
              data[first] = _objectSpread5({}, serverData[first]);
              var object = _objectSpread5({}, data);
              for (var _i = 0; _i < fields.length - 1; _i++) {
                object = object[fields[_i]];
              }
              object[last] = pendingOps[i2][attr].applyTo(object[last]);
            } else {
              data[attr] = pendingOps[i2][attr].applyTo(data[attr]);
            }
          }
        }
      }
      return data;
    }
    function commitServerChanges(serverData, objectCache, changes) {
      for (var _attr3 in changes) {
        var val = changes[_attr3];
        serverData[_attr3] = val;
        if (val && (0, _typeof2.default)(val) === "object" && !(val instanceof _ParseObject.default) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {
          var json = (0, _encode3.default)(val, false, true);
          objectCache[_attr3] = (0, _stringify.default)(json);
        }
      }
    }
  }
});

// node_modules/moralis-v1/lib/browser/SingleInstanceStateController.js
var require_SingleInstanceStateController = __commonJS({
  "node_modules/moralis-v1/lib/browser/SingleInstanceStateController.js"(exports) {
    "use strict";
    var _typeof = require_typeof();
    var _WeakMap = require_weak_map3();
    var _Object$defineProperty = require_define_property3();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clearAllState = clearAllState;
    exports.commitServerChanges = commitServerChanges;
    exports.duplicateState = duplicateState;
    exports.enqueueTask = enqueueTask;
    exports.estimateAttribute = estimateAttribute;
    exports.estimateAttributes = estimateAttributes;
    exports.getObjectCache = getObjectCache;
    exports.getPendingOps = getPendingOps;
    exports.getServerData = getServerData;
    exports.getState = getState;
    exports.initializeState = initializeState;
    exports.mergeFirstPendingState = mergeFirstPendingState;
    exports.popPendingState = popPendingState;
    exports.pushPendingState = pushPendingState;
    exports.removeState = removeState;
    exports.setPendingOp = setPendingOp;
    exports.setServerData = setServerData;
    var ObjectStateMutations = _interopRequireWildcard(require_ObjectStateMutations());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof _WeakMap !== "function")
        return null;
      var cacheBabelInterop = new _WeakMap();
      var cacheNodeInterop = new _WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      for (var key2 in obj) {
        if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
          var desc = _Object$defineProperty && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key2) : null;
          if (desc && (desc.get || desc.set)) {
            _Object$defineProperty(newObj, key2, desc);
          } else {
            newObj[key2] = obj[key2];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var objectState = {};
    function getState(obj) {
      var classData = objectState[obj.className];
      if (classData) {
        return classData[obj.id] || null;
      }
      return null;
    }
    function initializeState(obj, initial) {
      var state = getState(obj);
      if (state) {
        return state;
      }
      if (!objectState[obj.className]) {
        objectState[obj.className] = {};
      }
      if (!initial) {
        initial = ObjectStateMutations.defaultState();
      }
      state = objectState[obj.className][obj.id] = initial;
      return state;
    }
    function removeState(obj) {
      var state = getState(obj);
      if (state === null) {
        return null;
      }
      delete objectState[obj.className][obj.id];
      return state;
    }
    function getServerData(obj) {
      var state = getState(obj);
      if (state) {
        return state.serverData;
      }
      return {};
    }
    function setServerData(obj, attributes) {
      var _initializeState = initializeState(obj), serverData = _initializeState.serverData;
      ObjectStateMutations.setServerData(serverData, attributes);
    }
    function getPendingOps(obj) {
      var state = getState(obj);
      if (state) {
        return state.pendingOps;
      }
      return [{}];
    }
    function setPendingOp(obj, attr, op) {
      var _initializeState2 = initializeState(obj), pendingOps = _initializeState2.pendingOps;
      ObjectStateMutations.setPendingOp(pendingOps, attr, op);
    }
    function pushPendingState(obj) {
      var _initializeState3 = initializeState(obj), pendingOps = _initializeState3.pendingOps;
      ObjectStateMutations.pushPendingState(pendingOps);
    }
    function popPendingState(obj) {
      var _initializeState4 = initializeState(obj), pendingOps = _initializeState4.pendingOps;
      return ObjectStateMutations.popPendingState(pendingOps);
    }
    function mergeFirstPendingState(obj) {
      var pendingOps = getPendingOps(obj);
      ObjectStateMutations.mergeFirstPendingState(pendingOps);
    }
    function getObjectCache(obj) {
      var state = getState(obj);
      if (state) {
        return state.objectCache;
      }
      return {};
    }
    function estimateAttribute(obj, attr) {
      var serverData = getServerData(obj);
      var pendingOps = getPendingOps(obj);
      return ObjectStateMutations.estimateAttribute(serverData, pendingOps, obj.className, obj.id, attr);
    }
    function estimateAttributes(obj) {
      var serverData = getServerData(obj);
      var pendingOps = getPendingOps(obj);
      return ObjectStateMutations.estimateAttributes(serverData, pendingOps, obj.className, obj.id);
    }
    function commitServerChanges(obj, changes) {
      var state = initializeState(obj);
      ObjectStateMutations.commitServerChanges(state.serverData, state.objectCache, changes);
    }
    function enqueueTask(obj, task) {
      var state = initializeState(obj);
      return state.tasks.enqueue(task);
    }
    function clearAllState() {
      objectState = {};
    }
    function duplicateState(source, dest) {
      dest.id = source.id;
    }
  }
});

// node_modules/moralis-v1/lib/browser/UniqueInstanceStateController.js
var require_UniqueInstanceStateController = __commonJS({
  "node_modules/moralis-v1/lib/browser/UniqueInstanceStateController.js"(exports) {
    "use strict";
    var _typeof = require_typeof();
    var _WeakMap2 = require_weak_map3();
    var _Object$defineProperty = require_define_property3();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clearAllState = clearAllState;
    exports.commitServerChanges = commitServerChanges;
    exports.duplicateState = duplicateState;
    exports.enqueueTask = enqueueTask;
    exports.estimateAttribute = estimateAttribute;
    exports.estimateAttributes = estimateAttributes;
    exports.getObjectCache = getObjectCache;
    exports.getPendingOps = getPendingOps;
    exports.getServerData = getServerData;
    exports.getState = getState;
    exports.initializeState = initializeState;
    exports.mergeFirstPendingState = mergeFirstPendingState;
    exports.popPendingState = popPendingState;
    exports.pushPendingState = pushPendingState;
    exports.removeState = removeState;
    exports.setPendingOp = setPendingOp;
    exports.setServerData = setServerData;
    var _weakMap = _interopRequireDefault(require_weak_map3());
    var ObjectStateMutations = _interopRequireWildcard(require_ObjectStateMutations());
    var _TaskQueue = _interopRequireDefault(require_TaskQueue());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof _WeakMap2 !== "function")
        return null;
      var cacheBabelInterop = new _WeakMap2();
      var cacheNodeInterop = new _WeakMap2();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      for (var key2 in obj) {
        if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
          var desc = _Object$defineProperty && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key2) : null;
          if (desc && (desc.get || desc.set)) {
            _Object$defineProperty(newObj, key2, desc);
          } else {
            newObj[key2] = obj[key2];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var objectState = new _weakMap.default();
    function getState(obj) {
      var classData = objectState.get(obj);
      return classData || null;
    }
    function initializeState(obj, initial) {
      var state = getState(obj);
      if (state) {
        return state;
      }
      if (!initial) {
        initial = {
          serverData: {},
          pendingOps: [{}],
          objectCache: {},
          tasks: new _TaskQueue.default(),
          existed: false
        };
      }
      state = initial;
      objectState.set(obj, state);
      return state;
    }
    function removeState(obj) {
      var state = getState(obj);
      if (state === null) {
        return null;
      }
      objectState.delete(obj);
      return state;
    }
    function getServerData(obj) {
      var state = getState(obj);
      if (state) {
        return state.serverData;
      }
      return {};
    }
    function setServerData(obj, attributes) {
      var _initializeState = initializeState(obj), serverData = _initializeState.serverData;
      ObjectStateMutations.setServerData(serverData, attributes);
    }
    function getPendingOps(obj) {
      var state = getState(obj);
      if (state) {
        return state.pendingOps;
      }
      return [{}];
    }
    function setPendingOp(obj, attr, op) {
      var _initializeState2 = initializeState(obj), pendingOps = _initializeState2.pendingOps;
      ObjectStateMutations.setPendingOp(pendingOps, attr, op);
    }
    function pushPendingState(obj) {
      var _initializeState3 = initializeState(obj), pendingOps = _initializeState3.pendingOps;
      ObjectStateMutations.pushPendingState(pendingOps);
    }
    function popPendingState(obj) {
      var _initializeState4 = initializeState(obj), pendingOps = _initializeState4.pendingOps;
      return ObjectStateMutations.popPendingState(pendingOps);
    }
    function mergeFirstPendingState(obj) {
      var pendingOps = getPendingOps(obj);
      ObjectStateMutations.mergeFirstPendingState(pendingOps);
    }
    function getObjectCache(obj) {
      var state = getState(obj);
      if (state) {
        return state.objectCache;
      }
      return {};
    }
    function estimateAttribute(obj, attr) {
      var serverData = getServerData(obj);
      var pendingOps = getPendingOps(obj);
      return ObjectStateMutations.estimateAttribute(serverData, pendingOps, obj.className, obj.id, attr);
    }
    function estimateAttributes(obj) {
      var serverData = getServerData(obj);
      var pendingOps = getPendingOps(obj);
      return ObjectStateMutations.estimateAttributes(serverData, pendingOps, obj.className, obj.id);
    }
    function commitServerChanges(obj, changes) {
      var state = initializeState(obj);
      ObjectStateMutations.commitServerChanges(state.serverData, state.objectCache, changes);
    }
    function enqueueTask(obj, task) {
      var state = initializeState(obj);
      return state.tasks.enqueue(task);
    }
    function duplicateState(source, dest) {
      var oldState = initializeState(source);
      var newState = initializeState(dest);
      for (var key2 in oldState.serverData) {
        newState.serverData[key2] = oldState.serverData[key2];
      }
      for (var index = 0; index < oldState.pendingOps.length; index++) {
        for (var _key in oldState.pendingOps[index]) {
          newState.pendingOps[index][_key] = oldState.pendingOps[index][_key];
        }
      }
      for (var _key2 in oldState.objectCache) {
        newState.objectCache[_key2] = oldState.objectCache[_key2];
      }
      newState.existed = oldState.existed;
    }
    function clearAllState() {
      objectState = new _weakMap.default();
    }
  }
});

// node_modules/moralis-v1/lib/browser/unsavedChildren.js
var require_unsavedChildren = __commonJS({
  "node_modules/moralis-v1/lib/browser/unsavedChildren.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = unsavedChildren;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _concat = _interopRequireDefault(require_concat4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    function unsavedChildren(obj, allowDeepUnsaved) {
      var _context;
      var encountered = {
        objects: {},
        files: []
      };
      var identifier = (0, _concat.default)(_context = "".concat(obj.className, ":")).call(_context, obj._getId());
      encountered.objects[identifier] = obj.dirty() ? obj : true;
      var attributes = obj.attributes;
      for (var attr in attributes) {
        if ((0, _typeof2.default)(attributes[attr]) === "object") {
          traverse(attributes[attr], encountered, false, !!allowDeepUnsaved);
        }
      }
      var unsaved = [];
      for (var id2 in encountered.objects) {
        if (id2 !== identifier && encountered.objects[id2] !== true) {
          unsaved.push(encountered.objects[id2]);
        }
      }
      return (0, _concat.default)(unsaved).call(unsaved, encountered.files);
    }
    function traverse(obj, encountered, shouldThrow, allowDeepUnsaved) {
      if (obj instanceof _ParseObject.default) {
        var _context2;
        if (!obj.id && shouldThrow) {
          throw new Error("Cannot create a pointer to an unsaved Object.");
        }
        var _identifier = (0, _concat.default)(_context2 = "".concat(obj.className, ":")).call(_context2, obj._getId());
        if (!encountered.objects[_identifier]) {
          encountered.objects[_identifier] = obj.dirty() ? obj : true;
          var attributes = obj.attributes;
          for (var attr in attributes) {
            if ((0, _typeof2.default)(attributes[attr]) === "object") {
              traverse(attributes[attr], encountered, !allowDeepUnsaved, allowDeepUnsaved);
            }
          }
        }
        return;
      }
      if (obj instanceof _ParseFile.default) {
        var _context3;
        if (!obj.url() && (0, _indexOf.default)(_context3 = encountered.files).call(_context3, obj) < 0) {
          encountered.files.push(obj);
        }
        return;
      }
      if (obj instanceof _ParseRelation.default) {
        return;
      }
      if ((0, _isArray.default)(obj)) {
        (0, _forEach.default)(obj).call(obj, function(el) {
          if ((0, _typeof2.default)(el) === "object") {
            traverse(el, encountered, shouldThrow, allowDeepUnsaved);
          }
        });
      }
      for (var k2 in obj) {
        if ((0, _typeof2.default)(obj[k2]) === "object") {
          traverse(obj[k2], encountered, shouldThrow, allowDeepUnsaved);
        }
      }
    }
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i2, stringify_default;
var init_stringify = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i2 = buf && offset || 0;
  var b2 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i2++] = tl >>> 24 & 255;
  b2[i2++] = tl >>> 16 & 255;
  b2[i2++] = tl >>> 8 & 255;
  b2[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i2++] = tmh >>> 8 & 255;
  b2[i2++] = tmh & 255;
  b2[i2++] = tmh >>> 24 & 15 | 16;
  b2[i2++] = tmh >>> 16 & 255;
  b2[i2++] = clockseq >>> 8 | 128;
  b2[i2++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b2[i2 + n2] = node[n2];
  }
  return buf || stringify_default(b2);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
function v35_default(name2, version28, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version28;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x2 = input[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b2 = -271733879;
  var c2 = -1732584194;
  var d2 = 271733878;
  for (var i2 = 0; i2 < x2.length; i2 += 16) {
    var olda = a2;
    var oldb = b2;
    var oldc = c2;
    var oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x2[i2], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x2[i2], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x2[i2], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x2[i2], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x2, y2) {
  var lsw = (x2 & 65535) + (y2 & 65535);
  var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a2, b2, x2, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x2, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
}
function md5gg(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
}
function md5hh(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
}
function md5ii(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/sha1.js
function f(s2, x2, y2, z2) {
  switch (s2) {
    case 0:
      return x2 & y2 ^ ~x2 & z2;
    case 1:
      return x2 ^ y2 ^ z2;
    case 2:
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    case 3:
      return x2 ^ y2 ^ z2;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N2 = Math.ceil(l2 / 16);
  var M2 = new Array(N2);
  for (var _i = 0; _i < N2; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
    }
    M2[_i] = arr;
  }
  M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var W2 = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W2[t2] = M2[_i2][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W2[_t] = ROTL(W2[_t - 3] ^ W2[_t - 8] ^ W2[_t - 14] ^ W2[_t - 16], 1);
    }
    var a2 = H2[0];
    var b2 = H2[1];
    var c2 = H2[2];
    var d2 = H2[3];
    var e = H2[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s2 = Math.floor(_t2 / 20);
      var T = ROTL(a2, 5) + f(s2, b2, c2, d2) + e + K[s2] + W2[_t2] >>> 0;
      e = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H2[0] = H2[0] + a2 >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c2 >>> 0;
    H2[3] = H2[3] + d2 >>> 0;
    H2[4] = H2[4] + e >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/moralis-v1/node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/moralis-v1/lib/browser/ParseObject.js
var require_ParseObject = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseObject.js"(exports) {
    "use strict";
    var _typeof3 = require_typeof();
    var _Object$keys2 = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty2 = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty2 = require_define_property3();
    var _sliceInstanceProperty = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray2 = require_is_array4();
    var _WeakMap = require_weak_map3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty2(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _freeze = _interopRequireDefault(require_freeze3());
    var _keys = _interopRequireDefault(require_keys3());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _includes = _interopRequireDefault(require_includes5());
    var _getPrototypeOf = _interopRequireDefault(require_get_prototype_of7());
    var _concat = _interopRequireDefault(require_concat4());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _promise = _interopRequireDefault(require_promise3());
    var _create = _interopRequireDefault(require_create7());
    var _defineProperty3 = _interopRequireDefault(require_define_property3());
    var _find = _interopRequireDefault(require_find4());
    var _map = _interopRequireDefault(require_map10());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _canBeSerialized = _interopRequireDefault(require_canBeSerialized());
    var _decode2 = _interopRequireDefault(require_decode());
    var _encode3 = _interopRequireDefault(require_encode());
    var _escape2 = _interopRequireDefault(require_escape());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _parseDate = _interopRequireDefault(require_parseDate());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _promiseUtils = require_promiseUtils();
    var _LocalDatastoreUtils = require_LocalDatastoreUtils();
    var _ParseOp = require_ParseOp();
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    var SingleInstanceStateController = _interopRequireWildcard(require_SingleInstanceStateController());
    var _unique = _interopRequireDefault(require_unique());
    var UniqueInstanceStateController = _interopRequireWildcard(require_UniqueInstanceStateController());
    var _unsavedChildren = _interopRequireDefault(require_unsavedChildren());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof _WeakMap !== "function")
        return null;
      var cacheBabelInterop = new _WeakMap();
      var cacheNodeInterop = new _WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      for (var key2 in obj) {
        if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
          var desc = _Object$defineProperty2 && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key2) : null;
          if (desc && (desc.get || desc.set)) {
            _Object$defineProperty2(newObj, key2, desc);
          } else {
            newObj[key2] = obj[key2];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray2(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context21;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty(_context21 = Object.prototype.toString.call(o2)).call(_context21, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys2(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context19, _context20;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty2(_context19 = ownKeys5(Object(source), true)).call(_context19, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty2(_context20 = ownKeys5(Object(source))).call(_context20, function(key2) {
          _Object$defineProperty2(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    var _require = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    var uuidv4 = _require.v4;
    var classMap = {};
    var objectCount = 0;
    var singleInstance = !_CoreManager.default.get("IS_NODE");
    if (singleInstance) {
      _CoreManager.default.setObjectStateController(SingleInstanceStateController);
    } else {
      _CoreManager.default.setObjectStateController(UniqueInstanceStateController);
    }
    function getServerUrlPath() {
      var serverUrl = _CoreManager.default.get("SERVER_URL");
      if (serverUrl[serverUrl.length - 1] !== "/") {
        serverUrl += "/";
      }
      var url = serverUrl.replace(/https?:\/\//, "");
      return url.substr((0, _indexOf.default)(url).call(url, "/"));
    }
    var ParseObject = function() {
      function ParseObject2(className, attributes, options) {
        (0, _classCallCheck2.default)(this, ParseObject2);
        (0, _defineProperty2.default)(this, "id", void 0);
        (0, _defineProperty2.default)(this, "_localId", void 0);
        (0, _defineProperty2.default)(this, "_objCount", void 0);
        (0, _defineProperty2.default)(this, "className", void 0);
        if (typeof this.initialize === "function") {
          this.initialize.apply(this, arguments);
        }
        var toSet = null;
        this._objCount = objectCount++;
        if (typeof className === "string") {
          this.className = className;
          if (attributes && (0, _typeof2.default)(attributes) === "object") {
            toSet = attributes;
          }
        } else if (className && (0, _typeof2.default)(className) === "object") {
          this.className = className.className;
          toSet = {};
          for (var _attr in className) {
            if (_attr !== "className") {
              toSet[_attr] = className[_attr];
            }
          }
          if (attributes && (0, _typeof2.default)(attributes) === "object") {
            options = attributes;
          }
        }
        if (toSet && !this.set(toSet, options)) {
          throw new Error("Can't create an invalid Parse Object");
        }
      }
      (0, _createClass2.default)(ParseObject2, [{
        key: "attributes",
        get: (
          /** Prototype getters / setters * */
          function() {
            var stateController = _CoreManager.default.getObjectStateController();
            return (0, _freeze.default)(stateController.estimateAttributes(this._getStateIdentifier()));
          }
        )
        /**
         * The first time this object was saved on the server.
         *
         * @property {Date} createdAt
         * @returns {Date}
         */
      }, {
        key: "createdAt",
        get: function() {
          return this._getServerData().createdAt;
        }
        /**
         * The last time this object was updated on the server.
         *
         * @property {Date} updatedAt
         * @returns {Date}
         */
      }, {
        key: "updatedAt",
        get: function() {
          return this._getServerData().updatedAt;
        }
        /** Private methods * */
        /**
         * Returns a local or server Id used uniquely identify this object
         *
         * @returns {string}
         */
      }, {
        key: "_getId",
        value: function() {
          if (typeof this.id === "string") {
            return this.id;
          }
          if (typeof this._localId === "string") {
            return this._localId;
          }
          var localId = "local".concat(uuidv4());
          this._localId = localId;
          return localId;
        }
        /**
         * Returns a unique identifier used to pull data from the State Controller.
         *
         * @returns {Parse.Object|object}
         */
      }, {
        key: "_getStateIdentifier",
        value: function() {
          if (singleInstance) {
            var id2 = this.id;
            if (!id2) {
              id2 = this._getId();
            }
            return {
              id: id2,
              className: this.className
            };
          }
          return this;
        }
      }, {
        key: "_getServerData",
        value: function() {
          var stateController = _CoreManager.default.getObjectStateController();
          return stateController.getServerData(this._getStateIdentifier());
        }
      }, {
        key: "_clearServerData",
        value: function() {
          var serverData = this._getServerData();
          var unset = {};
          for (var _attr2 in serverData) {
            unset[_attr2] = void 0;
          }
          var stateController = _CoreManager.default.getObjectStateController();
          stateController.setServerData(this._getStateIdentifier(), unset);
        }
      }, {
        key: "_getPendingOps",
        value: function() {
          var stateController = _CoreManager.default.getObjectStateController();
          return stateController.getPendingOps(this._getStateIdentifier());
        }
        /**
         * @param {Array<string>} [keysToClear] - if specified, only ops matching
         * these fields will be cleared
         */
      }, {
        key: "_clearPendingOps",
        value: function(keysToClear) {
          var pending = this._getPendingOps();
          var latest = pending[pending.length - 1];
          var keys = keysToClear || (0, _keys.default)(latest);
          (0, _forEach.default)(keys).call(keys, function(key2) {
            delete latest[key2];
          });
        }
      }, {
        key: "_getDirtyObjectAttributes",
        value: function() {
          var attributes = this.attributes;
          var stateController = _CoreManager.default.getObjectStateController();
          var objectCache = stateController.getObjectCache(this._getStateIdentifier());
          var dirty = {};
          for (var _attr3 in attributes) {
            var val = attributes[_attr3];
            if (val && (0, _typeof2.default)(val) === "object" && !(val instanceof ParseObject2) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {
              try {
                var json = (0, _encode3.default)(val, false, true);
                var stringified = (0, _stringify.default)(json);
                if (objectCache[_attr3] !== stringified) {
                  dirty[_attr3] = val;
                }
              } catch (e) {
                dirty[_attr3] = val;
              }
            }
          }
          return dirty;
        }
      }, {
        key: "_toFullJSON",
        value: function(seen, offline) {
          var json = this.toJSON(seen, offline);
          json.__type = "Object";
          json.className = this.className;
          return json;
        }
      }, {
        key: "_getSaveJSON",
        value: function() {
          var pending = this._getPendingOps();
          var dirtyObjects = this._getDirtyObjectAttributes();
          var json = {};
          for (var attr in dirtyObjects) {
            var isDotNotation = false;
            for (var i2 = 0; i2 < pending.length; i2 += 1) {
              for (var field in pending[i2]) {
                if ((0, _includes.default)(field).call(field, ".")) {
                  var fieldName = field.split(".")[0];
                  if (fieldName === attr) {
                    isDotNotation = true;
                    break;
                  }
                }
              }
            }
            if (!isDotNotation) {
              json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();
            }
          }
          for (attr in pending[0]) {
            json[attr] = pending[0][attr].toJSON();
          }
          return json;
        }
      }, {
        key: "_getSaveParams",
        value: function() {
          var method = this.id ? "PUT" : "POST";
          var body = this._getSaveJSON();
          var path = "classes/".concat(this.className);
          if (this.id) {
            path += "/".concat(this.id);
          } else if (this.className === "_User") {
            path = "users";
          }
          return {
            method,
            body,
            path
          };
        }
      }, {
        key: "_finishFetch",
        value: function(serverData) {
          if (!this.id && serverData.objectId) {
            this.id = serverData.objectId;
          }
          var stateController = _CoreManager.default.getObjectStateController();
          stateController.initializeState(this._getStateIdentifier());
          var decoded = {};
          for (var _attr4 in serverData) {
            if (_attr4 === "ACL") {
              decoded[_attr4] = new _ParseACL.default(serverData[_attr4]);
            } else if (_attr4 !== "objectId") {
              decoded[_attr4] = (0, _decode2.default)(serverData[_attr4]);
              if (decoded[_attr4] instanceof _ParseRelation.default) {
                decoded[_attr4]._ensureParentAndKey(this, _attr4);
              }
            }
          }
          if (decoded.createdAt && typeof decoded.createdAt === "string") {
            decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);
          }
          if (decoded.updatedAt && typeof decoded.updatedAt === "string") {
            decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);
          }
          if (!decoded.updatedAt && decoded.createdAt) {
            decoded.updatedAt = decoded.createdAt;
          }
          stateController.commitServerChanges(this._getStateIdentifier(), decoded);
        }
      }, {
        key: "_setExisted",
        value: function(existed) {
          var stateController = _CoreManager.default.getObjectStateController();
          var state = stateController.getState(this._getStateIdentifier());
          if (state) {
            state.existed = existed;
          }
        }
      }, {
        key: "_migrateId",
        value: function(serverId) {
          if (this._localId && serverId) {
            if (singleInstance) {
              var stateController = _CoreManager.default.getObjectStateController();
              var oldState = stateController.removeState(this._getStateIdentifier());
              this.id = serverId;
              delete this._localId;
              if (oldState) {
                stateController.initializeState(this._getStateIdentifier(), oldState);
              }
            } else {
              this.id = serverId;
              delete this._localId;
            }
          }
        }
      }, {
        key: "_handleSaveResponse",
        value: function(response, status) {
          var changes = {};
          var stateController = _CoreManager.default.getObjectStateController();
          var pending = stateController.popPendingState(this._getStateIdentifier());
          for (var attr in pending) {
            if (pending[attr] instanceof _ParseOp.RelationOp) {
              changes[attr] = pending[attr].applyTo(void 0, this, attr);
            } else if (!(attr in response) && !(0, _includes.default)(attr).call(attr, ".")) {
              changes[attr] = pending[attr].applyTo(void 0);
            }
          }
          for (attr in response) {
            if ((attr === "createdAt" || attr === "updatedAt") && typeof response[attr] === "string") {
              changes[attr] = (0, _parseDate.default)(response[attr]);
            } else if (attr === "ACL") {
              changes[attr] = new _ParseACL.default(response[attr]);
            } else if (attr !== "objectId") {
              var val = (0, _decode2.default)(response[attr]);
              if (val && (0, _getPrototypeOf.default)(val) === Object.prototype) {
                changes[attr] = _objectSpread5(_objectSpread5({}, this.attributes[attr]), val);
              } else {
                changes[attr] = val;
              }
              if (changes[attr] instanceof _ParseOp.UnsetOp) {
                changes[attr] = void 0;
              }
            }
          }
          if (changes.createdAt && !changes.updatedAt) {
            changes.updatedAt = changes.createdAt;
          }
          this._migrateId(response.objectId);
          if (status !== 201) {
            this._setExisted(true);
          }
          stateController.commitServerChanges(this._getStateIdentifier(), changes);
        }
      }, {
        key: "_handleSaveError",
        value: function() {
          var stateController = _CoreManager.default.getObjectStateController();
          stateController.mergeFirstPendingState(this._getStateIdentifier());
        }
        /** Public methods * */
      }, {
        key: "initialize",
        value: function() {
        }
        /**
         * Returns a JSON version of the object suitable for saving to Parse.
         *
         * @param seen
         * @param offline
         * @returns {object}
         */
      }, {
        key: "toJSON",
        value: function(seen, offline) {
          var _context;
          var seenEntry = this.id ? (0, _concat.default)(_context = "".concat(this.className, ":")).call(_context, this.id) : this;
          seen = seen || [seenEntry];
          var json = {};
          var attrs = this.attributes;
          for (var _attr5 in attrs) {
            if ((_attr5 === "createdAt" || _attr5 === "updatedAt") && attrs[_attr5].toJSON) {
              json[_attr5] = attrs[_attr5].toJSON();
            } else {
              json[_attr5] = (0, _encode3.default)(attrs[_attr5], false, false, seen, offline);
            }
          }
          var pending = this._getPendingOps();
          for (var _attr6 in pending[0]) {
            json[_attr6] = pending[0][_attr6].toJSON(offline);
          }
          if (this.id) {
            json.objectId = this.id;
          }
          return json;
        }
        /**
         * Determines whether this ParseObject is equal to another ParseObject
         *
         * @param {object} other - An other object ot compare
         * @returns {boolean}
         */
      }, {
        key: "equals",
        value: function(other) {
          if (this === other) {
            return true;
          }
          return other instanceof ParseObject2 && this.className === other.className && this.id === other.id && typeof this.id !== "undefined";
        }
        /**
         * Returns true if this object has been modified since its last
         * save/refresh.  If an attribute is specified, it returns true only if that
         * particular attribute has been modified since the last save/refresh.
         *
         * @param {string} attr An attribute name (optional).
         * @returns {boolean}
         */
      }, {
        key: "dirty",
        value: function(attr) {
          if (!this.id) {
            return true;
          }
          var pendingOps = this._getPendingOps();
          var dirtyObjects = this._getDirtyObjectAttributes();
          if (attr) {
            if (dirtyObjects.hasOwnProperty(attr)) {
              return true;
            }
            for (var i2 = 0; i2 < pendingOps.length; i2++) {
              if (pendingOps[i2].hasOwnProperty(attr)) {
                return true;
              }
            }
            return false;
          }
          if ((0, _keys.default)(pendingOps[0]).length !== 0) {
            return true;
          }
          if ((0, _keys.default)(dirtyObjects).length !== 0) {
            return true;
          }
          return false;
        }
        /**
         * Returns an array of keys that have been modified since last save/refresh
         *
         * @returns {string[]}
         */
      }, {
        key: "dirtyKeys",
        value: function() {
          var pendingOps = this._getPendingOps();
          var keys = {};
          for (var i2 = 0; i2 < pendingOps.length; i2++) {
            for (var _attr7 in pendingOps[i2]) {
              keys[_attr7] = true;
            }
          }
          var dirtyObjects = this._getDirtyObjectAttributes();
          for (var _attr8 in dirtyObjects) {
            keys[_attr8] = true;
          }
          return (0, _keys.default)(keys);
        }
        /**
         * Returns true if the object has been fetched.
         *
         * @returns {boolean}
         */
      }, {
        key: "isDataAvailable",
        value: function() {
          var serverData = this._getServerData();
          return !!(0, _keys.default)(serverData).length;
        }
        /**
         * Gets a Pointer referencing this Object.
         *
         * @returns {Pointer}
         */
      }, {
        key: "toPointer",
        value: function() {
          if (!this.id) {
            throw new Error("Cannot create a pointer to an unsaved ParseObject");
          }
          return {
            __type: "Pointer",
            className: this.className,
            objectId: this.id
          };
        }
        /**
         * Gets a Pointer referencing this Object.
         *
         * @returns {Pointer}
         */
      }, {
        key: "toOfflinePointer",
        value: function() {
          if (!this._localId) {
            throw new Error("Cannot create a offline pointer to a saved ParseObject");
          }
          return {
            __type: "Object",
            className: this.className,
            _localId: this._localId
          };
        }
        /**
         * Gets the value of an attribute.
         *
         * @param {string} attr The string name of an attribute.
         * @returns {*}
         */
      }, {
        key: "get",
        value: function(attr) {
          return this.attributes[attr];
        }
        /**
         * Gets a relation on the given class for the attribute.
         *
         * @param {string} attr The attribute to get the relation for.
         * @returns {Parse.Relation}
         */
      }, {
        key: "relation",
        value: function(attr) {
          var value = this.get(attr);
          if (value) {
            if (!(value instanceof _ParseRelation.default)) {
              throw new Error("Called relation() on non-relation field ".concat(attr));
            }
            value._ensureParentAndKey(this, attr);
            return value;
          }
          return new _ParseRelation.default(this, attr);
        }
        /**
         * Gets the HTML-escaped value of an attribute.
         *
         * @param {string} attr The string name of an attribute.
         * @returns {string}
         */
      }, {
        key: "escape",
        value: function(attr) {
          var val = this.attributes[attr];
          if (val == null) {
            return "";
          }
          if (typeof val !== "string") {
            if (typeof val.toString !== "function") {
              return "";
            }
            val = val.toString();
          }
          return (0, _escape2.default)(val);
        }
        /**
         * Returns <code>true</code> if the attribute contains a value that is not
         * null or undefined.
         *
         * @param {string} attr The string name of the attribute.
         * @returns {boolean}
         */
      }, {
        key: "has",
        value: function(attr) {
          var attributes = this.attributes;
          if (attributes.hasOwnProperty(attr)) {
            return attributes[attr] != null;
          }
          return false;
        }
        /**
         * Sets a hash of model attributes on the object.
         *
         * <p>You can call it with an object containing keys and values, with one
         * key and value, or dot notation.  For example:<pre>
         *   gameTurn.set({
         *     player: player1,
         *     diceRoll: 2
         *   }, {
         *     error: function(gameTurnAgain, error) {
         *       // The set failed validation.
         *     }
         *   });
         *
         *   game.set("currentPlayer", player2, {
         *     error: function(gameTurnAgain, error) {
         *       // The set failed validation.
         *     }
         *   });
         *
         *   game.set("finished", true);</pre></p>
         *
         *   game.set("player.score", 10);</pre></p>
         *
         * @param {(string|object)} key The key to set.
         * @param {(string|object)} value The value to give it.
         * @param {object} options A set of options for the set.
         *     The only supported option is <code>error</code>.
         * @returns {(ParseObject|boolean)} true if the set succeeded.
         */
      }, {
        key: "set",
        value: function(key2, value, options) {
          var changes = {};
          var newOps = {};
          if (key2 && (0, _typeof2.default)(key2) === "object") {
            changes = key2;
            options = value;
          } else if (typeof key2 === "string") {
            changes[key2] = value;
          } else {
            return this;
          }
          options = options || {};
          var readonly = [];
          if (typeof this.constructor.readOnlyAttributes === "function") {
            readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());
          }
          for (var k2 in changes) {
            if (k2 === "createdAt" || k2 === "updatedAt") {
              continue;
            }
            if ((0, _indexOf.default)(readonly).call(readonly, k2) > -1) {
              throw new Error("Cannot modify readonly attribute: ".concat(k2));
            }
            if (options.unset) {
              newOps[k2] = new _ParseOp.UnsetOp();
            } else if (changes[k2] instanceof _ParseOp.Op) {
              newOps[k2] = changes[k2];
            } else if (changes[k2] && (0, _typeof2.default)(changes[k2]) === "object" && typeof changes[k2].__op === "string") {
              newOps[k2] = (0, _ParseOp.opFromJSON)(changes[k2]);
            } else if (k2 === "objectId" || k2 === "id") {
              if (typeof changes[k2] === "string") {
                this.id = changes[k2];
              }
            } else if (k2 === "ACL" && (0, _typeof2.default)(changes[k2]) === "object" && !(changes[k2] instanceof _ParseACL.default)) {
              newOps[k2] = new _ParseOp.SetOp(new _ParseACL.default(changes[k2]));
            } else if (changes[k2] instanceof _ParseRelation.default) {
              var relation = new _ParseRelation.default(this, k2);
              relation.targetClassName = changes[k2].targetClassName;
              newOps[k2] = new _ParseOp.SetOp(relation);
            } else {
              newOps[k2] = new _ParseOp.SetOp(changes[k2]);
            }
          }
          var currentAttributes = this.attributes;
          var serverData = this._getServerData();
          if (typeof key2 === "string" && (0, _includes.default)(key2).call(key2, ".")) {
            var field = key2.split(".")[0];
            if (!serverData[field]) {
              return this;
            }
          }
          var newValues = {};
          for (var _attr9 in newOps) {
            if (newOps[_attr9] instanceof _ParseOp.RelationOp) {
              newValues[_attr9] = newOps[_attr9].applyTo(currentAttributes[_attr9], this, _attr9);
            } else if (!(newOps[_attr9] instanceof _ParseOp.UnsetOp)) {
              newValues[_attr9] = newOps[_attr9].applyTo(currentAttributes[_attr9]);
            }
          }
          if (!options.ignoreValidation) {
            var validation = this.validate(newValues);
            if (validation) {
              if (typeof options.error === "function") {
                options.error(this, validation);
              }
              return false;
            }
          }
          var pendingOps = this._getPendingOps();
          var last = pendingOps.length - 1;
          var stateController = _CoreManager.default.getObjectStateController();
          for (var _attr10 in newOps) {
            var nextOp = newOps[_attr10].mergeWith(pendingOps[last][_attr10]);
            stateController.setPendingOp(this._getStateIdentifier(), _attr10, nextOp);
          }
          return this;
        }
        /**
         * Remove an attribute from the model. This is a noop if the attribute doesn't
         * exist.
         *
         * @param {string} attr The string name of an attribute.
         * @param options
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "unset",
        value: function(attr, options) {
          options = options || {};
          options.unset = true;
          return this.set(attr, null, options);
        }
        /**
         * Atomically increments the value of the given attribute the next time the
         * object is saved. If no amount is specified, 1 is used by default.
         *
         * @param attr {String} The key.
         * @param amount {Number} The amount to increment by (optional).
         * @returns {(ParseObject|boolean)}
         */
      }, {
        key: "increment",
        value: function(attr, amount) {
          if (typeof amount === "undefined") {
            amount = 1;
          }
          if (typeof amount !== "number") {
            throw new Error("Cannot increment by a non-numeric amount.");
          }
          return this.set(attr, new _ParseOp.IncrementOp(amount));
        }
        /**
         * Atomically decrements the value of the given attribute the next time the
         * object is saved. If no amount is specified, 1 is used by default.
         *
         * @param attr {String} The key.
         * @param amount {Number} The amount to decrement by (optional).
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "decrement",
        value: function(attr, amount) {
          if (typeof amount === "undefined") {
            amount = 1;
          }
          if (typeof amount !== "number") {
            throw new Error("Cannot decrement by a non-numeric amount.");
          }
          return this.set(attr, new _ParseOp.IncrementOp(amount * -1));
        }
        /**
         * Atomically add an object to the end of the array associated with a given
         * key.
         *
         * @param attr {String} The key.
         * @param item {} The item to add.
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "add",
        value: function(attr, item) {
          return this.set(attr, new _ParseOp.AddOp([item]));
        }
        /**
         * Atomically add the objects to the end of the array associated with a given
         * key.
         *
         * @param attr {String} The key.
         * @param items {Object[]} The items to add.
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "addAll",
        value: function(attr, items) {
          return this.set(attr, new _ParseOp.AddOp(items));
        }
        /**
         * Atomically add an object to the array associated with a given key, only
         * if it is not already present in the array. The position of the insert is
         * not guaranteed.
         *
         * @param attr {String} The key.
         * @param item {} The object to add.
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "addUnique",
        value: function(attr, item) {
          return this.set(attr, new _ParseOp.AddUniqueOp([item]));
        }
        /**
         * Atomically add the objects to the array associated with a given key, only
         * if it is not already present in the array. The position of the insert is
         * not guaranteed.
         *
         * @param attr {String} The key.
         * @param items {Object[]} The objects to add.
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "addAllUnique",
        value: function(attr, items) {
          return this.set(attr, new _ParseOp.AddUniqueOp(items));
        }
        /**
         * Atomically remove all instances of an object from the array associated
         * with a given key.
         *
         * @param attr {String} The key.
         * @param item {} The object to remove.
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "remove",
        value: function(attr, item) {
          return this.set(attr, new _ParseOp.RemoveOp([item]));
        }
        /**
         * Atomically remove all instances of the objects from the array associated
         * with a given key.
         *
         * @param attr {String} The key.
         * @param items {Object[]} The object to remove.
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "removeAll",
        value: function(attr, items) {
          return this.set(attr, new _ParseOp.RemoveOp(items));
        }
        /**
         * Returns an instance of a subclass of Parse.Op describing what kind of
         * modification has been performed on this field since the last time it was
         * saved. For example, after calling object.increment("x"), calling
         * object.op("x") would return an instance of Parse.Op.Increment.
         *
         * @param attr {String} The key.
         * @returns {Parse.Op} The operation, or undefined if none.
         */
      }, {
        key: "op",
        value: function(attr) {
          var pending = this._getPendingOps();
          for (var i2 = pending.length; i2--; ) {
            if (pending[i2][attr]) {
              return pending[i2][attr];
            }
          }
        }
        /**
         * Creates a new model with identical attributes to this one.
         *
         * @returns {Parse.Object}
         */
      }, {
        key: "clone",
        value: function clone() {
          var clone2 = new this.constructor();
          if (!clone2.className) {
            clone2.className = this.className;
          }
          var attributes = this.attributes;
          if (typeof this.constructor.readOnlyAttributes === "function") {
            var readonly = this.constructor.readOnlyAttributes() || [];
            var copy = {};
            for (var a2 in attributes) {
              if ((0, _indexOf.default)(readonly).call(readonly, a2) < 0) {
                copy[a2] = attributes[a2];
              }
            }
            attributes = copy;
          }
          if (clone2.set) {
            clone2.set(attributes);
          }
          return clone2;
        }
        /**
         * Creates a new instance of this object. Not to be confused with clone()
         *
         * @returns {Parse.Object}
         */
      }, {
        key: "newInstance",
        value: function() {
          var clone = new this.constructor();
          if (!clone.className) {
            clone.className = this.className;
          }
          clone.id = this.id;
          if (singleInstance) {
            return clone;
          }
          var stateController = _CoreManager.default.getObjectStateController();
          if (stateController) {
            stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());
          }
          return clone;
        }
        /**
         * Returns true if this object has never been saved to Parse.
         *
         * @returns {boolean}
         */
      }, {
        key: "isNew",
        value: function() {
          return !this.id;
        }
        /**
         * Returns true if this object was created by the Parse server when the
         * object might have already been there (e.g. in the case of a Facebook
         * login)
         *
         * @returns {boolean}
         */
      }, {
        key: "existed",
        value: function() {
          if (!this.id) {
            return false;
          }
          var stateController = _CoreManager.default.getObjectStateController();
          var state = stateController.getState(this._getStateIdentifier());
          if (state) {
            return state.existed;
          }
          return false;
        }
        /**
         * Returns true if this object exists on the Server
         *
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.
         */
      }, {
        key: "exists",
        value: function() {
          var _exists = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(options) {
            var query;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.id) {
                      _context2.next = 2;
                      break;
                    }
                    return _context2.abrupt("return", false);
                  case 2:
                    _context2.prev = 2;
                    query = new _ParseQuery.default(this.className);
                    _context2.next = 6;
                    return query.get(this.id, options);
                  case 6:
                    return _context2.abrupt("return", true);
                  case 9:
                    _context2.prev = 9;
                    _context2.t0 = _context2["catch"](2);
                    if (!(_context2.t0.code === _ParseError.default.OBJECT_NOT_FOUND)) {
                      _context2.next = 13;
                      break;
                    }
                    return _context2.abrupt("return", false);
                  case 13:
                    throw _context2.t0;
                  case 14:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee, this, [[2, 9]]);
          }));
          return function() {
            return _exists.apply(this, arguments);
          };
        }()
        /**
         * Checks if the model is currently in a valid state.
         *
         * @returns {boolean}
         */
      }, {
        key: "isValid",
        value: function() {
          return !this.validate(this.attributes);
        }
        /**
         * You should not call this function directly unless you subclass
         * <code>Parse.Object</code>, in which case you can override this method
         * to provide additional validation on <code>set</code> and
         * <code>save</code>.  Your implementation should return
         *
         * @param {object} attrs The current data to validate.
         * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.
         * @see Parse.Object#set
         */
      }, {
        key: "validate",
        value: function(attrs) {
          if (attrs.hasOwnProperty("ACL") && !(attrs.ACL instanceof _ParseACL.default)) {
            return new _ParseError.default(_ParseError.default.OTHER_CAUSE, "ACL must be a Parse ACL.");
          }
          for (var _key in attrs) {
            if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(_key)) {
              return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME);
            }
          }
          return false;
        }
        /**
         * Returns the ACL for this object.
         *
         * @returns {Parse.ACL} An instance of Parse.ACL.
         * @see Parse.Object#get
         */
      }, {
        key: "getACL",
        value: function() {
          var acl = this.get("ACL");
          if (acl instanceof _ParseACL.default) {
            return acl;
          }
          return null;
        }
        /**
         * Sets the ACL to be used for this object.
         *
         * @param {Parse.ACL} acl An instance of Parse.ACL.
         * @param {object} options
         * @returns {(ParseObject | boolean)} Whether the set passed validation.
         * @see Parse.Object#set
         */
      }, {
        key: "setACL",
        value: function(acl, options) {
          return this.set("ACL", acl, options);
        }
        /**
         * Clears any (or specific) changes to this object made since the last call to save()
         *
         * @param {string} [keys] - specify which fields to revert
         */
      }, {
        key: "revert",
        value: function() {
          var keysToRevert;
          for (var _len = arguments.length, keys = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            keys[_key2] = arguments[_key2];
          }
          if (keys.length) {
            keysToRevert = [];
            var _iterator = _createForOfIteratorHelper(keys), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _key3 = _step.value;
                if (typeof _key3 === "string") {
                  keysToRevert.push(_key3);
                } else {
                  throw new Error("Parse.Object#revert expects either no, or a list of string, arguments.");
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          this._clearPendingOps(keysToRevert);
        }
        /**
         * Clears all attributes on a model
         *
         * @returns {(ParseObject | boolean)}
         */
      }, {
        key: "clear",
        value: function() {
          var attributes = this.attributes;
          var erasable = {};
          var readonly = ["createdAt", "updatedAt"];
          if (typeof this.constructor.readOnlyAttributes === "function") {
            readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());
          }
          for (var _attr11 in attributes) {
            if ((0, _indexOf.default)(readonly).call(readonly, _attr11) < 0) {
              erasable[_attr11] = true;
            }
          }
          return this.set(erasable, {
            unset: true
          });
        }
        /**
         * Fetch the model from the server. If the server's representation of the
         * model differs from its current attributes, they will be overriden.
         *
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,
         *       or an array of array of strings.
         *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.
         * </ul>
         * @returns {Promise} A promise that is fulfilled when the fetch
         *     completes.
         */
      }, {
        key: "fetch",
        value: function(options) {
          options = options || {};
          var fetchOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            fetchOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            fetchOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            fetchOptions.context = options.context;
          }
          if (options.hasOwnProperty("include")) {
            fetchOptions.include = [];
            if ((0, _isArray.default)(options.include)) {
              var _context3;
              (0, _forEach.default)(_context3 = options.include).call(_context3, function(key2) {
                if ((0, _isArray.default)(key2)) {
                  var _context4;
                  fetchOptions.include = (0, _concat.default)(_context4 = fetchOptions.include).call(_context4, key2);
                } else {
                  fetchOptions.include.push(key2);
                }
              });
            } else {
              fetchOptions.include.push(options.include);
            }
          }
          var controller = _CoreManager.default.getObjectController();
          return controller.fetch(this, true, fetchOptions);
        }
        /**
         * Fetch the model from the server. If the server's representation of the
         * model differs from its current attributes, they will be overriden.
         *
         * Includes nested Parse.Objects for the provided key. You can use dot
         * notation to specify which fields in the included object are also fetched.
         *
         * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @returns {Promise} A promise that is fulfilled when the fetch
         *     completes.
         */
      }, {
        key: "fetchWithInclude",
        value: function(keys, options) {
          options = options || {};
          options.include = keys;
          return this.fetch(options);
        }
        /**
         * Set a hash of model attributes, and save the model to the server.
         * updatedAt will be updated when the request returns.
         * You can either call it as:<pre>
         * object.save();</pre>
         * or<pre>
         * object.save(attrs);</pre>
         * or<pre>
         * object.save(null, options);</pre>
         * or<pre>
         * object.save(attrs, options);</pre>
         * or<pre>
         * object.save(key, value, options);</pre>
         *
         * For example, <pre>
         * gameTurn.save({
         * player: "Jake Cutter",
         * diceRoll: 2
         * }).then(function(gameTurnAgain) {
         * // The save was successful.
         * }, function(error) {
         * // The save failed.  Error is an instance of Parse.Error.
         * });</pre>
         *
         * @param {string | object | null} [arg1]
         * Valid options are:<ul>
         * <li>`Object` - Key/value pairs to update on the object.</li>
         * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>
         * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>
         * </ul>
         * @param {string | object} [arg2]
         * <ul>
         * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>
         * <li>`Object` Options - Valid options are:
         * <ul>
         * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         * be used for this request.
         * <li>sessionToken: A valid session token, used for making a request on
         * behalf of a specific user.
         * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).
         * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.
         * </ul>
         * </li>
         * </ul>
         * @param {object} [arg3]
         * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.
         * Valid options are:
         * <ul>
         * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         * be used for this request.
         * <li>sessionToken: A valid session token, used for making a request on
         * behalf of a specific user.
         * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).
         * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.
         * </ul>
         * @returns {Promise} A promise that is fulfilled when the save
         * completes.
         */
      }, {
        key: "save",
        value: function(arg1, arg2, arg3) {
          var _this = this;
          var attrs;
          var options;
          if ((0, _typeof2.default)(arg1) === "object" || typeof arg1 === "undefined") {
            attrs = arg1;
            if ((0, _typeof2.default)(arg2) === "object") {
              options = arg2;
            }
          } else {
            attrs = {};
            attrs[arg1] = arg2;
            options = arg3;
          }
          if (attrs) {
            var validation = this.validate(attrs);
            if (validation) {
              return _promise.default.reject(validation);
            }
            this.set(attrs, options);
          }
          options = options || {};
          var saveOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            saveOptions.useMasterKey = !!options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken") && typeof options.sessionToken === "string") {
            saveOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("installationId") && typeof options.installationId === "string") {
            saveOptions.installationId = options.installationId;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            saveOptions.context = options.context;
          }
          var controller = _CoreManager.default.getObjectController();
          var unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;
          return controller.save(unsaved, saveOptions).then(function() {
            return controller.save(_this, saveOptions);
          });
        }
        /**
         * Destroy this model on the server if it was already persisted.
         *
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.
         * </ul>
         * @returns {Promise} A promise that is fulfilled when the destroy
         *     completes.
         */
      }, {
        key: "destroy",
        value: function(options) {
          options = options || {};
          var destroyOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            destroyOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            destroyOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            destroyOptions.context = options.context;
          }
          if (!this.id) {
            return _promise.default.resolve();
          }
          return _CoreManager.default.getObjectController().destroy(this, destroyOptions);
        }
        /**
         * Asynchronously stores the object and every object it points to in the local datastore,
         * recursively, using a default pin name: _default.
         *
         * If those other objects have not been fetched from Parse, they will not be stored.
         * However, if they have changed data, all the changes will be retained.
         *
         * <pre>
         * await object.pin();
         * </pre>
         *
         * To retrieve object:
         * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>
         *
         * @returns {Promise} A promise that is fulfilled when the pin completes.
         */
      }, {
        key: "pin",
        value: function() {
          return ParseObject2.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);
        }
        /**
         * Asynchronously removes the object and every object it points to in the local datastore,
         * recursively, using a default pin name: _default.
         *
         * <pre>
         * await object.unPin();
         * </pre>
         *
         * @returns {Promise} A promise that is fulfilled when the unPin completes.
         */
      }, {
        key: "unPin",
        value: function() {
          return ParseObject2.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);
        }
        /**
         * Asynchronously returns if the object is pinned
         *
         * <pre>
         * const isPinned = await object.isPinned();
         * </pre>
         *
         * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.
         */
      }, {
        key: "isPinned",
        value: function() {
          var _isPinned = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            var localDatastore, objectKey, pin;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    localDatastore = _CoreManager.default.getLocalDatastore();
                    if (localDatastore.isEnabled) {
                      _context5.next = 3;
                      break;
                    }
                    return _context5.abrupt("return", _promise.default.reject("Parse.enableLocalDatastore() must be called first"));
                  case 3:
                    objectKey = localDatastore.getKeyForObject(this);
                    _context5.next = 6;
                    return localDatastore.fromPinWithName(objectKey);
                  case 6:
                    pin = _context5.sent;
                    return _context5.abrupt("return", pin.length > 0);
                  case 8:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _isPinned.apply(this, arguments);
          };
        }()
        /**
         * Asynchronously stores the objects and every object they point to in the local datastore, recursively.
         *
         * If those other objects have not been fetched from Parse, they will not be stored.
         * However, if they have changed data, all the changes will be retained.
         *
         * <pre>
         * await object.pinWithName(name);
         * </pre>
         *
         * To retrieve object:
         * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>
         *
         * @param {string} name Name of Pin.
         * @returns {Promise} A promise that is fulfilled when the pin completes.
         */
      }, {
        key: "pinWithName",
        value: function(name2) {
          return ParseObject2.pinAllWithName(name2, [this]);
        }
        /**
         * Asynchronously removes the object and every object it points to in the local datastore, recursively.
         *
         * <pre>
         * await object.unPinWithName(name);
         * </pre>
         *
         * @param {string} name Name of Pin.
         * @returns {Promise} A promise that is fulfilled when the unPin completes.
         */
      }, {
        key: "unPinWithName",
        value: function(name2) {
          return ParseObject2.unPinAllWithName(name2, [this]);
        }
        /**
         * Asynchronously loads data from the local datastore into this object.
         *
         * <pre>
         * await object.fetchFromLocalDatastore();
         * </pre>
         *
         * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>
         * and then call <code>fetchFromLocalDatastore()</code> on it.
         *
         * @returns {Promise} A promise that is fulfilled when the fetch completes.
         */
      }, {
        key: "fetchFromLocalDatastore",
        value: function() {
          var _fetchFromLocalDatastore = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
            var localDatastore, objectKey, pinned, result;
            return _regenerator.default.wrap(function(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    localDatastore = _CoreManager.default.getLocalDatastore();
                    if (localDatastore.isEnabled) {
                      _context6.next = 3;
                      break;
                    }
                    throw new Error("Parse.enableLocalDatastore() must be called first");
                  case 3:
                    objectKey = localDatastore.getKeyForObject(this);
                    _context6.next = 6;
                    return localDatastore._serializeObject(objectKey);
                  case 6:
                    pinned = _context6.sent;
                    if (pinned) {
                      _context6.next = 9;
                      break;
                    }
                    throw new Error("Cannot fetch an unsaved ParseObject");
                  case 9:
                    result = ParseObject2.fromJSON(pinned);
                    this._finishFetch(result.toJSON());
                    return _context6.abrupt("return", this);
                  case 12:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee3, this);
          }));
          return function() {
            return _fetchFromLocalDatastore.apply(this, arguments);
          };
        }()
        /** Static methods * */
      }], [{
        key: "_clearAllState",
        value: function() {
          var stateController = _CoreManager.default.getObjectStateController();
          stateController.clearAllState();
        }
        /**
         * Fetches the given list of Parse.Object.
         * If any error is encountered, stops and calls the error handler.
         *
         * <pre>
         *   Parse.Object.fetchAll([object1, object2, ...])
         *    .then((list) => {
         *      // All the objects were fetched.
         *    }, (error) => {
         *      // An error occurred while fetching one of the objects.
         *    });
         * </pre>
         *
         * @param {Array} list A list of <code>Parse.Object</code>.
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,
         *       or an array of array of strings.
         * </ul>
         * @static
         * @returns {Parse.Object[]}
         */
      }, {
        key: "fetchAll",
        value: function(list) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var queryOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            queryOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            queryOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("include")) {
            queryOptions.include = ParseObject2.handleIncludeOptions(options);
          }
          return _CoreManager.default.getObjectController().fetch(list, true, queryOptions);
        }
        /**
         * Fetches the given list of Parse.Object.
         *
         * Includes nested Parse.Objects for the provided key. You can use dot
         * notation to specify which fields in the included object are also fetched.
         *
         * If any error is encountered, stops and calls the error handler.
         *
         * <pre>
         *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])
         *    .then((list) => {
         *      // All the objects were fetched.
         *    }, (error) => {
         *      // An error occurred while fetching one of the objects.
         *    });
         * </pre>
         *
         * @param {Array} list A list of <code>Parse.Object</code>.
         * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @static
         * @returns {Parse.Object[]}
         */
      }, {
        key: "fetchAllWithInclude",
        value: function(list, keys, options) {
          options = options || {};
          options.include = keys;
          return ParseObject2.fetchAll(list, options);
        }
        /**
         * Fetches the given list of Parse.Object if needed.
         * If any error is encountered, stops and calls the error handler.
         *
         * Includes nested Parse.Objects for the provided key. You can use dot
         * notation to specify which fields in the included object are also fetched.
         *
         * If any error is encountered, stops and calls the error handler.
         *
         * <pre>
         *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])
         *    .then((list) => {
         *      // All the objects were fetched.
         *    }, (error) => {
         *      // An error occurred while fetching one of the objects.
         *    });
         * </pre>
         *
         * @param {Array} list A list of <code>Parse.Object</code>.
         * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         *   <li>sessionToken: A valid session token, used for making a request on
         *       behalf of a specific user.
         * </ul>
         * @static
         * @returns {Parse.Object[]}
         */
      }, {
        key: "fetchAllIfNeededWithInclude",
        value: function(list, keys, options) {
          options = options || {};
          options.include = keys;
          return ParseObject2.fetchAllIfNeeded(list, options);
        }
        /**
         * Fetches the given list of Parse.Object if needed.
         * If any error is encountered, stops and calls the error handler.
         *
         * <pre>
         *   Parse.Object.fetchAllIfNeeded([object1, ...])
         *    .then((list) => {
         *      // Objects were fetched and updated.
         *    }, (error) => {
         *      // An error occurred while fetching one of the objects.
         *    });
         * </pre>
         *
         * @param {Array} list A list of <code>Parse.Object</code>.
         * @param {object} options
         * @static
         * @returns {Parse.Object[]}
         */
      }, {
        key: "fetchAllIfNeeded",
        value: function(list, options) {
          options = options || {};
          var queryOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            queryOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            queryOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("include")) {
            queryOptions.include = ParseObject2.handleIncludeOptions(options);
          }
          return _CoreManager.default.getObjectController().fetch(list, false, queryOptions);
        }
      }, {
        key: "handleIncludeOptions",
        value: function(options) {
          var include = [];
          if ((0, _isArray.default)(options.include)) {
            var _context7;
            (0, _forEach.default)(_context7 = options.include).call(_context7, function(key2) {
              if ((0, _isArray.default)(key2)) {
                include = (0, _concat.default)(include).call(include, key2);
              } else {
                include.push(key2);
              }
            });
          } else {
            include.push(options.include);
          }
          return include;
        }
        /**
         * Destroy the given list of models on the server if it was already persisted.
         *
         * <p>Unlike saveAll, if an error occurs while deleting an individual model,
         * this method will continue trying to delete the rest of the models if
         * possible, except in the case of a fatal error like a connection error.
         *
         * <p>In particular, the Parse.Error object returned in the case of error may
         * be one of two types:
         *
         * <ul>
         * <li>A Parse.Error.AGGREGATE_ERROR. This object's "errors" property is an
         * array of other Parse.Error objects. Each error object in this array
         * has an "object" property that references the object that could not be
         * deleted (for instance, because that object could not be found).</li>
         * <li>A non-aggregate Parse.Error. This indicates a serious error that
         * caused the delete operation to be aborted partway through (for
         * instance, a connection failure in the middle of the delete).</li>
         * </ul>
         *
         * <pre>
         * Parse.Object.destroyAll([object1, object2, ...])
         * .then((list) => {
         * // All the objects were deleted.
         * }, (error) => {
         * // An error occurred while deleting one or more of the objects.
         * // If this is an aggregate error, then we can inspect each error
         * // object individually to determine the reason why a particular
         * // object was not deleted.
         * if (error.code === Parse.Error.AGGREGATE_ERROR) {
         * for (var i = 0; i < error.errors.length; i++) {
         * console.log("Couldn't delete " + error.errors[i].object.id +
         * "due to " + error.errors[i].message);
         * }
         * } else {
         * console.log("Delete aborted because of " + error.message);
         * }
         * });
         * </pre>
         *
         * @param {Array} list A list of <code>Parse.Object</code>.
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is fulfilled when the destroyAll
         * completes.
         */
      }, {
        key: "destroyAll",
        value: function(list) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var destroyOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            destroyOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            destroyOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("batchSize") && typeof options.batchSize === "number") {
            destroyOptions.batchSize = options.batchSize;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            destroyOptions.context = options.context;
          }
          return _CoreManager.default.getObjectController().destroy(list, destroyOptions);
        }
        /**
         * Saves the given list of Parse.Object.
         * If any error is encountered, stops and calls the error handler.
         *
         * <pre>
         * Parse.Object.saveAll([object1, object2, ...])
         * .then((list) => {
         * // All the objects were saved.
         * }, (error) => {
         * // An error occurred while saving one of the objects.
         * });
         * </pre>
         *
         * @param {Array} list A list of <code>Parse.Object</code>.
         * @param {object} options
         * @static
         * @returns {Parse.Object[]}
         */
      }, {
        key: "saveAll",
        value: function(list) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var saveOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            saveOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("sessionToken")) {
            saveOptions.sessionToken = options.sessionToken;
          }
          if (options.hasOwnProperty("batchSize") && typeof options.batchSize === "number") {
            saveOptions.batchSize = options.batchSize;
          }
          if (options.hasOwnProperty("context") && (0, _typeof2.default)(options.context) === "object") {
            saveOptions.context = options.context;
          }
          return _CoreManager.default.getObjectController().save(list, saveOptions);
        }
        /**
         * Creates a reference to a subclass of Parse.Object with the given id. This
         * does not exist on Parse.Object, only on subclasses.
         *
         * <p>A shortcut for: <pre>
         *  var Foo = Parse.Object.extend("Foo");
         *  var pointerToFoo = new Foo();
         *  pointerToFoo.id = "myObjectId";
         * </pre>
         *
         * @param {string} id The ID of the object to create a reference to.
         * @static
         * @returns {Parse.Object} A Parse.Object reference.
         */
      }, {
        key: "createWithoutData",
        value: function(id2) {
          var obj = new this();
          obj.id = id2;
          return obj;
        }
        /**
         * Creates a new instance of a Parse Object from a JSON representation.
         *
         * @param {object} json The JSON map of the Object's data
         * @param {boolean} override In single instance mode, all old server data
         *   is overwritten if this is set to true
         * @static
         * @returns {Parse.Object} A Parse.Object reference
         */
      }, {
        key: "fromJSON",
        value: function(json, override) {
          if (!json.className) {
            throw new Error("Cannot create an object without a className");
          }
          var constructor = classMap[json.className];
          var o2 = constructor ? new constructor() : new ParseObject2(json.className);
          var otherAttributes = {};
          for (var _attr12 in json) {
            if (_attr12 !== "className" && _attr12 !== "__type") {
              otherAttributes[_attr12] = json[_attr12];
            }
          }
          if (override) {
            if (otherAttributes.objectId) {
              o2.id = otherAttributes.objectId;
            }
            var preserved = null;
            if (typeof o2._preserveFieldsOnFetch === "function") {
              preserved = o2._preserveFieldsOnFetch();
            }
            o2._clearServerData();
            if (preserved) {
              o2._finishFetch(preserved);
            }
          }
          o2._finishFetch(otherAttributes);
          if (json.objectId) {
            o2._setExisted(true);
          }
          return o2;
        }
        /**
         * Registers a subclass of Parse.Object with a specific class name.
         * When objects of that class are retrieved from a query, they will be
         * instantiated with this subclass.
         * This is only necessary when using ES6 subclassing.
         *
         * @param {string} className The class name of the subclass
         * @param {Function} constructor The subclass
         */
      }, {
        key: "registerSubclass",
        value: function(className, constructor) {
          if (typeof className !== "string") {
            throw new TypeError("The first argument must be a valid class name.");
          }
          if (typeof constructor === "undefined") {
            throw new TypeError("You must supply a subclass constructor.");
          }
          if (typeof constructor !== "function") {
            throw new TypeError("You must register the subclass constructor. Did you attempt to register an instance of the subclass?");
          }
          classMap[className] = constructor;
          if (!constructor.className) {
            constructor.className = className;
          }
        }
        /**
         * Creates a new subclass of Parse.Object for the given Parse class name.
         *
         * <p>Every extension of a Parse class will inherit from the most recent
         * previous extension of that class. When a Parse.Object is automatically
         * created by parsing JSON, it will use the most recent extension of that
         * class.</p>
         *
         * <p>You should call either:<pre>
         *     var MyClass = Parse.Object.extend("MyClass", {
         *         <i>Instance methods</i>,
         *         initialize: function(attrs, options) {
         *             this.someInstanceProperty = [],
         *             <i>Other instance properties</i>
         *         }
         *     }, {
         *         <i>Class properties</i>
         *     });</pre>
         * or, for Backbone compatibility:<pre>
         *     var MyClass = Parse.Object.extend({
         *         className: "MyClass",
         *         <i>Instance methods</i>,
         *         initialize: function(attrs, options) {
         *             this.someInstanceProperty = [],
         *             <i>Other instance properties</i>
         *         }
         *     }, {
         *         <i>Class properties</i>
         *     });</pre></p>
         *
         * @param {string} className The name of the Parse class backing this model.
         * @param {object} protoProps Instance properties to add to instances of the
         *     class returned from this method.
         * @param {object} classProps Class properties to add the class returned from
         *     this method.
         * @returns {Parse.Object} A new subclass of Parse.Object.
         */
      }, {
        key: "extend",
        value: function(className, protoProps, classProps) {
          if (typeof className !== "string") {
            if (className && typeof className.className === "string") {
              return ParseObject2.extend(className.className, className, protoProps);
            }
            throw new Error("Parse.Object.extend's first argument should be the className.");
          }
          var adjustedClassName = className;
          if (adjustedClassName === "User" && _CoreManager.default.get("PERFORM_USER_REWRITE")) {
            adjustedClassName = "_User";
          }
          var parentProto = ParseObject2.prototype;
          if (this.hasOwnProperty("__super__") && this.__super__) {
            parentProto = this.prototype;
          } else if (classMap[adjustedClassName]) {
            parentProto = classMap[adjustedClassName].prototype;
          }
          var ParseObjectSubclass = function(attributes, options) {
            this.className = adjustedClassName;
            this._objCount = objectCount++;
            if (typeof this.initialize === "function") {
              this.initialize.apply(this, arguments);
            }
            if (attributes && (0, _typeof2.default)(attributes) === "object") {
              if (!this.set(attributes || {}, options)) {
                throw new Error("Can't create an invalid Parse Object");
              }
            }
          };
          ParseObjectSubclass.className = adjustedClassName;
          ParseObjectSubclass.__super__ = parentProto;
          ParseObjectSubclass.prototype = (0, _create.default)(parentProto, {
            constructor: {
              value: ParseObjectSubclass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (protoProps) {
            for (var prop in protoProps) {
              if (prop !== "className") {
                (0, _defineProperty3.default)(ParseObjectSubclass.prototype, prop, {
                  value: protoProps[prop],
                  enumerable: false,
                  writable: true,
                  configurable: true
                });
              }
            }
          }
          if (classProps) {
            for (var _prop in classProps) {
              if (_prop !== "className") {
                (0, _defineProperty3.default)(ParseObjectSubclass, _prop, {
                  value: classProps[_prop],
                  enumerable: false,
                  writable: true,
                  configurable: true
                });
              }
            }
          }
          ParseObjectSubclass.extend = function(name2, protoProps2, classProps2) {
            if (typeof name2 === "string") {
              return ParseObject2.extend.call(ParseObjectSubclass, name2, protoProps2, classProps2);
            }
            return ParseObject2.extend.call(ParseObjectSubclass, adjustedClassName, name2, protoProps2);
          };
          ParseObjectSubclass.createWithoutData = ParseObject2.createWithoutData;
          classMap[adjustedClassName] = ParseObjectSubclass;
          return ParseObjectSubclass;
        }
        /**
         * Enable single instance objects, where any local objects with the same Id
         * share the same attributes, and stay synchronized with each other.
         * This is disabled by default in server environments, since it can lead to
         * security issues.
         *
         * @static
         */
      }, {
        key: "enableSingleInstance",
        value: function() {
          singleInstance = true;
          _CoreManager.default.setObjectStateController(SingleInstanceStateController);
        }
        /**
         * Disable single instance objects, where any local objects with the same Id
         * share the same attributes, and stay synchronized with each other.
         * When disabled, you can have two instances of the same object in memory
         * without them sharing attributes.
         *
         * @static
         */
      }, {
        key: "disableSingleInstance",
        value: function() {
          singleInstance = false;
          _CoreManager.default.setObjectStateController(UniqueInstanceStateController);
        }
        /**
         * Asynchronously stores the objects and every object they point to in the local datastore,
         * recursively, using a default pin name: _default.
         *
         * If those other objects have not been fetched from Parse, they will not be stored.
         * However, if they have changed data, all the changes will be retained.
         *
         * <pre>
         * await Parse.Object.pinAll([...]);
         * </pre>
         *
         * To retrieve object:
         * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>
         *
         * @param {Array} objects A list of <code>Parse.Object</code>.
         * @returns {Promise} A promise that is fulfilled when the pin completes.
         * @static
         */
      }, {
        key: "pinAll",
        value: function(objects) {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (!localDatastore.isEnabled) {
            return _promise.default.reject("Parse.enableLocalDatastore() must be called first");
          }
          return ParseObject2.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);
        }
        /**
         * Asynchronously stores the objects and every object they point to in the local datastore, recursively.
         *
         * If those other objects have not been fetched from Parse, they will not be stored.
         * However, if they have changed data, all the changes will be retained.
         *
         * <pre>
         * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);
         * </pre>
         *
         * To retrieve object:
         * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>
         *
         * @param {string} name Name of Pin.
         * @param {Array} objects A list of <code>Parse.Object</code>.
         * @returns {Promise} A promise that is fulfilled when the pin completes.
         * @static
         */
      }, {
        key: "pinAllWithName",
        value: function(name2, objects) {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (!localDatastore.isEnabled) {
            return _promise.default.reject("Parse.enableLocalDatastore() must be called first");
          }
          return localDatastore._handlePinAllWithName(name2, objects);
        }
        /**
         * Asynchronously removes the objects and every object they point to in the local datastore,
         * recursively, using a default pin name: _default.
         *
         * <pre>
         * await Parse.Object.unPinAll([...]);
         * </pre>
         *
         * @param {Array} objects A list of <code>Parse.Object</code>.
         * @returns {Promise} A promise that is fulfilled when the unPin completes.
         * @static
         */
      }, {
        key: "unPinAll",
        value: function(objects) {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (!localDatastore.isEnabled) {
            return _promise.default.reject("Parse.enableLocalDatastore() must be called first");
          }
          return ParseObject2.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);
        }
        /**
         * Asynchronously removes the objects and every object they point to in the local datastore, recursively.
         *
         * <pre>
         * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);
         * </pre>
         *
         * @param {string} name Name of Pin.
         * @param {Array} objects A list of <code>Parse.Object</code>.
         * @returns {Promise} A promise that is fulfilled when the unPin completes.
         * @static
         */
      }, {
        key: "unPinAllWithName",
        value: function(name2, objects) {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (!localDatastore.isEnabled) {
            return _promise.default.reject("Parse.enableLocalDatastore() must be called first");
          }
          return localDatastore._handleUnPinAllWithName(name2, objects);
        }
        /**
         * Asynchronously removes all objects in the local datastore using a default pin name: _default.
         *
         * <pre>
         * await Parse.Object.unPinAllObjects();
         * </pre>
         *
         * @returns {Promise} A promise that is fulfilled when the unPin completes.
         * @static
         */
      }, {
        key: "unPinAllObjects",
        value: function() {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (!localDatastore.isEnabled) {
            return _promise.default.reject("Parse.enableLocalDatastore() must be called first");
          }
          return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);
        }
        /**
         * Asynchronously removes all objects with the specified pin name.
         * Deletes the pin name also.
         *
         * <pre>
         * await Parse.Object.unPinAllObjectsWithName(name);
         * </pre>
         *
         * @param {string} name Name of Pin.
         * @returns {Promise} A promise that is fulfilled when the unPin completes.
         * @static
         */
      }, {
        key: "unPinAllObjectsWithName",
        value: function(name2) {
          var localDatastore = _CoreManager.default.getLocalDatastore();
          if (!localDatastore.isEnabled) {
            return _promise.default.reject("Parse.enableLocalDatastore() must be called first");
          }
          return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name2);
        }
      }]);
      return ParseObject2;
    }();
    var DefaultController = {
      fetch: function(target, forceFetch, options) {
        var localDatastore = _CoreManager.default.getLocalDatastore();
        if ((0, _isArray.default)(target)) {
          if (target.length < 1) {
            return _promise.default.resolve([]);
          }
          var objs = [];
          var ids = [];
          var className = null;
          var results = [];
          var error = null;
          (0, _forEach.default)(target).call(target, function(el) {
            if (error) {
              return;
            }
            if (!className) {
              className = el.className;
            }
            if (className !== el.className) {
              error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, "All objects should be of the same class");
            }
            if (!el.id) {
              error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, "All objects must have an ID");
            }
            if (forceFetch || !el.isDataAvailable()) {
              ids.push(el.id);
              objs.push(el);
            }
            results.push(el);
          });
          if (error) {
            return _promise.default.reject(error);
          }
          var query = new _ParseQuery.default(className);
          query.containedIn("objectId", ids);
          if (options && options.include) {
            query.include(options.include);
          }
          query._limit = ids.length;
          return (0, _find.default)(query).call(query, options).then(function() {
            var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(objects) {
              var idMap, i2, obj, _i, _obj, id2, _iterator2, _step2, object;
              return _regenerator.default.wrap(function(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      idMap = {};
                      (0, _forEach.default)(objects).call(objects, function(o2) {
                        idMap[o2.id] = o2;
                      });
                      i2 = 0;
                    case 3:
                      if (!(i2 < objs.length)) {
                        _context8.next = 11;
                        break;
                      }
                      obj = objs[i2];
                      if (!(!obj || !obj.id || !idMap[obj.id])) {
                        _context8.next = 8;
                        break;
                      }
                      if (!forceFetch) {
                        _context8.next = 8;
                        break;
                      }
                      return _context8.abrupt("return", _promise.default.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, "All objects must exist on the server.")));
                    case 8:
                      i2++;
                      _context8.next = 3;
                      break;
                    case 11:
                      if (!singleInstance) {
                        for (_i = 0; _i < results.length; _i++) {
                          _obj = results[_i];
                          if (_obj && _obj.id && idMap[_obj.id]) {
                            id2 = _obj.id;
                            _obj._finishFetch(idMap[id2].toJSON());
                            results[_i] = idMap[id2];
                          }
                        }
                      }
                      _iterator2 = _createForOfIteratorHelper(results);
                      _context8.prev = 13;
                      _iterator2.s();
                    case 15:
                      if ((_step2 = _iterator2.n()).done) {
                        _context8.next = 21;
                        break;
                      }
                      object = _step2.value;
                      _context8.next = 19;
                      return localDatastore._updateObjectIfPinned(object);
                    case 19:
                      _context8.next = 15;
                      break;
                    case 21:
                      _context8.next = 26;
                      break;
                    case 23:
                      _context8.prev = 23;
                      _context8.t0 = _context8["catch"](13);
                      _iterator2.e(_context8.t0);
                    case 26:
                      _context8.prev = 26;
                      _iterator2.f();
                      return _context8.finish(26);
                    case 29:
                      return _context8.abrupt("return", _promise.default.resolve(results));
                    case 30:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee4, null, [[13, 23, 26, 29]]);
            }));
            return function() {
              return _ref.apply(this, arguments);
            };
          }());
        }
        if (target instanceof ParseObject) {
          var _context9;
          if (!target.id) {
            return _promise.default.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, "Object does not have an ID"));
          }
          var RESTController = _CoreManager.default.getRESTController();
          var params = {};
          if (options && options.include) {
            params.include = options.include.join();
          }
          return RESTController.request("GET", (0, _concat.default)(_context9 = "classes/".concat(target.className, "/")).call(_context9, target._getId()), params, options).then(function() {
            var _ref2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(response) {
              return _regenerator.default.wrap(function(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      target._clearPendingOps();
                      target._clearServerData();
                      target._finishFetch(response);
                      _context10.next = 5;
                      return localDatastore._updateObjectIfPinned(target);
                    case 5:
                      return _context10.abrupt("return", target);
                    case 6:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee5);
            }));
            return function() {
              return _ref2.apply(this, arguments);
            };
          }());
        }
        return _promise.default.resolve();
      },
      destroy: function(target, options) {
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee8() {
          var batchSize, localDatastore, RESTController, batches, deleteCompleted, errors, _context14;
          return _regenerator.default.wrap(function(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get("REQUEST_BATCH_SIZE");
                  localDatastore = _CoreManager.default.getLocalDatastore();
                  RESTController = _CoreManager.default.getRESTController();
                  if (!(0, _isArray.default)(target)) {
                    _context16.next = 13;
                    break;
                  }
                  if (!(target.length < 1)) {
                    _context16.next = 6;
                    break;
                  }
                  return _context16.abrupt("return", _promise.default.resolve([]));
                case 6:
                  batches = [[]];
                  (0, _forEach.default)(target).call(target, function(obj) {
                    if (!obj.id) {
                      return;
                    }
                    batches[batches.length - 1].push(obj);
                    if (batches[batches.length - 1].length >= batchSize) {
                      batches.push([]);
                    }
                  });
                  if (batches[batches.length - 1].length === 0) {
                    batches.pop();
                  }
                  deleteCompleted = _promise.default.resolve();
                  errors = [];
                  (0, _forEach.default)(batches).call(batches, function(batch) {
                    deleteCompleted = deleteCompleted.then(function() {
                      return RESTController.request("POST", "batch", {
                        requests: (0, _map.default)(batch).call(batch, function(obj) {
                          var _context11, _context12;
                          return {
                            method: "DELETE",
                            path: (0, _concat.default)(_context11 = (0, _concat.default)(_context12 = "".concat(getServerUrlPath(), "classes/")).call(_context12, obj.className, "/")).call(_context11, obj._getId()),
                            body: {}
                          };
                        })
                      }, options).then(function(results) {
                        for (var i2 = 0; i2 < results.length; i2++) {
                          if (results[i2] && results[i2].hasOwnProperty("error")) {
                            var err = new _ParseError.default(results[i2].error.code, results[i2].error.error);
                            err.object = batch[i2];
                            errors.push(err);
                          }
                        }
                      });
                    });
                  });
                  return _context16.abrupt("return", deleteCompleted.then((0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6() {
                    var aggregate, _iterator3, _step3, object;
                    return _regenerator.default.wrap(function(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            if (!errors.length) {
                              _context13.next = 4;
                              break;
                            }
                            aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);
                            aggregate.errors = errors;
                            return _context13.abrupt("return", _promise.default.reject(aggregate));
                          case 4:
                            _iterator3 = _createForOfIteratorHelper(target);
                            _context13.prev = 5;
                            _iterator3.s();
                          case 7:
                            if ((_step3 = _iterator3.n()).done) {
                              _context13.next = 13;
                              break;
                            }
                            object = _step3.value;
                            _context13.next = 11;
                            return localDatastore._destroyObjectIfPinned(object);
                          case 11:
                            _context13.next = 7;
                            break;
                          case 13:
                            _context13.next = 18;
                            break;
                          case 15:
                            _context13.prev = 15;
                            _context13.t0 = _context13["catch"](5);
                            _iterator3.e(_context13.t0);
                          case 18:
                            _context13.prev = 18;
                            _iterator3.f();
                            return _context13.finish(18);
                          case 21:
                            return _context13.abrupt("return", _promise.default.resolve(target));
                          case 22:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee6, null, [[5, 15, 18, 21]]);
                  }))));
                case 13:
                  if (!(target instanceof ParseObject)) {
                    _context16.next = 15;
                    break;
                  }
                  return _context16.abrupt("return", RESTController.request("DELETE", (0, _concat.default)(_context14 = "classes/".concat(target.className, "/")).call(_context14, target._getId()), {}, options).then((0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7() {
                    return _regenerator.default.wrap(function(_context15) {
                      while (1) {
                        switch (_context15.prev = _context15.next) {
                          case 0:
                            _context15.next = 2;
                            return localDatastore._destroyObjectIfPinned(target);
                          case 2:
                            return _context15.abrupt("return", _promise.default.resolve(target));
                          case 3:
                          case "end":
                            return _context15.stop();
                        }
                      }
                    }, _callee7);
                  }))));
                case 15:
                  return _context16.abrupt("return", _promise.default.resolve(target));
                case 16:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee8);
        }))();
      },
      save: function(target, options) {
        var batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get("REQUEST_BATCH_SIZE");
        var localDatastore = _CoreManager.default.getLocalDatastore();
        var mapIdForPin = {};
        var RESTController = _CoreManager.default.getRESTController();
        var stateController = _CoreManager.default.getObjectStateController();
        options = options || {};
        options.returnStatus = options.returnStatus || true;
        if ((0, _isArray.default)(target)) {
          if (target.length < 1) {
            return _promise.default.resolve([]);
          }
          var unsaved = (0, _concat.default)(target).call(target);
          for (var i2 = 0; i2 < target.length; i2++) {
            if (target[i2] instanceof ParseObject) {
              unsaved = (0, _concat.default)(unsaved).call(unsaved, (0, _unsavedChildren.default)(target[i2], true));
            }
          }
          unsaved = (0, _unique.default)(unsaved);
          var filesSaved = [];
          var pending = [];
          (0, _forEach.default)(unsaved).call(unsaved, function(el) {
            if (el instanceof _ParseFile.default) {
              filesSaved.push(el.save(options));
            } else if (el instanceof ParseObject) {
              pending.push(el);
            }
          });
          return _promise.default.all(filesSaved).then(function() {
            var objectError = null;
            return (0, _promiseUtils.continueWhile)(function() {
              return pending.length > 0;
            }, function() {
              var batch = [];
              var nextPending = [];
              (0, _forEach.default)(pending).call(pending, function(el) {
                if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {
                  batch.push(el);
                } else {
                  nextPending.push(el);
                }
              });
              pending = nextPending;
              if (batch.length < 1) {
                return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Tried to save a batch with a cycle."));
              }
              var batchReturned = new _promiseUtils.resolvingPromise();
              var batchReady = [];
              var batchTasks = [];
              (0, _forEach.default)(batch).call(batch, function(obj, index) {
                var ready = new _promiseUtils.resolvingPromise();
                batchReady.push(ready);
                stateController.pushPendingState(obj._getStateIdentifier());
                batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function() {
                  ready.resolve();
                  return batchReturned.then(function(responses) {
                    if (responses[index].hasOwnProperty("success")) {
                      var objectId = responses[index].success.objectId;
                      var status = responses[index]._status;
                      delete responses[index]._status;
                      mapIdForPin[objectId] = obj._localId;
                      obj._handleSaveResponse(responses[index].success, status);
                    } else {
                      if (!objectError && responses[index].hasOwnProperty("error")) {
                        var serverError = responses[index].error;
                        objectError = new _ParseError.default(serverError.code, serverError.error);
                        pending = [];
                      }
                      obj._handleSaveError();
                    }
                  });
                }));
              });
              (0, _promiseUtils.when)(batchReady).then(function() {
                return RESTController.request("POST", "batch", {
                  requests: (0, _map.default)(batch).call(batch, function(obj) {
                    var params = obj._getSaveParams();
                    params.path = getServerUrlPath() + params.path;
                    return params;
                  })
                }, options);
              }).then(batchReturned.resolve, function(error) {
                batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));
              });
              return (0, _promiseUtils.when)(batchTasks);
            }).then((0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee9() {
              var _iterator4, _step4, object;
              return _regenerator.default.wrap(function(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      if (!objectError) {
                        _context17.next = 2;
                        break;
                      }
                      return _context17.abrupt("return", _promise.default.reject(objectError));
                    case 2:
                      _iterator4 = _createForOfIteratorHelper(target);
                      _context17.prev = 3;
                      _iterator4.s();
                    case 5:
                      if ((_step4 = _iterator4.n()).done) {
                        _context17.next = 13;
                        break;
                      }
                      object = _step4.value;
                      _context17.next = 9;
                      return localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);
                    case 9:
                      _context17.next = 11;
                      return localDatastore._updateObjectIfPinned(object);
                    case 11:
                      _context17.next = 5;
                      break;
                    case 13:
                      _context17.next = 18;
                      break;
                    case 15:
                      _context17.prev = 15;
                      _context17.t0 = _context17["catch"](3);
                      _iterator4.e(_context17.t0);
                    case 18:
                      _context17.prev = 18;
                      _iterator4.f();
                      return _context17.finish(18);
                    case 21:
                      return _context17.abrupt("return", _promise.default.resolve(target));
                    case 22:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee9, null, [[3, 15, 18, 21]]);
            })));
          });
        }
        if (target instanceof ParseObject) {
          target._getId();
          var localId = target._localId;
          var targetCopy = target;
          var task = function() {
            var params = targetCopy._getSaveParams();
            return RESTController.request(params.method, params.path, params.body, options).then(function(response) {
              var status = response._status;
              delete response._status;
              targetCopy._handleSaveResponse(response, status);
            }, function(error) {
              targetCopy._handleSaveError();
              return _promise.default.reject(error);
            });
          };
          stateController.pushPendingState(target._getStateIdentifier());
          return stateController.enqueueTask(target._getStateIdentifier(), task).then((0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee10() {
            return _regenerator.default.wrap(function(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    _context18.next = 2;
                    return localDatastore._updateLocalIdForObject(localId, target);
                  case 2:
                    _context18.next = 4;
                    return localDatastore._updateObjectIfPinned(target);
                  case 4:
                    return _context18.abrupt("return", target);
                  case 5:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee10);
          })), function(error) {
            return _promise.default.reject(error);
          });
        }
        return _promise.default.resolve();
      }
    };
    _CoreManager.default.setObjectController(DefaultController);
    var _default = ParseObject;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParseRole.js
var require_ParseRole = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseRole.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _get2 = _interopRequireDefault(require_get7());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _ParseObject2 = _interopRequireDefault(require_ParseObject());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var ParseRole = function(_ParseObject) {
      (0, _inherits2.default)(ParseRole2, _ParseObject);
      var _super = _createSuper(ParseRole2);
      function ParseRole2(name2, acl) {
        var _this;
        (0, _classCallCheck2.default)(this, ParseRole2);
        _this = _super.call(this, "_Role");
        if (typeof name2 === "string" && acl instanceof _ParseACL.default) {
          _this.setName(name2);
          _this.setACL(acl);
        }
        return _this;
      }
      (0, _createClass2.default)(ParseRole2, [{
        key: "getName",
        value: function() {
          var name2 = this.get("name");
          if (name2 == null || typeof name2 === "string") {
            return name2;
          }
          return "";
        }
        /**
         * Sets the name for a role. This value must be set before the role has
         * been saved to the server, and cannot be set once the role has been
         * saved.
         *
         * <p>
         *   A role's name can only contain alphanumeric characters, _, -, and
         *   spaces.
         * </p>
         *
         * <p>This is equivalent to calling role.set("name", name)</p>
         *
         * @param {string} name The name of the role.
         * @param {object} options Standard options object with success and error
         *     callbacks.
         * @returns {(ParseObject|boolean)} true if the set succeeded.
         */
      }, {
        key: "setName",
        value: function(name2, options) {
          return this.set("name", name2, options);
        }
        /**
         * Gets the Parse.Relation for the Parse.Users that are direct
         * children of this role. These users are granted any privileges that this
         * role has been granted (e.g. read or write access through ACLs). You can
         * add or remove users from the role through this relation.
         *
         * <p>This is equivalent to calling role.relation("users")</p>
         *
         * @returns {Parse.Relation} the relation for the users belonging to this
         *     role.
         */
      }, {
        key: "getUsers",
        value: function() {
          return this.relation("users");
        }
        /**
         * Gets the Parse.Relation for the Parse.Roles that are direct
         * children of this role. These roles' users are granted any privileges that
         * this role has been granted (e.g. read or write access through ACLs). You
         * can add or remove child roles from this role through this relation.
         *
         * <p>This is equivalent to calling role.relation("roles")</p>
         *
         * @returns {Parse.Relation} the relation for the roles belonging to this
         *     role.
         */
      }, {
        key: "getRoles",
        value: function() {
          return this.relation("roles");
        }
      }, {
        key: "validate",
        value: function(attrs, options) {
          var isInvalid = (0, _get2.default)((0, _getPrototypeOf2.default)(ParseRole2.prototype), "validate", this).call(this, attrs, options);
          if (isInvalid) {
            return isInvalid;
          }
          if ("name" in attrs && attrs.name !== this.getName()) {
            var newName = attrs.name;
            if (this.id && this.id !== attrs.objectId) {
              return new _ParseError.default(_ParseError.default.OTHER_CAUSE, "A role's name can only be set before it has been saved.");
            }
            if (typeof newName !== "string") {
              return new _ParseError.default(_ParseError.default.OTHER_CAUSE, "A role's name must be a String.");
            }
            if (!/^[0-9a-zA-Z\-_ ]+$/.test(newName)) {
              return new _ParseError.default(_ParseError.default.OTHER_CAUSE, "A role's name can be only contain alphanumeric characters, _, -, and spaces.");
            }
          }
          return false;
        }
      }]);
      return ParseRole2;
    }(_ParseObject2.default);
    _ParseObject2.default.registerSubclass("_Role", ParseRole);
    var _default = ParseRole;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/AnonymousUtils.js
var require_AnonymousUtils = __commonJS({
  "node_modules/moralis-v1/lib/browser/AnonymousUtils.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var _require = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    var uuidv4 = _require.v4;
    var registered = false;
    var AnonymousUtils = {
      /**
       * Gets whether the user has their account linked to anonymous user.
       *
       * @function isLinked
       * @name Parse.AnonymousUtils.isLinked
       * @param {Parse.User} user User to check for.
       *     The user must be logged in on this device.
       * @returns {boolean} <code>true</code> if the user has their account
       *     linked to an anonymous user.
       * @static
       */
      isLinked: function(user) {
        var provider = this._getAuthProvider();
        return user._isLinked(provider.getAuthType());
      },
      /**
       * Logs in a user Anonymously.
       *
       * @function logIn
       * @name Parse.AnonymousUtils.logIn
       * @param {object} options MasterKey / SessionToken.
       * @returns {Promise} Logged in user
       * @static
       */
      logIn: function(options) {
        var provider = this._getAuthProvider();
        return _ParseUser.default.logInWith(provider.getAuthType(), provider.getAuthData(), options);
      },
      /**
       * Links Anonymous User to an existing PFUser.
       *
       * @function link
       * @name Parse.AnonymousUtils.link
       * @param {Parse.User} user User to link. This must be the current user.
       * @param {object} options MasterKey / SessionToken.
       * @returns {Promise} Linked with User
       * @static
       */
      link: function(user, options) {
        var provider = this._getAuthProvider();
        return user.linkWith(provider.getAuthType(), provider.getAuthData(), options);
      },
      _getAuthProvider: function() {
        var provider = {
          restoreAuthentication: function() {
            return true;
          },
          getAuthType: function() {
            return "anonymous";
          },
          getAuthData: function() {
            return {
              authData: {
                id: uuidv4()
              }
            };
          }
        };
        if (!registered) {
          _ParseUser.default._registerAuthenticationProvider(provider);
          registered = true;
        }
        return provider;
      }
    };
    var _default = AnonymousUtils;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/isRevocableSession.js
var require_isRevocableSession = __commonJS({
  "node_modules/moralis-v1/lib/browser/isRevocableSession.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isRevocableSession;
    var _indexOf = _interopRequireDefault(require_index_of8());
    function isRevocableSession(token) {
      return (0, _indexOf.default)(token).call(token, "r:") > -1;
    }
  }
});

// node_modules/moralis-v1/lib/browser/ParseSession.js
var require_ParseSession = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseSession.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _promise = _interopRequireDefault(require_promise3());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _isRevocableSession = _interopRequireDefault(require_isRevocableSession());
    var _ParseObject2 = _interopRequireDefault(require_ParseObject());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var ParseSession = function(_ParseObject) {
      (0, _inherits2.default)(ParseSession2, _ParseObject);
      var _super = _createSuper(ParseSession2);
      function ParseSession2(attributes) {
        var _this;
        (0, _classCallCheck2.default)(this, ParseSession2);
        _this = _super.call(this, "_Session");
        if (attributes && (0, _typeof2.default)(attributes) === "object") {
          if (!_this.set(attributes || {})) {
            throw new Error("Can't create an invalid Session");
          }
        }
        return _this;
      }
      (0, _createClass2.default)(ParseSession2, [{
        key: "getSessionToken",
        value: function() {
          var token = this.get("sessionToken");
          if (typeof token === "string") {
            return token;
          }
          return "";
        }
      }], [{
        key: "readOnlyAttributes",
        value: function() {
          return ["createdWith", "expiresAt", "installationId", "restricted", "sessionToken", "user"];
        }
        /**
         * Retrieves the Session object for the currently logged in session.
         *
         * @param {object} options useMasterKey
         * @static
         * @returns {Promise} A promise that is resolved with the Parse.Session
         * object after it has been fetched. If there is no current user, the
         * promise will be rejected.
         */
      }, {
        key: "current",
        value: function(options) {
          options = options || {};
          var controller = _CoreManager.default.getSessionController();
          var sessionOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            sessionOptions.useMasterKey = options.useMasterKey;
          }
          return _ParseUser.default.currentAsync().then(function(user) {
            if (!user) {
              return _promise.default.reject("There is no current user.");
            }
            sessionOptions.sessionToken = user.getSessionToken();
            return controller.getSession(sessionOptions);
          });
        }
        /**
         * Determines whether the current session token is revocable.
         * This method is useful for migrating Express.js or Node.js web apps to
         * use revocable sessions. If you are migrating an app that uses the Parse
         * SDK in the browser only, please use Parse.User.enableRevocableSession()
         * instead, so that sessions can be automatically upgraded.
         *
         * @static
         * @returns {boolean}
         */
      }, {
        key: "isCurrentSessionRevocable",
        value: function() {
          var currentUser = _ParseUser.default.current();
          if (currentUser) {
            return (0, _isRevocableSession.default)(currentUser.getSessionToken() || "");
          }
          return false;
        }
      }]);
      return ParseSession2;
    }(_ParseObject2.default);
    _ParseObject2.default.registerSubclass("_Session", ParseSession);
    var DefaultController = {
      getSession: function(options) {
        var RESTController = _CoreManager.default.getRESTController();
        var session = new ParseSession();
        return RESTController.request("GET", "sessions/me", {}, options).then(function(sessionData) {
          session._finishFetch(sessionData);
          session._setExisted(true);
          return session;
        });
      }
    };
    _CoreManager.default.setSessionController(DefaultController);
    var _default = ParseSession;
    exports.default = _default;
  }
});

// node_modules/core-js-pure/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js-pure/internals/string-trim-forced.js"(exports, module) {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "​᠎";
    module.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js-pure/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "node_modules/core-js-pure/modules/es.string.trim.js"() {
    "use strict";
    var $ = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// node_modules/core-js-pure/es/string/virtual/trim.js
var require_trim = __commonJS({
  "node_modules/core-js-pure/es/string/virtual/trim.js"(exports, module) {
    "use strict";
    require_es_string_trim();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("String", "trim");
  }
});

// node_modules/core-js-pure/es/instance/trim.js
var require_trim2 = __commonJS({
  "node_modules/core-js-pure/es/instance/trim.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_trim();
    var StringPrototype = String.prototype;
    module.exports = function(it) {
      var own = it.trim;
      return typeof it == "string" || it === StringPrototype || isPrototypeOf(StringPrototype, it) && own === StringPrototype.trim ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/trim.js
var require_trim3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/trim.js"(exports, module) {
    "use strict";
    var parent = require_trim2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/trim.js
var require_trim4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/trim.js"(exports, module) {
    module.exports = require_trim3();
  }
});

// node_modules/core-js-pure/modules/es.array.every.js
var require_es_array_every = __commonJS({
  "node_modules/core-js-pure/modules/es.array.every.js"() {
    "use strict";
    var $ = require_export();
    var $every = require_array_iteration().every;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("every");
    $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
      every: function every(callbackfn) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/every.js
var require_every = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/every.js"(exports, module) {
    "use strict";
    require_es_array_every();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "every");
  }
});

// node_modules/core-js-pure/es/instance/every.js
var require_every2 = __commonJS({
  "node_modules/core-js-pure/es/instance/every.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_every();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.every;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.every ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/every.js
var require_every3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/every.js"(exports, module) {
    "use strict";
    var parent = require_every2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/every.js
var require_every4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/every.js"(exports, module) {
    module.exports = require_every3();
  }
});

// node_modules/core-js-pure/modules/es.object.values.js
var require_es_object_values = __commonJS({
  "node_modules/core-js-pure/modules/es.object.values.js"() {
    "use strict";
    var $ = require_export();
    var $values = require_object_to_array().values;
    $({ target: "Object", stat: true }, {
      values: function values(O2) {
        return $values(O2);
      }
    });
  }
});

// node_modules/core-js-pure/es/object/values.js
var require_values = __commonJS({
  "node_modules/core-js-pure/es/object/values.js"(exports, module) {
    "use strict";
    require_es_object_values();
    var path = require_path();
    module.exports = path.Object.values;
  }
});

// node_modules/core-js-pure/stable/object/values.js
var require_values2 = __commonJS({
  "node_modules/core-js-pure/stable/object/values.js"(exports, module) {
    "use strict";
    var parent = require_values();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/values.js
var require_values3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/values.js"(exports, module) {
    module.exports = require_values2();
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/bind.js
var require_bind8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/bind.js"(exports, module) {
    module.exports = require_bind3();
  }
});

// node_modules/moralis-v1/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/moralis-v1/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number, base2, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer = window.Buffer;
        } else {
          Buffer = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init2(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN3.prototype._initArray = function _initArray(number, base2, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
            w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
            w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c2 = string.charCodeAt(index);
        if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          return c2 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN3.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w2 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w2 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul3) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r2 *= mul3;
          if (c2 >= 49) {
            r2 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r2 += c2 - 17 + 10;
          } else {
            r2 += c2;
          }
        }
        return r2;
      }
      BN3.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base2);
          for (i2 = 0; i2 < mod; i2++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN3.prototype.clone = function clone() {
        var r2 = new BN3(null);
        this.copy(r2);
        return r2;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN3.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w2 = this.words[i2];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modn(groupBase).toString(base2);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN3.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
      };
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i2;
        var q2 = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[reqLength - i2 - 1] = b2;
          }
        } else {
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[i2] = b2;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0)
          return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w2;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b2 = this._zeroBits(this.words[i2]);
          r2 += b2;
          if (b2 !== 26)
            break;
        }
        return r2;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b2.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN3.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a2 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2 | 0;
            a2 = self2.words[i2] | 0;
            b2 = num.words[j2] | 0;
            r2 = a2 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o2 = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w2;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c2 !== 0) {
          o2[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2;
            var a2 = self2.words[i2] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a2 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t2 = new Array(N2);
        var l2 = BN3.prototype._countBits(N2) - 1;
        for (var i2 = 0; i2 < N2; i2++) {
          t2[i2] = this.revBin(i2, l2, N2);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x2, l2, N2) {
        if (x2 === 0 || x2 === N2 - 1)
          return x2;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x2 & 1) << l2 - i2 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i2 = 0; i2 < N2; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p2 = 0; p2 < N2; p2 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s2; j2++) {
              var re = rtws[p2 + j2];
              var ie = itws[p2 + j2];
              var ro = rtws[p2 + j2 + s2];
              var io = itws[p2 + j2 + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j2] = re + ro;
              itws[p2 + j2] = ie + io;
              rtws[p2 + j2 + s2] = re - ro;
              itws[p2 + j2 + s2] = ie - io;
              if (j2 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N2 = Math.max(m, n2) | 1;
        var odd = N2 & 1;
        var i2 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N2 - i2 - 1];
          rws[N2 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N2 - i2 - 1];
          iws[N2 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
          ws[i2] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N2; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i2 = 0; i2 < N2; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y2, out) {
        var N2 = 2 * this.guessLen13b(x2.length, y2.length);
        var rbt = this.makeRBT(N2);
        var _2 = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x2.words, x2.length, rws, N2);
        this.convert13b(y2.words, y2.length, nrws, N2);
        this.transform(rws, _2, rwst, iwst, N2, rbt);
        this.transform(nrws, _2, nrwst, niwst, N2, rbt);
        for (var i2 = 0; i2 < N2; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _2, N2, rbt);
        this.conjugate(rmws, _2, N2);
        this.normalize13b(rmws, N2);
        out.negative = x2.negative ^ y2.negative;
        out.length = x2.length + y2.length;
        return out.strip();
      };
      BN3.prototype.mul = function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = (this.words[i2] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0)
          return new BN3(1);
        var res = this;
        for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
          if (w2[i2] !== 0)
            break;
        }
        if (++i2 < w2.length) {
          for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
            if (w2[i2] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c2 = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2)
          return false;
        var w2 = this.words[s2];
        return !!(w2 & q2);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul3;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w2 & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2 + shift] = w2 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w2 = -(this.words[i2] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2] = w2 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a2.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN3(null);
          q2.length = m + 1;
          q2.words = new Array(q2.length);
          for (var i2 = 0; i2 < q2.length; i2++) {
            q2.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a2 = diff;
          if (q2) {
            q2.words[m] = 1;
          }
        }
        for (var j2 = m - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j2] = qj;
          }
        }
        if (q2) {
          q2.strip();
        }
        a2.strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a2
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN3.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w2 = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w2 / num | 0;
          carry = w2 % num;
        }
        return this.strip();
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x2 = this;
        var y2 = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN3(1);
        var B2 = new BN3(0);
        var C = new BN3(0);
        var D2 = new BN3(1);
        var g2 = 0;
        while (x2.isEven() && y2.isEven()) {
          x2.iushrn(1);
          y2.iushrn(1);
          ++g2;
        }
        var yp = y2.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x2.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B2.isOdd()) {
                A2.iadd(yp);
                B2.isub(xp);
              }
              A2.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
            ;
          if (j2 > 0) {
            y2.iushrn(j2);
            while (j2-- > 0) {
              if (C.isOdd() || D2.isOdd()) {
                C.iadd(yp);
                D2.isub(xp);
              }
              C.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y2) >= 0) {
            x2.isub(y2);
            A2.isub(C);
            B2.isub(D2);
          } else {
            y2.isub(x2);
            C.isub(A2);
            D2.isub(B2);
          }
        }
        return {
          a: C,
          b: D2,
          gcd: y2.iushln(g2)
        };
      };
      BN3.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
            ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a2.cmp(b2);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q2;
          return this;
        }
        var carry = q2;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w2 = this.words[i2] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i2] = w2;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b2 = num.words[i2] | 0;
          if (a2 === b2)
            continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p2) {
        this.name = name2;
        this.p = new BN3(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w2 = num.words[i2] | 0;
          lo += w2 * 977;
          num.words[i2] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert2(a2.negative === 0, "red works only with positives");
        assert2(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert2((a2.negative | b2.negative) === 0, "red works only with positives");
        assert2(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg3(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add3(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul3(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q2 = this.m.subn(1);
        var s2 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s2++;
          q2.iushrn(1);
        }
        assert2(!q2.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN3(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r2 = this.pow(a2, q2.addn(1).iushrn(1));
        var t2 = this.pow(a2, q2);
        var m = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m);
          var b2 = this.pow(c2, new BN3(1).iushln(m - i2 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a2, b2) {
        if (a2.isZero() || b2.isZero())
          return new BN3(0)._forceRed(this);
        var t2 = a2.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/logger/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/logger/lib.esm/_version.js"() {
    version2 = "logger/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/logger/lib.esm/index.js
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger;
var init_lib = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/logger/lib.esm/index.js"() {
    "use strict";
    init_version2();
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger = class _Logger {
      constructor(version28) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version28,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(_Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(_Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(_Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = _Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key2) => {
          const value = params[key2];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i2 = 0; i2 < value.length; i2++) {
                hex += HEX[value[i2] >> 4];
                hex += HEX[value[i2] & 15];
              }
              messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key2 + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key2) {
          error[key2] = params[key2];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name2, value) {
        return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
          argument: name2,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name2, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name2, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new _Logger(version2);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          _Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version28) {
        return new _Logger(version28);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/bytes/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/bytes/lib.esm/_version.js"() {
    version3 = "bytes/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/bytes/lib.esm/index.js
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var logger, HexCharacters;
var init_lib2 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/bytes/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version3();
    logger = new Logger(version3);
    HexCharacters = "0123456789abcdef";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version4;
var init_version4 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/_version.js"() {
    version4 = "bignumber/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
var import_bn, BN, logger2, _constructorGuard, MAX_SAFE, _warnedToStringRadix, BigNumber;
var init_bignumber = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"() {
    "use strict";
    import_bn = __toESM(require_bn());
    init_lib2();
    init_lib();
    init_version4();
    BN = import_bn.default.BN;
    logger2 = new Logger(version4);
    _constructorGuard = {};
    MAX_SAFE = 9007199254740991;
    _warnedToStringRadix = false;
    BigNumber = class _BigNumber {
      constructor(constructorGuard, hex) {
        logger2.checkNew(new.target, _BigNumber);
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
        if (this._hex[0] === "-") {
          return _BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o2 = _BigNumber.from(other);
        if (o2.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      }
      or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key2) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
        if (value instanceof _BigNumber) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new _BigNumber(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new _BigNumber(_constructorGuard, toHex(new BN(value)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return _BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") {
          return _BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return _BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return _BigNumber.from(hex);
            }
          } else {
            let hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
                return _BigNumber.from(hex);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
        return !!(value && value._isBigNumber);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var logger3, _constructorGuard2, Zero, NegativeOne, zeros, FixedFormat, FixedNumber, ONE, BUMP;
var init_fixednumber = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version4();
    init_bignumber();
    logger3 = new Logger(version4);
    _constructorGuard2 = {};
    Zero = BigNumber.from(0);
    NegativeOne = BigNumber.from(-1);
    zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    FixedFormat = class _FixedFormat {
      constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      static from(value) {
        if (value instanceof _FixedFormat) {
          return value;
        }
        if (typeof value === "number") {
          value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed = false;
          } else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger3.throwArgumentError("invalid fixed format", "format", value);
            }
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          const check = (key2, type, defaultValue) => {
            if (value[key2] == null) {
              return defaultValue;
            }
            if (typeof value[key2] !== type) {
              logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
            }
            return value[key2];
          };
          signed = check("signed", "boolean", signed);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new _FixedFormat(_constructorGuard2, signed, width, decimals);
      }
    };
    FixedNumber = class _FixedNumber {
      constructor(constructorGuard, hex, value, format) {
        logger3.checkNew(new.target, _FixedNumber);
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      _checkFormat(other) {
        if (this.format.name !== other.format.name) {
          logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      }
      addUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
      }
      subUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
      }
      mulUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
      }
      floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      // @TODO: Support other rounding algorithms
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return _FixedNumber.fromString(this._value, format);
      }
      static fromValue(value, decimals, format) {
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
      }
      static fromString(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault2("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static fromBytes(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static from(value, format) {
        if (typeof value === "string") {
          return _FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
          return _FixedNumber.fromBytes(value, format);
        }
        try {
          return _FixedNumber.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
      }
      static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
      }
    };
    ONE = FixedNumber.from(1);
    BUMP = FixedNumber.from("0.5");
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/index.js
var init_lib3 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/bignumber/lib.esm/index.js"() {
    init_bignumber();
    init_fixednumber();
    init_bignumber();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/properties/lib.esm/_version.js
var version5;
var init_version5 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/properties/lib.esm/_version.js"() {
    version5 = "properties/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/properties/lib.esm/index.js
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v2) => ({ key: key2, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger4.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
var __awaiter, logger4, opaque, Description;
var init_lib4 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/properties/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version5();
    __awaiter = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger4 = new Logger(version5);
    opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    Description = class {
      constructor(info) {
        for (const key2 in info) {
          this[key2] = deepCopy(info[key2]);
        }
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/_version.js
var version6;
var init_version6 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/_version.js"() {
    version6 = "abi/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/fragments.js
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i2) {
    logger5.throwArgumentError(`unexpected character at position ${i2}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i2 = 0; i2 < param.length; i2++) {
    let c2 = param[i2];
    switch (c2) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i2);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i2);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i2);
              }
              if (node.indexed) {
                throwError(i2);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i2);
        }
        node.type += c2;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i2);
        }
        node.type += c2;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c2;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c2;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c2;
        } else {
          throwError(i2);
        }
    }
  }
  if (node.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger5.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger5.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger5.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
var logger5, _constructorGuard3, ModifiersBytes, ModifiersNest, FormatTypes, paramTypeArray, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, ErrorFragment, regexIdentifier, regexParen;
var init_fragments = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/fragments.js"() {
    "use strict";
    init_lib3();
    init_lib4();
    init_lib();
    init_version6();
    logger5 = new Logger(version6);
    _constructorGuard3 = {};
    ModifiersBytes = { calldata: true, memory: true, storage: true };
    ModifiersNest = { calldata: true, memory: true };
    FormatTypes = Object.freeze({
      // Bare formatting, as is needed for computing a sighash of an event or function
      sighash: "sighash",
      // Human-Readable with Minimal spacing and without names (compact human-readable)
      minimal: "minimal",
      // Human-Readable with nice spacing, including all names
      full: "full",
      // JSON-format a la Solidity
      json: "json"
    });
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    ParamType = class _ParamType {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard3) {
          logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
          populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: _ParamType.fromObject({
              type: match[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      // Format the parameter fragment
      //   - sighash: "(uint256,address)"
      //   - minimal: "tuple(uint256,address) indexed"
      //   - full:    "tuple(uint256 foo, address bar) indexed baz"
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          let result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.components) {
            result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      static from(value, allowIndexed) {
        if (typeof value === "string") {
          return _ParamType.fromString(value, allowIndexed);
        }
        return _ParamType.fromObject(value);
      }
      static fromObject(value) {
        if (_ParamType.isParamType(value)) {
          return value;
        }
        return new _ParamType(_constructorGuard3, {
          name: value.name || null,
          type: verifyType(value.type),
          indexed: value.indexed == null ? null : !!value.indexed,
          components: value.components ? value.components.map(_ParamType.fromObject) : null
        });
      }
      static fromString(value, allowIndexed) {
        function ParamTypify(node) {
          return _ParamType.fromObject({
            name: node.name,
            type: node.type,
            indexed: node.indexed,
            components: node.components
          });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
      }
      static isParamType(value) {
        return !!(value != null && value._isParamType);
      }
    };
    Fragment = class _Fragment {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard3) {
          logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      static from(value) {
        if (_Fragment.isFragment(value)) {
          return value;
        }
        if (typeof value === "string") {
          return _Fragment.fromString(value);
        }
        return _Fragment.fromObject(value);
      }
      static fromObject(value) {
        if (_Fragment.isFragment(value)) {
          return value;
        }
        switch (value.type) {
          case "function":
            return FunctionFragment.fromObject(value);
          case "event":
            return EventFragment.fromObject(value);
          case "constructor":
            return ConstructorFragment.fromObject(value);
          case "error":
            return ErrorFragment.fromObject(value);
          case "fallback":
          case "receive":
            return null;
        }
        return logger5.throwArgumentError("invalid fragment object", "value", value);
      }
      static fromString(value) {
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
          return EventFragment.fromString(value.substring(5).trim());
        } else if (value.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value.substring(8).trim());
        } else if (value.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value.trim());
        } else if (value.split(" ")[0] === "error") {
          return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger5.throwArgumentError("unsupported fragment", "value", value);
      }
      static isFragment(value) {
        return !!(value && value._isFragment);
      }
    };
    EventFragment = class _EventFragment extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _EventFragment.fromString(value);
        }
        return _EventFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_EventFragment.isEventFragment(value)) {
          return value;
        }
        if (value.type !== "event") {
          logger5.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
          name: verifyIdentifier(value.name),
          anonymous: value.anonymous,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new _EventFragment(_constructorGuard3, params);
      }
      static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
          logger5.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger5.warn("unknown modifier: " + modifier);
          }
        });
        return _EventFragment.fromObject({
          name: match[1].trim(),
          anonymous,
          inputs: parseParams(match[2], true),
          type: "event"
        });
      }
      static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
      }
    };
    ConstructorFragment = class _ConstructorFragment extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        if (format === FormatTypes.sighash) {
          logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _ConstructorFragment.fromString(value);
        }
        return _ConstructorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_ConstructorFragment.isConstructorFragment(value)) {
          return value;
        }
        if (value.type !== "constructor") {
          logger5.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
          logger5.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
          name: null,
          type: value.type,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new _ConstructorFragment(_constructorGuard3, params);
      }
      static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger5.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return _ConstructorFragment.fromObject(params);
      }
      static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
      }
    };
    FunctionFragment = class _FunctionFragment extends ConstructorFragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _FunctionFragment.fromString(value);
        }
        return _FunctionFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_FunctionFragment.isFunctionFragment(value)) {
          return value;
        }
        if (value.type !== "function") {
          logger5.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          constant: state.constant,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new _FunctionFragment(_constructorGuard3, params);
      }
      static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
          logger5.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
          logger5.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          let returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger5.throwArgumentError("unexpected tokens", "value", value);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return _FunctionFragment.fromObject(params);
      }
      static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
      }
    };
    ErrorFragment = class _ErrorFragment extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _ErrorFragment.fromString(value);
        }
        return _ErrorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_ErrorFragment.isErrorFragment(value)) {
          return value;
        }
        if (value.type !== "error") {
          logger5.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new _ErrorFragment(_constructorGuard3, params));
      }
      static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
          logger5.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(_ErrorFragment.fromObject(params));
      }
      static isErrorFragment(value) {
        return value && value._isFragment && value.type === "error";
      }
    };
    regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var logger6, Coder, Writer, Reader;
var init_abstract_coder = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib();
    init_version6();
    logger6 = new Logger(version6);
    Coder = class {
      constructor(name2, type, localName, dynamic) {
        this.name = name2;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      _throwError(message, value) {
        logger6.throwArgumentError(message, this.localName, value);
      }
    };
    Writer = class {
      constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      get data() {
        return hexConcat(this._data);
      }
      get length() {
        return this._dataLength;
      }
      _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
      }
      appendWriter(writer) {
        return this._writeData(concat(writer._data));
      }
      // Arrayish items; padded on the right to wordSize
      writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
          bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
      }
      _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
          logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
          });
        }
        if (bytes.length % this.wordSize) {
          bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
      }
      // BigNumberish items; padded on the left to wordSize
      writeValue(value) {
        return this._writeData(this._getValue(value));
      }
      writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
          this._data[offset] = this._getValue(value);
        };
      }
    };
    Reader = class _Reader {
      constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      get data() {
        return hexlify(this._data);
      }
      get consumed() {
        return this._offset;
      }
      // The default Coerce function
      static coerce(name2, value) {
        let match = name2.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
          value = value.toNumber();
        }
        return value;
      }
      coerce(name2, value) {
        if (this._coerceFunc) {
          return this._coerceFunc(name2, value);
        }
        return _Reader.coerce(name2, value);
      }
      _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length <= this._data.length) {
            alignedLength = length;
          } else {
            logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
        return new _Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        return bytes.slice(0, length);
      }
      readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}
var import_js_sha3;
var init_lib5 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/keccak256/lib.esm/index.js"() {
    "use strict";
    import_js_sha3 = __toESM(require_sha3());
    init_lib2();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/rlp/lib.esm/_version.js
var version7;
var init_version7 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/rlp/lib.esm/_version.js"() {
    version7 = "rlp/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  decode: () => decode,
  encode: () => encode
});
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode(data) {
  const bytes = arrayify(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
var logger7;
var init_lib6 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/rlp/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version7();
    logger7 = new Logger(version7);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/address/lib.esm/_version.js
var version8;
var init_version8 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/address/lib.esm/_version.js"() {
    version8 = "address/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/address/lib.esm/index.js
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from = null;
  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger8.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
var logger8, MAX_SAFE_INTEGER, ibanLookup, safeDigits;
var init_lib7 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/address/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib5();
    init_lib6();
    init_lib();
    init_version8();
    logger8 = new Logger(version8);
    MAX_SAFE_INTEGER = 9007199254740991;
    ibanLookup = {};
    for (let i2 = 0; i2 < 10; i2++) {
      ibanLookup[String(i2)] = String(i2);
    }
    for (let i2 = 0; i2 < 26; i2++) {
      ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
    }
    safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder;
var init_address = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/address.js"() {
    "use strict";
    init_lib7();
    init_lib2();
    init_abstract_coder();
    AddressCoder = class extends Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, value) {
        try {
          value = getAddress(value);
        } catch (error) {
          this._throwError(error.message, value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder;
var init_anonymous = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js"() {
    "use strict";
    init_abstract_coder();
    AnonymousCoder = class extends Coder {
      constructor(coder) {
        super(coder.name, coder.type, void 0, coder.dynamic);
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i2 = 0; i2 < values.length; i2++) {
    const value = values[i2];
    if (value instanceof Error) {
      Object.defineProperty(values, i2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var logger9, ArrayCoder;
var init_array = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/array.js"() {
    "use strict";
    init_lib();
    init_version6();
    init_abstract_coder();
    init_anonymous();
    logger9 = new Logger(version6);
    ArrayCoder = class extends Coder {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i2 = 0; i2 < this.length; i2++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, value) {
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readValue().toNumber();
          if (count * 32 > reader._data.length) {
            logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
              length: reader._data.length,
              count
            });
          }
        }
        let coders = [];
        for (let i2 = 0; i2 < count; i2++) {
          coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder;
var init_boolean = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js"() {
    "use strict";
    init_abstract_coder();
    BooleanCoder = class extends Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder, BytesCoder;
var init_bytes = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js"() {
    "use strict";
    init_lib2();
    init_abstract_coder();
    DynamicBytesCoder = class extends Coder {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      }
    };
    BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder;
var init_fixed_bytes = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js"() {
    "use strict";
    init_lib2();
    init_abstract_coder();
    FixedBytesCoder = class extends Coder {
      constructor(size, localName) {
        let name2 = "bytes" + String(size);
        super(name2, name2, localName, false);
        this.size = size;
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
          this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder;
var init_null = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/null.js"() {
    "use strict";
    init_abstract_coder();
    NullCoder = class extends Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes([]);
      }
      decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero;
var init_addresses = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/addresses.js"() {
    AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2, Zero2, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256;
var init_bignumbers = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/bignumbers.js"() {
    init_lib3();
    NegativeOne2 = BigNumber.from(-1);
    Zero2 = BigNumber.from(0);
    One = BigNumber.from(1);
    Two = BigNumber.from(2);
    WeiPerEther = BigNumber.from("1000000000000000000");
    MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero;
var init_hashes = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/hashes.js"() {
    HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol;
var init_strings = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/strings.js"() {
    EtherSymbol = "Ξ";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});
var init_lib8 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/constants/lib.esm/index.js"() {
    "use strict";
    init_addresses();
    init_bignumbers();
    init_hashes();
    init_strings();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder;
var init_number = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/number.js"() {
    "use strict";
    init_lib3();
    init_lib8();
    init_abstract_coder();
    NumberCoder = class extends Coder {
      constructor(size, signed, localName) {
        const name2 = (signed ? "int" : "uint") + size * 8;
        super(name2, name2, localName, false);
        this.size = size;
        this.signed = signed;
      }
      defaultValue() {
        return 0;
      }
      encode(writer, value) {
        let v2 = BigNumber.from(value);
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          let bounds = maxUintValue.mask(this.size * 8 - 1);
          if (v2.gt(bounds) || v2.lt(bounds.add(One).mul(NegativeOne2))) {
            this._throwError("value out-of-bounds", value);
          }
        } else if (v2.lt(Zero2) || v2.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value);
        }
        v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v2);
      }
      decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/_version.js
var version9;
var init_version9 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/_version.js"() {
    version9 = "strings/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/utf8.js
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o2 = offset + 1; o2 < bytes.length; o2++) {
      if (bytes[o2] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
var logger10, UnicodeNormalizationForm, Utf8ErrorReason, Utf8ErrorFuncs;
var init_utf8 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/utf8.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version9();
    logger10 = new Logger(version9);
    (function(UnicodeNormalizationForm2) {
      UnicodeNormalizationForm2["current"] = "";
      UnicodeNormalizationForm2["NFC"] = "NFC";
      UnicodeNormalizationForm2["NFD"] = "NFD";
      UnicodeNormalizationForm2["NFKC"] = "NFKC";
      UnicodeNormalizationForm2["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
    (function(Utf8ErrorReason2) {
      Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason2["OVERRUN"] = "string overrun";
      Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason2["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason || (Utf8ErrorReason = {}));
    Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String(text) {
  const bytes = toUtf8Bytes(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data = arrayify(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
var init_bytes32 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/bytes32.js"() {
    "use strict";
    init_lib8();
    init_lib2();
    init_utf8();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range = ranges[i2];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}
var Table_A_1_ranges, Table_B_1_flags, Table_B_2_ranges, Table_B_2_lut_abs, Table_B_2_lut_rel, Table_B_2_complex, Table_C_ranges;
var init_idna = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/idna.js"() {
    "use strict";
    init_utf8();
    Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
    Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/index.js
var init_lib9 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/strings/lib.esm/index.js"() {
    "use strict";
    init_bytes32();
    init_idna();
    init_utf8();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder;
var init_string = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/string.js"() {
    "use strict";
    init_lib9();
    init_bytes();
    StringCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
      }
      decode(reader) {
        return toUtf8String(super.decode(reader));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder;
var init_tuple = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"() {
    "use strict";
    init_abstract_coder();
    init_array();
    TupleCoder = class extends Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
      }
      defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
          values.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name2 = coder.localName;
          if (name2) {
            if (!accum[name2]) {
              accum[name2] = 0;
            }
            accum[name2]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index) => {
          let name2 = coder.localName;
          if (!name2 || uniqueNames[name2] !== 1) {
            return;
          }
          if (name2 === "length") {
            name2 = "_length";
          }
          if (values[name2] != null) {
            return;
          }
          values[name2] = values[index];
        });
        return Object.freeze(values);
      }
      encode(writer, value) {
        return pack(writer, this.coders, value);
      }
      decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11, paramTypeBytes, paramTypeNumber, AbiCoder, defaultAbiCoder;
var init_abi_coder = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/abi-coder.js"() {
    "use strict";
    init_lib2();
    init_lib4();
    init_lib();
    init_version6();
    init_abstract_coder();
    init_address();
    init_array();
    init_boolean();
    init_bytes();
    init_fixed_bytes();
    init_null();
    init_number();
    init_string();
    init_tuple();
    init_fragments();
    logger11 = new Logger(version6);
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    AbiCoder = class _AbiCoder {
      constructor(coerceFunc) {
        logger11.checkNew(new.target, _AbiCoder);
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "array":
            return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new TupleCoder((param.components || []).map((component) => {
              return this._getCoder(component);
            }), param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match = param.type.match(paramTypeNumber);
        if (match) {
          let size = parseInt(match[2] || "256");
          if (size === 0 || size > 256 || size % 8 !== 0) {
            logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
          }
          return new NumberCoder(size / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          let size = parseInt(match[1]);
          if (size === 0 || size > 32) {
            logger11.throwArgumentError("invalid bytes length", "param", param);
          }
          return new FixedBytesCoder(size, param.name);
        }
        return logger11.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() {
        return 32;
      }
      _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
        return new Writer(this._getWordSize());
      }
      getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      encode(types, values) {
        if (types.length !== values.length) {
          logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values.length },
            value: { types, values }
          });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
      }
      decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
      }
    };
    defaultAbiCoder = new AbiCoder();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
var init_id = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/id.js"() {
    init_lib5();
    init_lib9();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/_version.js
var version10;
var init_version10 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/_version.js"() {
    version10 = "hash/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/namehash.js
function isValidName(name2) {
  try {
    const comps = name2.split(".");
    for (let i2 = 0; i2 < comps.length; i2++) {
      if (nameprep(comps[i2]).length === 0) {
        throw new Error("empty");
      }
    }
    return true;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger12.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros;
  while (current.length) {
    const partition = current.match(Partition);
    if (partition == null || partition[2] === "") {
      logger12.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes(nameprep(partition[3]));
    result = keccak256(concat([result, keccak256(label)]));
    current = partition[2] || "";
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat(name2.split(".").map((comp) => {
    const bytes = toUtf8Bytes("_" + nameprep(comp));
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
var logger12, Zeros, Partition;
var init_namehash = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/namehash.js"() {
    init_lib2();
    init_lib9();
    init_lib5();
    init_lib();
    init_version10();
    logger12 = new Logger(version10);
    Zeros = new Uint8Array(32);
    Zeros.fill(0);
    Partition = new RegExp("^((.*)\\.)?([^.]+)$");
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var messagePrefix;
var init_message = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/message.js"() {
    init_lib2();
    init_lib5();
    init_lib9();
    messagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/typed-data.js
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger13.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2562.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger13.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger13.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger13.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
var __awaiter2, logger13, padding, NegativeOne3, Zero3, One2, MaxUint2562, hexTrue, hexFalse, domainFieldTypes, domainFieldNames, domainChecks, TypedDataEncoder;
var init_typed_data = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/typed-data.js"() {
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib4();
    init_lib();
    init_version10();
    init_id();
    __awaiter2 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger13 = new Logger(version10);
    padding = new Uint8Array(32);
    padding.fill(0);
    NegativeOne3 = BigNumber.from(-1);
    Zero3 = BigNumber.from(0);
    One2 = BigNumber.from(1);
    MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    hexTrue = hexZeroPad(One2.toHexString(), 32);
    hexFalse = hexZeroPad(Zero3.toHexString(), 32);
    domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value) {
        try {
          return BigNumber.from(value).toString();
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
      },
      verifyingContract: function(value) {
        try {
          return getAddress(value).toLowerCase();
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
      },
      salt: function(value) {
        try {
          const bytes = arrayify(value);
          if (bytes.length !== 32) {
            throw new Error("bad length");
          }
          return hexlify(bytes);
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
      }
    };
    TypedDataEncoder = class _TypedDataEncoder {
      constructor(types) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
        defineReadOnly(this, "_encoderCache", {});
        defineReadOnly(this, "_types", {});
        const links = {};
        const parents = {};
        const subtypes = {};
        Object.keys(types).forEach((type) => {
          links[type] = {};
          parents[type] = [];
          subtypes[type] = {};
        });
        for (const name2 in types) {
          const uniqueNames = {};
          types[name2].forEach((field) => {
            if (uniqueNames[field.name]) {
              logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
            }
            uniqueNames[field.name] = true;
            const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            if (baseType === name2) {
              logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
            }
            const encoder = getBaseEncoder(baseType);
            if (encoder) {
              return;
            }
            if (!parents[baseType]) {
              logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
            }
            parents[baseType].push(name2);
            links[name2][baseType] = true;
          });
        }
        const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
        if (primaryTypes.length === 0) {
          logger13.throwArgumentError("missing primary type", "types", types);
        } else if (primaryTypes.length > 1) {
          logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
        }
        defineReadOnly(this, "primaryType", primaryTypes[0]);
        function checkCircular(type, found) {
          if (found[type]) {
            logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
          }
          found[type] = true;
          Object.keys(links[type]).forEach((child) => {
            if (!parents[child]) {
              return;
            }
            checkCircular(child, found);
            Object.keys(found).forEach((subtype) => {
              subtypes[subtype][child] = true;
            });
          });
          delete found[type];
        }
        checkCircular(this.primaryType, {});
        for (const name2 in subtypes) {
          const st = Object.keys(subtypes[name2]);
          st.sort();
          this._types[name2] = encodeType(name2, types[name2]) + st.map((t2) => encodeType(t2, types[t2])).join("");
        }
      }
      getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
          encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
      }
      _getEncoder(type) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return encoder;
          }
        }
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          const subtype = match[1];
          const subEncoder = this.getEncoder(subtype);
          const length = parseInt(match[3]);
          return (value) => {
            if (length >= 0 && value.length !== length) {
              logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            let result = value.map(subEncoder);
            if (this._types[subtype]) {
              result = result.map(keccak256);
            }
            return keccak256(hexConcat(result));
          };
        }
        const fields = this.types[type];
        if (fields) {
          const encodedType = id(this._types[type]);
          return (value) => {
            const values = fields.map(({ name: name2, type: type2 }) => {
              const result = this.getEncoder(type2)(value[name2]);
              if (this._types[type2]) {
                return keccak256(result);
              }
              return result;
            });
            values.unshift(encodedType);
            return hexConcat(values);
          };
        }
        return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      encodeType(name2) {
        const result = this._types[name2];
        if (!result) {
          logger13.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
        }
        return result;
      }
      encodeData(type, value) {
        return this.getEncoder(type)(value);
      }
      hashStruct(name2, value) {
        return keccak256(this.encodeData(name2, value));
      }
      encode(value) {
        return this.encodeData(this.primaryType, value);
      }
      hash(value) {
        return this.hashStruct(this.primaryType, value);
      }
      _visit(type, value, callback) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return callback(type, value);
          }
        }
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          const subtype = match[1];
          const length = parseInt(match[3]);
          if (length >= 0 && value.length !== length) {
            logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          return value.map((v2) => this._visit(subtype, v2, callback));
        }
        const fields = this.types[type];
        if (fields) {
          return fields.reduce((accum, { name: name2, type: type2 }) => {
            accum[name2] = this._visit(type2, value[name2], callback);
            return accum;
          }, {});
        }
        return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
      }
      static from(types) {
        return new _TypedDataEncoder(types);
      }
      static getPrimaryType(types) {
        return _TypedDataEncoder.from(types).primaryType;
      }
      static hashStruct(name2, types, value) {
        return _TypedDataEncoder.from(types).hashStruct(name2, value);
      }
      static hashDomain(domain) {
        const domainFields = [];
        for (const name2 in domain) {
          const type = domainFieldTypes[name2];
          if (!type) {
            logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
          }
          domainFields.push({ name: name2, type });
        }
        domainFields.sort((a2, b2) => {
          return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
        });
        return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      }
      static encode(domain, types, value) {
        return hexConcat([
          "0x1901",
          _TypedDataEncoder.hashDomain(domain),
          _TypedDataEncoder.from(types).hash(value)
        ]);
      }
      static hash(domain, types, value) {
        return keccak256(_TypedDataEncoder.encode(domain, types, value));
      }
      // Replaces all address types with ENS names with their looked up address
      static resolveNames(domain, types, value, resolveName2) {
        return __awaiter2(this, void 0, void 0, function* () {
          domain = shallowCopy(domain);
          const ensCache = {};
          if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
          }
          const encoder = _TypedDataEncoder.from(types);
          encoder.visit(value, (type, value2) => {
            if (type === "address" && !isHexString(value2, 20)) {
              ensCache[value2] = "0x";
            }
            return value2;
          });
          for (const name2 in ensCache) {
            ensCache[name2] = yield resolveName2(name2);
          }
          if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
          }
          value = encoder.visit(value, (type, value2) => {
            if (type === "address" && ensCache[value2]) {
              return ensCache[value2];
            }
            return value2;
          });
          return { domain, value };
        });
      }
      static getPayload(domain, types, value) {
        _TypedDataEncoder.hashDomain(domain);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name2) => {
          const value2 = domain[name2];
          if (value2 == null) {
            return;
          }
          domainValues[name2] = domainChecks[name2](value2);
          domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
        });
        const encoder = _TypedDataEncoder.from(types);
        const typesWithDomain = shallowCopy(types);
        if (typesWithDomain.EIP712Domain) {
          logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        } else {
          typesWithDomain.EIP712Domain = domainTypes;
        }
        encoder.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value, (type, value2) => {
            if (type.match(/^bytes(\d*)/)) {
              return hexlify(arrayify(value2));
            }
            if (type.match(/^u?int/)) {
              return BigNumber.from(value2).toString();
            }
            switch (type) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                if (typeof value2 !== "string") {
                  logger13.throwArgumentError(`invalid string`, "value", value2);
                }
                return value2;
            }
            return logger13.throwArgumentError("unsupported type", "type", type);
          })
        };
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/index.js
var init_lib10 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hash/lib.esm/index.js"() {
    "use strict";
    init_id();
    init_namehash();
    init_message();
    init_typed_data();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/interface.js
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var logger14, LogDescription, TransactionDescription, ErrorDescription, Indexed, BuiltinErrors, Interface;
var init_interface = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/interface.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib10();
    init_lib5();
    init_lib4();
    init_abi_coder();
    init_abstract_coder();
    init_fragments();
    init_lib();
    init_version6();
    logger14 = new Logger(version6);
    LogDescription = class extends Description {
    };
    TransactionDescription = class extends Description {
    };
    ErrorDescription = class extends Description {
    };
    Indexed = class extends Description {
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    Interface = class _Interface {
      constructor(fragments) {
        logger14.checkNew(new.target, _Interface);
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
          return Fragment.from(fragment);
        }).filter((fragment) => fragment != null));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        this.fragments.forEach((fragment) => {
          let bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                logger14.warn("duplicate definition - constructor");
                return;
              }
              defineReadOnly(this, "deploy", fragment);
              return;
            case "function":
              bucket = this.functions;
              break;
            case "event":
              bucket = this.events;
              break;
            case "error":
              bucket = this.errors;
              break;
            default:
              return;
          }
          let signature2 = fragment.format();
          if (bucket[signature2]) {
            logger14.warn("duplicate definition - " + signature2);
            return;
          }
          bucket[signature2] = fragment;
        });
        if (!this.deploy) {
          defineReadOnly(this, "deploy", ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        defineReadOnly(this, "_isInterface", true);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
          logger14.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        if (format === FormatTypes.json) {
          return JSON.stringify(abi.map((j2) => JSON.parse(j2)));
        }
        return abi;
      }
      // Sub-classes can override these to handle other blockchains
      static getAbiCoder() {
        return defaultAbiCoder;
      }
      static getAddress(address) {
        return getAddress(address);
      }
      static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
      }
      static getEventTopic(eventFragment) {
        return id(eventFragment.format());
      }
      // Find a function definition by any means necessary (unless it is ambiguous)
      getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          for (const name2 in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name2)) {
              return this.functions[name2];
            }
          }
          logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name2 = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.functions).filter((f3) => f3.split(
            "("
            /* fix:) */
          )[0] === name2);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching function", "name", name2);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching functions", "name", name2);
          }
          return this.functions[matching[0]];
        }
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      // Find an event definition by any means necessary (unless it is ambiguous)
      getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
          const topichash = nameOrSignatureOrTopic.toLowerCase();
          for (const name2 in this.events) {
            if (topichash === this.getEventTopic(name2)) {
              return this.events[name2];
            }
          }
          logger14.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          const name2 = nameOrSignatureOrTopic.trim();
          const matching = Object.keys(this.events).filter((f3) => f3.split(
            "("
            /* fix:) */
          )[0] === name2);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching event", "name", name2);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching events", "name", name2);
          }
          return this.events[matching[0]];
        }
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      }
      // Find a function definition by any means necessary (unless it is ambiguous)
      getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          const getSighash = getStatic(this.constructor, "getSighash");
          for (const name2 in this.errors) {
            const error = this.errors[name2];
            if (nameOrSignatureOrSighash === getSighash(error)) {
              return this.errors[name2];
            }
          }
          logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name2 = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.errors).filter((f3) => f3.split(
            "("
            /* fix:) */
          )[0] === name2);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching error", "name", name2);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching errors", "name", name2);
          }
          return this.errors[matching[0]];
        }
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      // Get the sighash (the bytes4 selector) used by Solidity to identify a function
      getSighash(fragment) {
        if (typeof fragment === "string") {
          try {
            fragment = this.getFunction(fragment);
          } catch (error) {
            try {
              fragment = this.getError(fragment);
            } catch (_2) {
              throw error;
            }
          }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
      }
      // Get the topic (the bytes32 hash) used by Solidity to identify an event
      getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
      }
      _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
      }
      _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
      }
      encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      }
      decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
          logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
      }
      encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        return hexlify(concat([
          this.getSighash(fragment),
          this._encodeParams(fragment.inputs, values || [])
        ]));
      }
      // Decode the data for a function call (e.g. tx.data)
      decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
      }
      // Encode the data for a function call (e.g. tx.data)
      encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values || [])
        ]));
      }
      // Decode the result from a function call (e.g. from eth_call)
      decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes);
            } catch (error) {
            }
            break;
          case 4: {
            const selector = hexlify(bytes.slice(0, 4));
            const builtin = BuiltinErrors[selector];
            if (builtin) {
              errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
              errorName = builtin.name;
              errorSignature = builtin.signature;
              if (builtin.reason) {
                reason = errorArgs[0];
              }
            } else {
              try {
                const error = this.getError(selector);
                errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                errorName = error.name;
                errorSignature = error.format();
              } catch (error) {
              }
            }
            break;
          }
        }
        return logger14.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          errorArgs,
          errorName,
          errorSignature,
          reason
        });
      }
      // Encode the result for a function call (e.g. for eth_call)
      encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
      }
      // Create the filter for the event with search criteria (e.g. for eth_filterLog)
      encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
          logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
          });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return id(value);
          } else if (param.type === "bytes") {
            return keccak256(hexlify(value));
          }
          if (param.type === "address") {
            this._abiCoder.encode(["address"], [value]);
          }
          return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
          let param = eventFragment.inputs[index];
          if (!param.indexed) {
            if (value != null) {
              logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            }
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
          logger14.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
          const value = values[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push(id(value));
            } else if (param.type === "bytes") {
              topics.push(keccak256(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(this._abiCoder.encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      }
      // Decode a filter for the event and the search criteria
      decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          let topicHash = this.getEventTopic(eventFragment);
          if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index]) {
              result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
          } else {
            try {
              result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            const value = result[index];
            if (value instanceof Error) {
              Object.defineProperty(result, param.name, {
                enumerable: true,
                get: () => {
                  throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                }
              });
            } else {
              result[param.name] = value;
            }
          }
        });
        for (let i2 = 0; i2 < result.length; i2++) {
          const value = result[i2];
          if (value instanceof Error) {
            Object.defineProperty(result, i2, {
              enumerable: true,
              get: () => {
                throw wrapAccessError(`index ${i2}`, value);
              }
            });
          }
        }
        return Object.freeze(result);
      }
      // Given a transaction, find the matching function fragment (if any) and
      // determine all its properties and call parameters
      parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: BigNumber.from(tx.value || "0")
        });
      }
      // @TODO
      //parseCallResult(data: BytesLike): ??
      // Given an event log, find the matching event fragment (if any) and
      // determine all its properties and values
      parseLog(log2) {
        let fragment = this.getEvent(log2.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log2.data, log2.topics)
        });
      }
      parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new ErrorDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
          errorFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment)
        });
      }
      /*
      static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
          if (Interface.isInterface(value)) {
              return value;
          }
          if (typeof(value) === "string") {
              return new Interface(JSON.parse(value));
          }
          return new Interface(value);
      }
      */
      static isInterface(value) {
        return !!(value && value._isInterface);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/index.js
var init_lib11 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abi/lib.esm/index.js"() {
    "use strict";
    init_fragments();
    init_abi_coder();
    init_interface();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version11;
var init_version11 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js"() {
    version11 = "abstract-provider/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter3, logger15, ForkEvent, Provider;
var init_lib12 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abstract-provider/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib();
    init_version11();
    __awaiter3 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger15 = new Logger(version11);
    ForkEvent = class extends Description {
      static isForkEvent(value) {
        return !!(value && value._isForkEvent);
      }
    };
    Provider = class _Provider {
      constructor() {
        logger15.checkAbstract(new.target, _Provider);
        defineReadOnly(this, "_isProvider", true);
      }
      getFeeData() {
        return __awaiter3(this, void 0, void 0, function* () {
          const { block, gasPrice } = yield resolveProperties({
            block: this.getBlock("latest"),
            gasPrice: this.getGasPrice().catch((error) => {
              return null;
            })
          });
          let maxFeePerGas = null, maxPriorityFeePerGas = null;
          if (block && block.baseFeePerGas) {
            maxPriorityFeePerGas = BigNumber.from("1500000000");
            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
          }
          return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
      }
      // Alias for "on"
      addListener(eventName, listener) {
        return this.on(eventName, listener);
      }
      // Alias for "off"
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
      static isProvider(value) {
        return !!(value && value._isProvider);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version12;
var init_version12 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js"() {
    version12 = "abstract-signer/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter4, logger16, allowedTransactionKeys, forwardErrors, Signer, VoidSigner;
var init_lib13 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/abstract-signer/lib.esm/index.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version12();
    __awaiter4 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger16 = new Logger(version12);
    allowedTransactionKeys = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    forwardErrors = [
      Logger.errors.INSUFFICIENT_FUNDS,
      Logger.errors.NONCE_EXPIRED,
      Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    Signer = class _Signer {
      ///////////////////
      // Sub-classes MUST call super
      constructor() {
        logger16.checkAbstract(new.target, _Signer);
        defineReadOnly(this, "_isSigner", true);
      }
      ///////////////////
      // Sub-classes MAY override these
      getBalance(blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getBalance");
          return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
      }
      getTransactionCount(blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getTransactionCount");
          return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
      }
      // Populates "from" if unspecified, and estimates the gas for the transaction
      estimateGas(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("estimateGas");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.estimateGas(tx);
        });
      }
      // Populates "from" if unspecified, and calls with the transaction
      call(transaction, blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("call");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.call(tx, blockTag);
        });
      }
      // Populates all fields in a transaction, signs it and sends it to the network
      sendTransaction(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("sendTransaction");
          const tx = yield this.populateTransaction(transaction);
          const signedTx = yield this.signTransaction(tx);
          return yield this.provider.sendTransaction(signedTx);
        });
      }
      getChainId() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getChainId");
          const network = yield this.provider.getNetwork();
          return network.chainId;
        });
      }
      getGasPrice() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getGasPrice");
          return yield this.provider.getGasPrice();
        });
      }
      getFeeData() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getFeeData");
          return yield this.provider.getFeeData();
        });
      }
      resolveName(name2) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("resolveName");
          return yield this.provider.resolveName(name2);
        });
      }
      // Checks a transaction does not contain invalid keys and if
      // no "from" is provided, populates it.
      // - does NOT require a provider
      // - adds "from" is not present
      // - returns a COPY (safe to mutate the result)
      // By default called from: (overriding these prevents it)
      //   - call
      //   - estimateGas
      //   - populateTransaction (and therefor sendTransaction)
      checkTransaction(transaction) {
        for (const key2 in transaction) {
          if (allowedTransactionKeys.indexOf(key2) === -1) {
            logger16.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
          }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
          tx.from = this.getAddress();
        } else {
          tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
          ]).then((result) => {
            if (result[0].toLowerCase() !== result[1].toLowerCase()) {
              logger16.throwArgumentError("from address mismatch", "transaction", transaction);
            }
            return result[0];
          });
        }
        return tx;
      }
      // Populates ALL keys for a transaction and checks that "from" matches
      // this Signer. Should be used by sendTransaction but NOT by signTransaction.
      // By default called from: (overriding these prevents it)
      //   - sendTransaction
      //
      // Notes:
      //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
      populateTransaction(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          if (tx.to != null) {
            tx.to = Promise.resolve(tx.to).then((to) => __awaiter4(this, void 0, void 0, function* () {
              if (to == null) {
                return null;
              }
              const address = yield this.resolveName(to);
              if (address == null) {
                logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
              }
              return address;
            }));
            tx.to.catch((error) => {
            });
          }
          const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
          if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
            logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
          } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
            logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
          }
          if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
            tx.type = 2;
          } else if (tx.type === 0 || tx.type === 1) {
            if (tx.gasPrice == null) {
              tx.gasPrice = this.getGasPrice();
            }
          } else {
            const feeData = yield this.getFeeData();
            if (tx.type == null) {
              if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                tx.type = 2;
                if (tx.gasPrice != null) {
                  const gasPrice = tx.gasPrice;
                  delete tx.gasPrice;
                  tx.maxFeePerGas = gasPrice;
                  tx.maxPriorityFeePerGas = gasPrice;
                } else {
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
              } else if (feeData.gasPrice != null) {
                if (hasEip1559) {
                  logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                  });
                }
                if (tx.gasPrice == null) {
                  tx.gasPrice = feeData.gasPrice;
                }
                tx.type = 0;
              } else {
                logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "signer.getFeeData"
                });
              }
            } else if (tx.type === 2) {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          }
          if (tx.nonce == null) {
            tx.nonce = this.getTransactionCount("pending");
          }
          if (tx.gasLimit == null) {
            tx.gasLimit = this.estimateGas(tx).catch((error) => {
              if (forwardErrors.indexOf(error.code) >= 0) {
                throw error;
              }
              return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                error,
                tx
              });
            });
          }
          if (tx.chainId == null) {
            tx.chainId = this.getChainId();
          } else {
            tx.chainId = Promise.all([
              Promise.resolve(tx.chainId),
              this.getChainId()
            ]).then((results) => {
              if (results[1] !== 0 && results[0] !== results[1]) {
                logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
              }
              return results[0];
            });
          }
          return yield resolveProperties(tx);
        });
      }
      ///////////////////
      // Sub-classes SHOULD leave these alone
      _checkProvider(operation) {
        if (!this.provider) {
          logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
          });
        }
      }
      static isSigner(value) {
        return !!(value && value._isSigner);
      }
    };
    VoidSigner = class _VoidSigner extends Signer {
      constructor(address, provider) {
        logger16.checkNew(new.target, _VoidSigner);
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      _fail(message, operation) {
        return Promise.resolve().then(() => {
          logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
        });
      }
      signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
      }
      signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
      }
      _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
      }
      connect(provider) {
        return new _VoidSigner(this.address, provider);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
function createCommonjsModule(fn2, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
    }
  }, fn2(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
function Point(curve, x2, y2, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x2, 16);
    this.y = new import_bn2.default(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
function JPoint(curve, x2, y2, z2) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x2, 16);
    this.y = new import_bn2.default(y2, 16);
    this.z = new import_bn2.default(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var import_bn2, import_hash2, minimalisticAssert, utils_1, utils_1$1, getNAF, getJSF, assert$1, base, inherits_browser, assert$2, short_1, curve_1, curves_1, hmacDrbg, assert$3, key, assert$4, signature, rand, assert$5, ec, elliptic_1, EC$1;
var init_elliptic = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js"() {
    import_bn2 = __toESM(require_bn());
    import_hash2 = __toESM(require_hash());
    minimalisticAssert = assert;
    assert.equal = function assertEqual(l2, r2, msg) {
      if (l2 != r2)
        throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
    };
    utils_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var utils = exports;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i2 = 0; i2 < msg.length; i2++)
            res[i2] = msg[i2] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i2 = 0; i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        } else {
          for (var i2 = 0; i2 < msg.length; i2++) {
            var c2 = msg.charCodeAt(i2);
            var hi = c2 >> 8;
            var lo = c2 & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i2 = 0; i2 < msg.length; i2++)
          res += zero2(msg[i2].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode4(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    });
    utils_1$1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var utils = exports;
      utils.assert = minimalisticAssert;
      utils.toArray = utils_1.toArray;
      utils.zero2 = utils_1.zero2;
      utils.toHex = utils_1.toHex;
      utils.encode = utils_1.encode;
      function getNAF2(num, w2, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w2 + 1;
        var k2 = num.clone();
        for (var i2 = 0; i2 < naf.length; i2++) {
          var z2;
          var mod = k2.andln(ws - 1);
          if (k2.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z2 = (ws >> 1) - mod;
            else
              z2 = mod;
            k2.isubn(z2);
          } else {
            z2 = 0;
          }
          naf[i2] = z2;
          k2.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF2;
      function getJSF2(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF2;
      function cachedProperty(obj, name2, computer) {
        var key2 = "_" + name2;
        obj.prototype[name2] = function cachedProperty2() {
          return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new import_bn2.default(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    });
    getNAF = utils_1$1.getNAF;
    getJSF = utils_1$1.getJSF;
    assert$1 = utils_1$1.assert;
    base = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate2() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
      assert$1(p2.precomputed);
      var doubles = p2._getDoubles();
      var naf = getNAF(k2, 1, this._bitLength);
      var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I2 /= 3;
      var repr = [];
      var j2;
      var nafW;
      for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
        nafW = 0;
        for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
          nafW = (nafW << 1) + naf[l2];
        repr.push(nafW);
      }
      var a2 = this.jpoint(null, null, null);
      var b2 = this.jpoint(null, null, null);
      for (var i2 = I2; i2 > 0; i2--) {
        for (j2 = 0; j2 < repr.length; j2++) {
          nafW = repr[j2];
          if (nafW === i2)
            b2 = b2.mixedAdd(doubles.points[j2]);
          else if (nafW === -i2)
            b2 = b2.mixedAdd(doubles.points[j2].neg());
        }
        a2 = a2.add(b2);
      }
      return a2.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
      var w2 = 4;
      var nafPoints = p2._getNAFPoints(w2);
      w2 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k2, w2, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1; i2 >= 0; i2--) {
        for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
          l2++;
        if (i2 >= 0)
          l2++;
        acc = acc.dblp(l2);
        if (i2 < 0)
          break;
        var z2 = naf[i2];
        assert$1(z2 !== 0);
        if (p2.type === "affine") {
          if (z2 > 0)
            acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
        } else {
          if (z2 > 0)
            acc = acc.add(wnd[z2 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z2 - 1 >> 1].neg());
        }
      }
      return p2.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i2;
      var j2;
      var p2;
      for (i2 = 0; i2 < len; i2++) {
        p2 = points[i2];
        var nafPoints = p2._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd;
        wnd[i2] = nafPoints.points;
      }
      for (i2 = len - 1; i2 >= 1; i2 -= 2) {
        var a2 = i2 - 1;
        var b2 = i2;
        if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
          naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
          naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
          max = Math.max(naf[a2].length, max);
          max = Math.max(naf[b2].length, max);
          continue;
        }
        var comb = [
          points[a2],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b2]
          /* 7 */
        ];
        if (points[a2].y.cmp(points[b2].y) === 0) {
          comb[1] = points[a2].add(points[b2]);
          comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
        } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
          comb[1] = points[a2].toJ().mixedAdd(points[b2]);
          comb[2] = points[a2].add(points[b2].neg());
        } else {
          comb[1] = points[a2].toJ().mixedAdd(points[b2]);
          comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a2], coeffs[b2]);
        max = Math.max(jsf[0].length, max);
        naf[a2] = new Array(max);
        naf[b2] = new Array(max);
        for (j2 = 0; j2 < max; j2++) {
          var ja = jsf[0][j2] | 0;
          var jb = jsf[1][j2] | 0;
          naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b2][j2] = 0;
          wnd[a2] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i2 = max; i2 >= 0; i2--) {
        var k2 = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j2 = 0; j2 < len; j2++) {
            tmp[j2] = naf[j2][i2] | 0;
            if (tmp[j2] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k2++;
          i2--;
        }
        if (i2 >= 0)
          k2++;
        acc = acc.dblp(k2);
        if (i2 < 0)
          break;
        for (j2 = 0; j2 < len; j2++) {
          var z2 = tmp[j2];
          p2;
          if (z2 === 0)
            continue;
          else if (z2 > 0)
            p2 = wnd[j2][z2 - 1 >> 1];
          else if (z2 < 0)
            p2 = wnd[j2][-z2 - 1 >> 1].neg();
          if (p2.type === "affine")
            acc = acc.mixedAdd(p2);
          else
            acc = acc.add(p2);
        }
      }
      for (i2 = 0; i2 < len; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate3() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils_1$1.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert$1(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert$1(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x2 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x2);
      return [4].concat(x2, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode2(enc, compact) {
      return utils_1$1.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i2 = 0; i2 < power; i2 += step) {
        for (var j2 = 0; j2 < step; j2++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl3 = max === 1 ? null : this.dbl();
      for (var i2 = 1; i2 < max; i2++)
        res[i2] = res[i2 - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k2) {
      var r2 = this;
      for (var i2 = 0; i2 < k2; i2++)
        r2 = r2.dbl();
      return r2;
    };
    inherits_browser = createCommonjsModule(function(module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    });
    assert$2 = utils_1$1.assert;
    inherits_browser(ShortCurve, base);
    short_1 = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new import_bn2.default(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new import_bn2.default(vec.a, 16),
            b: new import_bn2.default(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : import_bn2.default.mont(num);
      var tinv = new import_bn2.default(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l2 = ntinv.redSub(s2).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u2 = lambda;
      var v2 = this.n.clone();
      var x1 = new import_bn2.default(1);
      var y1 = new import_bn2.default(0);
      var x2 = new import_bn2.default(0);
      var y2 = new import_bn2.default(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i2 = 0;
      var r2;
      var x3;
      while (u2.cmpn(0) !== 0) {
        var q2 = v2.div(u2);
        r2 = v2.sub(q2.mul(u2));
        x3 = x2.sub(q2.mul(x1));
        var y3 = y2.sub(q2.mul(y1));
        if (!a1 && r2.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r2.neg();
          b1 = x3;
        } else if (a1 && ++i2 === 2) {
          break;
        }
        prevR = r2;
        v2 = u2;
        u2 = r2;
        x2 = x1;
        x1 = x3;
        y2 = y1;
        y1 = y3;
      }
      a2 = r2.neg();
      b2 = x3;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
      var basis = this.endo.basis;
      var v12 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k2).divRound(this.n);
      var c2 = v12.b.neg().mul(k2).divRound(this.n);
      var p1 = c1.mul(v12.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v12.b);
      var q2 = c2.mul(v2.b);
      var k1 = k2.sub(p1).sub(p2);
      var k22 = q1.add(q2).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
      x2 = new import_bn2.default(x2, 16);
      if (!x2.red)
        x2 = x2.toRed(this.red);
      var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
      var y3 = y2.redSqrt();
      if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x2, y3);
    };
    ShortCurve.prototype.validate = function validate4(point3) {
      if (point3.inf)
        return true;
      var x2 = point3.x;
      var y2 = point3.y;
      var ax = this.a.redMul(x2);
      var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
      return y2.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i2 = 0; i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]);
        var p2 = points[i2];
        var beta = p2._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p2 = p2.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i2 * 2] = p2;
        npoints[i2 * 2 + 1] = beta;
        ncoeffs[i2 * 2] = split.k1;
        ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j2 = 0; j2 < i2 * 2; j2++) {
        npoints[j2] = null;
        ncoeffs[j2] = null;
      }
      return res;
    };
    inherits_browser(Point, base.BasePoint);
    ShortCurve.prototype.point = function point2(x2, y2, isRed) {
      return new Point(this, x2, y2, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta2() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p2) {
          return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p2) {
      if (this.inf)
        return p2;
      if (p2.inf)
        return this;
      if (this.eq(p2))
        return this.dbl();
      if (this.neg().eq(p2))
        return this.curve.point(null, null);
      if (this.x.cmp(p2.x) === 0)
        return this.curve.point(null, null);
      var c2 = this.y.redSub(p2.y);
      if (c2.cmpn(0) !== 0)
        c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
      var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a2 = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
      var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k2) {
      k2 = new import_bn2.default(k2, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k2]);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq2(p2) {
      return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p2) {
          return p2.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    inherits_browser(JPoint, base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x2, y2, z2) {
      return new JPoint(this, x2, y2, z2);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg2() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add2(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      var pz2 = p2.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p2.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p2.z));
      var s2 = p2.y.redMul(z2.redMul(this.z));
      var h2 = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h2.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h2.redSqr();
      var h3 = h22.redMul(h2);
      var v2 = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
      var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p2.z).redMul(h2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p2) {
      if (this.isInfinity())
        return p2.toJ();
      if (p2.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p2.x.redMul(z2);
      var s1 = this.y;
      var s2 = p2.y.redMul(z2).redMul(this.z);
      var h2 = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h2.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h2.redSqr();
      var h3 = h22.redMul(h2);
      var v2 = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
      var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp2(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i2 = 0; i2 < pow; i2++)
          r2 = r2.dbl();
        return r2;
      }
      var a2 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i2 = 0; i2 < pow; i2++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c2.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c2.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl2() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t2 = m.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t2;
        ny = m.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a2 = this.x.redSqr();
        var b2 = this.y.redSqr();
        var c2 = b2.redSqr();
        var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
        d2 = d2.redIAdd(d2);
        var e = a2.redAdd(a2).redIAdd(a2);
        var f3 = e.redSqr();
        var c8 = c2.redIAdd(c2);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f3.redISub(d2).redISub(d2);
        ny = e.redMul(d2.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t2 = m.redSqr().redISub(s2).redISub(s2);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a2 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c2.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c2.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      var u2 = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t2);
      var yyu4 = yy.redMul(u2);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul2(k2, kbase) {
      k2 = new import_bn2.default(k2, kbase);
      return this.curve._wnafMul(this, k2);
    };
    JPoint.prototype.eq = function eq3(p2) {
      if (p2.type === "affine")
        return this.eq(p2.toJ());
      if (this === p2)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p2.z.redSqr();
      if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p2.z);
      return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x2) {
      var zs = this.z.redSqr();
      var rx = x2.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x2.clone();
      var t2 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity2() {
      return this.z.cmpn(0) === 0;
    };
    curve_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var curve = exports;
      curve.base = base;
      curve.short = short_1;
      curve.mont = /*RicMoo:ethers:require(./mont)*/
      null;
      curve.edwards = /*RicMoo:ethers:require(./edwards)*/
      null;
    });
    curves_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var curves = exports;
      var assert2 = utils_1$1.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve_1.short(options);
        else if (options.type === "edwards")
          this.curve = new curve_1.edwards(options);
        else
          this.curve = new curve_1.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert2(this.g.validate(), "Invalid curve");
        assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name2, options) {
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name2, {
              configurable: true,
              enumerable: true,
              value: curve
            });
            return curve;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: import_hash2.default.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: import_hash2.default.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
        null.crash();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: import_hash2.default.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    });
    hmacDrbg = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i2 = 0; i2 < this.V.length; i2++) {
        this.K[i2] = 0;
        this.V[i2] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new import_hash2.default.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add3;
        add3 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils_1.toArray(entropy, entropyEnc);
      add3 = utils_1.toArray(add3, addEnc);
      minimalisticAssert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add3 || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add3;
        add3 = enc;
        enc = null;
      }
      if (add3) {
        add3 = utils_1.toArray(add3, addEnc || "hex");
        this._update(add3);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add3);
      this._reseed++;
      return utils_1.encode(res, enc);
    };
    assert$3 = utils_1$1.assert;
    key = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate5() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
      this.priv = new import_bn2.default(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert$3(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert$3(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert$3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    };
    KeyPair.prototype.inspect = function inspect3() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    assert$4 = utils_1$1.assert;
    signature = Signature;
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils_1$1.toArray(data, enc);
      var p2 = new Position();
      if (data[p2.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p2);
      if (len === false) {
        return false;
      }
      if (len + p2.place !== data.length) {
        return false;
      }
      if (data[p2.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p2);
      if (rlen === false) {
        return false;
      }
      var r2 = data.slice(p2.place, rlen + p2.place);
      p2.place += rlen;
      if (data[p2.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p2);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p2.place) {
        return false;
      }
      var s2 = data.slice(p2.place, slen + p2.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new import_bn2.default(r2);
      this.s = new import_bn2.default(s2);
      this.recoveryParam = null;
      return true;
    };
    Signature.prototype.toDER = function toDER(enc) {
      var r2 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r2 = rmPadding(r2);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils_1$1.encode(res, enc);
    };
    rand = /*RicMoo:ethers:require(brorand)*/
    function() {
      throw new Error("unsupported");
    };
    assert$5 = utils_1$1.assert;
    ec = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new key(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return key.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return key.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new hmacDrbg({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new import_bn2.default(2));
      for (; ; ) {
        var priv = new import_bn2.default(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new hmacDrbg({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new import_bn2.default(1));
      for (var iter = 0; ; iter++) {
        var k2 = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
        k2 = this._truncateToN(k2, true);
        if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k2);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new signature({ r: r2, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature$1 = new signature(signature$1, "hex");
      var r2 = signature$1.r;
      var s2 = signature$1.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r2).umod(this.n);
      var p2;
      if (!this.curve._maxwellTrick) {
        p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
        if (p2.isInfinity())
          return false;
        return p2.getX().umod(this.n).cmp(r2) === 0;
      }
      p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.eqXToP(r2);
    };
    EC.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
      assert$5((3 & j2) === j2, "The recovery param is more than two bits");
      signature$1 = new signature(signature$1, enc);
      var n2 = this.n;
      var e = new import_bn2.default(msg);
      var r2 = signature$1.r;
      var s2 = signature$1.s;
      var isYOdd = j2 & 1;
      var isSecondKey = j2 >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature$1.r.invm(n2);
      var s1 = n2.sub(e).mul(rInv).umod(n2);
      var s22 = s2.mul(rInv).umod(n2);
      return this.g.mulAdd(s1, r2, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q2, enc) {
      signature$1 = new signature(signature$1, enc);
      if (signature$1.recoveryParam !== null)
        return signature$1.recoveryParam;
      for (var i2 = 0; i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature$1, i2);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q2))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    elliptic_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var elliptic = exports;
      elliptic.version = /*RicMoo:ethers*/
      { version: "6.5.4" }.version;
      elliptic.utils = utils_1$1;
      elliptic.rand = /*RicMoo:ethers:require(brorand)*/
      function() {
        throw new Error("unsupported");
      };
      elliptic.curve = curve_1;
      elliptic.curves = curves_1;
      elliptic.ec = ec;
      elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
      null;
    });
    EC$1 = elliptic_1.ec;
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version13;
var init_version13 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/signing-key/lib.esm/_version.js"() {
    version13 = "signing-key/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/signing-key/lib.esm/index.js
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
function recoverPublicKey(digest, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var logger17, _curve, SigningKey;
var init_lib14 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/signing-key/lib.esm/index.js"() {
    "use strict";
    init_elliptic();
    init_lib2();
    init_lib4();
    init_lib();
    init_version13();
    logger17 = new Logger(version13);
    _curve = null;
    SigningKey = class {
      constructor(privateKey) {
        defineReadOnly(this, "curve", "secp256k1");
        defineReadOnly(this, "privateKey", hexlify(privateKey));
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
        defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
        defineReadOnly(this, "_isSigningKey", true);
      }
      _addPoint(other) {
        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
        const p1 = getCurve().keyFromPublic(arrayify(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
      }
      signDigest(digest) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const digestBytes = arrayify(digest);
        if (digestBytes.length !== 32) {
          logger17.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature2 = keyPair2.sign(digestBytes, { canonical: true });
        return splitSignature({
          recoveryParam: signature2.recoveryParam,
          r: hexZeroPad("0x" + signature2.r.toString(16), 32),
          s: hexZeroPad("0x" + signature2.s.toString(16), 32)
        });
      }
      computeSharedSecret(otherKey) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
        return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
      }
      static isSigningKey(value) {
        return !!(value && value._isSigningKey);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/transactions/lib.esm/_version.js
var version14;
var init_version14 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/transactions/lib.esm/_version.js"() {
    version14 = "transactions/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/transactions/lib.esm/index.js
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero2;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger18.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode(raw);
  }
  const sig = splitSignature(signature2);
  let v2 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v2 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v2) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v2) {
    logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v2));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest = keccak256(serialize3(tx));
    tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip1559(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak256(encode(raw));
    try {
      tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse2(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
var logger18, TransactionTypes, transactionFields, allowedTransactionKeys2;
var init_lib15 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/transactions/lib.esm/index.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib5();
    init_lib4();
    init_lib6();
    init_lib14();
    init_lib();
    init_version14();
    logger18 = new Logger(version14);
    (function(TransactionTypes2) {
      TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
      TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
      TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
    })(TransactionTypes || (TransactionTypes = {}));
    transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    allowedTransactionKeys2 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/contracts/lib.esm/_version.js
var version15;
var init_version15 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/contracts/lib.esm/_version.js"() {
    version15 = "contracts/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/contracts/lib.esm/index.js
function resolveName(resolver, nameOrPromise) {
  return __awaiter5(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger19.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger19.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v2) => resolveAddresses(resolver, v2, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter5(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter5(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        intrinsic += 4;
        if (bytes[i2]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger19.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log2) => {
        let event = deepCopy(log2);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log2);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var __awaiter5, logger19, allowedTransactionKeys3, RunningEvent, ErrorRunningEvent, FragmentRunningEvent, WildcardRunningEvent, BaseContract, Contract, ContractFactory;
var init_lib16 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/contracts/lib.esm/index.js"() {
    "use strict";
    init_lib11();
    init_lib12();
    init_lib13();
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib15();
    init_lib();
    init_version15();
    __awaiter5 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger19 = new Logger(version15);
    allowedTransactionKeys3 = {
      chainId: true,
      data: true,
      from: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      customData: true,
      ccipReadEnabled: true
    };
    RunningEvent = class {
      constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
      }
      addListener(listener, once) {
        this._listeners.push({ listener, once });
      }
      removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
          if (done || item.listener !== listener) {
            return true;
          }
          done = true;
          return false;
        });
      }
      removeAllListeners() {
        this._listeners = [];
      }
      listeners() {
        return this._listeners.map((i2) => i2.listener);
      }
      listenerCount() {
        return this._listeners.length;
      }
      run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
          const argsCopy = args.slice();
          setTimeout(() => {
            item.listener.apply(this, argsCopy);
          }, 0);
          return !item.once;
        });
        return listenerCount;
      }
      prepareEvent(event) {
      }
      // Returns the array that will be applied to an emit
      getEmit(event) {
        return [event];
      }
    };
    ErrorRunningEvent = class extends RunningEvent {
      constructor() {
        super("error", null);
      }
    };
    FragmentRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface, fragment, topics) {
        const filter = {
          address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
          if (topic !== topics[0]) {
            logger19.throwArgumentError("topic mismatch", "topics", topics);
          }
          filter.topics = topics.slice();
        } else {
          filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
          return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
          event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
          event.args = null;
          event.decodeError = error;
        }
      }
      getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
          throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
      }
    };
    WildcardRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface) {
        super("*", { address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        try {
          const parsed = this.interface.parseLog(event);
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
          event.decode = (data, topics) => {
            return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.args = parsed.args;
        } catch (error) {
        }
      }
    };
    BaseContract = class {
      constructor(addressOrName, contractInterface, signerOrProvider) {
        logger19.checkNew(new.target, Contract);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
          defineReadOnly(this, "provider", null);
          defineReadOnly(this, "signer", null);
        } else if (Signer.isSigner(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider.provider || null);
          defineReadOnly(this, "signer", signerOrProvider);
        } else if (Provider.isProvider(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider);
          defineReadOnly(this, "signer", null);
        } else {
          logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
          const uniqueFilters = {};
          Object.keys(this.interface.events).forEach((eventSignature) => {
            const event = this.interface.events[eventSignature];
            defineReadOnly(this.filters, eventSignature, (...args) => {
              return {
                address: this.address,
                topics: this.interface.encodeFilterTopics(event, args)
              };
            });
            if (!uniqueFilters[event.name]) {
              uniqueFilters[event.name] = [];
            }
            uniqueFilters[event.name].push(eventSignature);
          });
          Object.keys(uniqueFilters).forEach((name2) => {
            const filters = uniqueFilters[name2];
            if (filters.length === 1) {
              defineReadOnly(this.filters, name2, this.filters[filters[0]]);
            } else {
              logger19.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
            }
          });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
          logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
          defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        } else {
          try {
            defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
          } catch (error) {
            logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Contract"
            });
          }
        }
        this.resolvedAddress.catch((e) => {
        });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature2) => {
          const fragment = this.interface.functions[signature2];
          if (uniqueSignatures[signature2]) {
            logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
            return;
          }
          uniqueSignatures[signature2] = true;
          {
            const name2 = fragment.name;
            if (!uniqueNames[`%${name2}`]) {
              uniqueNames[`%${name2}`] = [];
            }
            uniqueNames[`%${name2}`].push(signature2);
          }
          if (this[signature2] == null) {
            defineReadOnly(this, signature2, buildDefault(this, fragment, true));
          }
          if (this.functions[signature2] == null) {
            defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
          }
          if (this.callStatic[signature2] == null) {
            defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
          }
          if (this.populateTransaction[signature2] == null) {
            defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
          }
          if (this.estimateGas[signature2] == null) {
            defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
          }
        });
        Object.keys(uniqueNames).forEach((name2) => {
          const signatures = uniqueNames[name2];
          if (signatures.length > 1) {
            return;
          }
          name2 = name2.substring(1);
          const signature2 = signatures[0];
          try {
            if (this[name2] == null) {
              defineReadOnly(this, name2, this[signature2]);
            }
          } catch (e) {
          }
          if (this.functions[name2] == null) {
            defineReadOnly(this.functions, name2, this.functions[signature2]);
          }
          if (this.callStatic[name2] == null) {
            defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
          }
          if (this.populateTransaction[name2] == null) {
            defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
          }
          if (this.estimateGas[name2] == null) {
            defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
          }
        });
      }
      static getContractAddress(transaction) {
        return getContractAddress(transaction);
      }
      static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
          return contractInterface;
        }
        return new Interface(contractInterface);
      }
      // @TODO: Allow timeout?
      deployed() {
        return this._deployed();
      }
      _deployed(blockTag) {
        if (!this._deployedPromise) {
          if (this.deployTransaction) {
            this._deployedPromise = this.deployTransaction.wait().then(() => {
              return this;
            });
          } else {
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
              if (code === "0x") {
                logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                  contractAddress: this.address,
                  operation: "getDeployed"
                });
              }
              return this;
            });
          }
        }
        return this._deployedPromise;
      }
      // @TODO:
      // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
      // @TODO:
      // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
      fallback(overrides) {
        if (!this.signer) {
          logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function(key2) {
          if (tx[key2] == null) {
            return;
          }
          logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
          return this.signer.sendTransaction(tx);
        });
      }
      // Reconnect to a different signer or provider
      connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") {
          signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
          defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
      }
      // Re-attach to a different on-chain instance of this contract
      attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
      }
      static isIndexed(value) {
        return Indexed.isIndexed(value);
      }
      _normalizeRunningEvent(runningEvent) {
        if (this._runningEvents[runningEvent.tag]) {
          return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
      }
      _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
          if (eventName === "error") {
            return this._normalizeRunningEvent(new ErrorRunningEvent());
          }
          if (eventName === "event") {
            return this._normalizeRunningEvent(new RunningEvent("event", null));
          }
          if (eventName === "*") {
            return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
          }
          const fragment = this.interface.getEvent(eventName);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        if (eventName.topics && eventName.topics.length > 0) {
          try {
            const topic = eventName.topics[0];
            if (typeof topic !== "string") {
              throw new Error("invalid topic");
            }
            const fragment = this.interface.getEvent(topic);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
          } catch (error) {
          }
          const filter = {
            address: this.address,
            topics: eventName.topics
          };
          return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
          delete this._runningEvents[runningEvent.tag];
          const emit = this._wrappedEmits[runningEvent.tag];
          if (emit && runningEvent.filter) {
            this.provider.off(runningEvent.filter, emit);
            delete this._wrappedEmits[runningEvent.tag];
          }
        }
      }
      // Subclasses can override this to gracefully recover
      // from parse errors if they wish
      _wrapEvent(runningEvent, log2, listener) {
        const event = deepCopy(log2);
        event.removeListener = () => {
          if (!listener) {
            return;
          }
          runningEvent.removeListener(listener);
          this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => {
          return this.provider.getBlock(log2.blockHash);
        };
        event.getTransaction = () => {
          return this.provider.getTransaction(log2.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return this.provider.getTransactionReceipt(log2.transactionHash);
        };
        runningEvent.prepareEvent(event);
        return event;
      }
      _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
          logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        this._runningEvents[runningEvent.tag] = runningEvent;
        if (!this._wrappedEmits[runningEvent.tag]) {
          const wrappedEmit = (log2) => {
            let event = this._wrapEvent(runningEvent, log2, listener);
            if (event.decodeError == null) {
              try {
                const args = runningEvent.getEmit(event);
                this.emit(runningEvent.filter, ...args);
              } catch (error) {
                event.decodeError = error.error;
              }
            }
            if (runningEvent.filter != null) {
              this.emit("event", event);
            }
            if (event.decodeError != null) {
              this.emit("error", event.decodeError, event);
            }
          };
          this._wrappedEmits[runningEvent.tag] = wrappedEmit;
          if (runningEvent.filter != null) {
            this.provider.on(runningEvent.filter, wrappedEmit);
          }
        }
      }
      queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
          if (toBlock != null) {
            logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
          }
          filter.blockHash = fromBlockOrBlockhash;
        } else {
          filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
          filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs) => {
          return logs.map((log2) => this._wrapEvent(runningEvent, log2, null));
        });
      }
      on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
      }
      once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
      }
      emit(eventName, ...args) {
        if (!this.provider) {
          return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        this._checkRunningEvents(runningEvent);
        return result;
      }
      listenerCount(eventName) {
        if (!this.provider) {
          return 0;
        }
        if (eventName == null) {
          return Object.keys(this._runningEvents).reduce((accum, key2) => {
            return accum + this._runningEvents[key2].listenerCount();
          }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
      }
      listeners(eventName) {
        if (!this.provider) {
          return [];
        }
        if (eventName == null) {
          const result = [];
          for (let tag in this._runningEvents) {
            this._runningEvents[tag].listeners().forEach((listener) => {
              result.push(listener);
            });
          }
          return result;
        }
        return this._getRunningEvent(eventName).listeners();
      }
      removeAllListeners(eventName) {
        if (!this.provider) {
          return this;
        }
        if (eventName == null) {
          for (const tag in this._runningEvents) {
            const runningEvent2 = this._runningEvents[tag];
            runningEvent2.removeAllListeners();
            this._checkRunningEvents(runningEvent2);
          }
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
      }
      off(eventName, listener) {
        if (!this.provider) {
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
    };
    Contract = class extends BaseContract {
    };
    ContractFactory = class {
      constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof bytecode === "string") {
          bytecodeHex = bytecode;
        } else if (isBytes(bytecode)) {
          bytecodeHex = hexlify(bytecode);
        } else if (bytecode && typeof bytecode.object === "string") {
          bytecodeHex = bytecode.object;
        } else {
          bytecodeHex = "!";
        }
        if (bytecodeHex.substring(0, 2) !== "0x") {
          bytecodeHex = "0x" + bytecodeHex;
        }
        if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
          logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        if (signer && !Signer.isSigner(signer)) {
          logger19.throwArgumentError("invalid signer", "signer", signer);
        }
        defineReadOnly(this, "bytecode", bytecodeHex);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        defineReadOnly(this, "signer", signer || null);
      }
      // @TODO: Future; rename to populateTransaction?
      getDeployTransaction(...args) {
        let tx = {};
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          tx = shallowCopy(args.pop());
          for (const key2 in tx) {
            if (!allowedTransactionKeys3[key2]) {
              throw new Error("unknown transaction override " + key2);
            }
          }
        }
        ["data", "from", "to"].forEach((key2) => {
          if (tx[key2] == null) {
            return;
          }
          logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
        });
        if (tx.value) {
          const value = BigNumber.from(tx.value);
          if (!value.isZero() && !this.interface.deploy.payable) {
            logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.value",
              value: tx.value
            });
          }
        }
        logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        tx.data = hexlify(concat([
          this.bytecode,
          this.interface.encodeDeploy(args)
        ]));
        return tx;
      }
      deploy(...args) {
        return __awaiter5(this, void 0, void 0, function* () {
          let overrides = {};
          if (args.length === this.interface.deploy.inputs.length + 1) {
            overrides = args.pop();
          }
          logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
          const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
          params.push(overrides);
          const unsignedTx = this.getDeployTransaction(...params);
          const tx = yield this.signer.sendTransaction(unsignedTx);
          const address = getStatic(this.constructor, "getContractAddress")(tx);
          const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
          addContractWait(contract, tx);
          defineReadOnly(contract, "deployTransaction", tx);
          return contract;
        });
      }
      attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
      }
      connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
      }
      static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
          logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof compilerOutput === "string") {
          compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
          bytecode = compilerOutput.bytecode;
        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
          bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
      }
      static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
      }
      static getContractAddress(tx) {
        return getContractAddress(tx);
      }
      static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX, Base32, Base58;
var init_lib17 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/basex/lib.esm/index.js"() {
    init_lib2();
    init_lib4();
    BaseX = class {
      constructor(alphabet) {
        defineReadOnly(this, "alphabet", alphabet);
        defineReadOnly(this, "base", alphabet.length);
        defineReadOnly(this, "_alphabetMap", {});
        defineReadOnly(this, "_leader", alphabet.charAt(0));
        for (let i2 = 0; i2 < alphabet.length; i2++) {
          this._alphabetMap[alphabet.charAt(i2)] = i2;
        }
      }
      encode(value) {
        let source = arrayify(value);
        if (source.length === 0) {
          return "";
        }
        let digits = [0];
        for (let i2 = 0; i2 < source.length; ++i2) {
          let carry = source[i2];
          for (let j2 = 0; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        let string = "";
        for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
          string += this._leader;
        }
        for (let q2 = digits.length - 1; q2 >= 0; --q2) {
          string += this.alphabet[digits[q2]];
        }
        return string;
      }
      decode(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value.length === 0) {
          return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i2 = 0; i2 < value.length; i2++) {
          let byte = this._alphabetMap[value[i2]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          let carry = byte;
          for (let j2 = 0; j2 < bytes.length; ++j2) {
            carry += bytes[j2] * this.base;
            bytes[j2] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
          bytes.push(0);
        }
        return arrayify(new Uint8Array(bytes.reverse()));
      }
    };
    Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
var init_types = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/types.js"() {
    (function(SupportedAlgorithm2) {
      SupportedAlgorithm2["sha256"] = "sha256";
      SupportedAlgorithm2["sha512"] = "sha512";
    })(SupportedAlgorithm || (SupportedAlgorithm = {}));
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/_version.js
var version16;
var init_version16 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/_version.js"() {
    version16 = "sha2/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/sha2.js
function ripemd160(data) {
  return "0x" + import_hash3.default.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256(data) {
  return "0x" + import_hash3.default.sha256().update(arrayify(data)).digest("hex");
}
function sha512(data) {
  return "0x" + import_hash3.default.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key2, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger20.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify(key2)).update(arrayify(data)).digest("hex");
}
var import_hash3, logger20;
var init_sha2 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/sha2.js"() {
    "use strict";
    import_hash3 = __toESM(require_hash());
    init_lib2();
    init_types();
    init_lib();
    init_version16();
    logger20 = new Logger(version16);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/index.js
var init_lib18 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/sha2/lib.esm/index.js"() {
    init_sha2();
    init_types();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T;
  for (let i2 = 1; i2 <= l2; i2++) {
    block1[salt.length] = i2 >> 24 & 255;
    block1[salt.length + 1] = i2 >> 16 & 255;
    block1[salt.length + 2] = i2 >> 8 & 255;
    block1[salt.length + 3] = i2 & 255;
    let U2 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r2 = keylen - (l2 - 1) * hLen;
    }
    T.set(U2);
    for (let j2 = 1; j2 < iterations; j2++) {
      U2 = arrayify(computeHmac(hashAlgorithm, password, U2));
      for (let k2 = 0; k2 < hLen; k2++)
        T[k2] ^= U2[k2];
    }
    const destPos = (i2 - 1) * hLen;
    const len = i2 === l2 ? r2 : hLen;
    DK.set(arrayify(T).slice(0, len), destPos);
  }
  return hexlify(DK);
}
var init_pbkdf2 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js"() {
    "use strict";
    init_lib2();
    init_lib18();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/pbkdf2/lib.esm/index.js
var init_lib19 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/pbkdf2/lib.esm/index.js"() {
    init_pbkdf2();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version17;
var init_version17 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/_version.js"() {
    version17 = "wordlists/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist, logger21, Wordlist;
var init_wordlist = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js"() {
    "use strict";
    init_lib10();
    init_lib4();
    init_lib();
    init_version17();
    exportWordlist = false;
    logger21 = new Logger(version17);
    Wordlist = class _Wordlist {
      constructor(locale) {
        logger21.checkAbstract(new.target, _Wordlist);
        defineReadOnly(this, "locale", locale);
      }
      // Subclasses may override this
      split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
      }
      // Subclasses may override this
      join(words2) {
        return words2.join(" ");
      }
      static check(wordlist2) {
        const words2 = [];
        for (let i2 = 0; i2 < 2048; i2++) {
          const word = wordlist2.getWord(i2);
          if (i2 !== wordlist2.getWordIndex(word)) {
            return "0x";
          }
          words2.push(word);
        }
        return id(words2.join("\n") + "\n");
      }
      static register(lang, name2) {
        if (!name2) {
          name2 = lang.locale;
        }
        if (exportWordlist) {
          try {
            const anyGlobal2 = window;
            if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
              if (!anyGlobal2._ethers.wordlists[name2]) {
                defineReadOnly(anyGlobal2._ethers.wordlists, name2, lang);
              }
            }
          } catch (error) {
          }
        }
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var words, wordlist, LangEn, langEn;
var init_lang_en = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js"() {
    "use strict";
    init_wordlist();
    words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    wordlist = null;
    LangEn = class extends Wordlist {
      constructor() {
        super("en");
      }
      getWord(index) {
        loadWords(this);
        return wordlist[index];
      }
      getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      }
    };
    langEn = new LangEn();
    Wordlist.register(langEn);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists;
var init_wordlists = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js"() {
    "use strict";
    init_lang_en();
    wordlists = {
      en: langEn
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/index.js
var init_lib20 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wordlists/lib.esm/index.js"() {
    "use strict";
    init_wordlist();
    init_wordlists();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version18;
var init_version18 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hdnode/lib.esm/_version.js"() {
    version18 = "hdnode/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/hdnode/lib.esm/index.js
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger22.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger22.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i2 = 0; i2 < words2.length; i2++) {
    let index = wordlist2.getWordIndex(words2[i2].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger22.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}
var logger22, N, MasterSecret, HardenedBit, _constructorGuard4, defaultPath, HDNode;
var init_lib21 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/hdnode/lib.esm/index.js"() {
    "use strict";
    init_lib17();
    init_lib2();
    init_lib3();
    init_lib9();
    init_lib19();
    init_lib4();
    init_lib14();
    init_lib18();
    init_lib15();
    init_lib20();
    init_lib();
    init_version18();
    logger22 = new Logger(version18);
    N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    MasterSecret = toUtf8Bytes("Bitcoin seed");
    HardenedBit = 2147483648;
    _constructorGuard4 = {};
    defaultPath = "m/44'/60'/0'/0/0";
    HDNode = class _HDNode {
      /**
       *  This constructor should not be called directly.
       *
       *  Please use:
       *   - fromMnemonic
       *   - fromSeed
       */
      constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        logger22.checkNew(new.target, _HDNode);
        if (constructorGuard !== _constructorGuard4) {
          throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
          const signingKey = new SigningKey(privateKey);
          defineReadOnly(this, "privateKey", signingKey.privateKey);
          defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
        } else {
          defineReadOnly(this, "privateKey", null);
          defineReadOnly(this, "publicKey", hexlify(publicKey));
        }
        defineReadOnly(this, "parentFingerprint", parentFingerprint);
        defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        defineReadOnly(this, "chainCode", chainCode);
        defineReadOnly(this, "index", index);
        defineReadOnly(this, "depth", depth);
        if (mnemonicOrPath == null) {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", mnemonicOrPath);
        } else {
          defineReadOnly(this, "mnemonic", mnemonicOrPath);
          defineReadOnly(this, "path", mnemonicOrPath.path);
        }
      }
      get extendedKey() {
        if (this.depth >= 256) {
          throw new Error("Depth too large!");
        }
        return base58check(concat([
          this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
          hexlify(this.depth),
          this.parentFingerprint,
          hexZeroPad(hexlify(this.index), 4),
          this.chainCode,
          this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
        ]));
      }
      neuter() {
        return new _HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
      }
      _derive(index) {
        if (index > 4294967295) {
          throw new Error("invalid index - " + String(index));
        }
        let path = this.path;
        if (path) {
          path += "/" + (index & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
          if (!this.privateKey) {
            throw new Error("cannot derive child of neutered node");
          }
          data.set(arrayify(this.privateKey), 1);
          if (path) {
            path += "'";
          }
        } else {
          data.set(arrayify(this.publicKey));
        }
        for (let i2 = 24; i2 >= 0; i2 -= 8) {
          data[33 + (i2 >> 3)] = index >> 24 - i2 & 255;
        }
        const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
        const IL = I2.slice(0, 32);
        const IR = I2.slice(32);
        let ki = null;
        let Ki = null;
        if (this.privateKey) {
          ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
        } else {
          const ek = new SigningKey(hexlify(IL));
          Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
          mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path,
            locale: srcMnemonic.locale || "en"
          });
        }
        return new _HDNode(_constructorGuard4, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
      }
      derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
          throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
          components.shift();
        }
        let result = this;
        for (let i2 = 0; i2 < components.length; i2++) {
          const component = components[i2];
          if (component.match(/^[0-9]+'$/)) {
            const index = parseInt(component.substring(0, component.length - 1));
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(HardenedBit + index);
          } else if (component.match(/^[0-9]+$/)) {
            const index = parseInt(component);
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(index);
          } else {
            throw new Error("invalid path component - " + component);
          }
        }
        return result;
      }
      static _fromSeed(seed, mnemonic) {
        const seedArray = arrayify(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
          throw new Error("invalid seed");
        }
        const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new _HDNode(_constructorGuard4, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
      }
      static fromMnemonic(mnemonic, password, wordlist2) {
        wordlist2 = getWordlist(wordlist2);
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
        return _HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
          phrase: mnemonic,
          path: "m",
          locale: wordlist2.locale
        });
      }
      static fromSeed(seed) {
        return _HDNode._fromSeed(seed, null);
      }
      static fromExtendedKey(extendedKey) {
        const bytes = Base58.decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
          logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes[4];
        const parentFingerprint = hexlify(bytes.slice(5, 9));
        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = hexlify(bytes.slice(13, 45));
        const key2 = bytes.slice(45, 78);
        switch (hexlify(bytes.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf":
            return new _HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
          case "0x0488ade4":
          case "0x04358394 ":
            if (key2[0] !== 0) {
              break;
            }
            return new _HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/_version.js
var version19;
var init_version19 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/_version.js"() {
    version19 = "random/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/random.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger23.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto2.getRandomValues(result);
  return arrayify(result);
}
var logger23, anyGlobal, crypto2;
var init_random = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/random.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version19();
    logger23 = new Logger(version19);
    anyGlobal = getGlobal();
    crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto2 || !crypto2.getRandomValues) {
      logger23.warn("WARNING: Missing strong random number source");
      crypto2 = {
        getRandomValues: function(buffer) {
          return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array) {
  array = array.slice();
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j2];
    array[j2] = tmp;
  }
  return array;
}
var init_shuffle = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/shuffle.js"() {
    "use strict";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/index.js
var init_lib22 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/random/lib.esm/index.js"() {
    "use strict";
    init_random();
    init_shuffle();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version20;
var init_version20 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/_version.js"() {
    version20 = "json-wallets/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i2 = 0; i2 < comps.length; i2++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i2]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes = arrayify(randomBytes2);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
var init_utils = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/utils.js"() {
    "use strict";
    init_lib2();
    init_lib9();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
function decrypt(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger24.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i2 = 0; i2 < seed.length; i2++) {
    seedHex += String.fromCharCode(seed[i2]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
var import_aes_js, logger24, CrowdsaleAccount;
var init_crowdsale = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js"() {
    "use strict";
    import_aes_js = __toESM(require_aes_js());
    init_lib7();
    init_lib2();
    init_lib5();
    init_lib19();
    init_lib9();
    init_lib4();
    init_lib();
    init_version20();
    init_utils();
    logger24 = new Logger(version20);
    CrowdsaleAccount = class extends Description {
      isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var init_inspect = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/inspect.js"() {
    "use strict";
    init_lib7();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = function(name2, value) {
      return logger25.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N2 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p2 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N2 || !r2 || !p2) {
        throwError("kdf", kdf);
      }
      if ((N2 & N2 - 1) !== 0) {
        throwError("N", N2);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N2, r2, p2, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter6(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key2 = yield _computeKdfKey(data, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e) {
    return Promise.reject(e);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
    ;
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N2 = 1 << 17, r2 = 8, p2 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p2 = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N2, r2, p2, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N2,
          dklen: 32,
          p: p2,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = /* @__PURE__ */ new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
var import_aes_js2, import_scrypt_js, __awaiter6, logger25, KeystoreAccount;
var init_keystore = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js"() {
    "use strict";
    import_aes_js2 = __toESM(require_aes_js());
    import_scrypt_js = __toESM(require_scrypt());
    init_lib7();
    init_lib2();
    init_lib21();
    init_lib5();
    init_lib19();
    init_lib22();
    init_lib4();
    init_lib15();
    init_utils();
    init_lib();
    init_version20();
    __awaiter6 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger25 = new Logger(version20);
    KeystoreAccount = class extends Description {
      isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/index.js
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
var init_lib23 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/json-wallets/lib.esm/index.js"() {
    "use strict";
    init_crowdsale();
    init_inspect();
    init_keystore();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wallet/lib.esm/_version.js
var version21;
var init_version21 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    version21 = "wallet/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/wallet/lib.esm/index.js
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain, types, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature2);
}
var __awaiter7, logger26, Wallet;
var init_lib24 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    init_lib7();
    init_lib12();
    init_lib13();
    init_lib2();
    init_lib10();
    init_lib21();
    init_lib5();
    init_lib4();
    init_lib22();
    init_lib14();
    init_lib23();
    init_lib15();
    init_lib();
    init_version21();
    __awaiter7 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger26 = new Logger(version21);
    Wallet = class _Wallet extends Signer {
      constructor(privateKey, provider) {
        logger26.checkNew(new.target, _Wallet);
        super();
        if (isAccount(privateKey)) {
          const signingKey = new SigningKey(privateKey.privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
          if (this.address !== getAddress(privateKey.address)) {
            logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic2(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            defineReadOnly(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if (computeAddress(node.privateKey) !== this.address) {
              logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            defineReadOnly(this, "_mnemonic", () => null);
          }
        } else {
          if (SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            defineReadOnly(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
          }
          defineReadOnly(this, "_mnemonic", () => null);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        if (provider && !Provider.isProvider(provider)) {
          logger26.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new _Wallet(this, provider);
      }
      signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
          if (tx.from != null) {
            if (getAddress(tx.from) !== this.address) {
              logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature2 = this._signingKey().signDigest(keccak256(serialize(tx)));
          return serialize(tx, signature2);
        });
      }
      signMessage(message) {
        return __awaiter7(this, void 0, void 0, function* () {
          return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter7(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
            if (this.provider == null) {
              logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name2
              });
            }
            return this.provider.resolveName(name2);
          });
          return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      /**
       *  Static methods to create Wallet instances.
       */
      static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return _Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new _Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new _Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist2) {
        if (!path) {
          path = defaultPath;
        }
        return new _Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/networks/lib.esm/_version.js
var version22;
var init_version22 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/networks/lib.esm/_version.js"() {
    version22 = "networks/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/networks/lib.esm/index.js
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger27.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger27.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
var logger27, homestead, ropsten, classicMordor, networks;
var init_lib25 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/networks/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version22();
    logger27 = new Logger(version22);
    homestead = {
      chainId: 1,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "homestead",
      _defaultProvider: ethDefaultProvider("homestead")
    };
    ropsten = {
      chainId: 3,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "ropsten",
      _defaultProvider: ethDefaultProvider("ropsten")
    };
    classicMordor = {
      chainId: 63,
      name: "classicMordor",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
    };
    networks = {
      unspecified: { chainId: 0, name: "unspecified" },
      homestead,
      mainnet: homestead,
      morden: { chainId: 2, name: "morden" },
      ropsten,
      testnet: ropsten,
      rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
      },
      kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
      },
      goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
      },
      kintsugi: { chainId: 1337702, name: "kintsugi" },
      // ETC (See: #351)
      classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
      },
      classicMorden: { chainId: 62, name: "classicMorden" },
      classicMordor,
      classicTestnet: classicMordor,
      classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
      },
      xdai: { chainId: 100, name: "xdai" },
      matic: { chainId: 137, name: "matic" },
      maticmum: { chainId: 80001, name: "maticmum" },
      optimism: { chainId: 10, name: "optimism" },
      "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
      "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
      arbitrum: { chainId: 42161, name: "arbitrum" },
      "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
      bnb: { chainId: 56, name: "bnb" },
      bnbt: { chainId: 97, name: "bnbt" }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/base64/lib.esm/base64.js
function decode2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify(data);
}
function encode3(data) {
  data = arrayify(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}
var init_base64 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/base64/lib.esm/base64.js"() {
    "use strict";
    init_lib2();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  decode: () => decode2,
  encode: () => encode3
});
var init_lib26 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/base64/lib.esm/index.js"() {
    "use strict";
    init_base64();
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/web/lib.esm/_version.js
var version23;
var init_version23 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/web/lib.esm/_version.js"() {
    version23 = "web/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/web/lib.esm/geturl.js
function getUrl(href, options) {
  return __awaiter8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter8;
var init_geturl = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/web/lib.esm/geturl.js"() {
    "use strict";
    init_lib2();
    __awaiter8 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/web/lib.esm/index.js
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify(value);
  }
  return value;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger28.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode3(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode2(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter9(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var __awaiter9, logger28;
var init_lib27 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/web/lib.esm/index.js"() {
    "use strict";
    init_lib26();
    init_lib2();
    init_lib4();
    init_lib9();
    init_lib();
    init_version23();
    init_geturl();
    __awaiter9 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger28 = new Logger(version23);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/_version.js
var version24;
var init_version24 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/_version.js"() {
    version24 = "providers/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/formatter.js
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
var logger29, Formatter, throttleMessage;
var init_formatter = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/formatter.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib4();
    init_lib15();
    init_lib();
    init_version24();
    logger29 = new Logger(version24);
    Formatter = class _Formatter {
      constructor() {
        logger29.checkNew(new.target, _Formatter);
        this.formats = this.getDefaultFormats();
      }
      getDefaultFormats() {
        const formats = {};
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const blockTag = this.blockTag.bind(this);
        const data = this.data.bind(this);
        const hash3 = this.hash.bind(this);
        const hex = this.hex.bind(this);
        const number = this.number.bind(this);
        const type = this.type.bind(this);
        const strictData = (v2) => {
          return this.data(v2, true);
        };
        formats.transaction = {
          hash: hash3,
          type,
          accessList: _Formatter.allowNull(this.accessList.bind(this), null),
          blockHash: _Formatter.allowNull(hash3, null),
          blockNumber: _Formatter.allowNull(number, null),
          transactionIndex: _Formatter.allowNull(number, null),
          confirmations: _Formatter.allowNull(number, null),
          from: address,
          // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
          // must be set
          gasPrice: _Formatter.allowNull(bigNumber),
          maxPriorityFeePerGas: _Formatter.allowNull(bigNumber),
          maxFeePerGas: _Formatter.allowNull(bigNumber),
          gasLimit: bigNumber,
          to: _Formatter.allowNull(address, null),
          value: bigNumber,
          nonce: number,
          data,
          r: _Formatter.allowNull(this.uint256),
          s: _Formatter.allowNull(this.uint256),
          v: _Formatter.allowNull(number),
          creates: _Formatter.allowNull(address, null),
          raw: _Formatter.allowNull(data)
        };
        formats.transactionRequest = {
          from: _Formatter.allowNull(address),
          nonce: _Formatter.allowNull(number),
          gasLimit: _Formatter.allowNull(bigNumber),
          gasPrice: _Formatter.allowNull(bigNumber),
          maxPriorityFeePerGas: _Formatter.allowNull(bigNumber),
          maxFeePerGas: _Formatter.allowNull(bigNumber),
          to: _Formatter.allowNull(address),
          value: _Formatter.allowNull(bigNumber),
          data: _Formatter.allowNull(strictData),
          type: _Formatter.allowNull(number),
          accessList: _Formatter.allowNull(this.accessList.bind(this), null)
        };
        formats.receiptLog = {
          transactionIndex: number,
          blockNumber: number,
          transactionHash: hash3,
          address,
          topics: _Formatter.arrayOf(hash3),
          data,
          logIndex: number,
          blockHash: hash3
        };
        formats.receipt = {
          to: _Formatter.allowNull(this.address, null),
          from: _Formatter.allowNull(this.address, null),
          contractAddress: _Formatter.allowNull(address, null),
          transactionIndex: number,
          // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
          root: _Formatter.allowNull(hex),
          gasUsed: bigNumber,
          logsBloom: _Formatter.allowNull(data),
          blockHash: hash3,
          transactionHash: hash3,
          logs: _Formatter.arrayOf(this.receiptLog.bind(this)),
          blockNumber: number,
          confirmations: _Formatter.allowNull(number, null),
          cumulativeGasUsed: bigNumber,
          effectiveGasPrice: _Formatter.allowNull(bigNumber),
          status: _Formatter.allowNull(number),
          type
        };
        formats.block = {
          hash: _Formatter.allowNull(hash3),
          parentHash: hash3,
          number,
          timestamp: number,
          nonce: _Formatter.allowNull(hex),
          difficulty: this.difficulty.bind(this),
          gasLimit: bigNumber,
          gasUsed: bigNumber,
          miner: _Formatter.allowNull(address),
          extraData: data,
          transactions: _Formatter.allowNull(_Formatter.arrayOf(hash3)),
          baseFeePerGas: _Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = shallowCopy(formats.block);
        formats.blockWithTransactions.transactions = _Formatter.allowNull(_Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
          fromBlock: _Formatter.allowNull(blockTag, void 0),
          toBlock: _Formatter.allowNull(blockTag, void 0),
          blockHash: _Formatter.allowNull(hash3, void 0),
          address: _Formatter.allowNull(address, void 0),
          topics: _Formatter.allowNull(this.topics.bind(this), void 0)
        };
        formats.filterLog = {
          blockNumber: _Formatter.allowNull(number),
          blockHash: _Formatter.allowNull(hash3),
          transactionIndex: number,
          removed: _Formatter.allowNull(this.boolean.bind(this)),
          address,
          data: _Formatter.allowFalsish(data, "0x"),
          topics: _Formatter.arrayOf(hash3),
          transactionHash: hash3,
          logIndex: number
        };
        return formats;
      }
      accessList(accessList) {
        return accessListify(accessList || []);
      }
      // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
      // Strict! Used on input.
      number(number) {
        if (number === "0x") {
          return 0;
        }
        return BigNumber.from(number).toNumber();
      }
      type(number) {
        if (number === "0x" || number == null) {
          return 0;
        }
        return BigNumber.from(number).toNumber();
      }
      // Strict! Used on input.
      bigNumber(value) {
        return BigNumber.from(value);
      }
      // Requires a boolean, "true" or  "false"; returns a boolean
      boolean(value) {
        if (typeof value === "boolean") {
          return value;
        }
        if (typeof value === "string") {
          value = value.toLowerCase();
          if (value === "true") {
            return true;
          }
          if (value === "false") {
            return false;
          }
        }
        throw new Error("invalid boolean - " + value);
      }
      hex(value, strict) {
        if (typeof value === "string") {
          if (!strict && value.substring(0, 2) !== "0x") {
            value = "0x" + value;
          }
          if (isHexString(value)) {
            return value.toLowerCase();
          }
        }
        return logger29.throwArgumentError("invalid hash", "value", value);
      }
      data(value, strict) {
        const result = this.hex(value, strict);
        if (result.length % 2 !== 0) {
          throw new Error("invalid data; odd-length - " + value);
        }
        return result;
      }
      // Requires an address
      // Strict! Used on input.
      address(value) {
        return getAddress(value);
      }
      callAddress(value) {
        if (!isHexString(value, 32)) {
          return null;
        }
        const address = getAddress(hexDataSlice(value, 12));
        return address === AddressZero ? null : address;
      }
      contractAddress(value) {
        return getContractAddress(value);
      }
      // Strict! Used on input.
      blockTag(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        if (blockTag === "earliest") {
          return "0x0";
        }
        if (blockTag === "latest" || blockTag === "pending") {
          return blockTag;
        }
        if (typeof blockTag === "number" || isHexString(blockTag)) {
          return hexValue(blockTag);
        }
        throw new Error("invalid blockTag");
      }
      // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
      hash(value, strict) {
        const result = this.hex(value, strict);
        if (hexDataLength(result) !== 32) {
          return logger29.throwArgumentError("invalid hash", "value", value);
        }
        return result;
      }
      // Returns the difficulty as a number, or if too large (i.e. PoA network) null
      difficulty(value) {
        if (value == null) {
          return null;
        }
        const v2 = BigNumber.from(value);
        try {
          return v2.toNumber();
        } catch (error) {
        }
        return null;
      }
      uint256(value) {
        if (!isHexString(value)) {
          throw new Error("invalid uint256");
        }
        return hexZeroPad(value, 32);
      }
      _block(value, format) {
        if (value.author != null && value.miner == null) {
          value.miner = value.author;
        }
        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
        const result = _Formatter.check(format, value);
        result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
        return result;
      }
      block(value) {
        return this._block(value, this.formats.block);
      }
      blockWithTransactions(value) {
        return this._block(value, this.formats.blockWithTransactions);
      }
      // Strict! Used on input.
      transactionRequest(value) {
        return _Formatter.check(this.formats.transactionRequest, value);
      }
      transactionResponse(transaction) {
        if (transaction.gas != null && transaction.gasLimit == null) {
          transaction.gasLimit = transaction.gas;
        }
        if (transaction.to && BigNumber.from(transaction.to).isZero()) {
          transaction.to = "0x0000000000000000000000000000000000000000";
        }
        if (transaction.input != null && transaction.data == null) {
          transaction.data = transaction.input;
        }
        if (transaction.to == null && transaction.creates == null) {
          transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
          transaction.accessList = [];
        }
        const result = _Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
          let chainId = transaction.chainId;
          if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
          }
          result.chainId = chainId;
        } else {
          let chainId = transaction.networkId;
          if (chainId == null && result.v == null) {
            chainId = transaction.chainId;
          }
          if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
          }
          if (typeof chainId !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) {
              chainId = 0;
            }
            chainId = parseInt(chainId);
          }
          if (typeof chainId !== "number") {
            chainId = 0;
          }
          result.chainId = chainId;
        }
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
          result.blockHash = null;
        }
        return result;
      }
      transaction(value) {
        return parse2(value);
      }
      receiptLog(value) {
        return _Formatter.check(this.formats.receiptLog, value);
      }
      receipt(value) {
        const result = _Formatter.check(this.formats.receipt, value);
        if (result.root != null) {
          if (result.root.length <= 4) {
            const value2 = BigNumber.from(result.root).toNumber();
            if (value2 === 0 || value2 === 1) {
              if (result.status != null && result.status !== value2) {
                logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
              }
              result.status = value2;
              delete result.root;
            } else {
              logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
            }
          } else if (result.root.length !== 66) {
            logger29.throwArgumentError("invalid root hash", "value.root", result.root);
          }
        }
        if (result.status != null) {
          result.byzantium = true;
        }
        return result;
      }
      topics(value) {
        if (Array.isArray(value)) {
          return value.map((v2) => this.topics(v2));
        } else if (value != null) {
          return this.hash(value, true);
        }
        return null;
      }
      filter(value) {
        return _Formatter.check(this.formats.filter, value);
      }
      filterLog(value) {
        return _Formatter.check(this.formats.filterLog, value);
      }
      static check(format, object) {
        const result = {};
        for (const key2 in format) {
          try {
            const value = format[key2](object[key2]);
            if (value !== void 0) {
              result[key2] = value;
            }
          } catch (error) {
            error.checkKey = key2;
            error.checkValue = object[key2];
            throw error;
          }
        }
        return result;
      }
      // if value is null-ish, nullValue is returned
      static allowNull(format, nullValue) {
        return function(value) {
          if (value == null) {
            return nullValue;
          }
          return format(value);
        };
      }
      // If value is false-ish, replaceValue is returned
      static allowFalsish(format, replaceValue) {
        return function(value) {
          if (!value) {
            return replaceValue;
          }
          return format(value);
        };
      }
      // Requires an Array satisfying check
      static arrayOf(format) {
        return function(array) {
          if (!Array.isArray(array)) {
            throw new Error("not an array");
          }
          const result = [];
          array.forEach(function(value) {
            result.push(format(value));
          });
          return result;
        };
      }
    };
    throttleMessage = false;
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/base-provider.js
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger30.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger30.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger30.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i2 = 0; i2 < datas.length; i2++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i2 = 0; i2 < datas.length; i2++) {
    const data = arrayify(datas[i2]);
    result[i2] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
var import_bech32, __awaiter10, logger30, MAX_CCIP_REDIRECTS, PollableEvents, Event, coinInfos, matcherIpfs, matchers, Resolver, defaultFormatter, nextPollId, BaseProvider;
var init_base_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/base-provider.js"() {
    "use strict";
    init_lib12();
    init_lib17();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib10();
    init_lib25();
    init_lib4();
    init_lib18();
    init_lib9();
    init_lib27();
    import_bech32 = __toESM(require_bech32());
    init_lib();
    init_version24();
    init_formatter();
    __awaiter10 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger30 = new Logger(version24);
    MAX_CCIP_REDIRECTS = 10;
    PollableEvents = ["block", "network", "pending", "poll"];
    Event = class {
      constructor(tag, listener, once) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "listener", listener);
        defineReadOnly(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
      }
      get event() {
        switch (this.type) {
          case "tx":
            return this.hash;
          case "filter":
            return this.filter;
        }
        return this.tag;
      }
      get type() {
        return this.tag.split(":")[0];
      }
      get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") {
          return null;
        }
        return comps[1];
      }
      get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") {
          return null;
        }
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) {
          filter.topics = topics;
        }
        if (address && address !== "*") {
          filter.address = address;
        }
        return filter;
      }
      pollable() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
      }
    };
    coinInfos = {
      "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
      "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
      "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
      "60": { symbol: "eth", ilk: "eth" },
      "61": { symbol: "etc", ilk: "eth" },
      "700": { symbol: "xdai", ilk: "eth" }
    };
    matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
    matchers = [
      new RegExp("^(https)://(.*)$", "i"),
      new RegExp("^(data):(.*)$", "i"),
      matcherIpfs,
      new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
    ];
    Resolver = class {
      // The resolvedAddress is only for creating a ReverseLookup resolver
      constructor(provider, address, name2, resolvedAddress) {
        defineReadOnly(this, "provider", provider);
        defineReadOnly(this, "name", name2);
        defineReadOnly(this, "address", provider.formatter.address(address));
        defineReadOnly(this, "_resolvedAddress", resolvedAddress);
      }
      supportsWildcard() {
        if (!this._supportsEip2544) {
          this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
          }).then((result) => {
            return BigNumber.from(result).eq(1);
          }).catch((error) => {
            if (error.code === Logger.errors.CALL_EXCEPTION) {
              return false;
            }
            this._supportsEip2544 = null;
            throw error;
          });
        }
        return this._supportsEip2544;
      }
      _fetch(selector, parameters) {
        return __awaiter10(this, void 0, void 0, function* () {
          const tx = {
            to: this.address,
            ccipReadEnabled: true,
            data: hexConcat([selector, namehash(this.name), parameters || "0x"])
          };
          let parseBytes = false;
          if (yield this.supportsWildcard()) {
            parseBytes = true;
            tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
          }
          try {
            let result = yield this.provider.call(tx);
            if (arrayify(result).length % 32 === 4) {
              logger30.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
                transaction: tx,
                data: result
              });
            }
            if (parseBytes) {
              result = _parseBytes(result, 0);
            }
            return result;
          } catch (error) {
            if (error.code === Logger.errors.CALL_EXCEPTION) {
              return null;
            }
            throw error;
          }
        });
      }
      _fetchBytes(selector, parameters) {
        return __awaiter10(this, void 0, void 0, function* () {
          const result = yield this._fetch(selector, parameters);
          if (result != null) {
            return _parseBytes(result, 0);
          }
          return null;
        });
      }
      _getAddress(coinType, hexBytes) {
        const coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
          logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`
          });
        }
        if (coinInfo.ilk === "eth") {
          return this.provider.formatter.address(hexBytes);
        }
        const bytes = arrayify(hexBytes);
        if (coinInfo.p2pkh != null) {
          const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
          if (p2pkh) {
            const length = parseInt(p2pkh[1], 16);
            if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
              return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
            }
          }
        }
        if (coinInfo.p2sh != null) {
          const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
          if (p2sh) {
            const length = parseInt(p2sh[1], 16);
            if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
              return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
            }
          }
        }
        if (coinInfo.prefix != null) {
          const length = bytes[1];
          let version28 = bytes[0];
          if (version28 === 0) {
            if (length !== 20 && length !== 32) {
              version28 = -1;
            }
          } else {
            version28 = -1;
          }
          if (version28 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
            const words2 = import_bech32.default.toWords(bytes.slice(2));
            words2.unshift(version28);
            return import_bech32.default.encode(coinInfo.prefix, words2);
          }
        }
        return null;
      }
      getAddress(coinType) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (coinType == null) {
            coinType = 60;
          }
          if (coinType === 60) {
            try {
              const result = yield this._fetch("0x3b3b57de");
              if (result === "0x" || result === HashZero) {
                return null;
              }
              return this.provider.formatter.callAddress(result);
            } catch (error) {
              if (error.code === Logger.errors.CALL_EXCEPTION) {
                return null;
              }
              throw error;
            }
          }
          const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
          if (hexBytes == null || hexBytes === "0x") {
            return null;
          }
          const address = this._getAddress(coinType, hexBytes);
          if (address == null) {
            logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
              operation: `getAddress(${coinType})`,
              coinType,
              data: hexBytes
            });
          }
          return address;
        });
      }
      getAvatar() {
        return __awaiter10(this, void 0, void 0, function* () {
          const linkage = [{ type: "name", content: this.name }];
          try {
            const avatar = yield this.getText("avatar");
            if (avatar == null) {
              return null;
            }
            for (let i2 = 0; i2 < matchers.length; i2++) {
              const match = avatar.match(matchers[i2]);
              if (match == null) {
                continue;
              }
              const scheme = match[1].toLowerCase();
              switch (scheme) {
                case "https":
                  linkage.push({ type: "url", content: avatar });
                  return { linkage, url: avatar };
                case "data":
                  linkage.push({ type: "data", content: avatar });
                  return { linkage, url: avatar };
                case "ipfs":
                  linkage.push({ type: "ipfs", content: avatar });
                  return { linkage, url: getIpfsLink(avatar) };
                case "erc721":
                case "erc1155": {
                  const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                  linkage.push({ type: scheme, content: avatar });
                  const owner = this._resolvedAddress || (yield this.getAddress());
                  const comps = (match[2] || "").split("/");
                  if (comps.length !== 2) {
                    return null;
                  }
                  const addr = yield this.provider.formatter.address(comps[0]);
                  const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
                  if (scheme === "erc721") {
                    const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                      to: addr,
                      data: hexConcat(["0x6352211e", tokenId])
                    }));
                    if (owner !== tokenOwner) {
                      return null;
                    }
                    linkage.push({ type: "owner", content: tokenOwner });
                  } else if (scheme === "erc1155") {
                    const balance = BigNumber.from(yield this.provider.call({
                      to: addr,
                      data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                    }));
                    if (balance.isZero()) {
                      return null;
                    }
                    linkage.push({ type: "balance", content: balance.toString() });
                  }
                  const tx = {
                    to: this.provider.formatter.address(comps[0]),
                    data: hexConcat([selector, tokenId])
                  };
                  let metadataUrl = _parseString(yield this.provider.call(tx), 0);
                  if (metadataUrl == null) {
                    return null;
                  }
                  linkage.push({ type: "metadata-url-base", content: metadataUrl });
                  if (scheme === "erc1155") {
                    metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                    linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                  }
                  if (metadataUrl.match(/^ipfs:/i)) {
                    metadataUrl = getIpfsLink(metadataUrl);
                  }
                  linkage.push({ type: "metadata-url", content: metadataUrl });
                  const metadata = yield fetchJson(metadataUrl);
                  if (!metadata) {
                    return null;
                  }
                  linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                  let imageUrl = metadata.image;
                  if (typeof imageUrl !== "string") {
                    return null;
                  }
                  if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                  } else {
                    const ipfs = imageUrl.match(matcherIpfs);
                    if (ipfs == null) {
                      return null;
                    }
                    linkage.push({ type: "url-ipfs", content: imageUrl });
                    imageUrl = getIpfsLink(imageUrl);
                  }
                  linkage.push({ type: "url", content: imageUrl });
                  return { linkage, url: imageUrl };
                }
              }
            }
          } catch (error) {
          }
          return null;
        });
      }
      getContentHash() {
        return __awaiter10(this, void 0, void 0, function* () {
          const hexBytes = yield this._fetchBytes("0xbc1c58d1");
          if (hexBytes == null || hexBytes === "0x") {
            return null;
          }
          const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
          if (ipfs) {
            const length = parseInt(ipfs[3], 16);
            if (ipfs[4].length === length * 2) {
              return "ipfs://" + Base58.encode("0x" + ipfs[1]);
            }
          }
          const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
          if (swarm) {
            if (swarm[1].length === 32 * 2) {
              return "bzz://" + swarm[1];
            }
          }
          return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getContentHash()",
            data: hexBytes
          });
        });
      }
      getText(key2) {
        return __awaiter10(this, void 0, void 0, function* () {
          let keyBytes = toUtf8Bytes(key2);
          keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
          if (keyBytes.length % 32 !== 0) {
            keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
          }
          const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
          if (hexBytes == null || hexBytes === "0x") {
            return null;
          }
          return toUtf8String(hexBytes);
        });
      }
    };
    defaultFormatter = null;
    nextPollId = 1;
    BaseProvider = class extends Provider {
      /**
       *  ready
       *
       *  A Promise<Network> that resolves only once the provider is ready.
       *
       *  Sub-classes that call the super with a network without a chainId
       *  MUST set this. Standard named networks have a known chainId.
       *
       */
      constructor(network) {
        logger30.checkNew(new.target, Provider);
        super();
        this._events = [];
        this._emitted = { block: -2 };
        this.disableCcipRead = false;
        this.formatter = new.target.getFormatter();
        defineReadOnly(this, "anyNetwork", network === "any");
        if (this.anyNetwork) {
          network = this.detectNetwork();
        }
        if (network instanceof Promise) {
          this._networkPromise = network;
          network.catch((error) => {
          });
          this._ready().catch((error) => {
          });
        } else {
          const knownNetwork = getStatic(new.target, "getNetwork")(network);
          if (knownNetwork) {
            defineReadOnly(this, "_network", knownNetwork);
            this.emit("network", knownNetwork, null);
          } else {
            logger30.throwArgumentError("invalid network", "network", network);
          }
        }
        this._maxInternalBlockNumber = -1024;
        this._lastBlockNumber = -2;
        this._maxFilterBlockRange = 10;
        this._pollingInterval = 4e3;
        this._fastQueryDate = 0;
      }
      _ready() {
        return __awaiter10(this, void 0, void 0, function* () {
          if (this._network == null) {
            let network = null;
            if (this._networkPromise) {
              try {
                network = yield this._networkPromise;
              } catch (error) {
              }
            }
            if (network == null) {
              network = yield this.detectNetwork();
            }
            if (!network) {
              logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
            }
            if (this._network == null) {
              if (this.anyNetwork) {
                this._network = network;
              } else {
                defineReadOnly(this, "_network", network);
              }
              this.emit("network", network, null);
            }
          }
          return this._network;
        });
      }
      // This will always return the most recently established network.
      // For "any", this can change (a "network" event is emitted before
      // any change is reflected); otherwise this cannot change
      get ready() {
        return poll(() => {
          return this._ready().then((network) => {
            return network;
          }, (error) => {
            if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
              return void 0;
            }
            throw error;
          });
        });
      }
      // @TODO: Remove this and just create a singleton formatter
      static getFormatter() {
        if (defaultFormatter == null) {
          defaultFormatter = new Formatter();
        }
        return defaultFormatter;
      }
      // @TODO: Remove this and just use getNetwork
      static getNetwork(network) {
        return getNetwork(network == null ? "homestead" : network);
      }
      ccipReadFetch(tx, calldata, urls) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (this.disableCcipRead || urls.length === 0) {
            return null;
          }
          const sender = (tx.from || "0x0000000000000000000000000000000000000000").toLowerCase();
          const data = calldata.toLowerCase();
          const errorMessages = [];
          for (let i2 = 0; i2 < urls.length; i2++) {
            const url = urls[i2];
            const href = url.replace("{sender}", sender).replace("{data}", data);
            const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
            const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
              value.status = response.statusCode;
              return value;
            });
            if (result.data) {
              return result.data;
            }
            const errorMessage = result.message || "unknown error";
            if (result.status >= 400 && result.status < 500) {
              return logger30.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
            }
            errorMessages.push(errorMessage);
          }
          return logger30.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, Logger.errors.SERVER_ERROR, {
            urls,
            errorMessages
          });
        });
      }
      // Fetches the blockNumber, but will reuse any result that is less
      // than maxAge old or has been requested since the last request
      _getInternalBlockNumber(maxAge) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this._ready();
          if (maxAge > 0) {
            while (this._internalBlockNumber) {
              const internalBlockNumber = this._internalBlockNumber;
              try {
                const result = yield internalBlockNumber;
                if (getTime() - result.respTime <= maxAge) {
                  return result.blockNumber;
                }
                break;
              } catch (error) {
                if (this._internalBlockNumber === internalBlockNumber) {
                  break;
                }
              }
            }
          }
          const reqTime = getTime();
          const checkInternalBlockNumber = resolveProperties({
            blockNumber: this.perform("getBlockNumber", {}),
            networkError: this.getNetwork().then((network) => null, (error) => error)
          }).then(({ blockNumber, networkError }) => {
            if (networkError) {
              if (this._internalBlockNumber === checkInternalBlockNumber) {
                this._internalBlockNumber = null;
              }
              throw networkError;
            }
            const respTime = getTime();
            blockNumber = BigNumber.from(blockNumber).toNumber();
            if (blockNumber < this._maxInternalBlockNumber) {
              blockNumber = this._maxInternalBlockNumber;
            }
            this._maxInternalBlockNumber = blockNumber;
            this._setFastBlockNumber(blockNumber);
            return { blockNumber, reqTime, respTime };
          });
          this._internalBlockNumber = checkInternalBlockNumber;
          checkInternalBlockNumber.catch((error) => {
            if (this._internalBlockNumber === checkInternalBlockNumber) {
              this._internalBlockNumber = null;
            }
          });
          return (yield checkInternalBlockNumber).blockNumber;
        });
      }
      poll() {
        return __awaiter10(this, void 0, void 0, function* () {
          const pollId = nextPollId++;
          const runners = [];
          let blockNumber = null;
          try {
            blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
          } catch (error) {
            this.emit("error", error);
            return;
          }
          this._setFastBlockNumber(blockNumber);
          this.emit("poll", pollId, blockNumber);
          if (blockNumber === this._lastBlockNumber) {
            this.emit("didPoll", pollId);
            return;
          }
          if (this._emitted.block === -2) {
            this._emitted.block = blockNumber - 1;
          }
          if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
            logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
            this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
              blockNumber,
              event: "blockSkew",
              previousBlockNumber: this._emitted.block
            }));
            this.emit("block", blockNumber);
          } else {
            for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
              this.emit("block", i2);
            }
          }
          if (this._emitted.block !== blockNumber) {
            this._emitted.block = blockNumber;
            Object.keys(this._emitted).forEach((key2) => {
              if (key2 === "block") {
                return;
              }
              const eventBlockNumber = this._emitted[key2];
              if (eventBlockNumber === "pending") {
                return;
              }
              if (blockNumber - eventBlockNumber > 12) {
                delete this._emitted[key2];
              }
            });
          }
          if (this._lastBlockNumber === -2) {
            this._lastBlockNumber = blockNumber - 1;
          }
          this._events.forEach((event) => {
            switch (event.type) {
              case "tx": {
                const hash3 = event.hash;
                let runner = this.getTransactionReceipt(hash3).then((receipt) => {
                  if (!receipt || receipt.blockNumber == null) {
                    return null;
                  }
                  this._emitted["t:" + hash3] = receipt.blockNumber;
                  this.emit(hash3, receipt);
                  return null;
                }).catch((error) => {
                  this.emit("error", error);
                });
                runners.push(runner);
                break;
              }
              case "filter": {
                if (!event._inflight) {
                  event._inflight = true;
                  const filter = event.filter;
                  filter.fromBlock = event._lastBlockNumber + 1;
                  filter.toBlock = blockNumber;
                  if (filter.toBlock - this._maxFilterBlockRange > filter.fromBlock) {
                    filter.fromBlock = filter.toBlock - this._maxFilterBlockRange;
                  }
                  const runner = this.getLogs(filter).then((logs) => {
                    event._inflight = false;
                    if (logs.length === 0) {
                      return;
                    }
                    logs.forEach((log2) => {
                      if (log2.blockNumber > event._lastBlockNumber) {
                        event._lastBlockNumber = log2.blockNumber;
                      }
                      this._emitted["b:" + log2.blockHash] = log2.blockNumber;
                      this._emitted["t:" + log2.transactionHash] = log2.blockNumber;
                      this.emit(filter, log2);
                    });
                  }).catch((error) => {
                    this.emit("error", error);
                    event._inflight = false;
                  });
                  runners.push(runner);
                }
                break;
              }
            }
          });
          this._lastBlockNumber = blockNumber;
          Promise.all(runners).then(() => {
            this.emit("didPoll", pollId);
          }).catch((error) => {
            this.emit("error", error);
          });
          return;
        });
      }
      // Deprecated; do not use this
      resetEventsBlock(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
          this.poll();
        }
      }
      get network() {
        return this._network;
      }
      // This method should query the network if the underlying network
      // can change, such as when connected to a JSON-RPC backend
      detectNetwork() {
        return __awaiter10(this, void 0, void 0, function* () {
          return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "provider.detectNetwork"
          });
        });
      }
      getNetwork() {
        return __awaiter10(this, void 0, void 0, function* () {
          const network = yield this._ready();
          const currentNetwork = yield this.detectNetwork();
          if (network.chainId !== currentNetwork.chainId) {
            if (this.anyNetwork) {
              this._network = currentNetwork;
              this._lastBlockNumber = -2;
              this._fastBlockNumber = null;
              this._fastBlockNumberPromise = null;
              this._fastQueryDate = 0;
              this._emitted.block = -2;
              this._maxInternalBlockNumber = -1024;
              this._internalBlockNumber = null;
              this.emit("network", currentNetwork, network);
              yield stall(0);
              return this._network;
            }
            const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
              event: "changed",
              network,
              detectedNetwork: currentNetwork
            });
            this.emit("error", error);
            throw error;
          }
          return network;
        });
      }
      get blockNumber() {
        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
          this._setFastBlockNumber(blockNumber);
        }, (error) => {
        });
        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
      }
      get polling() {
        return this._poller != null;
      }
      set polling(value) {
        if (value && !this._poller) {
          this._poller = setInterval(() => {
            this.poll();
          }, this.pollingInterval);
          if (!this._bootstrapPoll) {
            this._bootstrapPoll = setTimeout(() => {
              this.poll();
              this._bootstrapPoll = setTimeout(() => {
                if (!this._poller) {
                  this.poll();
                }
                this._bootstrapPoll = null;
              }, this.pollingInterval);
            }, 0);
          }
        } else if (!value && this._poller) {
          clearInterval(this._poller);
          this._poller = null;
        }
      }
      get pollingInterval() {
        return this._pollingInterval;
      }
      set pollingInterval(value) {
        if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
          throw new Error("invalid polling interval");
        }
        this._pollingInterval = value;
        if (this._poller) {
          clearInterval(this._poller);
          this._poller = setInterval(() => {
            this.poll();
          }, this._pollingInterval);
        }
      }
      _getFastBlockNumber() {
        const now2 = getTime();
        if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
          this._fastQueryDate = now2;
          this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
            if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
              this._fastBlockNumber = blockNumber;
            }
            return this._fastBlockNumber;
          });
        }
        return this._fastBlockNumberPromise;
      }
      _setFastBlockNumber(blockNumber) {
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
          return;
        }
        this._fastQueryDate = getTime();
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
          this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
      }
      waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter10(this, void 0, void 0, function* () {
          return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
        });
      }
      _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter10(this, void 0, void 0, function* () {
          const receipt = yield this.getTransactionReceipt(transactionHash);
          if ((receipt ? receipt.confirmations : 0) >= confirmations) {
            return receipt;
          }
          return new Promise((resolve, reject) => {
            const cancelFuncs = [];
            let done = false;
            const alreadyDone = function() {
              if (done) {
                return true;
              }
              done = true;
              cancelFuncs.forEach((func) => {
                func();
              });
              return false;
            };
            const minedHandler = (receipt2) => {
              if (receipt2.confirmations < confirmations) {
                return;
              }
              if (alreadyDone()) {
                return;
              }
              resolve(receipt2);
            };
            this.on(transactionHash, minedHandler);
            cancelFuncs.push(() => {
              this.removeListener(transactionHash, minedHandler);
            });
            if (replaceable) {
              let lastBlockNumber = replaceable.startBlock;
              let scannedBlock = null;
              const replaceHandler = (blockNumber) => __awaiter10(this, void 0, void 0, function* () {
                if (done) {
                  return;
                }
                yield stall(1e3);
                this.getTransactionCount(replaceable.from).then((nonce) => __awaiter10(this, void 0, void 0, function* () {
                  if (done) {
                    return;
                  }
                  if (nonce <= replaceable.nonce) {
                    lastBlockNumber = blockNumber;
                  } else {
                    {
                      const mined = yield this.getTransaction(transactionHash);
                      if (mined && mined.blockNumber != null) {
                        return;
                      }
                    }
                    if (scannedBlock == null) {
                      scannedBlock = lastBlockNumber - 3;
                      if (scannedBlock < replaceable.startBlock) {
                        scannedBlock = replaceable.startBlock;
                      }
                    }
                    while (scannedBlock <= blockNumber) {
                      if (done) {
                        return;
                      }
                      const block = yield this.getBlockWithTransactions(scannedBlock);
                      for (let ti = 0; ti < block.transactions.length; ti++) {
                        const tx = block.transactions[ti];
                        if (tx.hash === transactionHash) {
                          return;
                        }
                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                          if (done) {
                            return;
                          }
                          const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                          if (alreadyDone()) {
                            return;
                          }
                          let reason = "replaced";
                          if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                            reason = "repriced";
                          } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                            reason = "cancelled";
                          }
                          reject(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                            cancelled: reason === "replaced" || reason === "cancelled",
                            reason,
                            replacement: this._wrapTransaction(tx),
                            hash: transactionHash,
                            receipt: receipt2
                          }));
                          return;
                        }
                      }
                      scannedBlock++;
                    }
                  }
                  if (done) {
                    return;
                  }
                  this.once("block", replaceHandler);
                }), (error) => {
                  if (done) {
                    return;
                  }
                  this.once("block", replaceHandler);
                });
              });
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
              cancelFuncs.push(() => {
                this.removeListener("block", replaceHandler);
              });
            }
            if (typeof timeout === "number" && timeout > 0) {
              const timer2 = setTimeout(() => {
                if (alreadyDone()) {
                  return;
                }
                reject(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
              }, timeout);
              if (timer2.unref) {
                timer2.unref();
              }
              cancelFuncs.push(() => {
                clearTimeout(timer2);
              });
            }
          });
        });
      }
      getBlockNumber() {
        return __awaiter10(this, void 0, void 0, function* () {
          return this._getInternalBlockNumber(0);
        });
      }
      getGasPrice() {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const result = yield this.perform("getGasPrice", {});
          try {
            return BigNumber.from(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getGasPrice",
              result,
              error
            });
          }
        });
      }
      getBalance(addressOrName, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag)
          });
          const result = yield this.perform("getBalance", params);
          try {
            return BigNumber.from(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getBalance",
              params,
              result,
              error
            });
          }
        });
      }
      getTransactionCount(addressOrName, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag)
          });
          const result = yield this.perform("getTransactionCount", params);
          try {
            return BigNumber.from(result).toNumber();
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getTransactionCount",
              params,
              result,
              error
            });
          }
        });
      }
      getCode(addressOrName, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag)
          });
          const result = yield this.perform("getCode", params);
          try {
            return hexlify(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getCode",
              params,
              result,
              error
            });
          }
        });
      }
      getStorageAt(addressOrName, position, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag),
            position: Promise.resolve(position).then((p2) => hexValue(p2))
          });
          const result = yield this.perform("getStorageAt", params);
          try {
            return hexlify(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getStorageAt",
              params,
              result,
              error
            });
          }
        });
      }
      // This should be called by any subclass wrapping a TransactionResponse
      _wrapTransaction(tx, hash3, startBlock) {
        if (hash3 != null && hexDataLength(hash3) !== 32) {
          throw new Error("invalid response - sendTransaction");
        }
        const result = tx;
        if (hash3 != null && tx.hash !== hash3) {
          logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
        }
        result.wait = (confirms, timeout) => __awaiter10(this, void 0, void 0, function* () {
          if (confirms == null) {
            confirms = 1;
          }
          if (timeout == null) {
            timeout = 0;
          }
          let replacement = void 0;
          if (confirms !== 0 && startBlock != null) {
            replacement = {
              data: tx.data,
              from: tx.from,
              nonce: tx.nonce,
              to: tx.to,
              value: tx.value,
              startBlock
            };
          }
          const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
          if (receipt == null && confirms === 0) {
            return null;
          }
          this._emitted["t:" + tx.hash] = receipt.blockNumber;
          if (receipt.status === 0) {
            logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
              transactionHash: tx.hash,
              transaction: tx,
              receipt
            });
          }
          return receipt;
        });
        return result;
      }
      sendTransaction(signedTransaction) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
          const tx = this.formatter.transaction(signedTransaction);
          if (tx.confirmations == null) {
            tx.confirmations = 0;
          }
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          try {
            const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
            return this._wrapTransaction(tx, hash3, blockNumber);
          } catch (error) {
            error.transaction = tx;
            error.transactionHash = tx.hash;
            throw error;
          }
        });
      }
      _getTransactionRequest(transaction) {
        return __awaiter10(this, void 0, void 0, function* () {
          const values = yield transaction;
          const tx = {};
          ["from", "to"].forEach((key2) => {
            if (values[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
          });
          ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
            if (values[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
          });
          ["type"].forEach((key2) => {
            if (values[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 != null ? v2 : null);
          });
          if (values.accessList) {
            tx.accessList = this.formatter.accessList(values.accessList);
          }
          ["data"].forEach((key2) => {
            if (values[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? hexlify(v2) : null);
          });
          return this.formatter.transactionRequest(yield resolveProperties(tx));
        });
      }
      _getFilter(filter) {
        return __awaiter10(this, void 0, void 0, function* () {
          filter = yield filter;
          const result = {};
          if (filter.address != null) {
            result.address = this._getAddress(filter.address);
          }
          ["blockHash", "topics"].forEach((key2) => {
            if (filter[key2] == null) {
              return;
            }
            result[key2] = filter[key2];
          });
          ["fromBlock", "toBlock"].forEach((key2) => {
            if (filter[key2] == null) {
              return;
            }
            result[key2] = this._getBlockTag(filter[key2]);
          });
          return this.formatter.filter(yield resolveProperties(result));
        });
      }
      _call(transaction, blockTag, attempt) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (attempt >= MAX_CCIP_REDIRECTS) {
            logger30.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
              redirects: attempt,
              transaction
            });
          }
          const txSender = transaction.to;
          const result = yield this.perform("call", { transaction, blockTag });
          if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
            try {
              const data = hexDataSlice(result, 4);
              const sender = hexDataSlice(data, 0, 32);
              if (!BigNumber.from(sender).eq(txSender)) {
                logger30.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              const urls = [];
              const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
              const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
              const urlsData = hexDataSlice(data, urlsOffset + 32);
              for (let u2 = 0; u2 < urlsLength; u2++) {
                const url = _parseString(urlsData, u2 * 32);
                if (url == null) {
                  logger30.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                urls.push(url);
              }
              const calldata = _parseBytes(data, 64);
              if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
                logger30.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              const callbackSelector = hexDataSlice(data, 96, 100);
              const extraData = _parseBytes(data, 128);
              const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
              if (ccipResult == null) {
                logger30.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              const tx = {
                to: txSender,
                data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
              };
              return this._call(tx, blockTag, attempt + 1);
            } catch (error) {
              if (error.code === Logger.errors.SERVER_ERROR) {
                throw error;
              }
            }
          }
          try {
            return hexlify(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "call",
              params: { transaction, blockTag },
              result,
              error
            });
          }
        });
      }
      call(transaction, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const resolved = yield resolveProperties({
            transaction: this._getTransactionRequest(transaction),
            blockTag: this._getBlockTag(blockTag),
            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
          });
          return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
        });
      }
      estimateGas(transaction) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            transaction: this._getTransactionRequest(transaction)
          });
          const result = yield this.perform("estimateGas", params);
          try {
            return BigNumber.from(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "estimateGas",
              params,
              result,
              error
            });
          }
        });
      }
      _getAddress(addressOrName) {
        return __awaiter10(this, void 0, void 0, function* () {
          addressOrName = yield addressOrName;
          if (typeof addressOrName !== "string") {
            logger30.throwArgumentError("invalid address or ENS name", "name", addressOrName);
          }
          const address = yield this.resolveName(addressOrName);
          if (address == null) {
            logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: `resolveName(${JSON.stringify(addressOrName)})`
            });
          }
          return address;
        });
      }
      _getBlock(blockHashOrBlockTag, includeTransactions) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          blockHashOrBlockTag = yield blockHashOrBlockTag;
          let blockNumber = -128;
          const params = {
            includeTransactions: !!includeTransactions
          };
          if (isHexString(blockHashOrBlockTag, 32)) {
            params.blockHash = blockHashOrBlockTag;
          } else {
            try {
              params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
              if (isHexString(params.blockTag)) {
                blockNumber = parseInt(params.blockTag.substring(2), 16);
              }
            } catch (error) {
              logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
            }
          }
          return poll(() => __awaiter10(this, void 0, void 0, function* () {
            const block = yield this.perform("getBlock", params);
            if (block == null) {
              if (params.blockHash != null) {
                if (this._emitted["b:" + params.blockHash] == null) {
                  return null;
                }
              }
              if (params.blockTag != null) {
                if (blockNumber > this._emitted.block) {
                  return null;
                }
              }
              return void 0;
            }
            if (includeTransactions) {
              let blockNumber2 = null;
              for (let i2 = 0; i2 < block.transactions.length; i2++) {
                const tx = block.transactions[i2];
                if (tx.blockNumber == null) {
                  tx.confirmations = 0;
                } else if (tx.confirmations == null) {
                  if (blockNumber2 == null) {
                    blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                  }
                  let confirmations = blockNumber2 - tx.blockNumber + 1;
                  if (confirmations <= 0) {
                    confirmations = 1;
                  }
                  tx.confirmations = confirmations;
                }
              }
              const blockWithTxs = this.formatter.blockWithTransactions(block);
              blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
              return blockWithTxs;
            }
            return this.formatter.block(block);
          }), { oncePoll: this });
        });
      }
      getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
      }
      getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
      }
      getTransaction(transactionHash) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          transactionHash = yield transactionHash;
          const params = { transactionHash: this.formatter.hash(transactionHash, true) };
          return poll(() => __awaiter10(this, void 0, void 0, function* () {
            const result = yield this.perform("getTransaction", params);
            if (result == null) {
              if (this._emitted["t:" + transactionHash] == null) {
                return null;
              }
              return void 0;
            }
            const tx = this.formatter.transactionResponse(result);
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              let confirmations = blockNumber - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
            return this._wrapTransaction(tx);
          }), { oncePoll: this });
        });
      }
      getTransactionReceipt(transactionHash) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          transactionHash = yield transactionHash;
          const params = { transactionHash: this.formatter.hash(transactionHash, true) };
          return poll(() => __awaiter10(this, void 0, void 0, function* () {
            const result = yield this.perform("getTransactionReceipt", params);
            if (result == null) {
              if (this._emitted["t:" + transactionHash] == null) {
                return null;
              }
              return void 0;
            }
            if (result.blockHash == null) {
              return void 0;
            }
            const receipt = this.formatter.receipt(result);
            if (receipt.blockNumber == null) {
              receipt.confirmations = 0;
            } else if (receipt.confirmations == null) {
              const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              let confirmations = blockNumber - receipt.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              receipt.confirmations = confirmations;
            }
            return receipt;
          }), { oncePoll: this });
        });
      }
      getLogs(filter) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({ filter: this._getFilter(filter) });
          const logs = yield this.perform("getLogs", params);
          logs.forEach((log2) => {
            if (log2.removed == null) {
              log2.removed = false;
            }
          });
          return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
        });
      }
      getEtherPrice() {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          return this.perform("getEtherPrice", {});
        });
      }
      _getBlockTag(blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          blockTag = yield blockTag;
          if (typeof blockTag === "number" && blockTag < 0) {
            if (blockTag % 1) {
              logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
            }
            let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            blockNumber += blockTag;
            if (blockNumber < 0) {
              blockNumber = 0;
            }
            return this.formatter.blockTag(blockNumber);
          }
          return this.formatter.blockTag(blockTag);
        });
      }
      getResolver(name2) {
        return __awaiter10(this, void 0, void 0, function* () {
          let currentName = name2;
          while (true) {
            if (currentName === "" || currentName === ".") {
              return null;
            }
            if (name2 !== "eth" && currentName === "eth") {
              return null;
            }
            const addr = yield this._getResolver(currentName, "getResolver");
            if (addr != null) {
              const resolver = new Resolver(this, addr, name2);
              if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
                return null;
              }
              return resolver;
            }
            currentName = currentName.split(".").slice(1).join(".");
          }
        });
      }
      _getResolver(name2, operation) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (operation == null) {
            operation = "ENS";
          }
          const network = yield this.getNetwork();
          if (!network.ensAddress) {
            logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
          }
          try {
            const addrData = yield this.call({
              to: network.ensAddress,
              data: "0x0178b8bf" + namehash(name2).substring(2)
            });
            return this.formatter.callAddress(addrData);
          } catch (error) {
          }
          return null;
        });
      }
      resolveName(name2) {
        return __awaiter10(this, void 0, void 0, function* () {
          name2 = yield name2;
          try {
            return Promise.resolve(this.formatter.address(name2));
          } catch (error) {
            if (isHexString(name2)) {
              throw error;
            }
          }
          if (typeof name2 !== "string") {
            logger30.throwArgumentError("invalid ENS name", "name", name2);
          }
          const resolver = yield this.getResolver(name2);
          if (!resolver) {
            return null;
          }
          return yield resolver.getAddress();
        });
      }
      lookupAddress(address) {
        return __awaiter10(this, void 0, void 0, function* () {
          address = yield address;
          address = this.formatter.address(address);
          const node = address.substring(2).toLowerCase() + ".addr.reverse";
          const resolverAddr = yield this._getResolver(node, "lookupAddress");
          if (resolverAddr == null) {
            return null;
          }
          const name2 = _parseString(yield this.call({
            to: resolverAddr,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          const addr = yield this.resolveName(name2);
          if (addr != address) {
            return null;
          }
          return name2;
        });
      }
      getAvatar(nameOrAddress) {
        return __awaiter10(this, void 0, void 0, function* () {
          let resolver = null;
          if (isHexString(nameOrAddress)) {
            const address = this.formatter.address(nameOrAddress);
            const node = address.substring(2).toLowerCase() + ".addr.reverse";
            const resolverAddress = yield this._getResolver(node, "getAvatar");
            if (!resolverAddress) {
              return null;
            }
            resolver = new Resolver(this, resolverAddress, node);
            try {
              const avatar2 = yield resolver.getAvatar();
              if (avatar2) {
                return avatar2.url;
              }
            } catch (error) {
              if (error.code !== Logger.errors.CALL_EXCEPTION) {
                throw error;
              }
            }
            try {
              const name2 = _parseString(yield this.call({
                to: resolverAddress,
                data: "0x691f3431" + namehash(node).substring(2)
              }), 0);
              resolver = yield this.getResolver(name2);
            } catch (error) {
              if (error.code !== Logger.errors.CALL_EXCEPTION) {
                throw error;
              }
              return null;
            }
          } else {
            resolver = yield this.getResolver(nameOrAddress);
            if (!resolver) {
              return null;
            }
          }
          const avatar = yield resolver.getAvatar();
          if (avatar == null) {
            return null;
          }
          return avatar.url;
        });
      }
      perform(method, params) {
        return logger30.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      _startEvent(event) {
        this.polling = this._events.filter((e) => e.pollable()).length > 0;
      }
      _stopEvent(event) {
        this.polling = this._events.filter((e) => e.pollable()).length > 0;
      }
      _addEventListener(eventName, listener, once) {
        const event = new Event(getEventTag2(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
      }
      on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
      }
      once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
      }
      emit(eventName, ...args) {
        let result = false;
        let stopped = [];
        let eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag) {
            return true;
          }
          setTimeout(() => {
            event.listener.apply(this, args);
          }, 0);
          result = true;
          if (event.once) {
            stopped.push(event);
            return false;
          }
          return true;
        });
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return result;
      }
      listenerCount(eventName) {
        if (!eventName) {
          return this._events.length;
        }
        let eventTag = getEventTag2(eventName);
        return this._events.filter((event) => {
          return event.tag === eventTag;
        }).length;
      }
      listeners(eventName) {
        if (eventName == null) {
          return this._events.map((event) => event.listener);
        }
        let eventTag = getEventTag2(eventName);
        return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
      }
      off(eventName, listener) {
        if (listener == null) {
          return this.removeAllListeners(eventName);
        }
        const stopped = [];
        let found = false;
        let eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag || event.listener != listener) {
            return true;
          }
          if (found) {
            return true;
          }
          found = true;
          stopped.push(event);
          return false;
        });
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return this;
      }
      removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
          stopped = this._events;
          this._events = [];
        } else {
          const eventTag = getEventTag2(eventName);
          this._events = this._events.filter((event) => {
            if (event.tag !== eventTag) {
              return true;
            }
            stopped.push(event);
            return false;
          });
        }
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return this;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
function checkError(method, error, params) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && e.message.match("reverted") && isHexString(e.data)) {
      return e.data;
    }
    logger31.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var __awaiter11, logger31, errorGas, _constructorGuard5, JsonRpcSigner, UncheckedJsonRpcSigner, allowedTransactionKeys4, JsonRpcProvider;
var init_json_rpc_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js"() {
    "use strict";
    init_lib13();
    init_lib3();
    init_lib2();
    init_lib10();
    init_lib4();
    init_lib9();
    init_lib15();
    init_lib27();
    init_lib();
    init_version24();
    init_base_provider();
    __awaiter11 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger31 = new Logger(version24);
    errorGas = ["call", "estimateGas"];
    _constructorGuard5 = {};
    JsonRpcSigner = class _JsonRpcSigner extends Signer {
      constructor(constructorGuard, provider, addressOrIndex) {
        logger31.checkNew(new.target, _JsonRpcSigner);
        super();
        if (constructorGuard !== _constructorGuard5) {
          throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        defineReadOnly(this, "provider", provider);
        if (addressOrIndex == null) {
          addressOrIndex = 0;
        }
        if (typeof addressOrIndex === "string") {
          defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
          defineReadOnly(this, "_index", null);
        } else if (typeof addressOrIndex === "number") {
          defineReadOnly(this, "_index", addressOrIndex);
          defineReadOnly(this, "_address", null);
        } else {
          logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
      }
      connect(provider) {
        return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "connect"
        });
      }
      connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
      }
      getAddress() {
        if (this._address) {
          return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then((accounts) => {
          if (accounts.length <= this._index) {
            logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "getAddress"
            });
          }
          return this.provider.formatter.address(accounts[this._index]);
        });
      }
      sendUncheckedTransaction(transaction) {
        transaction = shallowCopy(transaction);
        const fromAddress = this.getAddress().then((address) => {
          if (address) {
            address = address.toLowerCase();
          }
          return address;
        });
        if (transaction.gasLimit == null) {
          const estimate = shallowCopy(transaction);
          estimate.from = fromAddress;
          transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
          transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter11(this, void 0, void 0, function* () {
            if (to == null) {
              return null;
            }
            const address = yield this.provider.resolveName(to);
            if (address == null) {
              logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
            }
            return address;
          }));
        }
        return resolveProperties({
          tx: resolveProperties(transaction),
          sender: fromAddress
        }).then(({ tx, sender }) => {
          if (tx.from != null) {
            if (tx.from.toLowerCase() !== sender) {
              logger31.throwArgumentError("from address mismatch", "transaction", transaction);
            }
          } else {
            tx.from = sender;
          }
          const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
          return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
            return hash3;
          }, (error) => {
            return checkError("sendTransaction", error, hexTx);
          });
        });
      }
      signTransaction(transaction) {
        return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "signTransaction"
        });
      }
      sendTransaction(transaction) {
        return __awaiter11(this, void 0, void 0, function* () {
          const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
          const hash3 = yield this.sendUncheckedTransaction(transaction);
          try {
            return yield poll(() => __awaiter11(this, void 0, void 0, function* () {
              const tx = yield this.provider.getTransaction(hash3);
              if (tx === null) {
                return void 0;
              }
              return this.provider._wrapTransaction(tx, hash3, blockNumber);
            }), { oncePoll: this.provider });
          } catch (error) {
            error.transactionHash = hash3;
            throw error;
          }
        });
      }
      signMessage(message) {
        return __awaiter11(this, void 0, void 0, function* () {
          const data = typeof message === "string" ? toUtf8Bytes(message) : message;
          const address = yield this.getAddress();
          return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
        });
      }
      _legacySignMessage(message) {
        return __awaiter11(this, void 0, void 0, function* () {
          const data = typeof message === "string" ? toUtf8Bytes(message) : message;
          const address = yield this.getAddress();
          return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter11(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
            return this.provider.resolveName(name2);
          });
          const address = yield this.getAddress();
          return yield this.provider.send("eth_signTypedData_v4", [
            address.toLowerCase(),
            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
          ]);
        });
      }
      unlock(password) {
        return __awaiter11(this, void 0, void 0, function* () {
          const provider = this.provider;
          const address = yield this.getAddress();
          return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
        });
      }
    };
    UncheckedJsonRpcSigner = class extends JsonRpcSigner {
      sendTransaction(transaction) {
        return this.sendUncheckedTransaction(transaction).then((hash3) => {
          return {
            hash: hash3,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: (confirmations) => {
              return this.provider.waitForTransaction(hash3, confirmations);
            }
          };
        });
      }
    };
    allowedTransactionKeys4 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true
    };
    JsonRpcProvider = class _JsonRpcProvider extends BaseProvider {
      constructor(url, network) {
        logger31.checkNew(new.target, _JsonRpcProvider);
        let networkOrReady = network;
        if (networkOrReady == null) {
          networkOrReady = new Promise((resolve, reject) => {
            setTimeout(() => {
              this.detectNetwork().then((network2) => {
                resolve(network2);
              }, (error) => {
                reject(error);
              });
            }, 0);
          });
        }
        super(networkOrReady);
        if (!url) {
          url = getStatic(this.constructor, "defaultUrl")();
        }
        if (typeof url === "string") {
          defineReadOnly(this, "connection", Object.freeze({
            url
          }));
        } else {
          defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
        }
        this._nextId = 42;
      }
      get _cache() {
        if (this._eventLoopCache == null) {
          this._eventLoopCache = {};
        }
        return this._eventLoopCache;
      }
      static defaultUrl() {
        return "http://localhost:8545";
      }
      detectNetwork() {
        if (!this._cache["detectNetwork"]) {
          this._cache["detectNetwork"] = this._uncachedDetectNetwork();
          setTimeout(() => {
            this._cache["detectNetwork"] = null;
          }, 0);
        }
        return this._cache["detectNetwork"];
      }
      _uncachedDetectNetwork() {
        return __awaiter11(this, void 0, void 0, function* () {
          yield timer(0);
          let chainId = null;
          try {
            chainId = yield this.send("eth_chainId", []);
          } catch (error) {
            try {
              chainId = yield this.send("net_version", []);
            } catch (error2) {
            }
          }
          if (chainId != null) {
            const getNetwork2 = getStatic(this.constructor, "getNetwork");
            try {
              return getNetwork2(BigNumber.from(chainId).toNumber());
            } catch (error) {
              return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                chainId,
                event: "invalidNetwork",
                serverError: error
              });
            }
          }
          return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            event: "noNetwork"
          });
        });
      }
      getSigner(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
      }
      getUncheckedSigner(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
      }
      listAccounts() {
        return this.send("eth_accounts", []).then((accounts) => {
          return accounts.map((a2) => this.formatter.address(a2));
        });
      }
      send(method, params) {
        const request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        this.emit("debug", {
          action: "request",
          request: deepCopy(request),
          provider: this
        });
        const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
        if (cache && this._cache[method]) {
          return this._cache[method];
        }
        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
          this.emit("debug", {
            action: "response",
            request,
            response: result2,
            provider: this
          });
          return result2;
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request,
            provider: this
          });
          throw error;
        });
        if (cache) {
          this._cache[method] = result;
          setTimeout(() => {
            this._cache[method] = null;
          }, 0);
        }
        return result;
      }
      prepareRequest(method, params) {
        switch (method) {
          case "getBlockNumber":
            return ["eth_blockNumber", []];
          case "getGasPrice":
            return ["eth_gasPrice", []];
          case "getBalance":
            return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
          case "getTransactionCount":
            return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
          case "getCode":
            return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
          case "getStorageAt":
            return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
          case "sendTransaction":
            return ["eth_sendRawTransaction", [params.signedTransaction]];
          case "getBlock":
            if (params.blockTag) {
              return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
            } else if (params.blockHash) {
              return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
            }
            return null;
          case "getTransaction":
            return ["eth_getTransactionByHash", [params.transactionHash]];
          case "getTransactionReceipt":
            return ["eth_getTransactionReceipt", [params.transactionHash]];
          case "call": {
            const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
            return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
          }
          case "estimateGas": {
            const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
            return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
          }
          case "getLogs":
            if (params.filter && params.filter.address != null) {
              params.filter.address = getLowerCase(params.filter.address);
            }
            return ["eth_getLogs", [params.filter]];
          default:
            break;
        }
        return null;
      }
      perform(method, params) {
        return __awaiter11(this, void 0, void 0, function* () {
          if (method === "call" || method === "estimateGas") {
            const tx = params.transaction;
            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
              if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                const feeData = yield this.getFeeData();
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  params = shallowCopy(params);
                  params.transaction = shallowCopy(tx);
                  delete params.transaction.type;
                }
              }
            }
          }
          const args = this.prepareRequest(method, params);
          if (args == null) {
            logger31.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
          }
          try {
            return yield this.send(args[0], args[1]);
          } catch (error) {
            return checkError(method, error, params);
          }
        });
      }
      _startEvent(event) {
        if (event.tag === "pending") {
          this._startPending();
        }
        super._startEvent(event);
      }
      _startPending() {
        if (this._pendingFilter != null) {
          return;
        }
        const self2 = this;
        const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function(filterId) {
          function poll2() {
            self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
              if (self2._pendingFilter != pendingFilter) {
                return null;
              }
              let seq = Promise.resolve();
              hashes.forEach(function(hash3) {
                self2._emitted["t:" + hash3.toLowerCase()] = "pending";
                seq = seq.then(function() {
                  return self2.getTransaction(hash3).then(function(tx) {
                    self2.emit("pending", tx);
                    return null;
                  });
                });
              });
              return seq.then(function() {
                return timer(1e3);
              });
            }).then(function() {
              if (self2._pendingFilter != pendingFilter) {
                self2.send("eth_uninstallFilter", [filterId]);
                return;
              }
              setTimeout(function() {
                poll2();
              }, 0);
              return null;
            }).catch((error) => {
            });
          }
          poll2();
          return filterId;
        }).catch((error) => {
        });
      }
      _stopEvent(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
          this._pendingFilter = null;
        }
        super._stopEvent(event);
      }
      // Convert an ethers.js transaction into a JSON-RPC transaction
      //  - gasLimit => gas
      //  - All values hexlified
      //  - All numeric values zero-striped
      //  - All addresses are lowercased
      // NOTE: This allows a TransactionRequest, but all values should be resolved
      //       before this is called
      // @TODO: This will likely be removed in future versions and prepareRequest
      //        will be the preferred method for this.
      static hexlifyTransaction(transaction, allowExtra) {
        const allowed = shallowCopy(allowedTransactionKeys4);
        if (allowExtra) {
          for (const key2 in allowExtra) {
            if (allowExtra[key2]) {
              allowed[key2] = true;
            }
          }
        }
        checkProperties(transaction, allowed);
        const result = {};
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          const value = hexValue(transaction[key2]);
          if (key2 === "gasLimit") {
            key2 = "gas";
          }
          result[key2] = value;
        });
        ["from", "to", "data"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          result[key2] = hexlify(transaction[key2]);
        });
        if (transaction.accessList) {
          result["accessList"] = accessListify(transaction.accessList);
        }
        return result;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/ws.js
var WS;
var init_ws = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/ws.js"() {
    "use strict";
    init_lib();
    init_version24();
    WS = null;
    try {
      WS = WebSocket;
      if (WS == null) {
        throw new Error("inject please");
      }
    } catch (error) {
      const logger46 = new Logger(version24);
      WS = function() {
        logger46.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new WebSocket()"
        });
      };
    }
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var __awaiter12, logger32, NextId, WebSocketProvider;
var init_websocket_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js"() {
    "use strict";
    init_lib3();
    init_lib4();
    init_json_rpc_provider();
    init_ws();
    init_lib();
    init_version24();
    __awaiter12 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger32 = new Logger(version24);
    NextId = 1;
    WebSocketProvider = class extends JsonRpcProvider {
      constructor(url, network) {
        if (network === "any") {
          logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
          });
        }
        if (typeof url === "string") {
          super(url, network);
        } else {
          super("_websocket", network);
        }
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof url === "string") {
          defineReadOnly(this, "_websocket", new WS(this.connection.url));
        } else {
          defineReadOnly(this, "_websocket", url);
        }
        defineReadOnly(this, "_requests", {});
        defineReadOnly(this, "_subs", {});
        defineReadOnly(this, "_subIds", {});
        defineReadOnly(this, "_detectNetwork", super.detectNetwork());
        this.websocket.onopen = () => {
          this._wsReady = true;
          Object.keys(this._requests).forEach((id2) => {
            this.websocket.send(this._requests[id2].payload);
          });
        };
        this.websocket.onmessage = (messageEvent) => {
          const data = messageEvent.data;
          const result = JSON.parse(data);
          if (result.id != null) {
            const id2 = String(result.id);
            const request = this._requests[id2];
            delete this._requests[id2];
            if (result.result !== void 0) {
              request.callback(null, result.result);
              this.emit("debug", {
                action: "response",
                request: JSON.parse(request.payload),
                response: result.result,
                provider: this
              });
            } else {
              let error = null;
              if (result.error) {
                error = new Error(result.error.message || "unknown error");
                defineReadOnly(error, "code", result.error.code || null);
                defineReadOnly(error, "response", data);
              } else {
                error = new Error("unknown error");
              }
              request.callback(error, void 0);
              this.emit("debug", {
                action: "response",
                error,
                request: JSON.parse(request.payload),
                provider: this
              });
            }
          } else if (result.method === "eth_subscription") {
            const sub = this._subs[result.params.subscription];
            if (sub) {
              sub.processFunc(result.params.result);
            }
          } else {
            console.warn("this should not happen");
          }
        };
        const fauxPoll = setInterval(() => {
          this.emit("poll");
        }, 1e3);
        if (fauxPoll.unref) {
          fauxPoll.unref();
        }
      }
      // Cannot narrow the type of _websocket, as that is not backwards compatible
      // so we add a getter and let the WebSocket be a public API.
      get websocket() {
        return this._websocket;
      }
      detectNetwork() {
        return this._detectNetwork;
      }
      get pollingInterval() {
        return 0;
      }
      resetEventsBlock(blockNumber) {
        logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resetEventBlock"
        });
      }
      set pollingInterval(value) {
        logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setPollingInterval"
        });
      }
      poll() {
        return __awaiter12(this, void 0, void 0, function* () {
          return null;
        });
      }
      set polling(value) {
        if (!value) {
          return;
        }
        logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setPolling"
        });
      }
      send(method, params) {
        const rid = NextId++;
        return new Promise((resolve, reject) => {
          function callback(error, result) {
            if (error) {
              return reject(error);
            }
            return resolve(result);
          }
          const payload = JSON.stringify({
            method,
            params,
            id: rid,
            jsonrpc: "2.0"
          });
          this.emit("debug", {
            action: "request",
            request: JSON.parse(payload),
            provider: this
          });
          this._requests[String(rid)] = { callback, payload };
          if (this._wsReady) {
            this.websocket.send(payload);
          }
        });
      }
      static defaultUrl() {
        return "ws://localhost:8546";
      }
      _subscribe(tag, param, processFunc) {
        return __awaiter12(this, void 0, void 0, function* () {
          let subIdPromise = this._subIds[tag];
          if (subIdPromise == null) {
            subIdPromise = Promise.all(param).then((param2) => {
              return this.send("eth_subscribe", param2);
            });
            this._subIds[tag] = subIdPromise;
          }
          const subId = yield subIdPromise;
          this._subs[subId] = { tag, processFunc };
        });
      }
      _startEvent(event) {
        switch (event.type) {
          case "block":
            this._subscribe("block", ["newHeads"], (result) => {
              const blockNumber = BigNumber.from(result.number).toNumber();
              this._emitted.block = blockNumber;
              this.emit("block", blockNumber);
            });
            break;
          case "pending":
            this._subscribe("pending", ["newPendingTransactions"], (result) => {
              this.emit("pending", result);
            });
            break;
          case "filter":
            this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
              if (result.removed == null) {
                result.removed = false;
              }
              this.emit(event.filter, this.formatter.filterLog(result));
            });
            break;
          case "tx": {
            const emitReceipt = (event2) => {
              const hash3 = event2.hash;
              this.getTransactionReceipt(hash3).then((receipt) => {
                if (!receipt) {
                  return;
                }
                this.emit(hash3, receipt);
              });
            };
            emitReceipt(event);
            this._subscribe("tx", ["newHeads"], (result) => {
              this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
            });
            break;
          }
          case "debug":
          case "poll":
          case "willPoll":
          case "didPoll":
          case "error":
            break;
          default:
            console.log("unhandled:", event);
            break;
        }
      }
      _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
          if (this._events.filter((e) => e.type === "tx").length) {
            return;
          }
          tag = "tx";
        } else if (this.listenerCount(event.event)) {
          return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
          return;
        }
        delete this._subIds[tag];
        subId.then((subId2) => {
          if (!this._subs[subId2]) {
            return;
          }
          delete this._subs[subId2];
          this.send("eth_unsubscribe", [subId2]);
        });
      }
      destroy() {
        return __awaiter12(this, void 0, void 0, function* () {
          if (this.websocket.readyState === WS.CONNECTING) {
            yield new Promise((resolve) => {
              this.websocket.onopen = function() {
                resolve(true);
              };
              this.websocket.onerror = function() {
                resolve(false);
              };
            });
          }
          this.websocket.close(1e3);
        });
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
var __awaiter13, logger33, StaticJsonRpcProvider, UrlJsonRpcProvider;
var init_url_json_rpc_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version24();
    init_json_rpc_provider();
    __awaiter13 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger33 = new Logger(version24);
    StaticJsonRpcProvider = class extends JsonRpcProvider {
      detectNetwork() {
        const _super = Object.create(null, {
          detectNetwork: { get: () => super.detectNetwork }
        });
        return __awaiter13(this, void 0, void 0, function* () {
          let network = this.network;
          if (network == null) {
            network = yield _super.detectNetwork.call(this);
            if (!network) {
              logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
            }
            if (this._network == null) {
              defineReadOnly(this, "_network", network);
              this.emit("network", network, null);
            }
          }
          return network;
        });
      }
    };
    UrlJsonRpcProvider = class _UrlJsonRpcProvider extends StaticJsonRpcProvider {
      constructor(network, apiKey) {
        logger33.checkAbstract(new.target, _UrlJsonRpcProvider);
        network = getStatic(new.target, "getNetwork")(network);
        apiKey = getStatic(new.target, "getApiKey")(apiKey);
        const connection = getStatic(new.target, "getUrl")(network, apiKey);
        super(connection, network);
        if (typeof apiKey === "string") {
          defineReadOnly(this, "apiKey", apiKey);
        } else if (apiKey != null) {
          Object.keys(apiKey).forEach((key2) => {
            defineReadOnly(this, key2, apiKey[key2]);
          });
        }
      }
      _startPending() {
        logger33.warn("WARNING: API provider does not support pending filters");
      }
      isCommunityResource() {
        return false;
      }
      getSigner(address) {
        return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
      }
      listAccounts() {
        return Promise.resolve([]);
      }
      // Return a defaultApiKey if null, otherwise validate the API key
      static getApiKey(apiKey) {
        return apiKey;
      }
      // Returns the url or connection for the given network and API key. The
      // API key will have been sanitized by the getApiKey first, so any validation
      // or transformations can be done there.
      static getUrl(network, apiKey) {
        return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
          operation: "getUrl"
        });
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger34, defaultApiKey, AlchemyWebSocketProvider, AlchemyProvider;
var init_alchemy_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js"() {
    "use strict";
    init_lib4();
    init_formatter();
    init_websocket_provider();
    init_lib();
    init_version24();
    init_url_json_rpc_provider();
    logger34 = new Logger(version24);
    defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
    AlchemyWebSocketProvider = class extends WebSocketProvider {
      constructor(network, apiKey) {
        const provider = new AlchemyProvider(network, apiKey);
        const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        super(url, provider.network);
        defineReadOnly(this, "apiKey", provider.apiKey);
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    };
    AlchemyProvider = class extends UrlJsonRpcProvider {
      static getWebSocketProvider(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
      }
      static getApiKey(apiKey) {
        if (apiKey == null) {
          return defaultApiKey;
        }
        if (apiKey && typeof apiKey !== "string") {
          logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
          case "homestead":
            host = "eth-mainnet.alchemyapi.io/v2/";
            break;
          case "ropsten":
            host = "eth-ropsten.alchemyapi.io/v2/";
            break;
          case "rinkeby":
            host = "eth-rinkeby.alchemyapi.io/v2/";
            break;
          case "goerli":
            host = "eth-goerli.alchemyapi.io/v2/";
            break;
          case "kovan":
            host = "eth-kovan.alchemyapi.io/v2/";
            break;
          case "matic":
            host = "polygon-mainnet.g.alchemy.com/v2/";
            break;
          case "maticmum":
            host = "polygon-mumbai.g.alchemy.com/v2/";
            break;
          case "arbitrum":
            host = "arb-mainnet.g.alchemy.com/v2/";
            break;
          case "arbitrum-rinkeby":
            host = "arb-rinkeby.g.alchemy.com/v2/";
            break;
          case "optimism":
            host = "opt-mainnet.g.alchemy.com/v2/";
            break;
          case "optimism-kovan":
            host = "opt-kovan.g.alchemy.com/v2/";
            break;
          default:
            logger34.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
          allowGzip: true,
          url: "https://" + host + apiKey,
          throttleCallback: (attempt, url) => {
            if (apiKey === defaultApiKey) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
var __awaiter14, logger35, CloudflareProvider;
var init_cloudflare_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js"() {
    "use strict";
    init_url_json_rpc_provider();
    init_lib();
    init_version24();
    __awaiter14 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger35 = new Logger(version24);
    CloudflareProvider = class extends UrlJsonRpcProvider {
      static getApiKey(apiKey) {
        if (apiKey != null) {
          logger35.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
          case "homestead":
            host = "https://cloudflare-eth.com/";
            break;
          default:
            logger35.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
      }
      perform(method, params) {
        const _super = Object.create(null, {
          perform: { get: () => super.perform }
        });
        return __awaiter14(this, void 0, void 0, function* () {
          if (method === "getBlockNumber") {
            const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
            return block.number;
          }
          return _super.perform.call(this, method, params);
        });
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value = transaction[key2];
    if (key2 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value = hexValue(hexlify(value));
    } else if (key2 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key2] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data = e.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger36.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger36.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger36.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger36.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger36.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var __awaiter15, logger36, defaultApiKey2, EtherscanProvider;
var init_etherscan_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js"() {
    "use strict";
    init_lib2();
    init_lib4();
    init_lib15();
    init_lib27();
    init_formatter();
    init_lib();
    init_version24();
    init_base_provider();
    __awaiter15 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger36 = new Logger(version24);
    defaultApiKey2 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
    EtherscanProvider = class _EtherscanProvider extends BaseProvider {
      constructor(network, apiKey) {
        logger36.checkNew(new.target, _EtherscanProvider);
        super(network);
        defineReadOnly(this, "baseUrl", this.getBaseUrl());
        defineReadOnly(this, "apiKey", apiKey || defaultApiKey2);
      }
      getBaseUrl() {
        switch (this.network ? this.network.name : "invalid") {
          case "homestead":
            return "https://api.etherscan.io";
          case "ropsten":
            return "https://api-ropsten.etherscan.io";
          case "rinkeby":
            return "https://api-rinkeby.etherscan.io";
          case "kovan":
            return "https://api-kovan.etherscan.io";
          case "goerli":
            return "https://api-goerli.etherscan.io";
          default:
        }
        return logger36.throwArgumentError("unsupported network", "network", name);
      }
      getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key2) => {
          const value = params[key2];
          if (value != null) {
            accum += `&${key2}=${value}`;
          }
          return accum;
        }, "");
        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
      }
      getPostUrl() {
        return `${this.baseUrl}/api`;
      }
      getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
      }
      fetch(module, params, post) {
        return __awaiter15(this, void 0, void 0, function* () {
          const url = post ? this.getPostUrl() : this.getUrl(module, params);
          const payload = post ? this.getPostData(module, params) : null;
          const procFunc = module === "proxy" ? getJsonResult : getResult2;
          this.emit("debug", {
            action: "request",
            request: url,
            provider: this
          });
          const connection = {
            url,
            throttleSlotInterval: 1e3,
            throttleCallback: (attempt, url2) => {
              if (this.isCommunityResource()) {
                showThrottleMessage();
              }
              return Promise.resolve(true);
            }
          };
          let payloadStr = null;
          if (payload) {
            connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
            payloadStr = Object.keys(payload).map((key2) => {
              return `${key2}=${payload[key2]}`;
            }).join("&");
          }
          const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
          this.emit("debug", {
            action: "response",
            request: url,
            response: deepCopy(result),
            provider: this
          });
          return result;
        });
      }
      detectNetwork() {
        return __awaiter15(this, void 0, void 0, function* () {
          return this.network;
        });
      }
      perform(method, params) {
        const _super = Object.create(null, {
          perform: { get: () => super.perform }
        });
        return __awaiter15(this, void 0, void 0, function* () {
          switch (method) {
            case "getBlockNumber":
              return this.fetch("proxy", { action: "eth_blockNumber" });
            case "getGasPrice":
              return this.fetch("proxy", { action: "eth_gasPrice" });
            case "getBalance":
              return this.fetch("account", {
                action: "balance",
                address: params.address,
                tag: params.blockTag
              });
            case "getTransactionCount":
              return this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: params.address,
                tag: params.blockTag
              });
            case "getCode":
              return this.fetch("proxy", {
                action: "eth_getCode",
                address: params.address,
                tag: params.blockTag
              });
            case "getStorageAt":
              return this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: params.address,
                position: params.position,
                tag: params.blockTag
              });
            case "sendTransaction":
              return this.fetch("proxy", {
                action: "eth_sendRawTransaction",
                hex: params.signedTransaction
              }, true).catch((error) => {
                return checkError2("sendTransaction", error, params.signedTransaction);
              });
            case "getBlock":
              if (params.blockTag) {
                return this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: params.blockTag,
                  boolean: params.includeTransactions ? "true" : "false"
                });
              }
              throw new Error("getBlock by blockHash not implemented");
            case "getTransaction":
              return this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: params.transactionHash
              });
            case "getTransactionReceipt":
              return this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: params.transactionHash
              });
            case "call": {
              if (params.blockTag !== "latest") {
                throw new Error("EtherscanProvider does not support blockTag for call");
              }
              const postData = getTransactionPostData(params.transaction);
              postData.module = "proxy";
              postData.action = "eth_call";
              try {
                return yield this.fetch("proxy", postData, true);
              } catch (error) {
                return checkError2("call", error, params.transaction);
              }
            }
            case "estimateGas": {
              const postData = getTransactionPostData(params.transaction);
              postData.module = "proxy";
              postData.action = "eth_estimateGas";
              try {
                return yield this.fetch("proxy", postData, true);
              } catch (error) {
                return checkError2("estimateGas", error, params.transaction);
              }
            }
            case "getLogs": {
              const args = { action: "getLogs" };
              if (params.filter.fromBlock) {
                args.fromBlock = checkLogTag(params.filter.fromBlock);
              }
              if (params.filter.toBlock) {
                args.toBlock = checkLogTag(params.filter.toBlock);
              }
              if (params.filter.address) {
                args.address = params.filter.address;
              }
              if (params.filter.topics && params.filter.topics.length > 0) {
                if (params.filter.topics.length > 1) {
                  logger36.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                }
                if (params.filter.topics.length === 1) {
                  const topic0 = params.filter.topics[0];
                  if (typeof topic0 !== "string" || topic0.length !== 66) {
                    logger36.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                  }
                  args.topic0 = topic0;
                }
              }
              const logs = yield this.fetch("logs", args);
              let blocks = {};
              for (let i2 = 0; i2 < logs.length; i2++) {
                const log2 = logs[i2];
                if (log2.blockHash != null) {
                  continue;
                }
                if (blocks[log2.blockNumber] == null) {
                  const block = yield this.getBlock(log2.blockNumber);
                  if (block) {
                    blocks[log2.blockNumber] = block.hash;
                  }
                }
                log2.blockHash = blocks[log2.blockNumber];
              }
              return logs;
            }
            case "getEtherPrice":
              if (this.network.name !== "homestead") {
                return 0;
              }
              return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
            default:
              break;
          }
          return _super.perform.call(this, method, params);
        });
      }
      // Note: The `page` page parameter only allows pagination within the
      //       10,000 window available without a page and offset parameter
      //       Error: Result window is too large, PageNo x Offset size must
      //              be less than or equal to 10000
      getHistory(addressOrName, startBlock, endBlock) {
        return __awaiter15(this, void 0, void 0, function* () {
          const params = {
            action: "txlist",
            address: yield this.resolveName(addressOrName),
            startblock: startBlock == null ? 0 : startBlock,
            endblock: endBlock == null ? 99999999 : endBlock,
            sort: "asc"
          };
          const result = yield this.fetch("account", params);
          return result.map((tx) => {
            ["contractAddress", "to"].forEach(function(key2) {
              if (tx[key2] == "") {
                delete tx[key2];
              }
            });
            if (tx.creates == null && tx.contractAddress != null) {
              tx.creates = tx.contractAddress;
            }
            const item = this.formatter.transactionResponse(tx);
            if (tx.timeStamp) {
              item.timestamp = parseInt(tx.timeStamp);
            }
            return item;
          });
        });
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey2;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i2 = 0; i2 < networks2.length; i2++) {
    const network = networks2[i2];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger37.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a2 = values[middle - 1], b2 = values[middle];
  if (maxDelta != null && Math.abs(a2 - b2) > maxDelta) {
    return null;
  }
  return (a2 + b2) / 2;
}
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i2) => serialize2(i2)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key2) => {
      let v2 = value[key2];
      if (typeof v2 === "function") {
        v2 = "[function]";
      } else {
        v2 = serialize2(v2);
      }
      return JSON.stringify(key2) + ":" + v2;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
function stall2(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
function exposeDebugConfig(config, now2) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", { get: () => config.provider });
  if (config.start) {
    result.start = config.start;
  }
  if (now2) {
    result.duration = now2 - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c2) => {
      const value = normalize(c2.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c2.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const check = tally[keys[i2]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        let blockNumber = median(configs.map((c2) => c2.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c2) => c2.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config, blockNumber) {
  return __awaiter16(this, void 0, void 0, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter16(this, void 0, void 0, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger37.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var __awaiter16, logger37, nextRid, ForwardErrors, ForwardProperties, FallbackProvider;
var init_fallback_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js"() {
    "use strict";
    init_lib12();
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib22();
    init_lib27();
    init_base_provider();
    init_formatter();
    init_lib();
    init_version24();
    __awaiter16 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger37 = new Logger(version24);
    nextRid = 1;
    ForwardErrors = [
      Logger.errors.CALL_EXCEPTION,
      Logger.errors.INSUFFICIENT_FUNDS,
      Logger.errors.NONCE_EXPIRED,
      Logger.errors.REPLACEMENT_UNDERPRICED,
      Logger.errors.UNPREDICTABLE_GAS_LIMIT
    ];
    ForwardProperties = [
      "address",
      "args",
      "errorArgs",
      "errorSignature",
      "method",
      "transaction"
    ];
    FallbackProvider = class _FallbackProvider extends BaseProvider {
      constructor(providers, quorum) {
        logger37.checkNew(new.target, _FallbackProvider);
        if (providers.length === 0) {
          logger37.throwArgumentError("missing providers", "providers", providers);
        }
        const providerConfigs = providers.map((configOrProvider, index) => {
          if (Provider.isProvider(configOrProvider)) {
            const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
            const priority = 1;
            return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
          }
          const config = shallowCopy(configOrProvider);
          if (config.priority == null) {
            config.priority = 1;
          }
          if (config.stallTimeout == null) {
            config.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
          }
          if (config.weight == null) {
            config.weight = 1;
          }
          const weight = config.weight;
          if (weight % 1 || weight > 512 || weight < 1) {
            logger37.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
          }
          return Object.freeze(config);
        });
        const total = providerConfigs.reduce((accum, c2) => accum + c2.weight, 0);
        if (quorum == null) {
          quorum = total / 2;
        } else if (quorum > total) {
          logger37.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        let networkOrReady = checkNetworks(providerConfigs.map((c2) => c2.provider.network));
        if (networkOrReady == null) {
          networkOrReady = new Promise((resolve, reject) => {
            setTimeout(() => {
              this.detectNetwork().then(resolve, reject);
            }, 0);
          });
        }
        super(networkOrReady);
        defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
        defineReadOnly(this, "quorum", quorum);
        this._highestBlockNumber = -1;
      }
      detectNetwork() {
        return __awaiter16(this, void 0, void 0, function* () {
          const networks2 = yield Promise.all(this.providerConfigs.map((c2) => c2.provider.getNetwork()));
          return checkNetworks(networks2);
        });
      }
      perform(method, params) {
        return __awaiter16(this, void 0, void 0, function* () {
          if (method === "sendTransaction") {
            const results = yield Promise.all(this.providerConfigs.map((c2) => {
              return c2.provider.sendTransaction(params.signedTransaction).then((result) => {
                return result.hash;
              }, (error) => {
                return error;
              });
            }));
            for (let i3 = 0; i3 < results.length; i3++) {
              const result = results[i3];
              if (typeof result === "string") {
                return result;
              }
            }
            throw results[0];
          }
          if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
            yield this.getBlockNumber();
          }
          const processFunc = getProcessFunc(this, method, params);
          const configs = shuffled(this.providerConfigs.map(shallowCopy));
          configs.sort((a2, b2) => a2.priority - b2.priority);
          const currentBlockNumber = this._highestBlockNumber;
          let i2 = 0;
          let first = true;
          while (true) {
            const t0 = now();
            let inflightWeight = configs.filter((c2) => c2.runner && t0 - c2.start < c2.stallTimeout).reduce((accum, c2) => accum + c2.weight, 0);
            while (inflightWeight < this.quorum && i2 < configs.length) {
              const config = configs[i2++];
              const rid = nextRid++;
              config.start = now();
              config.staller = stall2(config.stallTimeout);
              config.staller.wait(() => {
                config.staller = null;
              });
              config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
                config.done = true;
                config.result = result;
                if (this.listenerCount("debug")) {
                  this.emit("debug", {
                    action: "request",
                    rid,
                    backend: exposeDebugConfig(config, now()),
                    request: { method, params: deepCopy(params) },
                    provider: this
                  });
                }
              }, (error) => {
                config.done = true;
                config.error = error;
                if (this.listenerCount("debug")) {
                  this.emit("debug", {
                    action: "request",
                    rid,
                    backend: exposeDebugConfig(config, now()),
                    request: { method, params: deepCopy(params) },
                    provider: this
                  });
                }
              });
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config, null),
                  request: { method, params: deepCopy(params) },
                  provider: this
                });
              }
              inflightWeight += config.weight;
            }
            const waiting = [];
            configs.forEach((c2) => {
              if (c2.done || !c2.runner) {
                return;
              }
              waiting.push(c2.runner);
              if (c2.staller) {
                waiting.push(c2.staller.getPromise());
              }
            });
            if (waiting.length) {
              yield Promise.race(waiting);
            }
            const results = configs.filter((c2) => c2.done && c2.error == null);
            if (results.length >= this.quorum) {
              const result = processFunc(results);
              if (result !== void 0) {
                configs.forEach((c2) => {
                  if (c2.staller) {
                    c2.staller.cancel();
                  }
                  c2.cancelled = true;
                });
                return result;
              }
              if (!first) {
                yield stall2(100).getPromise();
              }
              first = false;
            }
            const errors = configs.reduce((accum, c2) => {
              if (!c2.done || c2.error == null) {
                return accum;
              }
              const code = c2.error.code;
              if (ForwardErrors.indexOf(code) >= 0) {
                if (!accum[code]) {
                  accum[code] = { error: c2.error, weight: 0 };
                }
                accum[code].weight += c2.weight;
              }
              return accum;
            }, {});
            Object.keys(errors).forEach((errorCode) => {
              const tally = errors[errorCode];
              if (tally.weight < this.quorum) {
                return;
              }
              configs.forEach((c2) => {
                if (c2.staller) {
                  c2.staller.cancel();
                }
                c2.cancelled = true;
              });
              const e = tally.error;
              const props = {};
              ForwardProperties.forEach((name2) => {
                if (e[name2] == null) {
                  return;
                }
                props[name2] = e[name2];
              });
              logger37.throwError(e.reason || e.message, errorCode, props);
            });
            if (configs.filter((c2) => !c2.done).length === 0) {
              break;
            }
          }
          configs.forEach((c2) => {
            if (c2.staller) {
              c2.staller.cancel();
            }
            c2.cancelled = true;
          });
          return logger37.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
            method,
            params,
            //results: configs.map((c) => c.result),
            //errors: configs.map((c) => c.error),
            results: configs.map((c2) => exposeDebugConfig(c2)),
            provider: this
          });
        });
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider;
var init_ipc_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js"() {
    "use strict";
    IpcProvider = null;
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/infura-provider.js
var logger38, defaultProjectId, InfuraWebSocketProvider, InfuraProvider;
var init_infura_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/infura-provider.js"() {
    "use strict";
    init_lib4();
    init_websocket_provider();
    init_formatter();
    init_lib();
    init_version24();
    init_url_json_rpc_provider();
    logger38 = new Logger(version24);
    defaultProjectId = "84842078b09946638c03157f83405213";
    InfuraWebSocketProvider = class extends WebSocketProvider {
      constructor(network, apiKey) {
        const provider = new InfuraProvider(network, apiKey);
        const connection = provider.connection;
        if (connection.password) {
          logger38.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
          });
        }
        const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, network);
        defineReadOnly(this, "apiKey", provider.projectId);
        defineReadOnly(this, "projectId", provider.projectId);
        defineReadOnly(this, "projectSecret", provider.projectSecret);
      }
      isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
    };
    InfuraProvider = class extends UrlJsonRpcProvider {
      static getWebSocketProvider(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
      }
      static getApiKey(apiKey) {
        const apiKeyObj = {
          apiKey: defaultProjectId,
          projectId: defaultProjectId,
          projectSecret: null
        };
        if (apiKey == null) {
          return apiKeyObj;
        }
        if (typeof apiKey === "string") {
          apiKeyObj.projectId = apiKey;
        } else if (apiKey.projectSecret != null) {
          logger38.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
          logger38.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
          apiKeyObj.projectId = apiKey.projectId;
          apiKeyObj.projectSecret = apiKey.projectSecret;
        } else if (apiKey.projectId) {
          apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
          case "homestead":
            host = "mainnet.infura.io";
            break;
          case "ropsten":
            host = "ropsten.infura.io";
            break;
          case "rinkeby":
            host = "rinkeby.infura.io";
            break;
          case "kovan":
            host = "kovan.infura.io";
            break;
          case "goerli":
            host = "goerli.infura.io";
            break;
          case "matic":
            host = "polygon-mainnet.infura.io";
            break;
          case "maticmum":
            host = "polygon-mumbai.infura.io";
            break;
          case "optimism":
            host = "optimism-mainnet.infura.io";
            break;
          case "optimism-kovan":
            host = "optimism-kovan.infura.io";
            break;
          case "arbitrum":
            host = "arbitrum-mainnet.infura.io";
            break;
          case "arbitrum-rinkeby":
            host = "arbitrum-rinkeby.infura.io";
            break;
          default:
            logger38.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        const connection = {
          allowGzip: true,
          url: "https://" + host + "/v3/" + apiKey.projectId,
          throttleCallback: (attempt, url) => {
            if (apiKey.projectId === defaultProjectId) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      }
      isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var JsonRpcBatchProvider;
var init_json_rpc_batch_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js"() {
    init_lib4();
    init_lib27();
    init_json_rpc_provider();
    JsonRpcBatchProvider = class extends JsonRpcProvider {
      send(method, params) {
        const request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
          this._pendingBatch = [];
        }
        const inflightRequest = { request, resolve: null, reject: null };
        const promise = new Promise((resolve, reject) => {
          inflightRequest.resolve = resolve;
          inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
          this._pendingBatchAggregator = setTimeout(() => {
            const batch = this._pendingBatch;
            this._pendingBatch = null;
            this._pendingBatchAggregator = null;
            const request2 = batch.map((inflight) => inflight.request);
            this.emit("debug", {
              action: "requestBatch",
              request: deepCopy(request2),
              provider: this
            });
            return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
              this.emit("debug", {
                action: "response",
                request: request2,
                response: result,
                provider: this
              });
              batch.forEach((inflightRequest2, index) => {
                const payload = result[index];
                if (payload.error) {
                  const error = new Error(payload.error.message);
                  error.code = payload.error.code;
                  error.data = payload.error.data;
                  inflightRequest2.reject(error);
                } else {
                  inflightRequest2.resolve(payload.result);
                }
              });
            }, (error) => {
              this.emit("debug", {
                action: "response",
                error,
                request: request2,
                provider: this
              });
              batch.forEach((inflightRequest2) => {
                inflightRequest2.reject(error);
              });
            });
          }, 10);
        }
        return promise;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
var logger39, defaultApiKey3, NodesmithProvider;
var init_nodesmith_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js"() {
    "use strict";
    init_url_json_rpc_provider();
    init_lib();
    init_version24();
    logger39 = new Logger(version24);
    defaultApiKey3 = "ETHERS_JS_SHARED";
    NodesmithProvider = class extends UrlJsonRpcProvider {
      static getApiKey(apiKey) {
        if (apiKey && typeof apiKey !== "string") {
          logger39.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey3;
      }
      static getUrl(network, apiKey) {
        logger39.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let host = null;
        switch (network.name) {
          case "homestead":
            host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
            break;
          case "ropsten":
            host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
            break;
          case "rinkeby":
            host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
            break;
          case "goerli":
            host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
            break;
          case "kovan":
            host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
            break;
          default:
            logger39.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host + "?apiKey=" + apiKey;
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
var logger40, defaultApplicationIds, PocketProvider;
var init_pocket_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version24();
    init_url_json_rpc_provider();
    logger40 = new Logger(version24);
    defaultApplicationIds = {
      homestead: "6004bcd10040261633ade990",
      ropsten: "6004bd4d0040261633ade991",
      rinkeby: "6004bda20040261633ade994",
      goerli: "6004bd860040261633ade992"
    };
    PocketProvider = class extends UrlJsonRpcProvider {
      constructor(network, apiKey) {
        if (apiKey == null) {
          const n2 = getStatic(new.target, "getNetwork")(network);
          if (n2) {
            const applicationId = defaultApplicationIds[n2.name];
            if (applicationId) {
              apiKey = {
                applicationId,
                loadBalancer: true
              };
            }
          }
          if (apiKey == null) {
            logger40.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
          }
        }
        super(network, apiKey);
      }
      static getApiKey(apiKey) {
        if (apiKey == null) {
          logger40.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
        }
        const apiKeyObj = {
          applicationId: null,
          loadBalancer: false,
          applicationSecretKey: null
        };
        if (typeof apiKey === "string") {
          apiKeyObj.applicationId = apiKey;
        } else if (apiKey.applicationSecretKey != null) {
          logger40.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
          logger40.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
          apiKeyObj.applicationId = apiKey.applicationId;
          apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
          apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
        } else if (apiKey.applicationId) {
          logger40.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
          apiKeyObj.applicationId = apiKey.applicationId;
          apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
        } else {
          logger40.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
          case "homestead":
            host = "eth-mainnet.gateway.pokt.network";
            break;
          case "ropsten":
            host = "eth-ropsten.gateway.pokt.network";
            break;
          case "rinkeby":
            host = "eth-rinkeby.gateway.pokt.network";
            break;
          case "goerli":
            host = "eth-goerli.gateway.pokt.network";
            break;
          default:
            logger40.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        let url = null;
        if (apiKey.loadBalancer) {
          url = `https://${host}/v1/lb/${apiKey.applicationId}`;
        } else {
          url = `https://${host}/v1/${apiKey.applicationId}`;
        }
        const connection = { url };
        connection.headers = {};
        if (apiKey.applicationSecretKey != null) {
          connection.user = "";
          connection.password = apiKey.applicationSecretKey;
        }
        return connection;
      }
      isCommunityResource() {
        return this.applicationId === defaultApplicationIds[this.network.name];
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/web3-provider.js
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var logger41, _nextId, Web3Provider;
var init_web3_provider = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/web3-provider.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version24();
    init_json_rpc_provider();
    logger41 = new Logger(version24);
    _nextId = 1;
    Web3Provider = class _Web3Provider extends JsonRpcProvider {
      constructor(provider, network) {
        logger41.checkNew(new.target, _Web3Provider);
        if (provider == null) {
          logger41.throwArgumentError("missing provider", "provider", provider);
        }
        let path = null;
        let jsonRpcFetchFunc = null;
        let subprovider = null;
        if (typeof provider === "function") {
          path = "unknown:";
          jsonRpcFetchFunc = provider;
        } else {
          path = provider.host || provider.path || "";
          if (!path && provider.isMetaMask) {
            path = "metamask";
          }
          subprovider = provider;
          if (provider.request) {
            if (path === "") {
              path = "eip-1193:";
            }
            jsonRpcFetchFunc = buildEip1193Fetcher(provider);
          } else if (provider.sendAsync) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
          } else if (provider.send) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
          } else {
            logger41.throwArgumentError("unsupported provider", "provider", provider);
          }
          if (!path) {
            path = "unknown:";
          }
        }
        super(path, network);
        defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        defineReadOnly(this, "provider", subprovider);
      }
      send(method, params) {
        return this.jsonRpcFetchFunc(method, params);
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new JsonRpcProvider(network);
        case "ws":
          return new WebSocketProvider(network);
        default:
          logger42.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n2 = getNetwork(network);
  if (!n2 || !n2._defaultProvider) {
    logger42.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n2._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}
var logger42;
var init_lib28 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/providers/lib.esm/index.js"() {
    "use strict";
    init_lib12();
    init_lib25();
    init_base_provider();
    init_alchemy_provider();
    init_cloudflare_provider();
    init_etherscan_provider();
    init_fallback_provider();
    init_ipc_provider();
    init_infura_provider();
    init_json_rpc_provider();
    init_json_rpc_batch_provider();
    init_nodesmith_provider();
    init_pocket_provider();
    init_url_json_rpc_provider();
    init_web3_provider();
    init_websocket_provider();
    init_formatter();
    init_lib();
    init_version24();
    logger42 = new Logger(version24);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/solidity/lib.esm/_version.js
var version25;
var init_version25 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    version25 = "solidity/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/solidity/lib.esm/index.js
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger43.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger43.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger43.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros2).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger43.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger43.throwArgumentError("invalid type", "type", type);
}
function pack2(types, values) {
  if (types.length != values.length) {
    logger43.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack2(types, values));
}
function sha2562(types, values) {
  return sha256(pack2(types, values));
}
var regexBytes, regexNumber, regexArray, Zeros2, logger43;
var init_lib29 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib18();
    init_lib9();
    init_lib();
    init_version25();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
    logger43 = new Logger(version25);
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/units/lib.esm/_version.js
var version26;
var init_version26 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/units/lib.esm/_version.js"() {
    version26 = "units/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/@ethersproject/units/lib.esm/index.js
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger44.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger44.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger44, names;
var init_lib30 = __esm({
  "node_modules/moralis-v1/node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib();
    init_version26();
    logger44 = new Logger(version26);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// node_modules/moralis-v1/node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse2,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
var init_utils2 = __esm({
  "node_modules/moralis-v1/node_modules/ethers/lib.esm/utils.js"() {
    "use strict";
    init_lib11();
    init_lib7();
    init_lib26();
    init_lib17();
    init_lib2();
    init_lib10();
    init_lib21();
    init_lib23();
    init_lib5();
    init_lib();
    init_lib18();
    init_lib29();
    init_lib22();
    init_lib4();
    init_lib6();
    init_lib14();
    init_lib9();
    init_lib15();
    init_lib30();
    init_lib24();
    init_lib27();
    init_lib18();
    init_lib9();
  }
});

// node_modules/moralis-v1/node_modules/ethers/lib.esm/_version.js
var version27;
var init_version27 = __esm({
  "node_modules/moralis-v1/node_modules/ethers/lib.esm/_version.js"() {
    version27 = "ethers/5.6.0";
  }
});

// node_modules/moralis-v1/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger45,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version27,
  wordlists: () => wordlists
});
var logger45;
var init_ethers = __esm({
  "node_modules/moralis-v1/node_modules/ethers/lib.esm/ethers.js"() {
    "use strict";
    init_lib16();
    init_lib3();
    init_lib13();
    init_lib24();
    init_lib8();
    init_lib28();
    init_lib28();
    init_lib20();
    init_utils2();
    init_lib();
    init_version27();
    logger45 = new Logger(version27);
  }
});

// node_modules/moralis-v1/node_modules/ethers/lib.esm/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  ethers: () => ethers_exports,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger45,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version27,
  wordlists: () => wordlists
});
var init_lib31 = __esm({
  "node_modules/moralis-v1/node_modules/ethers/lib.esm/index.js"() {
    "use strict";
    init_ethers();
    init_ethers();
    try {
      const anyGlobal2 = window;
      if (anyGlobal2._ethers == null) {
        anyGlobal2._ethers = ethers_exports;
      }
    } catch (error) {
    }
  }
});

// node_modules/moralis-v1/lib/browser/Cloud.js
var require_Cloud = __commonJS({
  "node_modules/moralis-v1/lib/browser/Cloud.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getJobStatus = getJobStatus;
    exports.getJobsData = getJobsData;
    exports.run = run;
    exports.startJob = startJob;
    var _keys = _interopRequireDefault(require_keys3());
    var _promise = _interopRequireDefault(require_promise3());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _decode2 = _interopRequireDefault(require_decode());
    var _encode3 = _interopRequireDefault(require_encode());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    function run(name2, data, options) {
      options = options || {};
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new TypeError("Cloud function name must be a string.");
      }
      var requestOptions = {};
      if (options.useMasterKey) {
        requestOptions.useMasterKey = options.useMasterKey;
      }
      if (options.sessionToken) {
        requestOptions.sessionToken = options.sessionToken;
      }
      if (options.context && (0, _typeof2.default)(options.context) === "object") {
        requestOptions.context = options.context;
      }
      return _CoreManager.default.getCloudController().run(name2, data, requestOptions);
    }
    function getJobsData() {
      return _CoreManager.default.getCloudController().getJobsData({
        useMasterKey: true
      });
    }
    function startJob(name2, data) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new TypeError("Cloud job name must be a string.");
      }
      return _CoreManager.default.getCloudController().startJob(name2, data, {
        useMasterKey: true
      });
    }
    function getJobStatus(jobStatusId) {
      var query = new _ParseQuery.default("_JobStatus");
      return query.get(jobStatusId, {
        useMasterKey: true
      });
    }
    var DefaultController = {
      run: function(name2, data, options) {
        var RESTController = _CoreManager.default.getRESTController();
        var payload = (0, _encode3.default)(data, true);
        var request = RESTController.request("POST", "functions/".concat(name2), payload, options);
        return request.then(function(res) {
          if ((0, _typeof2.default)(res) === "object" && (0, _keys.default)(res).length > 0 && !res.hasOwnProperty("result")) {
            throw new _ParseError.default(_ParseError.default.INVALID_JSON, "The server returned an invalid response.");
          }
          var decoded = (0, _decode2.default)(res);
          if (decoded && decoded.hasOwnProperty("result")) {
            return _promise.default.resolve(decoded.result);
          }
          return _promise.default.resolve(void 0);
        });
      },
      getJobsData: function(options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "cloud_code/jobs/data", null, options);
      },
      startJob: function(name2, data, options) {
        var RESTController = _CoreManager.default.getRESTController();
        var payload = (0, _encode3.default)(data, true);
        return RESTController.request("POST", "jobs/".concat(name2), payload, options);
      }
    };
    _CoreManager.default.setCloudController(DefaultController);
  }
});

// node_modules/moralis-v1/lib/browser/createSigningData.js
var require_createSigningData = __commonJS({
  "node_modules/moralis-v1/lib/browser/createSigningData.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createSigningData;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _concat = _interopRequireDefault(require_concat4());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _Cloud = require_Cloud();
    function createSigningData() {
      return _createSigningData.apply(this, arguments);
    }
    function _createSigningData() {
      _createSigningData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(message) {
        var data, _context, _context2, _yield$run, dateTime, applicationId;
        return _regenerator.default.wrap(function(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return (0, _Cloud.run)("getServerTime");
              case 3:
                _yield$run = _context3.sent;
                dateTime = _yield$run.dateTime;
                applicationId = _CoreManager.default.get("APPLICATION_ID");
                data = (0, _concat.default)(_context = (0, _concat.default)(_context2 = "".concat(message, "\n\nId: ")).call(_context2, applicationId, ":")).call(_context, dateTime);
                _context3.next = 12;
                break;
              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3["catch"](0);
                data = "".concat(message);
              case 12:
                return _context3.abrupt("return", data);
              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee, null, [[0, 9]]);
      }));
      return _createSigningData.apply(this, arguments);
    }
  }
});

// node_modules/moralis-v1/lib/browser/MoralisErd.js
var require_MoralisErd = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisErd.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _filter = _interopRequireDefault(require_filter4());
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _createSigningData = _interopRequireDefault(require_createSigningData());
    var INIT_ERROR = "Could not initialise ledger app, make sure Elrond app is open";
    function getErdJs() {
      return MoralisErd.getErdJs();
    }
    var MoralisErd = function() {
      function MoralisErd2() {
        (0, _classCallCheck2.default)(this, MoralisErd2);
      }
      (0, _createClass2.default)(MoralisErd2, null, [{
        key: "getErdJs",
        value: function() {
          if (typeof window !== "undefined" && window.erdjs)
            return window.erdjs;
          throw new Error("Please add erdjs scripts");
        }
      }, {
        key: "gatewayAddress",
        value: function() {
          return "https://gateway.elrond.com";
        }
      }, {
        key: "hwProxy",
        value: function() {
          var _hwProxy = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var _getErdJs, ProxyProvider, proxy;
            return _regenerator.default.wrap(function(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!MoralisErd2._proxy) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", MoralisErd2._proxy);
                  case 2:
                    _getErdJs = getErdJs(), ProxyProvider = _getErdJs.ProxyProvider;
                    proxy = new ProxyProvider(MoralisErd2.gatewayAddress());
                    MoralisErd2._proxy = proxy;
                    return _context.abrupt("return", MoralisErd2._proxy);
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function() {
            return _hwProxy.apply(this, arguments);
          };
        }()
      }, {
        key: "hwProvider",
        value: function() {
          return MoralisErd2._hw;
        }
      }, {
        key: "enable",
        value: function() {
          var _enable = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            var _getErdJs2, HWProvider, proxy, hw, success;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _getErdJs2 = getErdJs(), HWProvider = _getErdJs2.HWProvider;
                    _context2.next = 3;
                    return MoralisErd2.hwProxy();
                  case 3:
                    proxy = _context2.sent;
                    hw = new HWProvider(proxy);
                    _context2.next = 7;
                    return hw.init();
                  case 7:
                    success = _context2.sent;
                    if (success) {
                      _context2.next = 10;
                      break;
                    }
                    throw new Error(INIT_ERROR);
                  case 10:
                    MoralisErd2._hw = hw;
                    return _context2.abrupt("return", hw);
                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function() {
            return _enable.apply(this, arguments);
          };
        }()
      }, {
        key: "authenticate",
        value: function() {
          var _authenticate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
            var hw, address, erdAddress, accounts, message, data, signature2, authData, user;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return MoralisErd2.enable();
                  case 2:
                    hw = _context3.sent;
                    _context3.next = 5;
                    return hw.login();
                  case 5:
                    address = _context3.sent;
                    erdAddress = address.toLowerCase();
                    accounts = [erdAddress];
                    message = MoralisErd2.getSigningData();
                    _context3.next = 11;
                    return (0, _createSigningData.default)(message);
                  case 11:
                    data = _context3.sent;
                    _context3.next = 14;
                    return MoralisErd2.sign(data);
                  case 14:
                    signature2 = _context3.sent;
                    authData = {
                      id: erdAddress,
                      signature: signature2,
                      data
                    };
                    _context3.next = 18;
                    return _ParseUser.default.logInWith("moralisErd", {
                      authData
                    });
                  case 18:
                    user = _context3.sent;
                    if (user) {
                      _context3.next = 21;
                      break;
                    }
                    throw new Error("Could not get user");
                  case 21:
                    _context3.next = 23;
                    return user.setACL(new _ParseACL.default(user));
                  case 23:
                    user.addAllUnique("erdAccounts", accounts);
                    user.set("erdAddress", erdAddress);
                    _context3.next = 27;
                    return user.save();
                  case 27:
                    return _context3.abrupt("return", user);
                  case 28:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));
          return function() {
            return _authenticate.apply(this, arguments);
          };
        }()
      }, {
        key: "link",
        value: function() {
          var _link = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(account, options) {
            var message, user, erdAddress, ErdAddress, query, erdAddressRecord, data, signature2, authData;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisErd2.getSigningData();
                    _context4.next = 3;
                    return _ParseUser.default.current();
                  case 3:
                    user = _context4.sent;
                    erdAddress = account.toLowerCase();
                    ErdAddress = _ParseObject.default.extend("_ErdAddress");
                    query = new _ParseQuery.default(ErdAddress);
                    _context4.next = 9;
                    return query.get(erdAddress).catch(function() {
                      return null;
                    });
                  case 9:
                    erdAddressRecord = _context4.sent;
                    if (erdAddressRecord) {
                      _context4.next = 20;
                      break;
                    }
                    _context4.next = 13;
                    return (0, _createSigningData.default)(message);
                  case 13:
                    data = _context4.sent;
                    _context4.next = 16;
                    return MoralisErd2.sign(data);
                  case 16:
                    signature2 = _context4.sent;
                    authData = {
                      id: erdAddress,
                      signature: signature2,
                      data
                    };
                    _context4.next = 20;
                    return user.linkWith("moralisErd", {
                      authData
                    });
                  case 20:
                    user.addAllUnique("erdAccounts", [erdAddress]);
                    user.set("erdAddress", erdAddress);
                    _context4.next = 24;
                    return user.save();
                  case 24:
                    return _context4.abrupt("return", user);
                  case 25:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));
          return function() {
            return _link.apply(this, arguments);
          };
        }()
      }, {
        key: "unlink",
        value: function() {
          var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(account) {
            var _user$get;
            var accountsLower, ErdAddress, query, erdAddressRecord, user, accounts, nextAccounts;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    accountsLower = account.toLowerCase();
                    ErdAddress = _ParseObject.default.extend("_ErdAddress");
                    query = new _ParseQuery.default(ErdAddress);
                    _context5.next = 5;
                    return query.get(accountsLower);
                  case 5:
                    erdAddressRecord = _context5.sent;
                    _context5.next = 8;
                    return erdAddressRecord.destroy();
                  case 8:
                    _context5.next = 10;
                    return _ParseUser.default.current();
                  case 10:
                    user = _context5.sent;
                    accounts = (_user$get = user.get("erdAccounts")) !== null && _user$get !== void 0 ? _user$get : [];
                    nextAccounts = (0, _filter.default)(accounts).call(accounts, function(v2) {
                      return v2 !== accountsLower;
                    });
                    user.set("erdAccounts", nextAccounts);
                    user.set("erdAddress", nextAccounts[0]);
                    _context5.next = 17;
                    return user._unlinkFrom("moralisErd");
                  case 17:
                    _context5.next = 19;
                    return user.save();
                  case 19:
                    return _context5.abrupt("return", user);
                  case 20:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));
          return function() {
            return _unlink.apply(this, arguments);
          };
        }()
      }, {
        key: "sign",
        value: function() {
          var _sign = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(data) {
            return _regenerator.default.wrap(function(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    return _context6.abrupt("return", data);
                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));
          return function() {
            return _sign.apply(this, arguments);
          };
        }()
      }, {
        key: "getSigningData",
        value: function() {
          return "Moralis Authentication";
        }
      }]);
      return MoralisErd2;
    }();
    var _default = MoralisErd;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/MoralisDot.js
var require_MoralisDot = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisDot.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _keys = _interopRequireDefault(require_keys3());
    var _filter = _interopRequireDefault(require_filter4());
    var _from = _interopRequireDefault(require_from3());
    var _slice = _interopRequireDefault(require_slice4());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _createSigningData = _interopRequireDefault(require_createSigningData());
    var web3EnablePromise = null;
    var MoralisDot = function() {
      function MoralisDot2() {
        (0, _classCallCheck2.default)(this, MoralisDot2);
      }
      (0, _createClass2.default)(MoralisDot2, null, [{
        key: "web3IsInjected",
        value: function() {
          return (0, _keys.default)(window.injectedWeb3).length !== 0;
        }
      }, {
        key: "enable",
        value: function() {
          var _enable = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(opts) {
            var _window$injectedWeb, _window$injectedWeb$t;
            var type, _args = arguments;
            return _regenerator.default.wrap(function(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    type = _args.length > 1 && _args[1] !== void 0 ? _args[1] : "polkadot-js";
                    if (!web3EnablePromise) {
                      _context.next = 3;
                      break;
                    }
                    return _context.abrupt("return", web3EnablePromise);
                  case 3:
                    web3EnablePromise = (_window$injectedWeb = window.injectedWeb3) === null || _window$injectedWeb === void 0 ? void 0 : (_window$injectedWeb$t = _window$injectedWeb[type]) === null || _window$injectedWeb$t === void 0 ? void 0 : _window$injectedWeb$t.enable(opts);
                    return _context.abrupt("return", web3EnablePromise);
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function() {
            return _enable.apply(this, arguments);
          };
        }()
      }, {
        key: "authenticate",
        value: function() {
          var _authenticate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(opts) {
            var _opts$name;
            var allAccounts, account, address, dotAddress, accounts, message, data, signature2, authData, user;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return MoralisDot2.enable((_opts$name = opts === null || opts === void 0 ? void 0 : opts.name) !== null && _opts$name !== void 0 ? _opts$name : "Moralis");
                  case 2:
                    MoralisDot2.web3 = _context2.sent;
                    _context2.next = 5;
                    return MoralisDot2.web3.accounts.get();
                  case 5:
                    allAccounts = _context2.sent;
                    account = allAccounts[0];
                    address = account === null || account === void 0 ? void 0 : account.address;
                    if (address) {
                      _context2.next = 10;
                      break;
                    }
                    throw new Error("Address not found");
                  case 10:
                    dotAddress = address;
                    accounts = [dotAddress];
                    message = MoralisDot2.getSigningData();
                    _context2.next = 15;
                    return (0, _createSigningData.default)(message);
                  case 15:
                    data = _context2.sent;
                    _context2.next = 18;
                    return MoralisDot2.sign(address, data);
                  case 18:
                    signature2 = _context2.sent;
                    authData = {
                      id: dotAddress,
                      signature: signature2,
                      data
                    };
                    _context2.next = 22;
                    return _ParseUser.default.logInWith("moralisDot", {
                      authData
                    });
                  case 22:
                    user = _context2.sent;
                    if (user) {
                      _context2.next = 25;
                      break;
                    }
                    throw new Error("Could not get user");
                  case 25:
                    _context2.next = 27;
                    return user.setACL(new _ParseACL.default(user));
                  case 27:
                    user.addAllUnique("dotAccounts", accounts);
                    user.set("dotAddress", dotAddress);
                    _context2.next = 31;
                    return user.save();
                  case 31:
                    return _context2.abrupt("return", user);
                  case 32:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function() {
            return _authenticate.apply(this, arguments);
          };
        }()
      }, {
        key: "link",
        value: function() {
          var _link = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(account, options) {
            var message, user, dotAddress, DotAddress, query, dotAddressRecord, data, signature2, authData;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisDot2.getSigningData();
                    _context3.next = 3;
                    return _ParseUser.default.current();
                  case 3:
                    user = _context3.sent;
                    dotAddress = account;
                    DotAddress = _ParseObject.default.extend("_DotAddress");
                    query = new _ParseQuery.default(DotAddress);
                    _context3.next = 9;
                    return query.get(dotAddress).catch(function() {
                      return null;
                    });
                  case 9:
                    dotAddressRecord = _context3.sent;
                    if (dotAddressRecord) {
                      _context3.next = 20;
                      break;
                    }
                    _context3.next = 13;
                    return (0, _createSigningData.default)(message);
                  case 13:
                    data = _context3.sent;
                    _context3.next = 16;
                    return MoralisDot2.sign(dotAddress, data);
                  case 16:
                    signature2 = _context3.sent;
                    authData = {
                      id: dotAddress,
                      signature: signature2,
                      data
                    };
                    _context3.next = 20;
                    return user.linkWith("moralisDot", {
                      authData
                    });
                  case 20:
                    user.addAllUnique("dotAccounts", [dotAddress]);
                    user.set("dotAddress", dotAddress);
                    _context3.next = 24;
                    return user.save();
                  case 24:
                    return _context3.abrupt("return", user);
                  case 25:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));
          return function() {
            return _link.apply(this, arguments);
          };
        }()
      }, {
        key: "unlink",
        value: function() {
          var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(account) {
            var _user$get;
            var accountsLower, DotAddress, query, dotAddressRecord, user, accounts, nextAccounts;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    accountsLower = account;
                    DotAddress = _ParseObject.default.extend("_DotAddress");
                    query = new _ParseQuery.default(DotAddress);
                    _context4.next = 5;
                    return query.get(accountsLower);
                  case 5:
                    dotAddressRecord = _context4.sent;
                    _context4.next = 8;
                    return dotAddressRecord.destroy();
                  case 8:
                    _context4.next = 10;
                    return _ParseUser.default.current();
                  case 10:
                    user = _context4.sent;
                    accounts = (_user$get = user.get("dotAccounts")) !== null && _user$get !== void 0 ? _user$get : [];
                    nextAccounts = (0, _filter.default)(accounts).call(accounts, function(v2) {
                      return v2 !== accountsLower;
                    });
                    user.set("dotAccounts", nextAccounts);
                    user.set("dotAddress", nextAccounts[0]);
                    _context4.next = 17;
                    return user._unlinkFrom("moralisDot");
                  case 17:
                    _context4.next = 19;
                    return user.save();
                  case 19:
                    return _context4.abrupt("return", user);
                  case 20:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));
          return function() {
            return _unlink.apply(this, arguments);
          };
        }()
      }, {
        key: "sign",
        value: function() {
          var _sign = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(address, data) {
            var web3, _yield$web3$signer$si, signature2;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (web3EnablePromise) {
                      _context5.next = 2;
                      break;
                    }
                    throw new Error("Must enable MoralisDot");
                  case 2:
                    _context5.next = 4;
                    return web3EnablePromise;
                  case 4:
                    web3 = _context5.sent;
                    if (web3.signer) {
                      _context5.next = 7;
                      break;
                    }
                    throw new Error("No signer found");
                  case 7:
                    _context5.next = 9;
                    return web3.signer.signRaw({
                      address,
                      data: stringToHex(data),
                      type: "bytes"
                    });
                  case 9:
                    _yield$web3$signer$si = _context5.sent;
                    signature2 = _yield$web3$signer$si.signature;
                    return _context5.abrupt("return", signature2);
                  case 12:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));
          return function() {
            return _sign.apply(this, arguments);
          };
        }()
      }, {
        key: "getSigningData",
        value: function() {
          return "Moralis Authentication";
        }
      }]);
      return MoralisDot2;
    }();
    var _default = MoralisDot;
    exports.default = _default;
    function stringToHex(value) {
      return toHexString(stringToU8a(value));
    }
    function stringToU8a(value) {
      var u8a = new Uint8Array(value.length);
      for (var i2 = 0; i2 < value.length; i2++) {
        u8a[i2] = value.charCodeAt(i2);
      }
      return u8a;
    }
    function toHexString(byteArray) {
      return "0x".concat((0, _from.default)(byteArray, function(byte) {
        var _context6;
        return (0, _slice.default)(_context6 = "0".concat((byte & 255).toString(16))).call(_context6, -2);
      }).join(""));
    }
  }
});

// node_modules/core-js-pure/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js-pure/internals/array-reduce.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = "Reduce of empty array with no initial value";
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo2) {
        var O2 = toObject(that);
        var self2 = IndexedObject(O2);
        var length = lengthOfArrayLike(O2);
        aCallable(callbackfn);
        if (length === 0 && argumentsLength < 2)
          throw new $TypeError(REDUCE_EMPTY);
        var index = IS_RIGHT ? length - 1 : 0;
        var i2 = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index in self2) {
              memo2 = self2[index];
              index += i2;
              break;
            }
            index += i2;
            if (IS_RIGHT ? index < 0 : length <= index) {
              throw new $TypeError(REDUCE_EMPTY);
            }
          }
        for (; IS_RIGHT ? index >= 0 : length > index; index += i2)
          if (index in self2) {
            memo2 = callbackfn(memo2, self2[index], index, O2);
          }
        return memo2;
      };
    };
    module.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js-pure/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "node_modules/core-js-pure/modules/es.array.reduce.js"() {
    "use strict";
    var $ = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_engine_v8_version();
    var IS_NODE = require_engine_is_node();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/reduce.js
var require_reduce = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/reduce.js"(exports, module) {
    "use strict";
    require_es_array_reduce();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "reduce");
  }
});

// node_modules/core-js-pure/es/instance/reduce.js
var require_reduce2 = __commonJS({
  "node_modules/core-js-pure/es/instance/reduce.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_reduce();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.reduce;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.reduce ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/reduce.js
var require_reduce3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/reduce.js"(exports, module) {
    "use strict";
    var parent = require_reduce2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/reduce.js
var require_reduce4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/reduce.js"(exports, module) {
    module.exports = require_reduce3();
  }
});

// node_modules/core-js-pure/internals/string-pad-webkit-bug.js
var require_string_pad_webkit_bug = __commonJS({
  "node_modules/core-js-pure/internals/string-pad-webkit-bug.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
  }
});

// node_modules/core-js-pure/modules/es.string.pad-start.js
var require_es_string_pad_start = __commonJS({
  "node_modules/core-js-pure/modules/es.string.pad-start.js"() {
    "use strict";
    var $ = require_export();
    var $padStart = require_string_pad().start;
    var WEBKIT_BUG = require_string_pad_webkit_bug();
    $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
      padStart: function padStart(maxLength) {
        return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/string/virtual/pad-start.js
var require_pad_start = __commonJS({
  "node_modules/core-js-pure/es/string/virtual/pad-start.js"(exports, module) {
    "use strict";
    require_es_string_pad_start();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("String", "padStart");
  }
});

// node_modules/core-js-pure/es/instance/pad-start.js
var require_pad_start2 = __commonJS({
  "node_modules/core-js-pure/es/instance/pad-start.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_pad_start();
    var StringPrototype = String.prototype;
    module.exports = function(it) {
      var own = it.padStart;
      return typeof it == "string" || it === StringPrototype || isPrototypeOf(StringPrototype, it) && own === StringPrototype.padStart ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/pad-start.js
var require_pad_start3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/pad-start.js"(exports, module) {
    "use strict";
    var parent = require_pad_start2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/pad-start.js
var require_pad_start4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/pad-start.js"(exports, module) {
    module.exports = require_pad_start3();
  }
});

// node_modules/moralis-v1/lib/browser/MoralisSol.js
var require_MoralisSol = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisSol.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _concat = _interopRequireDefault(require_concat4());
    var _filter = _interopRequireDefault(require_filter4());
    var _reduce = _interopRequireDefault(require_reduce4());
    var _padStart = _interopRequireDefault(require_pad_start4());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _createSigningData = _interopRequireDefault(require_createSigningData());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var base64 = {
      decode: function(s2) {
        return Uint8Array.from(atob(s2), function(c2) {
          return c2.charCodeAt(0);
        });
      },
      encode: function(b2) {
        return btoa(String.fromCharCode.apply(String, (0, _toConsumableArray2.default)(new Uint8Array(b2))));
      }
    };
    var MoralisSol = function() {
      function MoralisSol2() {
        (0, _classCallCheck2.default)(this, MoralisSol2);
      }
      (0, _createClass2.default)(MoralisSol2, null, [{
        key: "authenticate",
        value: function() {
          var _authenticate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(options) {
            var _context, _user$get;
            var phantom, solAddress, accounts, message, data, signature2, authData, user;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return MoralisSol2.enable();
                  case 2:
                    phantom = _context2.sent;
                    if (phantom) {
                      _context2.next = 5;
                      break;
                    }
                    throw new Error("Phantom wallet not available");
                  case 5:
                    solAddress = phantom.publicKey.toString();
                    if (solAddress) {
                      _context2.next = 8;
                      break;
                    }
                    throw new Error("Address not found");
                  case 8:
                    accounts = [solAddress];
                    message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisSol2.getSigningData();
                    _context2.next = 12;
                    return (0, _createSigningData.default)(message);
                  case 12:
                    data = _context2.sent;
                    _context2.next = 15;
                    return MoralisSol2.sign(data);
                  case 15:
                    signature2 = _context2.sent;
                    authData = {
                      id: solAddress,
                      signature: signature2,
                      data
                    };
                    _context2.next = 19;
                    return _ParseUser.default.logInWith("moralisSol", {
                      authData
                    });
                  case 19:
                    user = _context2.sent;
                    _context2.next = 22;
                    return user.setACL(new _ParseACL.default(user));
                  case 22:
                    if (user) {
                      _context2.next = 24;
                      break;
                    }
                    throw new Error("Could not get user");
                  case 24:
                    user.set("solAccounts", uniq((0, _concat.default)(_context = []).call(_context, accounts, (_user$get = user.get("solAccounts")) !== null && _user$get !== void 0 ? _user$get : [])));
                    user.set("solAddress", solAddress);
                    _context2.next = 28;
                    return user.save();
                  case 28:
                    return _context2.abrupt("return", user);
                  case 29:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee);
          }));
          return function() {
            return _authenticate.apply(this, arguments);
          };
        }()
      }, {
        key: "link",
        value: function() {
          var _link = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(account, options) {
            var _context3, _user$get2;
            var message, user, solAddress, SolAddress, query, solAddressRecord, data, signature2, authData;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisSol2.getSigningData();
                    _context4.next = 3;
                    return _ParseUser.default.current();
                  case 3:
                    user = _context4.sent;
                    solAddress = account;
                    SolAddress = _ParseObject.default.extend("_SolAddress");
                    query = new _ParseQuery.default(SolAddress);
                    _context4.next = 9;
                    return query.get(solAddress).catch(function() {
                      return null;
                    });
                  case 9:
                    solAddressRecord = _context4.sent;
                    if (solAddressRecord) {
                      _context4.next = 20;
                      break;
                    }
                    _context4.next = 13;
                    return (0, _createSigningData.default)(message);
                  case 13:
                    data = _context4.sent;
                    _context4.next = 16;
                    return MoralisSol2.sign(solAddress, data);
                  case 16:
                    signature2 = _context4.sent;
                    authData = {
                      id: solAddress,
                      signature: signature2,
                      data
                    };
                    _context4.next = 20;
                    return user.linkWith("moralisSol", {
                      authData
                    });
                  case 20:
                    user.set("SolAccounts", uniq((0, _concat.default)(_context3 = [solAddress]).call(_context3, (_user$get2 = user.get("SolAccounts")) !== null && _user$get2 !== void 0 ? _user$get2 : [])));
                    user.set("solAddress", solAddress);
                    _context4.next = 24;
                    return user.save();
                  case 24:
                    return _context4.abrupt("return", user);
                  case 25:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee2);
          }));
          return function() {
            return _link.apply(this, arguments);
          };
        }()
      }, {
        key: "unlink",
        value: function() {
          var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(account) {
            var _user$get3;
            var accountsLower, SolAddress, query, solAddressRecord, user, accounts, nextAccounts;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    accountsLower = account;
                    SolAddress = _ParseObject.default.extend("_SolAddress");
                    query = new _ParseQuery.default(SolAddress);
                    _context5.next = 5;
                    return query.get(accountsLower);
                  case 5:
                    solAddressRecord = _context5.sent;
                    _context5.next = 8;
                    return solAddressRecord.destroy();
                  case 8:
                    _context5.next = 10;
                    return _ParseUser.default.current();
                  case 10:
                    user = _context5.sent;
                    accounts = (_user$get3 = user.get("solAccounts")) !== null && _user$get3 !== void 0 ? _user$get3 : [];
                    nextAccounts = (0, _filter.default)(accounts).call(accounts, function(v2) {
                      return v2 !== accountsLower;
                    });
                    user.set("solAccounts", nextAccounts);
                    user.set("solAddress", nextAccounts[0]);
                    _context5.next = 17;
                    return user._unlinkFrom("moralisSol");
                  case 17:
                    _context5.next = 19;
                    return user.save();
                  case 19:
                    return _context5.abrupt("return", user);
                  case 20:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee3);
          }));
          return function() {
            return _unlink.apply(this, arguments);
          };
        }()
      }, {
        key: "sign",
        value: function() {
          var _sign = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(message) {
            var phantom, encodedMessage, signedMessage;
            return _regenerator.default.wrap(function(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return MoralisSol2.enable();
                  case 2:
                    phantom = _context6.sent;
                    encodedMessage = new TextEncoder().encode(message);
                    _context6.next = 6;
                    return phantom.signMessage(encodedMessage, "utf8");
                  case 6:
                    signedMessage = _context6.sent;
                    return _context6.abrupt("return", base64.encode(signedMessage.signature));
                  case 8:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee4);
          }));
          return function() {
            return _sign.apply(this, arguments);
          };
        }()
      }, {
        key: "getSigningData",
        value: function() {
          return "Moralis Authentication";
        }
      }]);
      return MoralisSol2;
    }();
    (0, _defineProperty2.default)(MoralisSol, "enable", (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5() {
      var provider;
      return _regenerator.default.wrap(function(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!(window && "solana" in window)) {
                _context8.next = 17;
                break;
              }
              provider = window.solana;
              if (!provider.isPhantom) {
                _context8.next = 17;
                break;
              }
              _context8.prev = 3;
              _context8.next = 6;
              return provider.connect({
                onlyIfTrusted: true
              });
            case 6:
              _context8.next = 16;
              break;
            case 8:
              _context8.prev = 8;
              _context8.t0 = _context8["catch"](3);
              if (!(_context8.t0.message === "User rejected the request.")) {
                _context8.next = 15;
                break;
              }
              _context8.next = 13;
              return provider.connect();
            case 13:
              _context8.next = 16;
              break;
            case 15:
              throw _context8.t0;
            case 16:
              return _context8.abrupt("return", provider);
            case 17:
              throw new Error("Phantom wallet not available");
            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee5, null, [[3, 8]]);
    })));
    function uniq(arr) {
      return (0, _filter.default)(arr).call(arr, function(v2, i2) {
        return (0, _indexOf.default)(arr).call(arr, v2) === i2;
      });
    }
    var _default = MoralisSol;
    exports.default = _default;
  }
});

// node_modules/core-js-pure/internals/is-integral-number.js
var require_is_integral_number = __commonJS({
  "node_modules/core-js-pure/internals/is-integral-number.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var floor = Math.floor;
    module.exports = Number.isInteger || function isInteger2(it) {
      return !isObject(it) && isFinite(it) && floor(it) === it;
    };
  }
});

// node_modules/core-js-pure/modules/es.number.is-integer.js
var require_es_number_is_integer = __commonJS({
  "node_modules/core-js-pure/modules/es.number.is-integer.js"() {
    "use strict";
    var $ = require_export();
    var isIntegralNumber = require_is_integral_number();
    $({ target: "Number", stat: true }, {
      isInteger: isIntegralNumber
    });
  }
});

// node_modules/core-js-pure/es/number/is-integer.js
var require_is_integer = __commonJS({
  "node_modules/core-js-pure/es/number/is-integer.js"(exports, module) {
    "use strict";
    require_es_number_is_integer();
    var path = require_path();
    module.exports = path.Number.isInteger;
  }
});

// node_modules/core-js-pure/stable/number/is-integer.js
var require_is_integer2 = __commonJS({
  "node_modules/core-js-pure/stable/number/is-integer.js"(exports, module) {
    "use strict";
    var parent = require_is_integer();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/number/is-integer.js
var require_is_integer3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/number/is-integer.js"(exports, module) {
    module.exports = require_is_integer2();
  }
});

// node_modules/moralis-v1/lib/browser/TransferUtils.js
var require_TransferUtils = __commonJS({
  "node_modules/moralis-v1/lib/browser/TransferUtils.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _keys = _interopRequireDefault(require_keys3());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _isInteger = _interopRequireDefault(require_is_integer3());
    var supportedTypes = ["native", "erc20", "erc721", "erc1155"];
    var ERC1155TransferABI = [{
      inputs: [{
        internalType: "address",
        name: "from",
        type: "address"
      }, {
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }, {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }],
      outputs: [{
        name: "",
        type: "bool"
      }],
      name: "safeTransferFrom",
      type: "function",
      constant: false,
      payable: false
    }, {
      inputs: [{
        internalType: "address",
        name: "from",
        type: "address"
      }, {
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }],
      outputs: [{
        name: "",
        type: "bool"
      }],
      name: "transferFrom",
      type: "function",
      constant: false,
      payable: false
    }];
    var ERC721TransferABI = [{
      inputs: [{
        internalType: "address",
        name: "from",
        type: "address"
      }, {
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }],
      outputs: [{
        name: "",
        type: "bool"
      }],
      name: "safeTransferFrom",
      type: "function",
      constant: false,
      payable: false
    }, {
      inputs: [{
        internalType: "address",
        name: "from",
        type: "address"
      }, {
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }],
      outputs: [{
        name: "",
        type: "bool"
      }],
      name: "transferFrom",
      type: "function",
      constant: false,
      payable: false
    }];
    var ERC20TransferABI = [{
      constant: false,
      inputs: [{
        name: "_to",
        type: "address"
      }, {
        name: "_value",
        type: "uint256"
      }],
      name: "transfer",
      outputs: [{
        name: "",
        type: "bool"
      }],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: true,
      inputs: [{
        name: "_owner",
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        name: "balance",
        type: "uint256"
      }],
      payable: false,
      stateMutability: "view",
      type: "function"
    }];
    var tokenParams = {
      native: {
        receiver: "",
        amount: ""
      },
      erc20: {
        contractAddress: "",
        receiver: "",
        amount: ""
      },
      erc721: {
        contractAddress: "",
        receiver: "",
        tokenId: ""
      },
      erc1155: {
        contractAddress: "",
        receiver: "",
        tokenId: "",
        amount: ""
      }
    };
    var isNotEmpty = function(value) {
      return typeof value !== "undefined" && value ? true : false;
    };
    var validateInput = function(type, payload) {
      var errors = [];
      var parameters = tokenParams[type];
      for (var _i = 0, _Object$keys = (0, _keys.default)(parameters); _i < _Object$keys.length; _i++) {
        var key2 = _Object$keys[_i];
        if (!isNotEmpty(payload[key2])) {
          errors.push("".concat(key2, " is required"));
        }
      }
      if (errors.length > 0) {
        throw errors;
      }
    };
    var isSupportedType = function(type) {
      if ((0, _indexOf.default)(supportedTypes).call(supportedTypes, type) === -1)
        throw "Unsupported type";
      return true;
    };
    var isUint256 = function(tokenId) {
      if (!(0, _isInteger.default)(+tokenId) || +tokenId < 0)
        throw new Error("Invalid token Id");
      return true;
    };
    module.exports = {
      abi: {
        erc1155: ERC1155TransferABI,
        erc721: ERC721TransferABI,
        erc20: ERC20TransferABI
      },
      validateInput,
      isSupportedType,
      isNotEmpty,
      isUint256
    };
  }
});

// node_modules/moralis-v1/lib/browser/utils/convert.js
var require_convert = __commonJS({
  "node_modules/moralis-v1/lib/browser/utils/convert.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _parseInt2 = _interopRequireDefault(require_parse_int3());
    function fromDecimalToHex(number) {
      if (typeof number !== "number")
        throw "The input provided should be a number";
      return "0x".concat(number.toString(16));
    }
    function fromHexToDecimal(hex) {
      if (typeof hex !== "string")
        throw "The input provided should be a string";
      return (0, _parseInt2.default)(hex, 16);
    }
    module.exports = {
      fromDecimalToHex,
      fromHexToDecimal
    };
  }
});

// node_modules/moralis-v1/lib/browser/utils/verifyChainId.js
var require_verifyChainId = __commonJS({
  "node_modules/moralis-v1/lib/browser/utils/verifyChainId.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _convert = require_convert();
    function verifyChainId(chainId) {
      if (typeof chainId === "number")
        chainId = (0, _convert.fromDecimalToHex)(chainId);
      return chainId;
    }
    var _default = verifyChainId;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/events.js
var require_events2 = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/events.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EthereumEvents = exports.ConnectorEvents = void 0;
    var _freeze = _interopRequireDefault(require_freeze3());
    var EthereumEvents = (0, _freeze.default)({
      CONNECT: "connect",
      DISCONNECT: "disconnect",
      CHAIN_CHANGED: "chainChanged",
      ACCOUNTS_CHANGED: "accountsChanged"
    });
    exports.EthereumEvents = EthereumEvents;
    var ConnectorEvents = (0, _freeze.default)({
      CONNECT: "connect",
      DISCONNECT: "disconnect",
      CHAIN_CHANGED: "chainChanged",
      ACCOUNT_CHANGED: "accountChanged"
    });
    exports.ConnectorEvents = ConnectorEvents;
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/AbstractWeb3Connector.js
var require_AbstractWeb3Connector = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/AbstractWeb3Connector.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _bind = _interopRequireDefault(require_bind8());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _events = _interopRequireDefault(require_events());
    var _verifyChainId = _interopRequireDefault(require_verifyChainId());
    var _events2 = require_events2();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var AbstractWeb3Connector = function(_EventEmitter) {
      (0, _inherits2.default)(AbstractWeb3Connector2, _EventEmitter);
      var _super = _createSuper(AbstractWeb3Connector2);
      function AbstractWeb3Connector2() {
        var _context, _context2, _context3, _context4;
        var _this;
        (0, _classCallCheck2.default)(this, AbstractWeb3Connector2);
        _this = _super.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "type", "abstract");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "network", "evm");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "account", null);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "chainId", null);
        _this.handleAccountsChanged = (0, _bind.default)(_context = _this.handleAccountsChanged).call(_context, (0, _assertThisInitialized2.default)(_this));
        _this.handleChainChanged = (0, _bind.default)(_context2 = _this.handleChainChanged).call(_context2, (0, _assertThisInitialized2.default)(_this));
        _this.handleConnect = (0, _bind.default)(_context3 = _this.handleConnect).call(_context3, (0, _assertThisInitialized2.default)(_this));
        _this.handleDisconnect = (0, _bind.default)(_context4 = _this.handleDisconnect).call(_context4, (0, _assertThisInitialized2.default)(_this));
        return _this;
      }
      (0, _createClass2.default)(AbstractWeb3Connector2, [{
        key: "subscribeToEvents",
        value: function(provider) {
          if (provider && provider.on) {
            provider.on(_events2.EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);
            provider.on(_events2.EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);
            provider.on(_events2.EthereumEvents.CONNECT, this.handleConnect);
            provider.on(_events2.EthereumEvents.DISCONNECT, this.handleDisconnect);
          }
        }
      }, {
        key: "unsubscribeToEvents",
        value: function(provider) {
          if (provider && provider.removeListener) {
            provider.removeListener(_events2.EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);
            provider.removeListener(_events2.EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);
            provider.removeListener(_events2.EthereumEvents.CONNECT, this.handleConnect);
            provider.removeListener(_events2.EthereumEvents.DISCONNECT, this.handleDisconnect);
          }
        }
        /**
         * Activates the provider.
         * Should returns an object with:
         * - provider: A valid EIP-1193 provider
         * - chainId(optional): the chainId that has been connected to (in hex format)
         * - account(optional): the address that is connected to the provider
         */
      }, {
        key: "activate",
        value: function() {
          var _activate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    throw new Error("Not implemented: activate()");
                  case 1:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee);
          }));
          return function() {
            return _activate.apply(this, arguments);
          };
        }()
        /**
         * Updates account and emit event, on EIP-1193 accountsChanged events
         */
      }, {
        key: "handleAccountsChanged",
        value: function(accounts) {
          var account = accounts && accounts[0] ? accounts[0].toLowerCase() : null;
          this.account = account;
          this.emit(_events2.ConnectorEvents.ACCOUNT_CHANGED, account);
        }
        /**
         * Updates chainId and emit event, on EIP-1193 accountsChanged events
         */
      }, {
        key: "handleChainChanged",
        value: function(chainId) {
          var newChainId = (0, _verifyChainId.default)(chainId);
          this.chainId = newChainId;
          this.emit(_events2.ConnectorEvents.CHAIN_CHANGED, newChainId);
        }
      }, {
        key: "handleConnect",
        value: function(connectInfo) {
          this.emit(_events2.ConnectorEvents.CONNECT, connectInfo);
        }
      }, {
        key: "handleDisconnect",
        value: function(error) {
          this.emit(_events2.ConnectorEvents.DISCONNECT, error);
        }
        /**
         * Cleans all active listners, connections and stale references
         */
      }, {
        key: "deactivate",
        value: function() {
          var _deactivate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            return _regenerator.default.wrap(function(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    this.unsubscribeToEvents(this.provider);
                    this.account = null;
                    this.chainId = null;
                  case 3:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _deactivate.apply(this, arguments);
          };
        }()
      }]);
      return AbstractWeb3Connector2;
    }(_events.default);
    var _default = AbstractWeb3Connector;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/MoralisRpcs.js
var require_MoralisRpcs = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/MoralisRpcs.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getMoralisRpcs = void 0;
    var getMoralisRpcs = function(speedyNodeKey) {
      return {
        1: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/eth/mainnet"),
        3: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/eth/ropsten"),
        4: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/eth/rinkeby"),
        5: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/eth/goerli"),
        42: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/eth/kovan"),
        137: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/polygon/mainnet"),
        80001: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/polygon/mumbai"),
        56: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/bsc/mainnet"),
        97: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/bsc/testnet"),
        43114: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/avalanche/mainnet"),
        43113: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/avalanche/testnet"),
        250: "https://speedy-nodes-nyc.moralis.io/".concat(speedyNodeKey, "/fantom/mainnet")
      };
    };
    exports.getMoralisRpcs = getMoralisRpcs;
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/WalletConnectWeb3Connector.js
var require_WalletConnectWeb3Connector = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/WalletConnectWeb3Connector.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.WalletConnectEvent = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _freeze = _interopRequireDefault(require_freeze3());
    var _concat = _interopRequireDefault(require_concat4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _keys = _interopRequireDefault(require_keys3());
    var _startsWith = _interopRequireDefault(require_starts_with4());
    var _verifyChainId = _interopRequireDefault(require_verifyChainId());
    var _AbstractWeb3Connector = _interopRequireDefault(require_AbstractWeb3Connector());
    var _MoralisRpcs = require_MoralisRpcs();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var WalletConnectEvent = (0, _freeze.default)({
      ACCOUNTS_CHANGED: "accountsChanged",
      CHAIN_CHANGED: "chainChanged",
      DISCONNECT: "disconnect"
    });
    exports.WalletConnectEvent = WalletConnectEvent;
    var WalletConnectWeb3Connector = function(_AbstractWeb3Connecto) {
      (0, _inherits2.default)(WalletConnectWeb3Connector2, _AbstractWeb3Connecto);
      var _super = _createSuper(WalletConnectWeb3Connector2);
      function WalletConnectWeb3Connector2() {
        var _context;
        var _this;
        (0, _classCallCheck2.default)(this, WalletConnectWeb3Connector2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, (0, _concat.default)(_context = [this]).call(_context, args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "type", "WalletConnect");
        return _this;
      }
      (0, _createClass2.default)(WalletConnectWeb3Connector2, [{
        key: "activate",
        value: function() {
          var _activate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var _ref, projectId, providedChainId, qrModalOptions, newSession, rpcMap, rpcs, config, WalletConnectProvider, _require, _window, _window$WalletConnect, accounts, account, chainId, verifiedChainId, _args = arguments;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _ref = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, projectId = _ref.projectId, providedChainId = _ref.chainId, qrModalOptions = _ref.qrModalOptions, newSession = _ref.newSession, rpcMap = _ref.rpcMap;
                    if (projectId) {
                      _context2.next = 3;
                      break;
                    }
                    throw new Error("WalletConnect requires projectId");
                  case 3:
                    if (newSession) {
                      this.cleanup();
                    }
                    if (this.provider) {
                      _context2.next = 14;
                      break;
                    }
                    rpcs = rpcMap || (0, _MoralisRpcs.getMoralisRpcs)("WalletConnect");
                    config = {
                      projectId,
                      chains: [providedChainId ? Number(providedChainId) : 1],
                      showQrModal: true,
                      rpcMap: rpcs,
                      qrModalOptions
                    };
                    try {
                      WalletConnectProvider = (_require = (init_index_es(), __toCommonJS(index_es_exports))) === null || _require === void 0 ? void 0 : _require.EthereumProvider;
                    } catch (error) {
                    }
                    if (!WalletConnectProvider) {
                      WalletConnectProvider = (_window = window) === null || _window === void 0 ? void 0 : (_window$WalletConnect = _window.WalletConnectProvider) === null || _window$WalletConnect === void 0 ? void 0 : _window$WalletConnect.EthereumProvider;
                    }
                    if (WalletConnectProvider) {
                      _context2.next = 11;
                      break;
                    }
                    throw new Error('Cannot enable via WalletConnect: dependency "@walletconnect/ethereum-provider" is missing');
                  case 11:
                    _context2.next = 13;
                    return WalletConnectProvider.init(config);
                  case 13:
                    this.provider = _context2.sent;
                  case 14:
                    if (this.provider) {
                      _context2.next = 16;
                      break;
                    }
                    throw new Error("Could not connect via WalletConnect, error in connecting to provider");
                  case 16:
                    _context2.next = 18;
                    return this.provider.enable();
                  case 18:
                    accounts = _context2.sent;
                    account = accounts[0].toLowerCase();
                    chainId = this.provider.chainId;
                    verifiedChainId = (0, _verifyChainId.default)(chainId);
                    this.account = account;
                    this.chainId = verifiedChainId;
                    this.subscribeToEvents(this.provider);
                    return _context2.abrupt("return", {
                      provider: this.provider,
                      account,
                      chainId: verifiedChainId
                    });
                  case 26:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _activate.apply(this, arguments);
          };
        }()
        // Cleanup old sessions
      }, {
        key: "cleanup",
        value: function() {
          try {
            if (window) {
              var _context3;
              (0, _forEach.default)(_context3 = (0, _keys.default)(window.localStorage)).call(_context3, function(key2) {
                if ((0, _startsWith.default)(key2).call(key2, "wc@")) {
                  window.localStorage.removeItem(key2);
                }
              });
            }
          } catch (error) {
          }
        }
      }, {
        key: "deactivate",
        value: function() {
          var _deactivate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    this.unsubscribeToEvents(this.provider);
                    if (!this.provider) {
                      _context4.next = 9;
                      break;
                    }
                    _context4.prev = 2;
                    _context4.next = 5;
                    return this.provider.close();
                  case 5:
                    _context4.next = 9;
                    break;
                  case 7:
                    _context4.prev = 7;
                    _context4.t0 = _context4["catch"](2);
                  case 9:
                    this.account = null;
                    this.chainId = null;
                    this.provider = null;
                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee2, this, [[2, 7]]);
          }));
          return function() {
            return _deactivate.apply(this, arguments);
          };
        }()
      }]);
      return WalletConnectWeb3Connector2;
    }(_AbstractWeb3Connector.default);
    var _default = WalletConnectWeb3Connector;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/InjectedWeb3Connector.js
var require_InjectedWeb3Connector = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/InjectedWeb3Connector.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.InjectedEvents = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _wrapNativeSuper2 = _interopRequireDefault(require_wrapNativeSuper());
    var _freeze = _interopRequireDefault(require_freeze3());
    var _concat = _interopRequireDefault(require_concat4());
    var _promise = _interopRequireDefault(require_promise3());
    var _AbstractWeb3Connector = _interopRequireDefault(require_AbstractWeb3Connector());
    var _events = _interopRequireDefault(require_events());
    var _verifyChainId = _interopRequireDefault(require_verifyChainId());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var InjectedEvents = (0, _freeze.default)({
      ACCOUNTS_CHANGED: "accountsChanged",
      CHAIN_CHANGED: "chainChanged",
      CONNECT: "connect",
      DISCONNECT: "disconnect"
    });
    exports.InjectedEvents = InjectedEvents;
    var NoEthereumProviderError = function(_Error) {
      (0, _inherits2.default)(NoEthereumProviderError2, _Error);
      var _super = _createSuper(NoEthereumProviderError2);
      function NoEthereumProviderError2() {
        var _this;
        (0, _classCallCheck2.default)(this, NoEthereumProviderError2);
        _this = _super.call(this);
        _this.message = "Non ethereum enabled browser";
        return _this;
      }
      return (0, _createClass2.default)(NoEthereumProviderError2);
    }((0, _wrapNativeSuper2.default)(Error));
    var InjectedWeb3Connector = function(_AbstractWeb3Connecto) {
      (0, _inherits2.default)(InjectedWeb3Connector2, _AbstractWeb3Connecto);
      var _super2 = _createSuper(InjectedWeb3Connector2);
      function InjectedWeb3Connector2() {
        var _context;
        var _this2;
        (0, _classCallCheck2.default)(this, InjectedWeb3Connector2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, (0, _concat.default)(_context = [this]).call(_context, args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "type", "injected");
        return _this2;
      }
      (0, _createClass2.default)(InjectedWeb3Connector2, [{
        key: "verifyEthereumBrowser",
        value: function() {
          var _window;
          if (!((_window = window) !== null && _window !== void 0 && _window.ethereum)) {
            throw new NoEthereumProviderError();
          }
        }
      }, {
        key: "activate",
        value: function() {
          var _activate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var _yield$Promise$all, _yield$Promise$all2, accounts, chainId, account, provider;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this.verifyEthereumBrowser();
                    _context2.next = 3;
                    return _promise.default.all([window.ethereum.request({
                      method: "eth_requestAccounts"
                    }), window.ethereum.request({
                      method: "eth_chainId"
                    })]);
                  case 3:
                    _yield$Promise$all = _context2.sent;
                    _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 2);
                    accounts = _yield$Promise$all2[0];
                    chainId = _yield$Promise$all2[1];
                    account = accounts[0] ? accounts[0].toLowerCase() : null;
                    provider = window.ethereum;
                    this.chainId = chainId;
                    this.account = account;
                    this.provider = provider;
                    this.subscribeToEvents(provider);
                    return _context2.abrupt("return", {
                      provider,
                      chainId,
                      account
                    });
                  case 14:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _activate.apply(this, arguments);
          };
        }()
      }, {
        key: "switchNetwork",
        value: function() {
          var _switchNetwork = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(chainId) {
            var currentNetwork;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this.verifyEthereumBrowser();
                    chainId = (0, _verifyChainId.default)(chainId);
                    currentNetwork = this.chainId;
                    if (!(currentNetwork === chainId)) {
                      _context3.next = 5;
                      break;
                    }
                    return _context3.abrupt("return");
                  case 5:
                    _context3.next = 7;
                    return window.ethereum.request({
                      method: "wallet_switchEthereumChain",
                      params: [{
                        chainId
                      }]
                    });
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _switchNetwork.apply(this, arguments);
          };
        }()
      }, {
        key: "addNetwork",
        value: function() {
          var _addNetwork = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(chainId, chainName, currencyName, currencySymbol, rpcUrl, blockExplorerUrl) {
            var newchainId;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    this.verifyEthereumBrowser();
                    newchainId = (0, _verifyChainId.default)(chainId);
                    _context4.next = 4;
                    return window.ethereum.request({
                      method: "wallet_addEthereumChain",
                      params: [{
                        chainId: newchainId,
                        chainName,
                        nativeCurrency: {
                          name: currencyName,
                          symbol: currencySymbol,
                          decimals: 18
                        },
                        rpcUrls: [rpcUrl],
                        blockExplorerUrls: blockExplorerUrl ? [blockExplorerUrl] : null
                      }]
                    });
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee3, this);
          }));
          return function() {
            return _addNetwork.apply(this, arguments);
          };
        }()
      }]);
      return InjectedWeb3Connector2;
    }(_AbstractWeb3Connector.default);
    var _default = InjectedWeb3Connector;
    exports.default = _default;
  }
});

// node_modules/core-js-pure/internals/url-constructor-detection.js
var require_url_constructor_detection = __commonJS({
  "node_modules/core-js-pure/internals/url-constructor-detection.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = !fails(function() {
      var url = new URL("b?a=1&b=2&c=3", "http://a");
      var params = url.searchParams;
      var params2 = new URLSearchParams("a=1&a=2&b=3");
      var result = "";
      url.pathname = "c%20d";
      params.forEach(function(value, key2) {
        params["delete"]("b");
        result += key2 + value;
      });
      params2["delete"]("a", 2);
      params2["delete"]("b", void 0);
      return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "http://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://тест").host !== "xn--e1aybc" || new URL("http://a#б").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
    });
  }
});

// node_modules/core-js-pure/modules/web.url-search-params.constructor.js
var require_web_url_search_params_constructor = __commonJS({
  "node_modules/core-js-pure/modules/web.url-search-params.constructor.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    var $ = require_export();
    var global2 = require_global();
    var safeGetBuiltIn = require_safe_get_built_in();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var DESCRIPTORS = require_descriptors();
    var USE_NATIVE_URL = require_url_constructor_detection();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var defineBuiltIns = require_define_built_ins();
    var setToStringTag = require_set_to_string_tag();
    var createIteratorConstructor = require_iterator_create_constructor();
    var InternalStateModule = require_internal_state();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var bind = require_function_bind_context();
    var classof = require_classof();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var $toString = require_to_string();
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var createIterResultObject = require_create_iter_result_object();
    var validateArgumentsLength = require_validate_arguments_length();
    var wellKnownSymbol = require_well_known_symbol();
    var arraySort = require_array_sort();
    var ITERATOR = wellKnownSymbol("iterator");
    var URL_SEARCH_PARAMS = "URLSearchParams";
    var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
    var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
    var nativeFetch = safeGetBuiltIn("fetch");
    var NativeRequest = safeGetBuiltIn("Request");
    var Headers = safeGetBuiltIn("Headers");
    var RequestPrototype = NativeRequest && NativeRequest.prototype;
    var HeadersPrototype = Headers && Headers.prototype;
    var RegExp2 = global2.RegExp;
    var TypeError2 = global2.TypeError;
    var decodeURIComponent2 = global2.decodeURIComponent;
    var encodeURIComponent2 = global2.encodeURIComponent;
    var charAt = uncurryThis("".charAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var shift = uncurryThis([].shift);
    var splice = uncurryThis([].splice);
    var split = uncurryThis("".split);
    var stringSlice = uncurryThis("".slice);
    var plus = /\+/g;
    var sequences = Array(4);
    var percentSequence = function(bytes) {
      return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp2("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
    };
    var percentDecode = function(sequence) {
      try {
        return decodeURIComponent2(sequence);
      } catch (error) {
        return sequence;
      }
    };
    var deserialize = function(it) {
      var result = replace(it, plus, " ");
      var bytes = 4;
      try {
        return decodeURIComponent2(result);
      } catch (error) {
        while (bytes) {
          result = replace(result, percentSequence(bytes--), percentDecode);
        }
        return result;
      }
    };
    var find = /[!'()~]|%20/g;
    var replacements = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+"
    };
    var replacer = function(match) {
      return replacements[match];
    };
    var serialize3 = function(it) {
      return replace(encodeURIComponent2(it), find, replacer);
    };
    var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
      setInternalState(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        target: getInternalParamsState(params).entries,
        index: 0,
        kind
      });
    }, URL_SEARCH_PARAMS, function next() {
      var state = getInternalIteratorState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      var entry = target[index];
      switch (state.kind) {
        case "keys":
          return createIterResultObject(entry.key, false);
        case "values":
          return createIterResultObject(entry.value, false);
      }
      return createIterResultObject([entry.key, entry.value], false);
    }, true);
    var URLSearchParamsState = function(init2) {
      this.entries = [];
      this.url = null;
      if (init2 !== void 0) {
        if (isObject(init2))
          this.parseObject(init2);
        else
          this.parseQuery(typeof init2 == "string" ? charAt(init2, 0) === "?" ? stringSlice(init2, 1) : init2 : $toString(init2));
      }
    };
    URLSearchParamsState.prototype = {
      type: URL_SEARCH_PARAMS,
      bindURL: function(url) {
        this.url = url;
        this.update();
      },
      parseObject: function(object) {
        var entries = this.entries;
        var iteratorMethod = getIteratorMethod(object);
        var iterator, next, step, entryIterator, entryNext, first, second;
        if (iteratorMethod) {
          iterator = getIterator(object, iteratorMethod);
          next = iterator.next;
          while (!(step = call(next, iterator)).done) {
            entryIterator = getIterator(anObject(step.value));
            entryNext = entryIterator.next;
            if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done)
              throw new TypeError2("Expected sequence with length 2");
            push(entries, { key: $toString(first.value), value: $toString(second.value) });
          }
        } else
          for (var key2 in object)
            if (hasOwn(object, key2)) {
              push(entries, { key: key2, value: $toString(object[key2]) });
            }
      },
      parseQuery: function(query) {
        if (query) {
          var entries = this.entries;
          var attributes = split(query, "&");
          var index = 0;
          var attribute, entry;
          while (index < attributes.length) {
            attribute = attributes[index++];
            if (attribute.length) {
              entry = split(attribute, "=");
              push(entries, {
                key: deserialize(shift(entry)),
                value: deserialize(join(entry, "="))
              });
            }
          }
        }
      },
      serialize: function() {
        var entries = this.entries;
        var result = [];
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          push(result, serialize3(entry.key) + "=" + serialize3(entry.value));
        }
        return join(result, "&");
      },
      update: function() {
        this.entries.length = 0;
        this.parseQuery(this.url.query);
      },
      updateURL: function() {
        if (this.url)
          this.url.update();
      }
    };
    var URLSearchParamsConstructor = function URLSearchParams2() {
      anInstance(this, URLSearchParamsPrototype);
      var init2 = arguments.length > 0 ? arguments[0] : void 0;
      var state = setInternalState(this, new URLSearchParamsState(init2));
      if (!DESCRIPTORS)
        this.size = state.entries.length;
    };
    var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
    defineBuiltIns(URLSearchParamsPrototype, {
      // `URLSearchParams.prototype.append` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-append
      append: function append(name2, value) {
        var state = getInternalParamsState(this);
        validateArgumentsLength(arguments.length, 2);
        push(state.entries, { key: $toString(name2), value: $toString(value) });
        if (!DESCRIPTORS)
          this.length++;
        state.updateURL();
      },
      // `URLSearchParams.prototype.delete` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
      "delete": function(name2) {
        var state = getInternalParamsState(this);
        var length = validateArgumentsLength(arguments.length, 1);
        var entries = state.entries;
        var key2 = $toString(name2);
        var $value = length < 2 ? void 0 : arguments[1];
        var value = $value === void 0 ? $value : $toString($value);
        var index = 0;
        while (index < entries.length) {
          var entry = entries[index];
          if (entry.key === key2 && (value === void 0 || entry.value === value)) {
            splice(entries, index, 1);
            if (value !== void 0)
              break;
          } else
            index++;
        }
        if (!DESCRIPTORS)
          this.size = entries.length;
        state.updateURL();
      },
      // `URLSearchParams.prototype.get` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-get
      get: function get(name2) {
        var entries = getInternalParamsState(this).entries;
        validateArgumentsLength(arguments.length, 1);
        var key2 = $toString(name2);
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key2)
            return entries[index].value;
        }
        return null;
      },
      // `URLSearchParams.prototype.getAll` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
      getAll: function getAll(name2) {
        var entries = getInternalParamsState(this).entries;
        validateArgumentsLength(arguments.length, 1);
        var key2 = $toString(name2);
        var result = [];
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key2)
            push(result, entries[index].value);
        }
        return result;
      },
      // `URLSearchParams.prototype.has` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-has
      has: function has(name2) {
        var entries = getInternalParamsState(this).entries;
        var length = validateArgumentsLength(arguments.length, 1);
        var key2 = $toString(name2);
        var $value = length < 2 ? void 0 : arguments[1];
        var value = $value === void 0 ? $value : $toString($value);
        var index = 0;
        while (index < entries.length) {
          var entry = entries[index++];
          if (entry.key === key2 && (value === void 0 || entry.value === value))
            return true;
        }
        return false;
      },
      // `URLSearchParams.prototype.set` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-set
      set: function set(name2, value) {
        var state = getInternalParamsState(this);
        validateArgumentsLength(arguments.length, 1);
        var entries = state.entries;
        var found = false;
        var key2 = $toString(name2);
        var val = $toString(value);
        var index = 0;
        var entry;
        for (; index < entries.length; index++) {
          entry = entries[index];
          if (entry.key === key2) {
            if (found)
              splice(entries, index--, 1);
            else {
              found = true;
              entry.value = val;
            }
          }
        }
        if (!found)
          push(entries, { key: key2, value: val });
        if (!DESCRIPTORS)
          this.size = entries.length;
        state.updateURL();
      },
      // `URLSearchParams.prototype.sort` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
      sort: function sort() {
        var state = getInternalParamsState(this);
        arraySort(state.entries, function(a2, b2) {
          return a2.key > b2.key ? 1 : -1;
        });
        state.updateURL();
      },
      // `URLSearchParams.prototype.forEach` method
      forEach: function forEach(callback) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : void 0);
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          boundFunction(entry.value, entry.key, this);
        }
      },
      // `URLSearchParams.prototype.keys` method
      keys: function keys() {
        return new URLSearchParamsIterator(this, "keys");
      },
      // `URLSearchParams.prototype.values` method
      values: function values() {
        return new URLSearchParamsIterator(this, "values");
      },
      // `URLSearchParams.prototype.entries` method
      entries: function entries() {
        return new URLSearchParamsIterator(this, "entries");
      }
    }, { enumerable: true });
    defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
    defineBuiltIn(URLSearchParamsPrototype, "toString", function toString2() {
      return getInternalParamsState(this).serialize();
    }, { enumerable: true });
    if (DESCRIPTORS)
      defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
        get: function size() {
          return getInternalParamsState(this).entries.length;
        },
        configurable: true,
        enumerable: true
      });
    setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    $({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
      URLSearchParams: URLSearchParamsConstructor
    });
    if (!USE_NATIVE_URL && isCallable(Headers)) {
      headersHas = uncurryThis(HeadersPrototype.has);
      headersSet = uncurryThis(HeadersPrototype.set);
      wrapRequestOptions = function(init2) {
        if (isObject(init2)) {
          var body = init2.body;
          var headers;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init2.headers ? new Headers(init2.headers) : new Headers();
            if (!headersHas(headers, "content-type")) {
              headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
            return create(init2, {
              body: createPropertyDescriptor(0, $toString(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        return init2;
      };
      if (isCallable(nativeFetch)) {
        $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
          fetch: function fetch2(input) {
            return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          }
        });
      }
      if (isCallable(NativeRequest)) {
        RequestConstructor = function Request(input) {
          anInstance(this, RequestPrototype);
          return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
        };
        RequestPrototype.constructor = RequestConstructor;
        RequestConstructor.prototype = RequestPrototype;
        $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
          Request: RequestConstructor
        });
      }
    }
    var headersHas;
    var headersSet;
    var wrapRequestOptions;
    var RequestConstructor;
    module.exports = {
      URLSearchParams: URLSearchParamsConstructor,
      getState: getInternalParamsState
    };
  }
});

// node_modules/core-js-pure/modules/web.url-search-params.js
var require_web_url_search_params = __commonJS({
  "node_modules/core-js-pure/modules/web.url-search-params.js"() {
    "use strict";
    require_web_url_search_params_constructor();
  }
});

// node_modules/core-js-pure/modules/web.url-search-params.delete.js
var require_web_url_search_params_delete = __commonJS({
  "node_modules/core-js-pure/modules/web.url-search-params.delete.js"() {
  }
});

// node_modules/core-js-pure/modules/web.url-search-params.has.js
var require_web_url_search_params_has = __commonJS({
  "node_modules/core-js-pure/modules/web.url-search-params.has.js"() {
  }
});

// node_modules/core-js-pure/modules/web.url-search-params.size.js
var require_web_url_search_params_size = __commonJS({
  "node_modules/core-js-pure/modules/web.url-search-params.size.js"() {
  }
});

// node_modules/core-js-pure/web/url-search-params.js
var require_url_search_params = __commonJS({
  "node_modules/core-js-pure/web/url-search-params.js"(exports, module) {
    "use strict";
    require_web_url_search_params();
    require_web_url_search_params_delete();
    require_web_url_search_params_has();
    require_web_url_search_params_size();
    var path = require_path();
    module.exports = path.URLSearchParams;
  }
});

// node_modules/core-js-pure/internals/object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js-pure/internals/object-assign.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var uncurryThis = require_function_uncurry_this();
    var call = require_function_call();
    var fails = require_fails();
    var objectKeys = require_object_keys();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var $assign = Object.assign;
    var defineProperty = Object.defineProperty;
    var concat2 = uncurryThis([].concat);
    module.exports = !$assign || fails(function() {
      if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A2 = {};
      var B2 = {};
      var symbol = Symbol("assign detection");
      var alphabet = "abcdefghijklmnopqrst";
      A2[symbol] = 7;
      alphabet.split("").forEach(function(chr) {
        B2[chr] = chr;
      });
      return $assign({}, A2)[symbol] !== 7 || objectKeys($assign({}, B2)).join("") !== alphabet;
    }) ? function assign(target, source) {
      var T = toObject(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable = propertyIsEnumerableModule.f;
      while (argumentsLength > index) {
        var S2 = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? concat2(objectKeys(S2), getOwnPropertySymbols(S2)) : objectKeys(S2);
        var length = keys.length;
        var j2 = 0;
        var key2;
        while (length > j2) {
          key2 = keys[j2++];
          if (!DESCRIPTORS || call(propertyIsEnumerable, S2, key2))
            T[key2] = S2[key2];
        }
      }
      return T;
    } : $assign;
  }
});

// node_modules/core-js-pure/internals/string-punycode-to-ascii.js
var require_string_punycode_to_ascii = __commonJS({
  "node_modules/core-js-pure/internals/string-punycode-to-ascii.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var maxInt = 2147483647;
    var base2 = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexNonASCII = /[^\0-\u007E]/;
    var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
    var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
    var baseMinusTMin = base2 - tMin;
    var $RangeError = RangeError;
    var exec = uncurryThis(regexSeparators.exec);
    var floor = Math.floor;
    var fromCharCode = String.fromCharCode;
    var charCodeAt = uncurryThis("".charCodeAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var split = uncurryThis("".split);
    var toLowerCase = uncurryThis("".toLowerCase);
    var ucs2decode = function(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = charCodeAt(string, counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = charCodeAt(string, counter++);
          if ((extra & 64512) === 56320) {
            push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            push(output, value);
            counter--;
          }
        } else {
          push(output, value);
        }
      }
      return output;
    };
    var digitToBasic = function(digit) {
      return digit + 22 + 75 * (digit < 26);
    };
    var adapt = function(delta, numPoints, firstTime) {
      var k2 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      while (delta > baseMinusTMin * tMax >> 1) {
        delta = floor(delta / baseMinusTMin);
        k2 += base2;
      }
      return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var encode4 = function(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n2 = initialN;
      var delta = 0;
      var bias = initialBias;
      var i2, currentValue;
      for (i2 = 0; i2 < input.length; i2++) {
        currentValue = input[i2];
        if (currentValue < 128) {
          push(output, fromCharCode(currentValue));
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        push(output, delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        for (i2 = 0; i2 < input.length; i2++) {
          currentValue = input[i2];
          if (currentValue >= n2 && currentValue < m) {
            m = currentValue;
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          throw new $RangeError(OVERFLOW_ERROR);
        }
        delta += (m - n2) * handledCPCountPlusOne;
        n2 = m;
        for (i2 = 0; i2 < input.length; i2++) {
          currentValue = input[i2];
          if (currentValue < n2 && ++delta > maxInt) {
            throw new $RangeError(OVERFLOW_ERROR);
          }
          if (currentValue === n2) {
            var q2 = delta;
            var k2 = base2;
            while (true) {
              var t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t2)
                break;
              var qMinusT = q2 - t2;
              var baseMinusT = base2 - t2;
              push(output, fromCharCode(digitToBasic(t2 + qMinusT % baseMinusT)));
              q2 = floor(qMinusT / baseMinusT);
              k2 += base2;
            }
            push(output, fromCharCode(digitToBasic(q2)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            handledCPCount++;
          }
        }
        delta++;
        n2++;
      }
      return join(output, "");
    };
    module.exports = function(input) {
      var encoded = [];
      var labels = split(replace(toLowerCase(input), regexSeparators, "."), ".");
      var i2, label;
      for (i2 = 0; i2 < labels.length; i2++) {
        label = labels[i2];
        push(encoded, exec(regexNonASCII, label) ? "xn--" + encode4(label) : label);
      }
      return join(encoded, ".");
    };
  }
});

// node_modules/core-js-pure/modules/web.url.constructor.js
var require_web_url_constructor = __commonJS({
  "node_modules/core-js-pure/modules/web.url.constructor.js"() {
    "use strict";
    require_es_string_iterator();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var USE_NATIVE_URL = require_url_constructor_detection();
    var global2 = require_global();
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var anInstance = require_an_instance();
    var hasOwn = require_has_own_property();
    var assign = require_object_assign();
    var arrayFrom = require_array_from();
    var arraySlice = require_array_slice();
    var codeAt = require_string_multibyte().codeAt;
    var toASCII = require_string_punycode_to_ascii();
    var $toString = require_to_string();
    var setToStringTag = require_set_to_string_tag();
    var validateArgumentsLength = require_validate_arguments_length();
    var URLSearchParamsModule = require_web_url_search_params_constructor();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var getInternalURLState = InternalStateModule.getterFor("URL");
    var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
    var getInternalSearchParamsState = URLSearchParamsModule.getState;
    var NativeURL = global2.URL;
    var TypeError2 = global2.TypeError;
    var parseInt2 = global2.parseInt;
    var floor = Math.floor;
    var pow = Math.pow;
    var charAt = uncurryThis("".charAt);
    var exec = uncurryThis(/./.exec);
    var join = uncurryThis([].join);
    var numberToString = uncurryThis(1 .toString);
    var pop = uncurryThis([].pop);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var shift = uncurryThis([].shift);
    var split = uncurryThis("".split);
    var stringSlice = uncurryThis("".slice);
    var toLowerCase = uncurryThis("".toLowerCase);
    var unshift = uncurryThis([].unshift);
    var INVALID_AUTHORITY = "Invalid authority";
    var INVALID_SCHEME = "Invalid scheme";
    var INVALID_HOST = "Invalid host";
    var INVALID_PORT = "Invalid port";
    var ALPHA = /[a-z]/i;
    var ALPHANUMERIC = /[\d+-.a-z]/i;
    var DIGIT = /\d/;
    var HEX_START = /^0x/i;
    var OCT = /^[0-7]+$/;
    var DEC = /^\d+$/;
    var HEX2 = /^[\da-f]+$/i;
    var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
    var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
    var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
    var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
    var TAB_AND_NEW_LINE = /[\t\n\r]/g;
    var EOF;
    var parseIPv4 = function(input) {
      var parts = split(input, ".");
      var partsLength, numbers, index, part, radix, number, ipv4;
      if (parts.length && parts[parts.length - 1] === "") {
        parts.length--;
      }
      partsLength = parts.length;
      if (partsLength > 4)
        return input;
      numbers = [];
      for (index = 0; index < partsLength; index++) {
        part = parts[index];
        if (part === "")
          return input;
        radix = 10;
        if (part.length > 1 && charAt(part, 0) === "0") {
          radix = exec(HEX_START, part) ? 16 : 8;
          part = stringSlice(part, radix === 8 ? 1 : 2);
        }
        if (part === "") {
          number = 0;
        } else {
          if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX2, part))
            return input;
          number = parseInt2(part, radix);
        }
        push(numbers, number);
      }
      for (index = 0; index < partsLength; index++) {
        number = numbers[index];
        if (index === partsLength - 1) {
          if (number >= pow(256, 5 - partsLength))
            return null;
        } else if (number > 255)
          return null;
      }
      ipv4 = pop(numbers);
      for (index = 0; index < numbers.length; index++) {
        ipv4 += numbers[index] * pow(256, 3 - index);
      }
      return ipv4;
    };
    var parseIPv6 = function(input) {
      var address = [0, 0, 0, 0, 0, 0, 0, 0];
      var pieceIndex = 0;
      var compress = null;
      var pointer = 0;
      var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
      var chr = function() {
        return charAt(input, pointer);
      };
      if (chr() === ":") {
        if (charAt(input, 1) !== ":")
          return;
        pointer += 2;
        pieceIndex++;
        compress = pieceIndex;
      }
      while (chr()) {
        if (pieceIndex === 8)
          return;
        if (chr() === ":") {
          if (compress !== null)
            return;
          pointer++;
          pieceIndex++;
          compress = pieceIndex;
          continue;
        }
        value = length = 0;
        while (length < 4 && exec(HEX2, chr())) {
          value = value * 16 + parseInt2(chr(), 16);
          pointer++;
          length++;
        }
        if (chr() === ".") {
          if (length === 0)
            return;
          pointer -= length;
          if (pieceIndex > 6)
            return;
          numbersSeen = 0;
          while (chr()) {
            ipv4Piece = null;
            if (numbersSeen > 0) {
              if (chr() === "." && numbersSeen < 4)
                pointer++;
              else
                return;
            }
            if (!exec(DIGIT, chr()))
              return;
            while (exec(DIGIT, chr())) {
              number = parseInt2(chr(), 10);
              if (ipv4Piece === null)
                ipv4Piece = number;
              else if (ipv4Piece === 0)
                return;
              else
                ipv4Piece = ipv4Piece * 10 + number;
              if (ipv4Piece > 255)
                return;
              pointer++;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            numbersSeen++;
            if (numbersSeen === 2 || numbersSeen === 4)
              pieceIndex++;
          }
          if (numbersSeen !== 4)
            return;
          break;
        } else if (chr() === ":") {
          pointer++;
          if (!chr())
            return;
        } else if (chr())
          return;
        address[pieceIndex++] = value;
      }
      if (compress !== null) {
        swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          swap = address[pieceIndex];
          address[pieceIndex--] = address[compress + swaps - 1];
          address[compress + --swaps] = swap;
        }
      } else if (pieceIndex !== 8)
        return;
      return address;
    };
    var findLongestZeroSequence = function(ipv6) {
      var maxIndex = null;
      var maxLength = 1;
      var currStart = null;
      var currLength = 0;
      var index = 0;
      for (; index < 8; index++) {
        if (ipv6[index] !== 0) {
          if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
          }
          currStart = null;
          currLength = 0;
        } else {
          if (currStart === null)
            currStart = index;
          ++currLength;
        }
      }
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      return maxIndex;
    };
    var serializeHost = function(host) {
      var result, index, compress, ignore0;
      if (typeof host == "number") {
        result = [];
        for (index = 0; index < 4; index++) {
          unshift(result, host % 256);
          host = floor(host / 256);
        }
        return join(result, ".");
      } else if (typeof host == "object") {
        result = "";
        compress = findLongestZeroSequence(host);
        for (index = 0; index < 8; index++) {
          if (ignore0 && host[index] === 0)
            continue;
          if (ignore0)
            ignore0 = false;
          if (compress === index) {
            result += index ? ":" : "::";
            ignore0 = true;
          } else {
            result += numberToString(host[index], 16);
            if (index < 7)
              result += ":";
          }
        }
        return "[" + result + "]";
      }
      return host;
    };
    var C0ControlPercentEncodeSet = {};
    var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
      " ": 1,
      '"': 1,
      "<": 1,
      ">": 1,
      "`": 1
    });
    var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
      "#": 1,
      "?": 1,
      "{": 1,
      "}": 1
    });
    var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
      "/": 1,
      ":": 1,
      ";": 1,
      "=": 1,
      "@": 1,
      "[": 1,
      "\\": 1,
      "]": 1,
      "^": 1,
      "|": 1
    });
    var percentEncode = function(chr, set) {
      var code = codeAt(chr, 0);
      return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
    };
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var isWindowsDriveLetter = function(string, normalized) {
      var second;
      return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
    };
    var startsWithWindowsDriveLetter = function(string) {
      var third;
      return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
    };
    var isSingleDot = function(segment) {
      return segment === "." || toLowerCase(segment) === "%2e";
    };
    var isDoubleDot = function(segment) {
      segment = toLowerCase(segment);
      return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
    };
    var SCHEME_START = {};
    var SCHEME = {};
    var NO_SCHEME = {};
    var SPECIAL_RELATIVE_OR_AUTHORITY = {};
    var PATH_OR_AUTHORITY = {};
    var RELATIVE = {};
    var RELATIVE_SLASH = {};
    var SPECIAL_AUTHORITY_SLASHES = {};
    var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
    var AUTHORITY = {};
    var HOST = {};
    var HOSTNAME = {};
    var PORT = {};
    var FILE = {};
    var FILE_SLASH = {};
    var FILE_HOST = {};
    var PATH_START = {};
    var PATH = {};
    var CANNOT_BE_A_BASE_URL_PATH = {};
    var QUERY = {};
    var FRAGMENT = {};
    var URLState = function(url, isBase, base2) {
      var urlString = $toString(url);
      var baseState, failure, searchParams;
      if (isBase) {
        failure = this.parse(urlString);
        if (failure)
          throw new TypeError2(failure);
        this.searchParams = null;
      } else {
        if (base2 !== void 0)
          baseState = new URLState(base2, true);
        failure = this.parse(urlString, null, baseState);
        if (failure)
          throw new TypeError2(failure);
        searchParams = getInternalSearchParamsState(new URLSearchParams2());
        searchParams.bindURL(this);
        this.searchParams = searchParams;
      }
    };
    URLState.prototype = {
      type: "URL",
      // https://url.spec.whatwg.org/#url-parsing
      // eslint-disable-next-line max-statements -- TODO
      parse: function(input, stateOverride, base2) {
        var url = this;
        var state = stateOverride || SCHEME_START;
        var pointer = 0;
        var buffer = "";
        var seenAt = false;
        var seenBracket = false;
        var seenPasswordToken = false;
        var codePoints, chr, bufferCodePoints, failure;
        input = $toString(input);
        if (!stateOverride) {
          url.scheme = "";
          url.username = "";
          url.password = "";
          url.host = null;
          url.port = null;
          url.path = [];
          url.query = null;
          url.fragment = null;
          url.cannotBeABaseURL = false;
          input = replace(input, LEADING_C0_CONTROL_OR_SPACE, "");
          input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
        }
        input = replace(input, TAB_AND_NEW_LINE, "");
        codePoints = arrayFrom(input);
        while (pointer <= codePoints.length) {
          chr = codePoints[pointer];
          switch (state) {
            case SCHEME_START:
              if (chr && exec(ALPHA, chr)) {
                buffer += toLowerCase(chr);
                state = SCHEME;
              } else if (!stateOverride) {
                state = NO_SCHEME;
                continue;
              } else
                return INVALID_SCHEME;
              break;
            case SCHEME:
              if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
                buffer += toLowerCase(chr);
              } else if (chr === ":") {
                if (stateOverride && (url.isSpecial() !== hasOwn(specialSchemes, buffer) || buffer === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host))
                  return;
                url.scheme = buffer;
                if (stateOverride) {
                  if (url.isSpecial() && specialSchemes[url.scheme] === url.port)
                    url.port = null;
                  return;
                }
                buffer = "";
                if (url.scheme === "file") {
                  state = FILE;
                } else if (url.isSpecial() && base2 && base2.scheme === url.scheme) {
                  state = SPECIAL_RELATIVE_OR_AUTHORITY;
                } else if (url.isSpecial()) {
                  state = SPECIAL_AUTHORITY_SLASHES;
                } else if (codePoints[pointer + 1] === "/") {
                  state = PATH_OR_AUTHORITY;
                  pointer++;
                } else {
                  url.cannotBeABaseURL = true;
                  push(url.path, "");
                  state = CANNOT_BE_A_BASE_URL_PATH;
                }
              } else if (!stateOverride) {
                buffer = "";
                state = NO_SCHEME;
                pointer = 0;
                continue;
              } else
                return INVALID_SCHEME;
              break;
            case NO_SCHEME:
              if (!base2 || base2.cannotBeABaseURL && chr !== "#")
                return INVALID_SCHEME;
              if (base2.cannotBeABaseURL && chr === "#") {
                url.scheme = base2.scheme;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
                url.fragment = "";
                url.cannotBeABaseURL = true;
                state = FRAGMENT;
                break;
              }
              state = base2.scheme === "file" ? FILE : RELATIVE;
              continue;
            case SPECIAL_RELATIVE_OR_AUTHORITY:
              if (chr === "/" && codePoints[pointer + 1] === "/") {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                pointer++;
              } else {
                state = RELATIVE;
                continue;
              }
              break;
            case PATH_OR_AUTHORITY:
              if (chr === "/") {
                state = AUTHORITY;
                break;
              } else {
                state = PATH;
                continue;
              }
            case RELATIVE:
              url.scheme = base2.scheme;
              if (chr === EOF) {
                url.username = base2.username;
                url.password = base2.password;
                url.host = base2.host;
                url.port = base2.port;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
              } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
                state = RELATIVE_SLASH;
              } else if (chr === "?") {
                url.username = base2.username;
                url.password = base2.password;
                url.host = base2.host;
                url.port = base2.port;
                url.path = arraySlice(base2.path);
                url.query = "";
                state = QUERY;
              } else if (chr === "#") {
                url.username = base2.username;
                url.password = base2.password;
                url.host = base2.host;
                url.port = base2.port;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
                url.fragment = "";
                state = FRAGMENT;
              } else {
                url.username = base2.username;
                url.password = base2.password;
                url.host = base2.host;
                url.port = base2.port;
                url.path = arraySlice(base2.path);
                url.path.length--;
                state = PATH;
                continue;
              }
              break;
            case RELATIVE_SLASH:
              if (url.isSpecial() && (chr === "/" || chr === "\\")) {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              } else if (chr === "/") {
                state = AUTHORITY;
              } else {
                url.username = base2.username;
                url.password = base2.password;
                url.host = base2.host;
                url.port = base2.port;
                state = PATH;
                continue;
              }
              break;
            case SPECIAL_AUTHORITY_SLASHES:
              state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              if (chr !== "/" || charAt(buffer, pointer + 1) !== "/")
                continue;
              pointer++;
              break;
            case SPECIAL_AUTHORITY_IGNORE_SLASHES:
              if (chr !== "/" && chr !== "\\") {
                state = AUTHORITY;
                continue;
              }
              break;
            case AUTHORITY:
              if (chr === "@") {
                if (seenAt)
                  buffer = "%40" + buffer;
                seenAt = true;
                bufferCodePoints = arrayFrom(buffer);
                for (var i2 = 0; i2 < bufferCodePoints.length; i2++) {
                  var codePoint = bufferCodePoints[i2];
                  if (codePoint === ":" && !seenPasswordToken) {
                    seenPasswordToken = true;
                    continue;
                  }
                  var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                  if (seenPasswordToken)
                    url.password += encodedCodePoints;
                  else
                    url.username += encodedCodePoints;
                }
                buffer = "";
              } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                if (seenAt && buffer === "")
                  return INVALID_AUTHORITY;
                pointer -= arrayFrom(buffer).length + 1;
                buffer = "";
                state = HOST;
              } else
                buffer += chr;
              break;
            case HOST:
            case HOSTNAME:
              if (stateOverride && url.scheme === "file") {
                state = FILE_HOST;
                continue;
              } else if (chr === ":" && !seenBracket) {
                if (buffer === "")
                  return INVALID_HOST;
                failure = url.parseHost(buffer);
                if (failure)
                  return failure;
                buffer = "";
                state = PORT;
                if (stateOverride === HOSTNAME)
                  return;
              } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                if (url.isSpecial() && buffer === "")
                  return INVALID_HOST;
                if (stateOverride && buffer === "" && (url.includesCredentials() || url.port !== null))
                  return;
                failure = url.parseHost(buffer);
                if (failure)
                  return failure;
                buffer = "";
                state = PATH_START;
                if (stateOverride)
                  return;
                continue;
              } else {
                if (chr === "[")
                  seenBracket = true;
                else if (chr === "]")
                  seenBracket = false;
                buffer += chr;
              }
              break;
            case PORT:
              if (exec(DIGIT, chr)) {
                buffer += chr;
              } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
                if (buffer !== "") {
                  var port = parseInt2(buffer, 10);
                  if (port > 65535)
                    return INVALID_PORT;
                  url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                  buffer = "";
                }
                if (stateOverride)
                  return;
                state = PATH_START;
                continue;
              } else
                return INVALID_PORT;
              break;
            case FILE:
              url.scheme = "file";
              if (chr === "/" || chr === "\\")
                state = FILE_SLASH;
              else if (base2 && base2.scheme === "file") {
                switch (chr) {
                  case EOF:
                    url.host = base2.host;
                    url.path = arraySlice(base2.path);
                    url.query = base2.query;
                    break;
                  case "?":
                    url.host = base2.host;
                    url.path = arraySlice(base2.path);
                    url.query = "";
                    state = QUERY;
                    break;
                  case "#":
                    url.host = base2.host;
                    url.path = arraySlice(base2.path);
                    url.query = base2.query;
                    url.fragment = "";
                    state = FRAGMENT;
                    break;
                  default:
                    if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                      url.host = base2.host;
                      url.path = arraySlice(base2.path);
                      url.shortenPath();
                    }
                    state = PATH;
                    continue;
                }
              } else {
                state = PATH;
                continue;
              }
              break;
            case FILE_SLASH:
              if (chr === "/" || chr === "\\") {
                state = FILE_HOST;
                break;
              }
              if (base2 && base2.scheme === "file" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                if (isWindowsDriveLetter(base2.path[0], true))
                  push(url.path, base2.path[0]);
                else
                  url.host = base2.host;
              }
              state = PATH;
              continue;
            case FILE_HOST:
              if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
                if (!stateOverride && isWindowsDriveLetter(buffer)) {
                  state = PATH;
                } else if (buffer === "") {
                  url.host = "";
                  if (stateOverride)
                    return;
                  state = PATH_START;
                } else {
                  failure = url.parseHost(buffer);
                  if (failure)
                    return failure;
                  if (url.host === "localhost")
                    url.host = "";
                  if (stateOverride)
                    return;
                  buffer = "";
                  state = PATH_START;
                }
                continue;
              } else
                buffer += chr;
              break;
            case PATH_START:
              if (url.isSpecial()) {
                state = PATH;
                if (chr !== "/" && chr !== "\\")
                  continue;
              } else if (!stateOverride && chr === "?") {
                url.query = "";
                state = QUERY;
              } else if (!stateOverride && chr === "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr !== EOF) {
                state = PATH;
                if (chr !== "/")
                  continue;
              }
              break;
            case PATH:
              if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
                if (isDoubleDot(buffer)) {
                  url.shortenPath();
                  if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                    push(url.path, "");
                  }
                } else if (isSingleDot(buffer)) {
                  if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                    push(url.path, "");
                  }
                } else {
                  if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                    if (url.host)
                      url.host = "";
                    buffer = charAt(buffer, 0) + ":";
                  }
                  push(url.path, buffer);
                }
                buffer = "";
                if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
                  while (url.path.length > 1 && url.path[0] === "") {
                    shift(url.path);
                  }
                }
                if (chr === "?") {
                  url.query = "";
                  state = QUERY;
                } else if (chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                }
              } else {
                buffer += percentEncode(chr, pathPercentEncodeSet);
              }
              break;
            case CANNOT_BE_A_BASE_URL_PATH:
              if (chr === "?") {
                url.query = "";
                state = QUERY;
              } else if (chr === "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr !== EOF) {
                url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case QUERY:
              if (!stateOverride && chr === "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr !== EOF) {
                if (chr === "'" && url.isSpecial())
                  url.query += "%27";
                else if (chr === "#")
                  url.query += "%23";
                else
                  url.query += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case FRAGMENT:
              if (chr !== EOF)
                url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
              break;
          }
          pointer++;
        }
      },
      // https://url.spec.whatwg.org/#host-parsing
      parseHost: function(input) {
        var result, codePoints, index;
        if (charAt(input, 0) === "[") {
          if (charAt(input, input.length - 1) !== "]")
            return INVALID_HOST;
          result = parseIPv6(stringSlice(input, 1, -1));
          if (!result)
            return INVALID_HOST;
          this.host = result;
        } else if (!this.isSpecial()) {
          if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input))
            return INVALID_HOST;
          result = "";
          codePoints = arrayFrom(input);
          for (index = 0; index < codePoints.length; index++) {
            result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
          }
          this.host = result;
        } else {
          input = toASCII(input);
          if (exec(FORBIDDEN_HOST_CODE_POINT, input))
            return INVALID_HOST;
          result = parseIPv4(input);
          if (result === null)
            return INVALID_HOST;
          this.host = result;
        }
      },
      // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
      cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || this.scheme === "file";
      },
      // https://url.spec.whatwg.org/#include-credentials
      includesCredentials: function() {
        return this.username !== "" || this.password !== "";
      },
      // https://url.spec.whatwg.org/#is-special
      isSpecial: function() {
        return hasOwn(specialSchemes, this.scheme);
      },
      // https://url.spec.whatwg.org/#shorten-a-urls-path
      shortenPath: function() {
        var path = this.path;
        var pathSize = path.length;
        if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
          path.length--;
        }
      },
      // https://url.spec.whatwg.org/#concept-url-serializer
      serialize: function() {
        var url = this;
        var scheme = url.scheme;
        var username = url.username;
        var password = url.password;
        var host = url.host;
        var port = url.port;
        var path = url.path;
        var query = url.query;
        var fragment = url.fragment;
        var output = scheme + ":";
        if (host !== null) {
          output += "//";
          if (url.includesCredentials()) {
            output += username + (password ? ":" + password : "") + "@";
          }
          output += serializeHost(host);
          if (port !== null)
            output += ":" + port;
        } else if (scheme === "file")
          output += "//";
        output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        if (query !== null)
          output += "?" + query;
        if (fragment !== null)
          output += "#" + fragment;
        return output;
      },
      // https://url.spec.whatwg.org/#dom-url-href
      setHref: function(href) {
        var failure = this.parse(href);
        if (failure)
          throw new TypeError2(failure);
        this.searchParams.update();
      },
      // https://url.spec.whatwg.org/#dom-url-origin
      getOrigin: function() {
        var scheme = this.scheme;
        var port = this.port;
        if (scheme === "blob")
          try {
            return new URLConstructor(scheme.path[0]).origin;
          } catch (error) {
            return "null";
          }
        if (scheme === "file" || !this.isSpecial())
          return "null";
        return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
      },
      // https://url.spec.whatwg.org/#dom-url-protocol
      getProtocol: function() {
        return this.scheme + ":";
      },
      setProtocol: function(protocol) {
        this.parse($toString(protocol) + ":", SCHEME_START);
      },
      // https://url.spec.whatwg.org/#dom-url-username
      getUsername: function() {
        return this.username;
      },
      setUsername: function(username) {
        var codePoints = arrayFrom($toString(username));
        if (this.cannotHaveUsernamePasswordPort())
          return;
        this.username = "";
        for (var i2 = 0; i2 < codePoints.length; i2++) {
          this.username += percentEncode(codePoints[i2], userinfoPercentEncodeSet);
        }
      },
      // https://url.spec.whatwg.org/#dom-url-password
      getPassword: function() {
        return this.password;
      },
      setPassword: function(password) {
        var codePoints = arrayFrom($toString(password));
        if (this.cannotHaveUsernamePasswordPort())
          return;
        this.password = "";
        for (var i2 = 0; i2 < codePoints.length; i2++) {
          this.password += percentEncode(codePoints[i2], userinfoPercentEncodeSet);
        }
      },
      // https://url.spec.whatwg.org/#dom-url-host
      getHost: function() {
        var host = this.host;
        var port = this.port;
        return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
      },
      setHost: function(host) {
        if (this.cannotBeABaseURL)
          return;
        this.parse(host, HOST);
      },
      // https://url.spec.whatwg.org/#dom-url-hostname
      getHostname: function() {
        var host = this.host;
        return host === null ? "" : serializeHost(host);
      },
      setHostname: function(hostname) {
        if (this.cannotBeABaseURL)
          return;
        this.parse(hostname, HOSTNAME);
      },
      // https://url.spec.whatwg.org/#dom-url-port
      getPort: function() {
        var port = this.port;
        return port === null ? "" : $toString(port);
      },
      setPort: function(port) {
        if (this.cannotHaveUsernamePasswordPort())
          return;
        port = $toString(port);
        if (port === "")
          this.port = null;
        else
          this.parse(port, PORT);
      },
      // https://url.spec.whatwg.org/#dom-url-pathname
      getPathname: function() {
        var path = this.path;
        return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
      },
      setPathname: function(pathname) {
        if (this.cannotBeABaseURL)
          return;
        this.path = [];
        this.parse(pathname, PATH_START);
      },
      // https://url.spec.whatwg.org/#dom-url-search
      getSearch: function() {
        var query = this.query;
        return query ? "?" + query : "";
      },
      setSearch: function(search) {
        search = $toString(search);
        if (search === "") {
          this.query = null;
        } else {
          if (charAt(search, 0) === "?")
            search = stringSlice(search, 1);
          this.query = "";
          this.parse(search, QUERY);
        }
        this.searchParams.update();
      },
      // https://url.spec.whatwg.org/#dom-url-searchparams
      getSearchParams: function() {
        return this.searchParams.facade;
      },
      // https://url.spec.whatwg.org/#dom-url-hash
      getHash: function() {
        var fragment = this.fragment;
        return fragment ? "#" + fragment : "";
      },
      setHash: function(hash3) {
        hash3 = $toString(hash3);
        if (hash3 === "") {
          this.fragment = null;
          return;
        }
        if (charAt(hash3, 0) === "#")
          hash3 = stringSlice(hash3, 1);
        this.fragment = "";
        this.parse(hash3, FRAGMENT);
      },
      update: function() {
        this.query = this.searchParams.serialize() || null;
      }
    };
    var URLConstructor = function URL3(url) {
      var that = anInstance(this, URLPrototype);
      var base2 = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : void 0;
      var state = setInternalState(that, new URLState(url, false, base2));
      if (!DESCRIPTORS) {
        that.href = state.serialize();
        that.origin = state.getOrigin();
        that.protocol = state.getProtocol();
        that.username = state.getUsername();
        that.password = state.getPassword();
        that.host = state.getHost();
        that.hostname = state.getHostname();
        that.port = state.getPort();
        that.pathname = state.getPathname();
        that.search = state.getSearch();
        that.searchParams = state.getSearchParams();
        that.hash = state.getHash();
      }
    };
    var URLPrototype = URLConstructor.prototype;
    var accessorDescriptor = function(getter, setter) {
      return {
        get: function() {
          return getInternalURLState(this)[getter]();
        },
        set: setter && function(value) {
          return getInternalURLState(this)[setter](value);
        },
        configurable: true,
        enumerable: true
      };
    };
    if (DESCRIPTORS) {
      defineBuiltInAccessor(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
      defineBuiltInAccessor(URLPrototype, "origin", accessorDescriptor("getOrigin"));
      defineBuiltInAccessor(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
      defineBuiltInAccessor(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
      defineBuiltInAccessor(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
      defineBuiltInAccessor(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
      defineBuiltInAccessor(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
      defineBuiltInAccessor(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
      defineBuiltInAccessor(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
      defineBuiltInAccessor(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
      defineBuiltInAccessor(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
      defineBuiltInAccessor(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
    }
    defineBuiltIn(URLPrototype, "toJSON", function toJSON2() {
      return getInternalURLState(this).serialize();
    }, { enumerable: true });
    defineBuiltIn(URLPrototype, "toString", function toString2() {
      return getInternalURLState(this).serialize();
    }, { enumerable: true });
    if (NativeURL) {
      nativeCreateObjectURL = NativeURL.createObjectURL;
      nativeRevokeObjectURL = NativeURL.revokeObjectURL;
      if (nativeCreateObjectURL)
        defineBuiltIn(URLConstructor, "createObjectURL", bind(nativeCreateObjectURL, NativeURL));
      if (nativeRevokeObjectURL)
        defineBuiltIn(URLConstructor, "revokeObjectURL", bind(nativeRevokeObjectURL, NativeURL));
    }
    var nativeCreateObjectURL;
    var nativeRevokeObjectURL;
    setToStringTag(URLConstructor, "URL");
    $({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
      URL: URLConstructor
    });
  }
});

// node_modules/core-js-pure/modules/web.url.js
var require_web_url = __commonJS({
  "node_modules/core-js-pure/modules/web.url.js"() {
    "use strict";
    require_web_url_constructor();
  }
});

// node_modules/core-js-pure/modules/web.url.can-parse.js
var require_web_url_can_parse = __commonJS({
  "node_modules/core-js-pure/modules/web.url.can-parse.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var fails = require_fails();
    var validateArgumentsLength = require_validate_arguments_length();
    var toString2 = require_to_string();
    var USE_NATIVE_URL = require_url_constructor_detection();
    var URL3 = getBuiltIn("URL");
    var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL && fails(function() {
      URL3.canParse();
    });
    $({ target: "URL", stat: true, forced: !THROWS_WITHOUT_ARGUMENTS }, {
      canParse: function canParse(url) {
        var length = validateArgumentsLength(arguments.length, 1);
        var urlString = toString2(url);
        var base2 = length < 2 || arguments[1] === void 0 ? void 0 : toString2(arguments[1]);
        try {
          return !!new URL3(urlString, base2);
        } catch (error) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js-pure/modules/web.url.to-json.js
var require_web_url_to_json = __commonJS({
  "node_modules/core-js-pure/modules/web.url.to-json.js"() {
  }
});

// node_modules/core-js-pure/web/url.js
var require_url = __commonJS({
  "node_modules/core-js-pure/web/url.js"(exports, module) {
    "use strict";
    require_url_search_params();
    require_web_url();
    require_web_url_can_parse();
    require_web_url_to_json();
    var path = require_path();
    module.exports = path.URL;
  }
});

// node_modules/core-js-pure/stable/url/index.js
var require_url2 = __commonJS({
  "node_modules/core-js-pure/stable/url/index.js"(exports, module) {
    "use strict";
    var parent = require_url();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/url.js
var require_url3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/url.js"(exports, module) {
    module.exports = require_url2();
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/NetworkWeb3Connector.js
var require_NetworkWeb3Connector = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/NetworkWeb3Connector.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _concat = _interopRequireDefault(require_concat4());
    var _url = _interopRequireDefault(require_url3());
    var _keys = _interopRequireDefault(require_keys3());
    var _reduce = _interopRequireDefault(require_reduce4());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _convert = require_convert();
    var _verifyChainId = _interopRequireDefault(require_verifyChainId());
    var _AbstractWeb3Connector = _interopRequireDefault(require_AbstractWeb3Connector());
    var _MoralisRpcs = require_MoralisRpcs();
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var MiniRpcProvider = (0, _createClass2.default)(function MiniRpcProvider2(chainId, url) {
      var _this = this;
      (0, _classCallCheck2.default)(this, MiniRpcProvider2);
      (0, _defineProperty2.default)(this, "request", function() {
        var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(method, params) {
          var RESTController, response, _context, body, _body$error, _body$error2, _body$error3, _context2;
          return _regenerator.default.wrap(function(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (typeof method !== "string") {
                    params = method.params;
                    method = method.method;
                  }
                  RESTController = _CoreManager.default.getRESTController();
                  _context3.prev = 2;
                  _context3.next = 5;
                  return RESTController.ajax("POST", _this.url, (0, _stringify.default)({
                    jsonrpc: "2.0",
                    id: 1,
                    method,
                    params
                  }), {
                    "Content-Type": "application/json"
                  });
                case 5:
                  response = _context3.sent;
                  if (response) {
                    _context3.next = 8;
                    break;
                  }
                  throw new Error("No response");
                case 8:
                  if (!(!response.status || response.status > 400)) {
                    _context3.next = 10;
                    break;
                  }
                  throw new Error((0, _concat.default)(_context = "Error response [".concat(response.status, "] ")).call(_context, response.statusText));
                case 10:
                  body = response.response;
                  if (!("error" in body)) {
                    _context3.next = 13;
                    break;
                  }
                  throw new Error(body === null || body === void 0 ? void 0 : (_body$error = body.error) === null || _body$error === void 0 ? void 0 : _body$error.message, body === null || body === void 0 ? void 0 : (_body$error2 = body.error) === null || _body$error2 === void 0 ? void 0 : _body$error2.code, body === null || body === void 0 ? void 0 : (_body$error3 = body.error) === null || _body$error3 === void 0 ? void 0 : _body$error3.data);
                case 13:
                  if ("result" in body) {
                    _context3.next = 15;
                    break;
                  }
                  throw new Error("Received unexpected JSON-RPC response");
                case 15:
                  return _context3.abrupt("return", body.result);
                case 18:
                  _context3.prev = 18;
                  _context3.t0 = _context3["catch"](2);
                  throw new Error((0, _concat.default)(_context2 = 'Failed to make "'.concat(method, '" request with networkConnector: "')).call(_context2, _context3.t0.message, '"'));
                case 21:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee, null, [[2, 18]]);
        }));
        return function() {
          return _ref.apply(this, arguments);
        };
      }());
      this.chainId = chainId;
      this.url = url;
      var parsed = new _url.default(url);
      this.host = parsed.host;
      this.path = parsed.pathname;
    });
    var NetworkWeb3Connector = function(_AbstractWeb3Connecto) {
      (0, _inherits2.default)(NetworkWeb3Connector2, _AbstractWeb3Connecto);
      var _super = _createSuper(NetworkWeb3Connector2);
      function NetworkWeb3Connector2() {
        var _ref3, _context4;
        var _this2;
        var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, urls = _ref2.urls, defaultChainId = _ref2.defaultChainId, chainId = _ref2.chainId, speedyNodeApiKey = _ref2.speedyNodeApiKey;
        (0, _classCallCheck2.default)(this, NetworkWeb3Connector2);
        _this2 = _super.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "type", "network");
        if (!urls && speedyNodeApiKey) {
          urls = (0, _MoralisRpcs.getMoralisRpcs)(speedyNodeApiKey);
        }
        if (!urls && !speedyNodeApiKey) {
          throw new Error("Cannot connect to rpc: No urls or speedyNodeApiKey provided for NetworkWeb3Connector.");
        }
        if (speedyNodeApiKey) {
          console.warn("Moralis: Using speedyNodeApiKey on the browser enviroment is not recommended, as it is publicly visible.");
        }
        _this2.chainId = (0, _verifyChainId.default)((_ref3 = chainId !== null && chainId !== void 0 ? chainId : defaultChainId) !== null && _ref3 !== void 0 ? _ref3 : Number((0, _keys.default)(urls)[0]));
        _this2.providers = (0, _reduce.default)(_context4 = (0, _keys.default)(urls)).call(_context4, function(accumulator, chainId2) {
          accumulator[Number(chainId2)] = new MiniRpcProvider(Number(chainId2), urls[Number(chainId2)]);
          return accumulator;
        }, {});
        return _this2;
      }
      (0, _createClass2.default)(NetworkWeb3Connector2, [{
        key: "activate",
        value: function() {
          var _activate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            var _ref4, providedChainId, _ref4$privateKey, privateKey, provider, _args2 = arguments;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _ref4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, providedChainId = _ref4.chainId, _ref4$privateKey = _ref4.privateKey, privateKey = _ref4$privateKey === void 0 ? null : _ref4$privateKey;
                    if (providedChainId) {
                      this.chainId = (0, _verifyChainId.default)(providedChainId);
                    }
                    provider = this.providers[(0, _convert.fromHexToDecimal)(this.chainId)];
                    if (provider) {
                      _context5.next = 5;
                      break;
                    }
                    throw new Error("No rpc url provided for chainId ".concat(this.chainId));
                  case 5:
                    if (!(privateKey != null)) {
                      _context5.next = 9;
                      break;
                    }
                    _context5.next = 8;
                    return new _ethers.ethers.Wallet(privateKey).getAddress();
                  case 8:
                    this.account = _context5.sent;
                  case 9:
                    return _context5.abrupt("return", {
                      provider,
                      chainId: this.chainId,
                      account: this.account
                    });
                  case 10:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _activate.apply(this, arguments);
          };
        }()
      }]);
      return NetworkWeb3Connector2;
    }(_AbstractWeb3Connector.default);
    var _default = NetworkWeb3Connector;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/InternalWeb3Provider.js
var require_InternalWeb3Provider = __commonJS({
  "node_modules/moralis-v1/lib/browser/InternalWeb3Provider.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.InternalWeb3Events = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _freeze = _interopRequireDefault(require_freeze3());
    var _bind = _interopRequireDefault(require_bind8());
    var _events = _interopRequireDefault(require_events());
    var _events2 = require_events2();
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    var _convert = require_convert();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var InternalWeb3Events = (0, _freeze.default)({
      ACCOUNT_CHANGED: "accountChanged",
      CHAIN_CHANGED: "chainChanged",
      PROVIDER_CONNECT: "provider-connect",
      PROVIDER_DISCONNECT: "provider-disconnect",
      WEB3_ENABLED: "web3Enabled",
      WEB3_DEACTIVATED: "web3Deactivated"
    });
    exports.InternalWeb3Events = InternalWeb3Events;
    var InternalWeb3Provider = function(_EventEmitter) {
      (0, _inherits2.default)(InternalWeb3Provider2, _EventEmitter);
      var _super = _createSuper(InternalWeb3Provider2);
      function InternalWeb3Provider2(connector) {
        var _context, _context2, _context3, _context4;
        var _this;
        var anyNetwork = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var privateKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        (0, _classCallCheck2.default)(this, InternalWeb3Provider2);
        _this = _super.call(this);
        if (!connector) {
          throw new Error("Cannot initialize InternalWeb3Provider without a connector");
        }
        _this.connector = connector;
        _this.anyNetwork = anyNetwork;
        _this.privateKey = privateKey;
        _this.handleAccountChanged = (0, _bind.default)(_context = _this.handleAccountChanged).call(_context, (0, _assertThisInitialized2.default)(_this));
        _this.handleChainChanged = (0, _bind.default)(_context2 = _this.handleChainChanged).call(_context2, (0, _assertThisInitialized2.default)(_this));
        _this.handleConnect = (0, _bind.default)(_context3 = _this.handleConnect).call(_context3, (0, _assertThisInitialized2.default)(_this));
        _this.handleDisconnect = (0, _bind.default)(_context4 = _this.handleDisconnect).call(_context4, (0, _assertThisInitialized2.default)(_this));
        return _this;
      }
      (0, _createClass2.default)(InternalWeb3Provider2, [{
        key: "activate",
        value: function() {
          var _activate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(options) {
            var _yield$this$connector, provider, chainId, account, network;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (this.connector) {
                      _context5.next = 2;
                      break;
                    }
                    throw new Error("Cannot activate InternalWeb3Provider without a connector");
                  case 2:
                    if (this.connector.on) {
                      this.connector.on(_events2.ConnectorEvents.ACCOUNT_CHANGED, this.handleAccountChanged);
                      this.connector.on(_events2.ConnectorEvents.CHAIN_CHANGED, this.handleChainChanged);
                      this.connector.on(_events2.ConnectorEvents.CONNECT, this.handleConnect);
                      this.connector.on(_events2.ConnectorEvents.DISCONNECT, this.handleDisconnect);
                    }
                    _context5.next = 5;
                    return this.connector.activate(options);
                  case 5:
                    _yield$this$connector = _context5.sent;
                    provider = _yield$this$connector.provider;
                    chainId = _yield$this$connector.chainId;
                    account = _yield$this$connector.account;
                    this.provider = provider;
                    this.chainId = chainId;
                    this.account = account;
                    network = this.anyNetwork ? "any" : (0, _convert.fromHexToDecimal)(chainId);
                    this.web3 = new _ethers.ethers.providers.Web3Provider(provider, network);
                    return _context5.abrupt("return", {
                      provider,
                      chainId,
                      account,
                      web3: this.web3
                    });
                  case 15:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _activate.apply(this, arguments);
          };
        }()
        // Returns a provider (or wallet if a privateKey is provided) that can sign messages (throws if not possible, ie. the account cannot sign)
      }, {
        key: "signer",
        get: function() {
          return this.privateKey != null ? new _ethers.ethers.Wallet(this.privateKey, this.web3) : this.web3.getSigner(this.account);
        }
        // Returns a provider (or wallet if a privateKey is provided) that can sign messages or the normal web3 provider as fallback
      }, {
        key: "signerOrProvider",
        get: function() {
          try {
            if (this.account) {
              return this.privateKey != null ? new _ethers.ethers.Wallet(this.privateKey, this.web3) : this.web3.getSigner(this.account);
            }
            return this.web3;
          } catch (error) {
            return this.web3;
          }
        }
      }, {
        key: "handleChainChanged",
        value: function(chainId) {
          this.chainId = chainId;
          this.web3 = new _ethers.ethers.providers.Web3Provider(this.provider, (0, _convert.fromHexToDecimal)(chainId));
          this.emit(InternalWeb3Events.CHAIN_CHANGED, chainId);
        }
      }, {
        key: "handleAccountChanged",
        value: function(account) {
          this.account = account;
          this.emit(InternalWeb3Events.ACCOUNT_CHANGED, account);
        }
        // Handle Connect events fired from connectors
      }, {
        key: "handleConnect",
        value: function(connectInfo) {
          this.emit(InternalWeb3Events.PROVIDER_CONNECT, connectInfo);
        }
        // Handle Disconnect events fired from connectors
      }, {
        key: "handleDisconnect",
        value: function(error) {
          this.emit(InternalWeb3Events.PROVIDER_DISCONNECT, error);
        }
      }, {
        key: "deactivate",
        value: function() {
          var _deactivate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            return _regenerator.default.wrap(function(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    this.account = null;
                    this.chainId = null;
                    this.web3 = null;
                    this.provider = null;
                    this.privateKey = null;
                    if (!this.connector) {
                      _context6.next = 10;
                      break;
                    }
                    if (this.connector.removeListener) {
                      this.connector.removeListener(InternalWeb3Events.CHAIN_CHANGED, this.handleChainChanged);
                      this.connector.removeListener(InternalWeb3Events.ACCOUNT_CHANGED, this.handleAccountChanged);
                      this.connector.removeListener(InternalWeb3Events.PROVIDER_CONNECT, this.handleConnect);
                      this.connector.removeListener(InternalWeb3Events.PROVIDER_DISCONNECT, this.handleDisconnect);
                    }
                    if (!this.connector.deactivate) {
                      _context6.next = 10;
                      break;
                    }
                    _context6.next = 10;
                    return this.connector.deactivate();
                  case 10:
                    this.connector = null;
                  case 11:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _deactivate.apply(this, arguments);
          };
        }()
      }]);
      return InternalWeb3Provider2;
    }(_events.default);
    var _default = InternalWeb3Provider;
    exports.default = _default;
  }
});

// node_modules/@magic-sdk/types/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@magic-sdk/types/dist/cjs/index.js"(exports, module) {
    "use strict";
    var m = Object.defineProperty;
    var N2 = Object.getOwnPropertyDescriptor;
    var A2 = Object.getOwnPropertyNames;
    var R2 = Object.prototype.hasOwnProperty;
    var E2 = (s2, n2) => {
      for (var a2 in n2)
        m(s2, a2, { get: n2[a2], enumerable: true });
    };
    var f3 = (s2, n2, a2, p2) => {
      if (n2 && typeof n2 == "object" || typeof n2 == "function")
        for (let i2 of A2(n2))
          !R2.call(s2, i2) && i2 !== a2 && m(s2, i2, { get: () => n2[i2], enumerable: !(p2 = N2(n2, i2)) || p2.enumerable });
      return s2;
    };
    var x2 = (s2) => f3(m({}, "__esModule", { value: true }), s2);
    var L2 = {};
    E2(L2, { EthChainType: () => T, MagicIncomingWindowMessage: () => l2, MagicOutgoingWindowMessage: () => I2, MagicPayloadMethod: () => g2, RPCErrorCode: () => c2, SDKErrorCode: () => u2, SDKWarningCode: () => o2 });
    module.exports = x2(L2);
    var u2 = ((_2) => (_2.MissingApiKey = "MISSING_API_KEY", _2.ModalNotReady = "MODAL_NOT_READY", _2.MalformedResponse = "MALFORMED_RESPONSE", _2.InvalidArgument = "INVALID_ARGUMENT", _2.ExtensionNotInitialized = "EXTENSION_NOT_INITIALIZED", _2.IncompatibleExtensions = "INCOMPATIBLE_EXTENSIONS", _2))(u2 || {});
    var o2 = ((i2) => (i2.SyncWeb3Method = "SYNC_WEB3_METHOD", i2.DuplicateIframe = "DUPLICATE_IFRAME", i2.ReactNativeEndpointConfiguration = "REACT_NATIVE_ENDPOINT_CONFIGURATION", i2.DeprecationNotice = "DEPRECATION_NOTICE", i2))(o2 || {});
    var c2 = ((t2) => (t2[t2.ParseError = -32700] = "ParseError", t2[t2.InvalidRequest = -32600] = "InvalidRequest", t2[t2.MethodNotFound = -32601] = "MethodNotFound", t2[t2.InvalidParams = -32602] = "InvalidParams", t2[t2.InternalError = -32603] = "InternalError", t2[t2.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", t2[t2.MagicLinkExpired = -10001] = "MagicLinkExpired", t2[t2.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", t2[t2.MagicLinkInvalidRedirectURL = -10006] = "MagicLinkInvalidRedirectURL", t2[t2.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn", t2[t2.UpdateEmailFailed = -10004] = "UpdateEmailFailed", t2[t2.UserRequestEditEmail = -10005] = "UserRequestEditEmail", t2[t2.InactiveRecipient = -10010] = "InactiveRecipient", t2[t2.AccessDeniedToUser = -10011] = "AccessDeniedToUser", t2))(c2 || {});
    var g2 = ((e) => (e.LoginWithSms = "magic_auth_login_with_sms", e.LoginWithEmailOTP = "magic_auth_login_with_email_otp", e.LoginWithMagicLink = "magic_auth_login_with_magic_link", e.LoginWithCredential = "magic_auth_login_with_credential", e.GetIdToken = "magic_auth_get_id_token", e.GenerateIdToken = "magic_auth_generate_id_token", e.GetMetadata = "magic_auth_get_metadata", e.IsLoggedIn = "magic_auth_is_logged_in", e.Logout = "magic_auth_logout", e.UpdateEmail = "magic_auth_update_email", e.UserSettings = "magic_auth_settings", e.UserSettingsTestMode = "magic_auth_settings_testing_mode", e.LoginWithSmsTestMode = "magic_auth_login_with_sms_testing_mode", e.LoginWithEmailOTPTestMode = "magic_auth_login_with_email_otp_testing_mode", e.LoginWithMagicLinkTestMode = "magic_login_with_magic_link_testing_mode", e.LoginWithCredentialTestMode = "magic_auth_login_with_credential_testing_mode", e.GetIdTokenTestMode = "magic_auth_get_id_token_testing_mode", e.GenerateIdTokenTestMode = "magic_auth_generate_id_token_testing_mode", e.GetMetadataTestMode = "magic_auth_get_metadata_testing_mode", e.IsLoggedInTestMode = "magic_auth_is_logged_in_testing_mode", e.LogoutTestMode = "magic_auth_logout_testing_mode", e.UpdateEmailTestMode = "magic_auth_update_email_testing_mode", e.IntermediaryEvent = "magic_intermediary_event", e.RequestAccounts = "eth_requestAccounts", e.GetInfo = "mc_get_wallet_info", e.ShowUI = "mc_wallet", e.NFTPurchase = "magic_nft_purchase", e.RequestUserInfoWithUI = "mc_request_user_info", e.Disconnect = "mc_disconnect", e.UpdatePhoneNumber = "magic_auth_update_phone_number", e.UpdatePhoneNumberTestMode = "magic_auth_update_phone_number_testing_mode", e.RecoverAccount = "magic_auth_recover_account", e.RecoverAccountTestMode = "magic_auth_recover_account_testing_mode", e))(g2 || {});
    var l2 = ((r2) => (r2.MAGIC_HANDLE_RESPONSE = "MAGIC_HANDLE_RESPONSE", r2.MAGIC_OVERLAY_READY = "MAGIC_OVERLAY_READY", r2.MAGIC_SHOW_OVERLAY = "MAGIC_SHOW_OVERLAY", r2.MAGIC_HIDE_OVERLAY = "MAGIC_HIDE_OVERLAY", r2.MAGIC_HANDLE_EVENT = "MAGIC_HANDLE_EVENT", r2))(l2 || {});
    var I2 = ((n2) => (n2.MAGIC_HANDLE_REQUEST = "MAGIC_HANDLE_REQUEST", n2))(I2 || {});
    var T = ((n2) => (n2.Harmony = "HARMONY", n2))(T || {});
  }
});

// node_modules/@magic-sdk/provider/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@magic-sdk/provider/dist/cjs/index.js"(exports, module) {
    "use strict";
    var $t = Object.create;
    var B2 = Object.defineProperty;
    var Nt = Object.defineProperties;
    var Mt = Object.getOwnPropertyDescriptor;
    var wt = Object.getOwnPropertyDescriptors;
    var At = Object.getOwnPropertyNames;
    var He = Object.getOwnPropertySymbols;
    var Lt = Object.getPrototypeOf;
    var ze = Object.prototype.hasOwnProperty;
    var St = Object.prototype.propertyIsEnumerable;
    var Ve = (n2, e, t2) => e in n2 ? B2(n2, e, { enumerable: true, configurable: true, writable: true, value: t2 }) : n2[e] = t2;
    var ae = (n2, e) => {
      for (var t2 in e || (e = {}))
        ze.call(e, t2) && Ve(n2, t2, e[t2]);
      if (He)
        for (var t2 of He(e))
          St.call(e, t2) && Ve(n2, t2, e[t2]);
      return n2;
    };
    var Ye = (n2, e) => Nt(n2, wt(e));
    var Ot = (n2, e) => () => (e || n2((e = { exports: {} }).exports, e), e.exports);
    var Ze = (n2, e) => {
      for (var t2 in e)
        B2(n2, t2, { get: e[t2], enumerable: true });
    };
    var Qe = (n2, e, t2, r2) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let o2 of At(e))
          !ze.call(n2, o2) && o2 !== t2 && B2(n2, o2, { get: () => e[o2], enumerable: !(r2 = Mt(e, o2)) || r2.enumerable });
      return n2;
    };
    var Ct = (n2, e, t2) => (t2 = n2 != null ? $t(Lt(n2)) : {}, Qe(e || !n2 || !n2.__esModule ? B2(t2, "default", { value: n2, enumerable: true }) : t2, n2));
    var _t = (n2) => Qe(B2({}, "__esModule", { value: true }), n2);
    var b2 = (n2, e, t2) => new Promise((r2, o2) => {
      var s2 = (c2) => {
        try {
          i2(t2.next(c2));
        } catch (p2) {
          o2(p2);
        }
      }, a2 = (c2) => {
        try {
          i2(t2.throw(c2));
        } catch (p2) {
          o2(p2);
        }
      }, i2 = (c2) => c2.done ? r2(c2.value) : Promise.resolve(c2.value).then(s2, a2);
      i2((t2 = t2.apply(n2, e)).next());
    });
    var yt = Ot((Er, Ge) => {
      "use strict";
      var Sn = Object.prototype.hasOwnProperty, v2 = "~";
      function Q2() {
      }
      Object.create && (Q2.prototype = /* @__PURE__ */ Object.create(null), new Q2().__proto__ || (v2 = false));
      function On(n2, e, t2) {
        this.fn = n2, this.context = e, this.once = t2 || false;
      }
      function ft(n2, e, t2, r2, o2) {
        if (typeof t2 != "function")
          throw new TypeError("The listener must be a function");
        var s2 = new On(t2, r2 || n2, o2), a2 = v2 ? v2 + e : e;
        return n2._events[a2] ? n2._events[a2].fn ? n2._events[a2] = [n2._events[a2], s2] : n2._events[a2].push(s2) : (n2._events[a2] = s2, n2._eventsCount++), n2;
      }
      function he(n2, e) {
        --n2._eventsCount === 0 ? n2._events = new Q2() : delete n2._events[e];
      }
      function R2() {
        this._events = new Q2(), this._eventsCount = 0;
      }
      R2.prototype.eventNames = function() {
        var e = [], t2, r2;
        if (this._eventsCount === 0)
          return e;
        for (r2 in t2 = this._events)
          Sn.call(t2, r2) && e.push(v2 ? r2.slice(1) : r2);
        return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t2)) : e;
      };
      R2.prototype.listeners = function(e) {
        var t2 = v2 ? v2 + e : e, r2 = this._events[t2];
        if (!r2)
          return [];
        if (r2.fn)
          return [r2.fn];
        for (var o2 = 0, s2 = r2.length, a2 = new Array(s2); o2 < s2; o2++)
          a2[o2] = r2[o2].fn;
        return a2;
      };
      R2.prototype.listenerCount = function(e) {
        var t2 = v2 ? v2 + e : e, r2 = this._events[t2];
        return r2 ? r2.fn ? 1 : r2.length : 0;
      };
      R2.prototype.emit = function(e, t2, r2, o2, s2, a2) {
        var i2 = v2 ? v2 + e : e;
        if (!this._events[i2])
          return false;
        var c2 = this._events[i2], p2 = arguments.length, l2, u2;
        if (c2.fn) {
          switch (c2.once && this.removeListener(e, c2.fn, void 0, true), p2) {
            case 1:
              return c2.fn.call(c2.context), true;
            case 2:
              return c2.fn.call(c2.context, t2), true;
            case 3:
              return c2.fn.call(c2.context, t2, r2), true;
            case 4:
              return c2.fn.call(c2.context, t2, r2, o2), true;
            case 5:
              return c2.fn.call(c2.context, t2, r2, o2, s2), true;
            case 6:
              return c2.fn.call(c2.context, t2, r2, o2, s2, a2), true;
          }
          for (u2 = 1, l2 = new Array(p2 - 1); u2 < p2; u2++)
            l2[u2 - 1] = arguments[u2];
          c2.fn.apply(c2.context, l2);
        } else {
          var P2 = c2.length, S2;
          for (u2 = 0; u2 < P2; u2++)
            switch (c2[u2].once && this.removeListener(e, c2[u2].fn, void 0, true), p2) {
              case 1:
                c2[u2].fn.call(c2[u2].context);
                break;
              case 2:
                c2[u2].fn.call(c2[u2].context, t2);
                break;
              case 3:
                c2[u2].fn.call(c2[u2].context, t2, r2);
                break;
              case 4:
                c2[u2].fn.call(c2[u2].context, t2, r2, o2);
                break;
              default:
                if (!l2)
                  for (S2 = 1, l2 = new Array(p2 - 1); S2 < p2; S2++)
                    l2[S2 - 1] = arguments[S2];
                c2[u2].fn.apply(c2[u2].context, l2);
            }
        }
        return true;
      };
      R2.prototype.on = function(e, t2, r2) {
        return ft(this, e, t2, r2, false);
      };
      R2.prototype.once = function(e, t2, r2) {
        return ft(this, e, t2, r2, true);
      };
      R2.prototype.removeListener = function(e, t2, r2, o2) {
        var s2 = v2 ? v2 + e : e;
        if (!this._events[s2])
          return this;
        if (!t2)
          return he(this, s2), this;
        var a2 = this._events[s2];
        if (a2.fn)
          a2.fn === t2 && (!o2 || a2.once) && (!r2 || a2.context === r2) && he(this, s2);
        else {
          for (var i2 = 0, c2 = [], p2 = a2.length; i2 < p2; i2++)
            (a2[i2].fn !== t2 || o2 && !a2[i2].once || r2 && a2[i2].context !== r2) && c2.push(a2[i2]);
          c2.length ? this._events[s2] = c2.length === 1 ? c2[0] : c2 : he(this, s2);
        }
        return this;
      };
      R2.prototype.removeAllListeners = function(e) {
        var t2;
        return e ? (t2 = v2 ? v2 + e : e, this._events[t2] && he(this, t2)) : (this._events = new Q2(), this._eventsCount = 0), this;
      };
      R2.prototype.off = R2.prototype.removeListener;
      R2.prototype.addListener = R2.prototype.on;
      R2.prefixed = v2;
      R2.EventEmitter = R2;
      typeof Ge < "u" && (Ge.exports = R2);
    });
    var Qn = {};
    Ze(Qn, { Extension: () => M2, MagicExtensionError: () => k2, MagicExtensionWarning: () => G2, MagicRPCError: () => N2, MagicSDKError: () => $, MagicSDKWarning: () => D2, SDKBase: () => se, STORE_KEY_PRIVATE_KEY: () => Te, STORE_KEY_PUBLIC_JWK: () => ne, TypedEmitter: () => Ee, ViewController: () => Me, clearKeys: () => re, createDeprecationWarning: () => Mn, createDuplicateIframeWarning: () => Nn, createExtensionNotInitializedError: () => De, createIncompatibleExtensionsError: () => ke, createInvalidArgumentError: () => qe, createJwt: () => We, createMalformedResponseError: () => _e, createMissingApiKeyError: () => Ce, createModalNotReadyError: () => $n, createPromiEvent: () => te, createPromise: () => fe, createReactNativeEndpointConfigurationWarning: () => Ue, createSDK: () => dt, createSynchronousWeb3MethodWarning: () => Je, createTypedEmitter: () => ee, createURL: () => be, decodeJSON: () => Le, encodeJSON: () => Y2, getPayloadId: () => me, isEmpty: () => Z2, isJsonRpcErrorCode: () => Oe, isJsonRpcRequestPayload: () => xn, isJsonRpcResponsePayload: () => Se, isMagicPayloadMethod: () => bn, isPromiEvent: () => Fe, storage: () => j2, uuid: () => Ke });
    module.exports = _t(Qn);
    function Dt(n2) {
      let e = { exports: {} };
      return n2(e, e.exports), e.exports;
    }
    var kt = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var Ae = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: kt, MAX_SAFE_COMPONENT_LENGTH: 16 };
    var qt = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...n2) => console.error("SEMVER", ...n2) : () => {
    };
    var m = qt;
    var z2 = Dt(function(n2, e) {
      let { MAX_SAFE_COMPONENT_LENGTH: t2 } = Ae, r2 = (e = n2.exports = {}).re = [], o2 = e.src = [], s2 = e.t = {}, a2 = 0, i2 = (c2, p2, l2) => {
        let u2 = a2++;
        m(u2, p2), s2[c2] = u2, o2[u2] = p2, r2[u2] = new RegExp(p2, l2 ? "g" : void 0);
      };
      i2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), i2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), i2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), i2("MAINVERSION", `(${o2[s2.NUMERICIDENTIFIER]})\\.(${o2[s2.NUMERICIDENTIFIER]})\\.(${o2[s2.NUMERICIDENTIFIER]})`), i2("MAINVERSIONLOOSE", `(${o2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${o2[s2.NUMERICIDENTIFIERLOOSE]})\\.(${o2[s2.NUMERICIDENTIFIERLOOSE]})`), i2("PRERELEASEIDENTIFIER", `(?:${o2[s2.NUMERICIDENTIFIER]}|${o2[s2.NONNUMERICIDENTIFIER]})`), i2("PRERELEASEIDENTIFIERLOOSE", `(?:${o2[s2.NUMERICIDENTIFIERLOOSE]}|${o2[s2.NONNUMERICIDENTIFIER]})`), i2("PRERELEASE", `(?:-(${o2[s2.PRERELEASEIDENTIFIER]}(?:\\.${o2[s2.PRERELEASEIDENTIFIER]})*))`), i2("PRERELEASELOOSE", `(?:-?(${o2[s2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o2[s2.PRERELEASEIDENTIFIERLOOSE]})*))`), i2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), i2("BUILD", `(?:\\+(${o2[s2.BUILDIDENTIFIER]}(?:\\.${o2[s2.BUILDIDENTIFIER]})*))`), i2("FULLPLAIN", `v?${o2[s2.MAINVERSION]}${o2[s2.PRERELEASE]}?${o2[s2.BUILD]}?`), i2("FULL", `^${o2[s2.FULLPLAIN]}$`), i2("LOOSEPLAIN", `[v=\\s]*${o2[s2.MAINVERSIONLOOSE]}${o2[s2.PRERELEASELOOSE]}?${o2[s2.BUILD]}?`), i2("LOOSE", `^${o2[s2.LOOSEPLAIN]}$`), i2("GTLT", "((?:<|>)?=?)"), i2("XRANGEIDENTIFIERLOOSE", `${o2[s2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), i2("XRANGEIDENTIFIER", `${o2[s2.NUMERICIDENTIFIER]}|x|X|\\*`), i2("XRANGEPLAIN", `[v=\\s]*(${o2[s2.XRANGEIDENTIFIER]})(?:\\.(${o2[s2.XRANGEIDENTIFIER]})(?:\\.(${o2[s2.XRANGEIDENTIFIER]})(?:${o2[s2.PRERELEASE]})?${o2[s2.BUILD]}?)?)?`), i2("XRANGEPLAINLOOSE", `[v=\\s]*(${o2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o2[s2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o2[s2.XRANGEIDENTIFIERLOOSE]})(?:${o2[s2.PRERELEASELOOSE]})?${o2[s2.BUILD]}?)?)?`), i2("XRANGE", `^${o2[s2.GTLT]}\\s*${o2[s2.XRANGEPLAIN]}$`), i2("XRANGELOOSE", `^${o2[s2.GTLT]}\\s*${o2[s2.XRANGEPLAINLOOSE]}$`), i2("COERCE", `(^|[^\\d])(\\d{1,${t2}})(?:\\.(\\d{1,${t2}}))?(?:\\.(\\d{1,${t2}}))?(?:$|[^\\d])`), i2("COERCERTL", o2[s2.COERCE], true), i2("LONETILDE", "(?:~>?)"), i2("TILDETRIM", `(\\s*)${o2[s2.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", i2("TILDE", `^${o2[s2.LONETILDE]}${o2[s2.XRANGEPLAIN]}$`), i2("TILDELOOSE", `^${o2[s2.LONETILDE]}${o2[s2.XRANGEPLAINLOOSE]}$`), i2("LONECARET", "(?:\\^)"), i2("CARETTRIM", `(\\s*)${o2[s2.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", i2("CARET", `^${o2[s2.LONECARET]}${o2[s2.XRANGEPLAIN]}$`), i2("CARETLOOSE", `^${o2[s2.LONECARET]}${o2[s2.XRANGEPLAINLOOSE]}$`), i2("COMPARATORLOOSE", `^${o2[s2.GTLT]}\\s*(${o2[s2.LOOSEPLAIN]})$|^$`), i2("COMPARATOR", `^${o2[s2.GTLT]}\\s*(${o2[s2.FULLPLAIN]})$|^$`), i2("COMPARATORTRIM", `(\\s*)${o2[s2.GTLT]}\\s*(${o2[s2.LOOSEPLAIN]}|${o2[s2.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", i2("HYPHENRANGE", `^\\s*(${o2[s2.XRANGEPLAIN]})\\s+-\\s+(${o2[s2.XRANGEPLAIN]})\\s*$`), i2("HYPHENRANGELOOSE", `^\\s*(${o2[s2.XRANGEPLAINLOOSE]})\\s+-\\s+(${o2[s2.XRANGEPLAINLOOSE]})\\s*$`), i2("STAR", "(<|>)?=?\\s*\\*"), i2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), i2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    });
    var et = /^[0-9]+$/;
    var lt = (n2, e) => {
      let t2 = et.test(n2), r2 = et.test(e);
      return t2 && r2 && (n2 = +n2, e = +e), n2 === e ? 0 : t2 && !r2 ? -1 : r2 && !t2 ? 1 : n2 < e ? -1 : 1;
    };
    var Jt = (n2, e) => lt(e, n2);
    var Ut = { compareIdentifiers: lt, rcompareIdentifiers: Jt };
    var { MAX_LENGTH: tt, MAX_SAFE_INTEGER: ce } = Ae;
    var { re: nt, t: rt } = z2;
    var { compareIdentifiers: H2 } = Ut;
    var E2 = class {
      constructor(e, t2) {
        if (t2 && typeof t2 == "object" || (t2 = { loose: !!t2, includePrerelease: false }), e instanceof E2) {
          if (e.loose === !!t2.loose && e.includePrerelease === !!t2.includePrerelease)
            return e;
          e = e.version;
        } else if (typeof e != "string")
          throw new TypeError(`Invalid Version: ${e}`);
        if (e.length > tt)
          throw new TypeError(`version is longer than ${tt} characters`);
        m("SemVer", e, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
        let r2 = e.trim().match(t2.loose ? nt[rt.LOOSE] : nt[rt.FULL]);
        if (!r2)
          throw new TypeError(`Invalid Version: ${e}`);
        if (this.raw = e, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > ce || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > ce || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > ce || this.patch < 0)
          throw new TypeError("Invalid patch version");
        r2[4] ? this.prerelease = r2[4].split(".").map((o2) => {
          if (/^[0-9]+$/.test(o2)) {
            let s2 = +o2;
            if (s2 >= 0 && s2 < ce)
              return s2;
          }
          return o2;
        }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e) {
        if (m("SemVer.compare", this.version, this.options, e), !(e instanceof E2)) {
          if (typeof e == "string" && e === this.version)
            return 0;
          e = new E2(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
      }
      compareMain(e) {
        return e instanceof E2 || (e = new E2(e, this.options)), H2(this.major, e.major) || H2(this.minor, e.minor) || H2(this.patch, e.patch);
      }
      comparePre(e) {
        if (e instanceof E2 || (e = new E2(e, this.options)), this.prerelease.length && !e.prerelease.length)
          return -1;
        if (!this.prerelease.length && e.prerelease.length)
          return 1;
        if (!this.prerelease.length && !e.prerelease.length)
          return 0;
        let t2 = 0;
        do {
          let r2 = this.prerelease[t2], o2 = e.prerelease[t2];
          if (m("prerelease compare", t2, r2, o2), r2 === void 0 && o2 === void 0)
            return 0;
          if (o2 === void 0)
            return 1;
          if (r2 === void 0)
            return -1;
          if (r2 !== o2)
            return H2(r2, o2);
        } while (++t2);
      }
      compareBuild(e) {
        e instanceof E2 || (e = new E2(e, this.options));
        let t2 = 0;
        do {
          let r2 = this.build[t2], o2 = e.build[t2];
          if (m("prerelease compare", t2, r2, o2), r2 === void 0 && o2 === void 0)
            return 0;
          if (o2 === void 0)
            return 1;
          if (r2 === void 0)
            return -1;
          if (r2 !== o2)
            return H2(r2, o2);
        } while (++t2);
      }
      inc(e, t2) {
        switch (e) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
            break;
          case "major":
            this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0)
              this.prerelease = [0];
            else {
              let r2 = this.prerelease.length;
              for (; --r2 >= 0; )
                typeof this.prerelease[r2] == "number" && (this.prerelease[r2]++, r2 = -2);
              r2 === -1 && this.prerelease.push(0);
            }
            t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
            break;
          default:
            throw new Error(`invalid increment argument: ${e}`);
        }
        return this.format(), this.raw = this.version, this;
      }
    };
    var Gt = (n2, e, t2) => new E2(n2, t2).compare(new E2(e, t2));
    var U2 = Gt;
    var Ft = (n2, e, t2) => U2(n2, e, t2) === 0;
    var Kt = Ft;
    var jt = (n2, e, t2) => U2(n2, e, t2) !== 0;
    var Wt = jt;
    var Xt = (n2, e, t2) => U2(n2, e, t2) > 0;
    var Bt = Xt;
    var Ht = (n2, e, t2) => U2(n2, e, t2) >= 0;
    var Vt = Ht;
    var zt = (n2, e, t2) => U2(n2, e, t2) < 0;
    var Yt = zt;
    var Zt = (n2, e, t2) => U2(n2, e, t2) <= 0;
    var Qt = Zt;
    var en2 = (n2, e, t2, r2) => {
      switch (e) {
        case "===":
          return typeof n2 == "object" && (n2 = n2.version), typeof t2 == "object" && (t2 = t2.version), n2 === t2;
        case "!==":
          return typeof n2 == "object" && (n2 = n2.version), typeof t2 == "object" && (t2 = t2.version), n2 !== t2;
        case "":
        case "=":
        case "==":
          return Kt(n2, t2, r2);
        case "!=":
          return Wt(n2, t2, r2);
        case ">":
          return Bt(n2, t2, r2);
        case ">=":
          return Vt(n2, t2, r2);
        case "<":
          return Yt(n2, t2, r2);
        case "<=":
          return Qt(n2, t2, r2);
        default:
          throw new TypeError(`Invalid operator: ${e}`);
      }
    };
    var we = en2;
    var V = Symbol("SemVer ANY");
    var O2 = class {
      static get ANY() {
        return V;
      }
      constructor(e, t2) {
        if (t2 && typeof t2 == "object" || (t2 = { loose: !!t2, includePrerelease: false }), e instanceof O2) {
          if (e.loose === !!t2.loose)
            return e;
          e = e.value;
        }
        m("comparator", e, t2), this.options = t2, this.loose = !!t2.loose, this.parse(e), this.semver === V ? this.value = "" : this.value = this.operator + this.semver.version, m("comp", this);
      }
      parse(e) {
        let t2 = this.options.loose ? st[ot.COMPARATORLOOSE] : st[ot.COMPARATOR], r2 = e.match(t2);
        if (!r2)
          throw new TypeError(`Invalid comparator: ${e}`);
        this.operator = r2[1] !== void 0 ? r2[1] : "", this.operator === "=" && (this.operator = ""), r2[2] ? this.semver = new E2(r2[2], this.options.loose) : this.semver = V;
      }
      toString() {
        return this.value;
      }
      test(e) {
        if (m("Comparator.test", e, this.options.loose), this.semver === V || e === V)
          return true;
        if (typeof e == "string")
          try {
            e = new E2(e, this.options);
          } catch (t2) {
            return false;
          }
        return we(e, this.operator, this.semver, this.options);
      }
      intersects(e, t2) {
        if (!(e instanceof O2))
          throw new TypeError("a Comparator is required");
        if (t2 && typeof t2 == "object" || (t2 = { loose: !!t2, includePrerelease: false }), this.operator === "")
          return this.value === "" || new w2(e.value, t2).test(this.value);
        if (e.operator === "")
          return e.value === "" || new w2(this.value, t2).test(e.semver);
        let r2 = !(this.operator !== ">=" && this.operator !== ">" || e.operator !== ">=" && e.operator !== ">"), o2 = !(this.operator !== "<=" && this.operator !== "<" || e.operator !== "<=" && e.operator !== "<"), s2 = this.semver.version === e.semver.version, a2 = !(this.operator !== ">=" && this.operator !== "<=" || e.operator !== ">=" && e.operator !== "<="), i2 = we(this.semver, "<", e.semver, t2) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), c2 = we(this.semver, ">", e.semver, t2) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
        return r2 || o2 || s2 && a2 || i2 || c2;
      }
    };
    var { re: st, t: ot } = z2;
    var w2 = class {
      constructor(e, t2) {
        if (t2 && typeof t2 == "object" || (t2 = { loose: !!t2, includePrerelease: false }), e instanceof w2)
          return e.loose === !!t2.loose && e.includePrerelease === !!t2.includePrerelease ? e : new w2(e.raw, t2);
        if (e instanceof O2)
          return this.raw = e.value, this.set = [[e]], this.format(), this;
        if (this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((r2) => this.parseRange(r2.trim())).filter((r2) => r2.length), !this.set.length)
          throw new TypeError(`Invalid SemVer Range: ${e}`);
        this.format();
      }
      format() {
        return this.range = this.set.map((e) => e.join(" ").trim()).join("||").trim(), this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(e) {
        let { loose: t2 } = this.options;
        e = e.trim();
        let r2 = t2 ? g2[y2.HYPHENRANGELOOSE] : g2[y2.HYPHENRANGE];
        e = e.replace(r2, hn(this.options.includePrerelease)), m("hyphen replace", e), e = e.replace(g2[y2.COMPARATORTRIM], tn2), m("comparator trim", e, g2[y2.COMPARATORTRIM]), e = (e = (e = e.replace(g2[y2.TILDETRIM], nn2)).replace(g2[y2.CARETTRIM], rn2)).split(/\s+/).join(" ");
        let o2 = t2 ? g2[y2.COMPARATORLOOSE] : g2[y2.COMPARATOR];
        return e.split(" ").map((s2) => sn(s2, this.options)).join(" ").split(/\s+/).map((s2) => mn(s2, this.options)).filter(this.options.loose ? (s2) => !!s2.match(o2) : () => true).map((s2) => new O2(s2, this.options));
      }
      intersects(e, t2) {
        if (!(e instanceof w2))
          throw new TypeError("a Range is required");
        return this.set.some((r2) => it(r2, t2) && e.set.some((o2) => it(o2, t2) && r2.every((s2) => o2.every((a2) => s2.intersects(a2, t2)))));
      }
      test(e) {
        if (!e)
          return false;
        if (typeof e == "string")
          try {
            e = new E2(e, this.options);
          } catch (t2) {
            return false;
          }
        for (let t2 = 0; t2 < this.set.length; t2++)
          if (En(this.set[t2], e, this.options))
            return true;
        return false;
      }
    };
    var { re: g2, t: y2, comparatorTrimReplace: tn2, tildeTrimReplace: nn2, caretTrimReplace: rn2 } = z2;
    var it = (n2, e) => {
      let t2 = true, r2 = n2.slice(), o2 = r2.pop();
      for (; t2 && r2.length; )
        t2 = r2.every((s2) => o2.intersects(s2, e)), o2 = r2.pop();
      return t2;
    };
    var sn = (n2, e) => (m("comp", n2, e), n2 = cn(n2, e), m("caret", n2), n2 = on2(n2, e), m("tildes", n2), n2 = pn(n2, e), m("xrange", n2), n2 = dn(n2, e), m("stars", n2), n2);
    var T = (n2) => !n2 || n2.toLowerCase() === "x" || n2 === "*";
    var on2 = (n2, e) => n2.trim().split(/\s+/).map((t2) => an2(t2, e)).join(" ");
    var an2 = (n2, e) => {
      let t2 = e.loose ? g2[y2.TILDELOOSE] : g2[y2.TILDE];
      return n2.replace(t2, (r2, o2, s2, a2, i2) => {
        let c2;
        return m("tilde", n2, r2, o2, s2, a2, i2), T(o2) ? c2 = "" : T(s2) ? c2 = `>=${o2}.0.0 <${+o2 + 1}.0.0-0` : T(a2) ? c2 = `>=${o2}.${s2}.0 <${o2}.${+s2 + 1}.0-0` : i2 ? (m("replaceTilde pr", i2), c2 = `>=${o2}.${s2}.${a2}-${i2} <${o2}.${+s2 + 1}.0-0`) : c2 = `>=${o2}.${s2}.${a2} <${o2}.${+s2 + 1}.0-0`, m("tilde return", c2), c2;
      });
    };
    var cn = (n2, e) => n2.trim().split(/\s+/).map((t2) => ln(t2, e)).join(" ");
    var ln = (n2, e) => {
      m("caret", n2, e);
      let t2 = e.loose ? g2[y2.CARETLOOSE] : g2[y2.CARET], r2 = e.includePrerelease ? "-0" : "";
      return n2.replace(t2, (o2, s2, a2, i2, c2) => {
        let p2;
        return m("caret", n2, o2, s2, a2, i2, c2), T(s2) ? p2 = "" : T(a2) ? p2 = `>=${s2}.0.0${r2} <${+s2 + 1}.0.0-0` : T(i2) ? p2 = s2 === "0" ? `>=${s2}.${a2}.0${r2} <${s2}.${+a2 + 1}.0-0` : `>=${s2}.${a2}.0${r2} <${+s2 + 1}.0.0-0` : c2 ? (m("replaceCaret pr", c2), p2 = s2 === "0" ? a2 === "0" ? `>=${s2}.${a2}.${i2}-${c2} <${s2}.${a2}.${+i2 + 1}-0` : `>=${s2}.${a2}.${i2}-${c2} <${s2}.${+a2 + 1}.0-0` : `>=${s2}.${a2}.${i2}-${c2} <${+s2 + 1}.0.0-0`) : (m("no pr"), p2 = s2 === "0" ? a2 === "0" ? `>=${s2}.${a2}.${i2}${r2} <${s2}.${a2}.${+i2 + 1}-0` : `>=${s2}.${a2}.${i2}${r2} <${s2}.${+a2 + 1}.0-0` : `>=${s2}.${a2}.${i2} <${+s2 + 1}.0.0-0`), m("caret return", p2), p2;
      });
    };
    var pn = (n2, e) => (m("replaceXRanges", n2, e), n2.split(/\s+/).map((t2) => un2(t2, e)).join(" "));
    var un2 = (n2, e) => {
      n2 = n2.trim();
      let t2 = e.loose ? g2[y2.XRANGELOOSE] : g2[y2.XRANGE];
      return n2.replace(t2, (r2, o2, s2, a2, i2, c2) => {
        m("xRange", n2, r2, o2, s2, a2, i2, c2);
        let p2 = T(s2), l2 = p2 || T(a2), u2 = l2 || T(i2), P2 = u2;
        return o2 === "=" && P2 && (o2 = ""), c2 = e.includePrerelease ? "-0" : "", p2 ? r2 = o2 === ">" || o2 === "<" ? "<0.0.0-0" : "*" : o2 && P2 ? (l2 && (a2 = 0), i2 = 0, o2 === ">" ? (o2 = ">=", l2 ? (s2 = +s2 + 1, a2 = 0, i2 = 0) : (a2 = +a2 + 1, i2 = 0)) : o2 === "<=" && (o2 = "<", l2 ? s2 = +s2 + 1 : a2 = +a2 + 1), o2 === "<" && (c2 = "-0"), r2 = `${o2 + s2}.${a2}.${i2}${c2}`) : l2 ? r2 = `>=${s2}.0.0${c2} <${+s2 + 1}.0.0-0` : u2 && (r2 = `>=${s2}.${a2}.0${c2} <${s2}.${+a2 + 1}.0-0`), m("xRange return", r2), r2;
      });
    };
    var dn = (n2, e) => (m("replaceStars", n2, e), n2.trim().replace(g2[y2.STAR], ""));
    var mn = (n2, e) => (m("replaceGTE0", n2, e), n2.trim().replace(g2[e.includePrerelease ? y2.GTE0PRE : y2.GTE0], ""));
    var hn = (n2) => (e, t2, r2, o2, s2, a2, i2, c2, p2, l2, u2, P2, S2) => `${t2 = T(r2) ? "" : T(o2) ? `>=${r2}.0.0${n2 ? "-0" : ""}` : T(s2) ? `>=${r2}.${o2}.0${n2 ? "-0" : ""}` : a2 ? `>=${t2}` : `>=${t2}${n2 ? "-0" : ""}`} ${c2 = T(p2) ? "" : T(l2) ? `<${+p2 + 1}.0.0-0` : T(u2) ? `<${p2}.${+l2 + 1}.0-0` : P2 ? `<=${p2}.${l2}.${u2}-${P2}` : n2 ? `<${p2}.${l2}.${+u2 + 1}-0` : `<=${c2}`}`.trim();
    var En = (n2, e, t2) => {
      for (let r2 = 0; r2 < n2.length; r2++)
        if (!n2[r2].test(e))
          return false;
      if (e.prerelease.length && !t2.includePrerelease) {
        for (let r2 = 0; r2 < n2.length; r2++)
          if (m(n2[r2].semver), n2[r2].semver !== O2.ANY && n2[r2].semver.prerelease.length > 0) {
            let o2 = n2[r2].semver;
            if (o2.major === e.major && o2.minor === e.minor && o2.patch === e.patch)
              return true;
          }
        return false;
      }
      return true;
    };
    var pt = (n2, e, t2) => {
      try {
        e = new w2(e, t2);
      } catch (r2) {
        return false;
      }
      return e.test(n2);
    };
    var { MAX_LENGTH: fn2 } = Ae;
    var { re: at, t: ct } = z2;
    var yn = (n2, e) => {
      if (e && typeof e == "object" || (e = { loose: !!e, includePrerelease: false }), n2 instanceof E2)
        return n2;
      if (typeof n2 != "string" || n2.length > fn2 || !(e.loose ? at[ct.LOOSE] : at[ct.FULL]).test(n2))
        return null;
      try {
        return new E2(n2, e);
      } catch (t2) {
        return null;
      }
    };
    var gn = yn;
    var { re: le, t: pe } = z2;
    var ut = (n2, e) => {
      if (n2 instanceof E2)
        return n2;
      if (typeof n2 == "number" && (n2 = String(n2)), typeof n2 != "string")
        return null;
      let t2 = null;
      if ((e = e || {}).rtl) {
        let r2;
        for (; (r2 = le[pe.COERCERTL].exec(n2)) && (!t2 || t2.index + t2[0].length !== n2.length); )
          t2 && r2.index + r2[0].length === t2.index + t2[0].length || (t2 = r2), le[pe.COERCERTL].lastIndex = r2.index + r2[1].length + r2[2].length;
        le[pe.COERCERTL].lastIndex = -1;
      } else
        t2 = n2.match(le[pe.COERCE]);
      return t2 === null ? null : gn(`${t2[2]}.${t2[3] || "0"}.${t2[4] || "0"}`, e);
    };
    function Rn(n2) {
      return String.fromCharCode(parseInt(n2.slice(1), 16));
    }
    function Tn(n2) {
      return `%${`00${n2.charCodeAt(0).toString(16)}`.slice(-2)}`;
    }
    function vn(n2) {
      return btoa(encodeURIComponent(n2).replace(/%[0-9A-F]{2}/g, Rn));
    }
    function In(n2) {
      return decodeURIComponent(Array.from(atob(n2), Tn).join(""));
    }
    function Y2(n2) {
      return vn(JSON.stringify(n2));
    }
    function Le(n2) {
      return JSON.parse(In(n2));
    }
    var x2 = require_cjs();
    var ue = require_cjs();
    function A2(n2) {
      return typeof n2 == "undefined";
    }
    function Pn(n2) {
      return n2 === null;
    }
    function de(n2) {
      return Pn(n2) || A2(n2);
    }
    function xn(n2) {
      return de(n2) ? false : !A2(n2.jsonrpc) && !A2(n2.id) && !A2(n2.method) && !A2(n2.params);
    }
    function Se(n2) {
      return de(n2) ? false : !A2(n2.jsonrpc) && !A2(n2.id) && (!A2(n2.result) || !A2(n2.error));
    }
    function bn(n2) {
      return de(n2) ? false : typeof n2 == "string" && Object.values(ue.MagicPayloadMethod).includes(n2);
    }
    function Oe(n2) {
      return de(n2) ? false : typeof n2 == "number" && Object.values(ue.RPCErrorCode).includes(n2);
    }
    function Z2(n2) {
      if (!n2)
        return true;
      for (let e in n2)
        if (Object.hasOwnProperty.call(n2, e))
          return false;
      return true;
    }
    var h2 = {};
    function dt(n2, e) {
      return Object.assign(h2, e), n2;
    }
    var mt = { "magic-sdk": "magic-sdk", "@magic-sdk/react-native": "magic-sdk-rn", "@magic-sdk/react-native-bare": "magic-sdk-rn-bare", "@magic-sdk/react-native-expo": "magic-sdk-rn-expo" };
    var $ = class extends Error {
      constructor(t2, r2) {
        super(`Magic SDK Error: [${t2}] ${r2}`);
        this.code = t2;
        this.rawMessage = r2;
        this.__proto__ = Error;
        Object.setPrototypeOf(this, $.prototype);
      }
    };
    var N2 = class extends Error {
      constructor(t2) {
        super();
        this.__proto__ = Error;
        let r2 = Number(t2 == null ? void 0 : t2.code);
        this.rawMessage = (t2 == null ? void 0 : t2.message) || "Internal error", this.code = Oe(r2) ? r2 : x2.RPCErrorCode.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, this.data = (t2 == null ? void 0 : t2.data) || void 0, Object.setPrototypeOf(this, N2.prototype);
      }
    };
    var D2 = class {
      constructor(e, t2) {
        this.code = e;
        this.rawMessage = t2;
        this.message = `Magic SDK Warning: [${e}] ${t2}`;
      }
      log() {
        console.warn(this.message);
      }
    };
    var k2 = class extends Error {
      constructor(t2, r2, o2, s2) {
        super(`Magic Extension Error (${t2.name}): [${r2}] ${o2}`);
        this.code = r2;
        this.rawMessage = o2;
        this.data = s2;
        this.__proto__ = Error;
        Object.setPrototypeOf(this, k2.prototype);
      }
    };
    var G2 = class {
      constructor(e, t2, r2) {
        this.code = t2;
        this.rawMessage = r2;
        this.message = `Magic Extension Warning (${e.name}): [${t2}] ${r2}`;
      }
      log() {
        console.warn(this.message);
      }
    };
    function Ce() {
      return new $(x2.SDKErrorCode.MissingApiKey, "Please provide an API key that you acquired from the Magic developer dashboard.");
    }
    function $n() {
      return new $(x2.SDKErrorCode.ModalNotReady, "Modal is not ready.");
    }
    function _e() {
      return new $(x2.SDKErrorCode.MalformedResponse, "Response from the Magic iframe is malformed.");
    }
    function De(n2) {
      return new $(x2.SDKErrorCode.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \`Extension.${n2}\` can be accessed. Do not invoke \`Extension.${n2}\` inside an extension constructor.`);
    }
    function ke(n2) {
      let e = `Some extensions are incompatible with \`${h2.sdkName}@${h2.version}\`:`;
      return n2.filter((t2) => typeof t2.compat != "undefined" && t2.compat !== null).forEach((t2) => {
        let r2 = t2.compat[h2.sdkName];
        typeof r2 == "string" ? e += `
  - Extension \`${t2.name}\` supports version(s) \`${r2}\`` : r2 || (e += `
  - Extension \`${t2.name}\` does not support ${h2.platform} environments.`);
      }), new $(x2.SDKErrorCode.IncompatibleExtensions, e);
    }
    function qe(n2) {
      let e = (t2) => {
        let r2 = t2 + 1, o2 = r2 % 10, s2 = r2 % 100;
        return o2 === 1 && s2 !== 11 ? `${r2}st` : o2 === 2 && s2 !== 12 ? `${r2}nd` : o2 === 3 && s2 !== 13 ? `${r2}rd` : `${r2}th`;
      };
      return new $(x2.SDKErrorCode.InvalidArgument, `Invalid ${e(n2.argument)} argument given to \`${n2.procedure}\`.
  Expected: \`${n2.expected}\`
  Received: \`${n2.received}\``);
    }
    function Nn() {
      return new D2(x2.SDKWarningCode.DuplicateIframe, "Duplicate iframes found.");
    }
    function Je() {
      return new D2(x2.SDKWarningCode.SyncWeb3Method, "Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.");
    }
    function Ue() {
      return new D2(x2.SDKWarningCode.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \`endpoint\` parameter SHOULD NOT be provided. The Magic \`<iframe>\` is automatically wrapped by a WebView pointed at \`${h2.defaultEndpoint}\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`);
    }
    function Mn(n2) {
      let { method: e, removalVersions: t2, useInstead: r2 } = n2, o2 = t2[h2.sdkName], s2 = r2 ? ` Use \`${r2}\` instead.` : "", a2 = `\`${e}\` will be removed from \`${h2.sdkName}\` in version \`${o2}\`.${s2}`;
      return new D2(x2.SDKWarningCode.DeprecationNotice, a2);
    }
    var L2 = require_cjs();
    var F2 = require_cjs();
    function* wn() {
      let n2 = 0;
      for (; ; )
        n2 < Number.MAX_SAFE_INTEGER ? yield ++n2 : n2 = 0;
    }
    var An = wn();
    function me() {
      return An.next().value;
    }
    var ht = Symbol("Payload pre-processed by Magic SDK");
    function Et(n2) {
      return Object.defineProperty(n2, ht, { value: true, enumerable: false }), n2;
    }
    function Ln(n2) {
      return !!n2[ht];
    }
    function q2(n2) {
      var e, t2, r2;
      return Ln(n2) || (n2.jsonrpc = (e = n2.jsonrpc) != null ? e : "2.0", n2.id = me(), n2.method = (t2 = n2.method) != null ? t2 : "noop", n2.params = (r2 = n2.params) != null ? r2 : [], Et(n2)), n2;
    }
    function d2(n2, e = []) {
      return Et({ params: e, method: n2, jsonrpc: "2.0", id: me() });
    }
    var C = class {
      constructor(e) {
        e instanceof C ? (this._jsonrpc = e.payload.jsonrpc, this._id = e.payload.id, this._result = e.payload.result, this._error = e.payload.error) : Se(e) ? (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = e.result, this._error = e.error) : (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = void 0, this._error = void 0);
      }
      applyError(e) {
        return this._error = e, this;
      }
      applyResult(e) {
        return this._result = e, this;
      }
      get hasError() {
        return typeof this._error != "undefined" && this._error !== null;
      }
      get hasResult() {
        return typeof this._result != "undefined";
      }
      get payload() {
        return { jsonrpc: this._jsonrpc, id: this._id, result: this._result, error: this._error };
      }
    };
    var gt = Ct(yt());
    var Ee = class extends gt.default {
    };
    function ee() {
      let n2 = new Ee();
      return { emitter: n2, createChainingEmitterMethod: (r2, o2) => (...s2) => (n2[r2].apply(n2, s2), o2), createBoundEmitterMethod: (r2) => (...o2) => n2[r2].apply(n2, o2) };
    }
    var Rt = Symbol("isPromiEvent");
    function Fe(n2) {
      return !!n2[Rt];
    }
    function te(n2) {
      let e = fe(n2), { createBoundEmitterMethod: t2, createChainingEmitterMethod: r2 } = ee(), o2 = Symbol("Promise.then"), s2 = Symbol("Promise.catch"), a2 = Symbol("Promise.finally"), i2 = (l2, u2) => (...P2) => {
        let S2 = u2[l2].apply(u2, P2);
        return c2(S2);
      }, c2 = (l2) => Object.assign(l2, { [Rt]: true, [o2]: l2[o2] || l2.then, [s2]: l2[s2] || l2.catch, [a2]: l2[a2] || l2.finally, then: i2(o2, l2), catch: i2(s2, l2), finally: i2(a2, l2), on: r2("on", l2), once: r2("once", l2), addListener: r2("addListener", l2), off: r2("off", l2), removeListener: r2("removeListener", l2), removeAllListeners: r2("removeAllListeners", l2), emit: t2("emit"), eventNames: t2("eventNames"), listeners: t2("listeners"), listenerCount: t2("listenerCount") }), p2 = c2(e.then((l2) => (p2.emit("done", l2), p2.emit("settled"), l2), (l2) => {
        throw p2.emit("error", l2), p2.emit("settled"), l2;
      }));
      return p2;
    }
    function fe(n2) {
      return new Promise((e, t2) => {
        let r2 = n2(e, t2);
        Promise.resolve(r2).catch(t2);
      });
    }
    var I2 = class {
      constructor(e) {
        this.sdk = e;
      }
      get overlay() {
        return this.sdk.overlay;
      }
      request(e) {
        let t2 = this.overlay.post(F2.MagicOutgoingWindowMessage.MAGIC_HANDLE_REQUEST, q2(e)), r2 = te((s2, a2) => {
          t2.then((i2) => {
            if (o2(), i2.hasError)
              a2(new N2(i2.payload.error));
            else if (i2.hasResult)
              s2(i2.payload.result);
            else
              throw _e();
          }).catch((i2) => {
            o2(), a2(i2);
          });
        }), o2 = this.overlay.on(F2.MagicIncomingWindowMessage.MAGIC_HANDLE_EVENT, (s2) => {
          var i2;
          let { response: a2 } = s2.data;
          if (a2.id === e.id && ((i2 = a2.result) == null ? void 0 : i2.event)) {
            let { event: c2, params: p2 = [] } = a2.result;
            r2.emit(c2, ...p2);
          }
        });
        return r2;
      }
      createIntermediaryEvent(e, t2) {
        return (o2) => {
          let s2 = d2(F2.MagicPayloadMethod.IntermediaryEvent, [{ payloadId: t2, eventType: e, args: o2 }]);
          this.request(s2);
        };
      }
    };
    var ye = class extends I2 {
      loginWithMagicLink(e) {
        let { email: t2, showUI: r2 = true, redirectURI: o2 } = e, s2 = d2(this.sdk.testMode ? L2.MagicPayloadMethod.LoginWithMagicLinkTestMode : L2.MagicPayloadMethod.LoginWithMagicLink, [{ email: t2, showUI: r2, redirectURI: o2 }]);
        return this.request(s2);
      }
      loginWithSMS(e) {
        let { phoneNumber: t2 } = e, r2 = d2(this.sdk.testMode ? L2.MagicPayloadMethod.LoginWithSmsTestMode : L2.MagicPayloadMethod.LoginWithSms, [{ phoneNumber: t2, showUI: true }]);
        return this.request(r2);
      }
      loginWithEmailOTP(e) {
        let { email: t2, showUI: r2 } = e, o2 = d2(this.sdk.testMode ? L2.MagicPayloadMethod.LoginWithEmailOTPTestMode : L2.MagicPayloadMethod.LoginWithEmailOTP, [{ email: t2, showUI: r2 }]);
        if (!r2) {
          let s2 = this.request(o2);
          return s2 && s2.on("otp-input-sent", (a2) => {
            this.createIntermediaryEvent("verify-email-otp", o2.id)(a2);
          }), s2;
        }
        return this.request(o2);
      }
      loginWithCredential(e) {
        let t2 = e != null ? e : "";
        if (!e && h2.platform === "web") {
          t2 = window.location.search;
          let o2 = window.location.origin + window.location.pathname;
          window.history.replaceState(null, "", o2);
        }
        let r2 = d2(this.sdk.testMode ? L2.MagicPayloadMethod.LoginWithCredentialTestMode : L2.MagicPayloadMethod.LoginWithCredential, [t2]);
        return this.request(r2);
      }
    };
    var f3 = require_cjs();
    var j2 = {};
    Ze(j2, { clear: () => Cn, getItem: () => J, iterate: () => qn, key: () => Dn, keys: () => kn, length: () => _n, removeItem: () => Re, setItem: () => K });
    var ge;
    function _2(n2) {
      return (...e) => b2(this, null, function* () {
        return ge || (ge = yield h2.configureStorage()), yield ge.ready(), ge[n2](...e);
      });
    }
    var J = _2("getItem");
    var K = _2("setItem");
    var Re = _2("removeItem");
    var Cn = _2("clear");
    var _n = _2("length");
    var Dn = _2("key");
    var kn = _2("keys");
    var qn = _2("iterate");
    function Ke() {
      let n2 = window.crypto.getRandomValues(new Uint8Array(16));
      n2[6] = n2[6] & 15 | 64, n2[8] = n2[8] & 191 | 128;
      let e = "";
      return e += n2[0].toString(16), e += n2[1].toString(16), e += n2[2].toString(16), e += n2[3].toString(16), e += "-", e += n2[4].toString(16), e += n2[5].toString(16), e += "-", e += n2[6].toString(16), e += n2[7].toString(16), e += "-", e += n2[8].toString(16), e += n2[9].toString(16), e += "-", e += n2[10].toString(16), e += n2[11].toString(16), e += n2[12].toString(16), e += n2[13].toString(16), e += n2[14].toString(16), e += n2[15].toString(16), e;
    }
    var Te = "STORE_KEY_PRIVATE_KEY";
    var ne = "STORE_KEY_PUBLIC_JWK";
    var je = "ECDSA";
    var vt = "P-256";
    var Jn = { name: je, namedCurve: vt };
    var Un = { name: je, namedCurve: vt };
    function re() {
      Re(ne), Re(Te);
    }
    function We() {
      return b2(this, null, function* () {
        let n2 = yield Gn();
        if (!n2) {
          console.info("unable to create public key or webcrypto is unsupported");
          return;
        }
        let { subtle: e } = window.crypto, t2 = yield J(Te);
        if (!t2 || !e) {
          console.info("unable to find private key or webcrypto unsupported");
          return;
        }
        let r2 = { iat: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), jti: Ke() }, o2 = { typ: "dpop+jwt", alg: "ES256", jwk: n2 }, s2 = { protected: Tt(JSON.stringify(o2)), claims: Tt(JSON.stringify(r2)) }, a2 = jn(`${s2.protected}.${s2.claims}`), i2 = { name: je, hash: { name: "SHA-256" } }, c2 = Xn(new Uint8Array(yield e.sign(i2, t2, a2)));
        return `${s2.protected}.${s2.claims}.${c2}`;
      });
    }
    function Gn() {
      return b2(this, null, function* () {
        if (!Kn()) {
          console.info("webcrypto is not supported");
          return;
        }
        return (yield J(ne)) || (yield Fn()), J(ne);
      });
    }
    function Fn() {
      return b2(this, null, function* () {
        let n2 = null, { subtle: e } = window.crypto, t2 = yield e.generateKey(Jn, true, ["sign"]), r2 = yield e.exportKey("jwk", t2.privateKey);
        n2 = yield e.exportKey("jwk", t2.publicKey);
        let o2 = yield e.importKey("jwk", r2, Un, false, ["sign"]);
        yield K(Te, o2), yield K(ne, n2);
      });
    }
    function Kn() {
      let n2 = typeof window != "undefined" && !!window.crypto, e = n2 && !!window.crypto.subtle;
      return n2 && e;
    }
    function Tt(n2) {
      return It(Wn(n2));
    }
    function jn(n2) {
      return new TextEncoder().encode(n2);
    }
    function It(n2) {
      return btoa(n2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/g, "");
    }
    function Wn(n2) {
      return encodeURIComponent(n2).replace(/%([0-9A-F]{2})/g, (t2, r2) => String.fromCharCode(parseInt(r2, 16)));
    }
    function Xn(n2) {
      let e = "";
      return n2.forEach((t2) => {
        e += String.fromCharCode(t2);
      }), It(e);
    }
    var ve = class extends I2 {
      getIdToken(e) {
        let t2 = d2(this.sdk.testMode ? f3.MagicPayloadMethod.GetIdTokenTestMode : f3.MagicPayloadMethod.GetIdToken, [e]);
        return this.request(t2);
      }
      generateIdToken(e) {
        let t2 = d2(this.sdk.testMode ? f3.MagicPayloadMethod.GenerateIdTokenTestMode : f3.MagicPayloadMethod.GenerateIdToken, [e]);
        return this.request(t2);
      }
      getMetadata() {
        let e = d2(this.sdk.testMode ? f3.MagicPayloadMethod.GetMetadataTestMode : f3.MagicPayloadMethod.GetMetadata);
        return this.request(e);
      }
      updateEmail(e) {
        let { email: t2, showUI: r2 = true } = e, o2 = d2(this.sdk.testMode ? f3.MagicPayloadMethod.UpdateEmailTestMode : f3.MagicPayloadMethod.UpdateEmail, [{ email: t2, showUI: r2 }]);
        return this.request(o2);
      }
      isLoggedIn() {
        let e = d2(this.sdk.testMode ? f3.MagicPayloadMethod.IsLoggedInTestMode : f3.MagicPayloadMethod.IsLoggedIn);
        return this.request(e);
      }
      logout() {
        re();
        let e = d2(this.sdk.testMode ? f3.MagicPayloadMethod.LogoutTestMode : f3.MagicPayloadMethod.Logout);
        return this.request(e);
      }
      showSettings() {
        let e = d2(this.sdk.testMode ? f3.MagicPayloadMethod.UserSettingsTestMode : f3.MagicPayloadMethod.UserSettings);
        return this.request(e);
      }
      updatePhoneNumber() {
        let e = d2(this.sdk.testMode ? f3.MagicPayloadMethod.UpdatePhoneNumberTestMode : f3.MagicPayloadMethod.UpdatePhoneNumber);
        return this.request(e);
      }
      recoverAccount(e) {
        let t2 = d2(this.sdk.testMode ? f3.MagicPayloadMethod.RecoverAccountTestMode : f3.MagicPayloadMethod.RecoverAccount, [e]);
        return this.request(t2);
      }
    };
    var W2 = require_cjs();
    var Ie = class extends I2 {
      connectWithUI() {
        let e = d2(W2.MagicPayloadMethod.RequestAccounts);
        return this.request(e);
      }
      showUI() {
        let e = d2(W2.MagicPayloadMethod.ShowUI);
        return this.request(e);
      }
      getInfo() {
        let e = d2(W2.MagicPayloadMethod.GetInfo);
        return this.request(e);
      }
      requestUserInfoWithUI(e) {
        let t2 = d2(W2.MagicPayloadMethod.RequestUserInfoWithUI, e ? [e] : []);
        return this.request(t2);
      }
      disconnect() {
        re();
        let e = d2(W2.MagicPayloadMethod.Disconnect);
        return this.request(e);
      }
    };
    var Xe = require_cjs();
    var { createBoundEmitterMethod: Pe, createChainingEmitterMethod: X2 } = ee();
    var xe = class extends I2 {
      constructor() {
        super(...arguments);
        this.isMagic = true;
        this.on = X2("on", this);
        this.once = X2("once", this);
        this.addListener = X2("addListener", this);
        this.off = X2("off", this);
        this.removeListener = X2("removeListener", this);
        this.removeAllListeners = X2("removeAllListeners", this);
        this.emit = Pe("emit");
        this.eventNames = Pe("eventNames");
        this.listeners = Pe("listeners");
        this.listenerCount = Pe("listenerCount");
      }
      sendAsync(t2, r2) {
        if (!r2)
          throw qe({ procedure: "Magic.rpcProvider.sendAsync", argument: 1, expected: "function", received: r2 === null ? "null" : typeof r2 });
        if (Array.isArray(t2))
          this.overlay.post(Xe.MagicOutgoingWindowMessage.MAGIC_HANDLE_REQUEST, t2.map((o2) => {
            let s2 = q2(o2);
            return this.prefixPayloadMethodForTestMode(s2), s2;
          })).then((o2) => {
            r2(null, o2.map((s2) => Ye(ae({}, s2.payload), { error: s2.hasError ? new N2(s2.payload.error) : null })));
          });
        else {
          let o2 = q2(t2);
          this.prefixPayloadMethodForTestMode(o2), this.overlay.post(Xe.MagicOutgoingWindowMessage.MAGIC_HANDLE_REQUEST, o2).then((s2) => {
            r2(s2.hasError ? new N2(s2.payload.error) : null, s2.payload);
          });
        }
      }
      send(t2, r2) {
        if (typeof t2 == "string") {
          let s2 = d2(t2, Array.isArray(r2) ? r2 : []);
          return this.request(s2);
        }
        if (Array.isArray(t2) || !!r2) {
          this.sendAsync(t2, r2);
          return;
        }
        let o2 = Je();
        return o2.log(), new C(t2).applyError({ code: -32603, message: o2.rawMessage }).payload;
      }
      enable() {
        let t2 = d2("eth_accounts");
        return this.request(t2);
      }
      request(t2) {
        return this.prefixPayloadMethodForTestMode(t2), super.request(t2);
      }
      prefixPayloadMethodForTestMode(t2) {
        let r2 = "testMode/eth/";
        this.sdk.testMode && (t2.method = `${r2}${t2.method}`);
      }
    };
    function be(n2, e) {
      return e ? new URL(n2, e) : new URL(n2);
    }
    var Pt = ["request", "overlay", "sdk"];
    function Bn(n2) {
      let e = Object.getPrototypeOf(n2), t2 = [e];
      for (; e !== I2.prototype; )
        e = Object.getPrototypeOf(e), t2.push(e);
      return t2;
    }
    var $e = class extends I2 {
      constructor() {
        super(void 0);
        this.__sdk_access_field_descriptors__ = /* @__PURE__ */ new Map();
        this.__is_initialized__ = false;
        this.utils = { createPromiEvent: te, isPromiEvent: Fe, encodeJSON: Y2, decodeJSON: Le, createJsonRpcRequestPayload: d2, standardizeJsonRpcRequestPayload: q2, storage: j2 };
        let t2 = [this, ...Bn(this)];
        Pt.forEach((r2) => {
          let o2 = t2.map((c2) => Object.getOwnPropertyDescriptor(c2, r2)), s2 = o2.findIndex((c2) => !!c2), a2 = s2 > 0, i2 = o2[s2];
          i2 && (this.__sdk_access_field_descriptors__.set(r2, { descriptor: i2, isPrototypeField: a2 }), Object.defineProperty(this, r2, { configurable: true, get: () => {
            throw De(r2);
          } }));
        });
      }
      init(t2) {
        this.__is_initialized__ || (Pt.forEach((r2) => {
          if (this.__sdk_access_field_descriptors__.has(r2)) {
            let { descriptor: o2, isPrototypeField: s2 } = this.__sdk_access_field_descriptors__.get(r2);
            s2 ? delete this[r2] : Object.defineProperty(this, r2, o2);
          }
        }), this.sdk = t2, this.__is_initialized__ = true);
      }
      createDeprecationWarning(t2) {
        let { method: r2, removalVersion: o2, useInstead: s2 } = t2, a2 = s2 ? ` Use \`${s2}\` instead.` : "", i2 = `\`${r2}\` will be removed from this Extension in version \`${o2}\`.${a2}`;
        return new G2(this, "DEPRECATION_NOTICE", i2);
      }
      createWarning(t2, r2) {
        return new G2(this, t2, r2);
      }
      createError(t2, r2, o2) {
        return new k2(this, t2, r2, o2);
      }
    };
    var Be = class extends $e {
    };
    var M2 = class extends $e {
    };
    M2.Internal = Be, M2.Anonymous = "anonymous extension";
    var xt = require_cjs();
    var Ne = class extends I2 {
      purchase(e) {
        let t2 = d2(xt.MagicPayloadMethod.NFTPurchase, [e]);
        return this.request(t2);
      }
    };
    function bt(n2) {
      return n2.compat && n2.compat[h2.sdkName] != null ? typeof n2.compat[h2.sdkName] == "string" ? pt(ut(h2.version), n2.compat[h2.sdkName]) : !!n2.compat[h2.sdkName] : true;
    }
    function Hn(n2) {
      var o2;
      let e = (o2 = n2 == null ? void 0 : n2.extensions) != null ? o2 : [], t2 = {}, r2 = [];
      if (Array.isArray(e) ? e.forEach((s2) => {
        bt(s2) ? (s2.init(this), (s2.name || s2.name !== M2.Anonymous) && (this[s2.name] = s2), s2 instanceof M2.Internal && (Z2(s2.config) || (t2[s2.name] = s2.config))) : r2.push(s2);
      }) : Object.keys(e).forEach((s2) => {
        if (bt(e[s2])) {
          e[s2].init(this);
          let a2 = e[s2];
          this[s2] = a2, a2 instanceof M2.Internal && (Z2(a2.config) || (t2[e[s2].name] = a2.config));
        } else
          r2.push(e[s2]);
      }), r2.length)
        throw ke(r2);
      return t2;
    }
    var oe = class {
      constructor(e, t2) {
        this.apiKey = e;
        var a2;
        if (!e)
          throw Ce();
        h2.platform === "react-native" && (t2 == null ? void 0 : t2.endpoint) && Ue().log();
        let { defaultEndpoint: r2, version: o2 } = h2;
        this.testMode = !!(t2 != null && t2.testMode), this.endpoint = be((a2 = t2 == null ? void 0 : t2.endpoint) != null ? a2 : r2).origin, this.auth = new ye(this), this.user = new ve(this), this.wallet = new Ie(this), this.nft = new Ne(this), this.rpcProvider = new xe(this);
        let s2 = Hn.call(this, t2);
        this.parameters = Y2(ae({ API_KEY: this.apiKey, DOMAIN_ORIGIN: window.location ? window.location.origin : "", ETH_NETWORK: t2 == null ? void 0 : t2.network, host: be(this.endpoint).host, sdk: mt[h2.sdkName], version: o2, ext: Z2(s2) ? void 0 : s2, locale: (t2 == null ? void 0 : t2.locale) || "en_US" }, h2.bundleId ? { bundleId: h2.bundleId } : {}));
      }
      get overlay() {
        if (!oe.__overlays__.has(this.parameters)) {
          let e = new h2.ViewController(this.endpoint, this.parameters);
          e.init(), oe.__overlays__.set(this.parameters, e);
        }
        return oe.__overlays__.get(this.parameters);
      }
      preload() {
        return b2(this, null, function* () {
          yield this.overlay.ready;
        });
      }
    };
    var se = oe;
    se.__overlays__ = /* @__PURE__ */ new Map();
    var ie = require_cjs();
    function Vn(n2, e) {
      return e && Array.isArray(n2) ? n2.find((t2) => t2.id === e) : n2;
    }
    function zn(n2, e) {
      var o2;
      let t2 = (o2 = e.data.response) == null ? void 0 : o2.id, r2 = Vn(n2, t2);
      if (t2 && r2) {
        let s2 = new C(r2).applyResult(e.data.response.result).applyError(e.data.response.error);
        return { id: t2, response: s2 };
      }
      return {};
    }
    function Yn(n2, e) {
      return b2(this, null, function* () {
        let t2 = yield J("rt"), r2;
        if (h2.platform === "web")
          try {
            r2 = yield We();
          } catch (o2) {
            console.error("webcrypto error", o2);
          }
        return r2 ? t2 ? { msgType: n2, payload: e, jwt: r2, rt: t2 } : { msgType: n2, payload: e, jwt: r2 } : { msgType: n2, payload: e };
      });
    }
    function Zn(n2) {
      return b2(this, null, function* () {
        !n2.data.rt || (yield K("rt", n2.data.rt));
      });
    }
    var Me = class {
      constructor(e, t2) {
        this.endpoint = e;
        this.parameters = t2;
        this.messageHandlers = /* @__PURE__ */ new Set();
        this.ready = this.waitForReady(), this.listen();
      }
      post(e, t2) {
        return b2(this, null, function* () {
          return fe((r2) => b2(this, null, function* () {
            yield this.ready;
            let o2 = [], s2 = Array.isArray(t2) ? t2.map((p2) => p2.id) : [], a2 = yield Yn(`${e}-${this.parameters}`, t2);
            yield this._post(a2);
            let i2 = (p2) => (l2) => {
              let { id: u2, response: P2 } = zn(t2, l2);
              Zn(l2), u2 && P2 && Array.isArray(t2) && s2.includes(u2) ? (o2.push(P2), o2.length === t2.length && (p2(), r2(o2))) : u2 && P2 && !Array.isArray(t2) && u2 === t2.id && (p2(), r2(P2));
            }, c2 = this.on(ie.MagicIncomingWindowMessage.MAGIC_HANDLE_RESPONSE, i2(() => c2()));
          }));
        });
      }
      on(e, t2) {
        let r2 = t2.bind(window), o2 = (s2) => {
          s2.data.msgType === `${e}-${this.parameters}` && r2(s2);
        };
        return this.messageHandlers.add(o2), () => this.messageHandlers.delete(o2);
      }
      waitForReady() {
        return new Promise((e) => {
          this.on(ie.MagicIncomingWindowMessage.MAGIC_OVERLAY_READY, () => e());
        });
      }
      listen() {
        this.on(ie.MagicIncomingWindowMessage.MAGIC_HIDE_OVERLAY, () => {
          this.hideOverlay();
        }), this.on(ie.MagicIncomingWindowMessage.MAGIC_SHOW_OVERLAY, () => {
          this.showOverlay();
        });
      }
    };
  }
});

// node_modules/@magic-sdk/commons/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@magic-sdk/commons/dist/cjs/index.js"(exports, module) {
    "use strict";
    var e = Object.defineProperty;
    var x2 = Object.getOwnPropertyDescriptor;
    var c2 = Object.getOwnPropertyNames;
    var M2 = Object.prototype.hasOwnProperty;
    var m = (n2, i2) => {
      for (var o2 in i2)
        e(n2, o2, { get: i2[o2], enumerable: true });
    };
    var E2 = (n2, i2, o2, g2) => {
      if (i2 && typeof i2 == "object" || typeof i2 == "function")
        for (let a2 of c2(i2))
          !M2.call(n2, a2) && a2 !== o2 && e(n2, a2, { get: () => i2[a2], enumerable: !(g2 = x2(i2, a2)) || g2.enumerable });
      return n2;
    };
    var s2 = (n2, i2, o2) => (E2(n2, i2, "default"), o2 && E2(o2, i2, "default"));
    var p2 = (n2) => E2(e({}, "__esModule", { value: true }), n2);
    var t2 = {};
    m(t2, { Extension: () => r2.Extension, ExtensionError: () => r2.MagicExtensionError, ExtensionWarning: () => r2.MagicExtensionWarning, RPCError: () => r2.MagicRPCError, SDKError: () => r2.MagicSDKError, SDKWarning: () => r2.MagicSDKWarning, isPromiEvent: () => r2.isPromiEvent });
    module.exports = p2(t2);
    var r2 = require_cjs2();
    s2(t2, require_cjs(), module.exports);
  }
});

// node_modules/magic-sdk/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/magic-sdk/dist/cjs/index.js"(exports, module) {
    "use strict";
    var et = Object.create;
    var be = Object.defineProperty;
    var rt = Object.getOwnPropertyDescriptor;
    var tt = Object.getOwnPropertyNames;
    var nt = Object.getPrototypeOf;
    var ot = Object.prototype.hasOwnProperty;
    var er = (p2, E2) => () => (E2 || p2((E2 = { exports: {} }).exports, E2), E2.exports);
    var it = (p2, E2) => {
      for (var I2 in E2)
        be(p2, I2, { get: E2[I2], enumerable: true });
    };
    var ge = (p2, E2, I2, L2) => {
      if (E2 && typeof E2 == "object" || typeof E2 == "function")
        for (let D2 of tt(E2))
          !ot.call(p2, D2) && D2 !== I2 && be(p2, D2, { get: () => E2[D2], enumerable: !(L2 = rt(E2, D2)) || L2.enumerable });
      return p2;
    };
    var ne = (p2, E2, I2) => (ge(p2, E2, "default"), I2 && ge(I2, E2, "default"));
    var rr = (p2, E2, I2) => (I2 = p2 != null ? et(nt(p2)) : {}, ge(E2 || !p2 || !p2.__esModule ? be(I2, "default", { value: p2, enumerable: true }) : I2, p2));
    var at = (p2) => ge(be({}, "__esModule", { value: true }), p2);
    var de = (p2, E2, I2) => new Promise((L2, D2) => {
      var X2 = (A2) => {
        try {
          Y2(I2.next(A2));
        } catch (M2) {
          D2(M2);
        }
      }, P2 = (A2) => {
        try {
          Y2(I2.throw(A2));
        } catch (M2) {
          D2(M2);
        }
      }, Y2 = (A2) => A2.done ? L2(A2.value) : Promise.resolve(A2.value).then(X2, P2);
      Y2((I2 = I2.apply(p2, E2)).next());
    });
    var nr = er((tr, Ce) => {
      (function(p2) {
        if (typeof tr == "object" && typeof Ce < "u")
          Ce.exports = p2();
        else if (typeof define == "function" && define.amd)
          define([], p2);
        else {
          var E2;
          typeof window < "u" ? E2 = window : typeof global < "u" ? E2 = global : typeof self < "u" ? E2 = self : E2 = this, E2.localforage = p2();
        }
      })(function() {
        var p2, E2, I2;
        return function L2(D2, X2, P2) {
          function Y2(H2, $) {
            if (!X2[H2]) {
              if (!D2[H2]) {
                var m = typeof __require == "function" && __require;
                if (!$ && m)
                  return m(H2, true);
                if (A2)
                  return A2(H2, true);
                var _2 = new Error("Cannot find module '" + H2 + "'");
                throw _2.code = "MODULE_NOT_FOUND", _2;
              }
              var B2 = X2[H2] = { exports: {} };
              D2[H2][0].call(B2.exports, function(z2) {
                var Z2 = D2[H2][1][z2];
                return Y2(Z2 || z2);
              }, B2, B2.exports, L2, D2, X2, P2);
            }
            return X2[H2].exports;
          }
          for (var A2 = typeof __require == "function" && __require, M2 = 0; M2 < P2.length; M2++)
            Y2(P2[M2]);
          return Y2;
        }({ 1: [function(L2, D2, X2) {
          (function(P2) {
            "use strict";
            var Y2 = P2.MutationObserver || P2.WebKitMutationObserver, A2;
            if (Y2) {
              var M2 = 0, H2 = new Y2(z2), $ = P2.document.createTextNode("");
              H2.observe($, { characterData: true }), A2 = function() {
                $.data = M2 = ++M2 % 2;
              };
            } else if (!P2.setImmediate && typeof P2.MessageChannel < "u") {
              var m = new P2.MessageChannel();
              m.port1.onmessage = z2, A2 = function() {
                m.port2.postMessage(0);
              };
            } else
              "document" in P2 && "onreadystatechange" in P2.document.createElement("script") ? A2 = function() {
                var F2 = P2.document.createElement("script");
                F2.onreadystatechange = function() {
                  z2(), F2.onreadystatechange = null, F2.parentNode.removeChild(F2), F2 = null;
                }, P2.document.documentElement.appendChild(F2);
              } : A2 = function() {
                setTimeout(z2, 0);
              };
            var _2, B2 = [];
            function z2() {
              _2 = true;
              for (var F2, k2, U2 = B2.length; U2; ) {
                for (k2 = B2, B2 = [], F2 = -1; ++F2 < U2; )
                  k2[F2]();
                U2 = B2.length;
              }
              _2 = false;
            }
            D2.exports = Z2;
            function Z2(F2) {
              B2.push(F2) === 1 && !_2 && A2();
            }
          }).call(this, typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {});
        }, {}], 2: [function(L2, D2, X2) {
          "use strict";
          var P2 = L2(1);
          function Y2() {
          }
          var A2 = {}, M2 = ["REJECTED"], H2 = ["FULFILLED"], $ = ["PENDING"];
          D2.exports = m;
          function m(h2) {
            if (typeof h2 != "function")
              throw new TypeError("resolver must be a function");
            this.state = $, this.queue = [], this.outcome = void 0, h2 !== Y2 && Z2(this, h2);
          }
          m.prototype.catch = function(h2) {
            return this.then(null, h2);
          }, m.prototype.then = function(h2, N2) {
            if (typeof h2 != "function" && this.state === H2 || typeof N2 != "function" && this.state === M2)
              return this;
            var S2 = new this.constructor(Y2);
            if (this.state !== $) {
              var O2 = this.state === H2 ? h2 : N2;
              B2(S2, O2, this.outcome);
            } else
              this.queue.push(new _2(S2, h2, N2));
            return S2;
          };
          function _2(h2, N2, S2) {
            this.promise = h2, typeof N2 == "function" && (this.onFulfilled = N2, this.callFulfilled = this.otherCallFulfilled), typeof S2 == "function" && (this.onRejected = S2, this.callRejected = this.otherCallRejected);
          }
          _2.prototype.callFulfilled = function(h2) {
            A2.resolve(this.promise, h2);
          }, _2.prototype.otherCallFulfilled = function(h2) {
            B2(this.promise, this.onFulfilled, h2);
          }, _2.prototype.callRejected = function(h2) {
            A2.reject(this.promise, h2);
          }, _2.prototype.otherCallRejected = function(h2) {
            B2(this.promise, this.onRejected, h2);
          };
          function B2(h2, N2, S2) {
            P2(function() {
              var O2;
              try {
                O2 = N2(S2);
              } catch (V) {
                return A2.reject(h2, V);
              }
              O2 === h2 ? A2.reject(h2, new TypeError("Cannot resolve promise with itself")) : A2.resolve(h2, O2);
            });
          }
          A2.resolve = function(h2, N2) {
            var S2 = F2(z2, N2);
            if (S2.status === "error")
              return A2.reject(h2, S2.value);
            var O2 = S2.value;
            if (O2)
              Z2(h2, O2);
            else {
              h2.state = H2, h2.outcome = N2;
              for (var V = -1, j2 = h2.queue.length; ++V < j2; )
                h2.queue[V].callFulfilled(N2);
            }
            return h2;
          }, A2.reject = function(h2, N2) {
            h2.state = M2, h2.outcome = N2;
            for (var S2 = -1, O2 = h2.queue.length; ++S2 < O2; )
              h2.queue[S2].callRejected(N2);
            return h2;
          };
          function z2(h2) {
            var N2 = h2 && h2.then;
            if (h2 && (typeof h2 == "object" || typeof h2 == "function") && typeof N2 == "function")
              return function() {
                N2.apply(h2, arguments);
              };
          }
          function Z2(h2, N2) {
            var S2 = false;
            function O2(J) {
              S2 || (S2 = true, A2.reject(h2, J));
            }
            function V(J) {
              S2 || (S2 = true, A2.resolve(h2, J));
            }
            function j2() {
              N2(V, O2);
            }
            var Q2 = F2(j2);
            Q2.status === "error" && O2(Q2.value);
          }
          function F2(h2, N2) {
            var S2 = {};
            try {
              S2.value = h2(N2), S2.status = "success";
            } catch (O2) {
              S2.status = "error", S2.value = O2;
            }
            return S2;
          }
          m.resolve = k2;
          function k2(h2) {
            return h2 instanceof this ? h2 : A2.resolve(new this(Y2), h2);
          }
          m.reject = U2;
          function U2(h2) {
            var N2 = new this(Y2);
            return A2.reject(N2, h2);
          }
          m.all = se;
          function se(h2) {
            var N2 = this;
            if (Object.prototype.toString.call(h2) !== "[object Array]")
              return this.reject(new TypeError("must be an array"));
            var S2 = h2.length, O2 = false;
            if (!S2)
              return this.resolve([]);
            for (var V = new Array(S2), j2 = 0, Q2 = -1, J = new this(Y2); ++Q2 < S2; )
              ee(h2[Q2], Q2);
            return J;
            function ee(fe, a2) {
              N2.resolve(fe).then(s2, function(v2) {
                O2 || (O2 = true, A2.reject(J, v2));
              });
              function s2(v2) {
                V[a2] = v2, ++j2 === S2 && !O2 && (O2 = true, A2.resolve(J, V));
              }
            }
          }
          m.race = te;
          function te(h2) {
            var N2 = this;
            if (Object.prototype.toString.call(h2) !== "[object Array]")
              return this.reject(new TypeError("must be an array"));
            var S2 = h2.length, O2 = false;
            if (!S2)
              return this.resolve([]);
            for (var V = -1, j2 = new this(Y2); ++V < S2; )
              Q2(h2[V]);
            return j2;
            function Q2(J) {
              N2.resolve(J).then(function(ee) {
                O2 || (O2 = true, A2.resolve(j2, ee));
              }, function(ee) {
                O2 || (O2 = true, A2.reject(j2, ee));
              });
            }
          }
        }, { 1: 1 }], 3: [function(L2, D2, X2) {
          (function(P2) {
            "use strict";
            typeof P2.Promise != "function" && (P2.Promise = L2(2));
          }).call(this, typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {});
        }, { 2: 2 }], 4: [function(L2, D2, X2) {
          "use strict";
          var P2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
            return typeof e;
          } : function(e) {
            return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          };
          function Y2(e, t2) {
            if (!(e instanceof t2))
              throw new TypeError("Cannot call a class as a function");
          }
          function A2() {
            try {
              if (typeof indexedDB < "u")
                return indexedDB;
              if (typeof webkitIndexedDB < "u")
                return webkitIndexedDB;
              if (typeof mozIndexedDB < "u")
                return mozIndexedDB;
              if (typeof OIndexedDB < "u")
                return OIndexedDB;
              if (typeof msIndexedDB < "u")
                return msIndexedDB;
            } catch {
              return;
            }
          }
          var M2 = A2();
          function H2() {
            try {
              if (!M2 || !M2.open)
                return false;
              var e = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), t2 = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
              return (!e || t2) && typeof indexedDB < "u" && typeof IDBKeyRange < "u";
            } catch {
              return false;
            }
          }
          function $(e, t2) {
            e = e || [], t2 = t2 || {};
            try {
              return new Blob(e, t2);
            } catch (n2) {
              if (n2.name !== "TypeError")
                throw n2;
              for (var r2 = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, o2 = new r2(), i2 = 0; i2 < e.length; i2 += 1)
                o2.append(e[i2]);
              return o2.getBlob(t2.type);
            }
          }
          typeof Promise > "u" && L2(3);
          var m = Promise;
          function _2(e, t2) {
            t2 && e.then(function(r2) {
              t2(null, r2);
            }, function(r2) {
              t2(r2);
            });
          }
          function B2(e, t2, r2) {
            typeof t2 == "function" && e.then(t2), typeof r2 == "function" && e.catch(r2);
          }
          function z2(e) {
            return typeof e != "string" && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e;
          }
          function Z2() {
            if (arguments.length && typeof arguments[arguments.length - 1] == "function")
              return arguments[arguments.length - 1];
          }
          var F2 = "local-forage-detect-blob-support", k2 = void 0, U2 = {}, se = Object.prototype.toString, te = "readonly", h2 = "readwrite";
          function N2(e) {
            for (var t2 = e.length, r2 = new ArrayBuffer(t2), o2 = new Uint8Array(r2), i2 = 0; i2 < t2; i2++)
              o2[i2] = e.charCodeAt(i2);
            return r2;
          }
          function S2(e) {
            return new m(function(t2) {
              var r2 = e.transaction(F2, h2), o2 = $([""]);
              r2.objectStore(F2).put(o2, "key"), r2.onabort = function(i2) {
                i2.preventDefault(), i2.stopPropagation(), t2(false);
              }, r2.oncomplete = function() {
                var i2 = navigator.userAgent.match(/Chrome\/(\d+)/), n2 = navigator.userAgent.match(/Edge\//);
                t2(n2 || !i2 || parseInt(i2[1], 10) >= 43);
              };
            }).catch(function() {
              return false;
            });
          }
          function O2(e) {
            return typeof k2 == "boolean" ? m.resolve(k2) : S2(e).then(function(t2) {
              return k2 = t2, k2;
            });
          }
          function V(e) {
            var t2 = U2[e.name], r2 = {};
            r2.promise = new m(function(o2, i2) {
              r2.resolve = o2, r2.reject = i2;
            }), t2.deferredOperations.push(r2), t2.dbReady ? t2.dbReady = t2.dbReady.then(function() {
              return r2.promise;
            }) : t2.dbReady = r2.promise;
          }
          function j2(e) {
            var t2 = U2[e.name], r2 = t2.deferredOperations.pop();
            if (r2)
              return r2.resolve(), r2.promise;
          }
          function Q2(e, t2) {
            var r2 = U2[e.name], o2 = r2.deferredOperations.pop();
            if (o2)
              return o2.reject(t2), o2.promise;
          }
          function J(e, t2) {
            return new m(function(r2, o2) {
              if (U2[e.name] = U2[e.name] || G2(), e.db)
                if (t2)
                  V(e), e.db.close();
                else
                  return r2(e.db);
              var i2 = [e.name];
              t2 && i2.push(e.version);
              var n2 = M2.open.apply(M2, i2);
              t2 && (n2.onupgradeneeded = function(f3) {
                var u2 = n2.result;
                try {
                  u2.createObjectStore(e.storeName), f3.oldVersion <= 1 && u2.createObjectStore(F2);
                } catch (c2) {
                  if (c2.name === "ConstraintError")
                    console.warn('The database "' + e.name + '" has been upgraded from version ' + f3.oldVersion + " to version " + f3.newVersion + ', but the storage "' + e.storeName + '" already exists.');
                  else
                    throw c2;
                }
              }), n2.onerror = function(f3) {
                f3.preventDefault(), o2(n2.error);
              }, n2.onsuccess = function() {
                var f3 = n2.result;
                f3.onversionchange = function(u2) {
                  u2.target.close();
                }, r2(f3), j2(e);
              };
            });
          }
          function ee(e) {
            return J(e, false);
          }
          function fe(e) {
            return J(e, true);
          }
          function a2(e, t2) {
            if (!e.db)
              return true;
            var r2 = !e.db.objectStoreNames.contains(e.storeName), o2 = e.version < e.db.version, i2 = e.version > e.db.version;
            if (o2 && (e.version !== t2 && console.warn('The database "' + e.name + `" can't be downgraded from version ` + e.db.version + " to version " + e.version + "."), e.version = e.db.version), i2 || r2) {
              if (r2) {
                var n2 = e.db.version + 1;
                n2 > e.version && (e.version = n2);
              }
              return true;
            }
            return false;
          }
          function s2(e) {
            return new m(function(t2, r2) {
              var o2 = new FileReader();
              o2.onerror = r2, o2.onloadend = function(i2) {
                var n2 = btoa(i2.target.result || "");
                t2({ __local_forage_encoded_blob: true, data: n2, type: e.type });
              }, o2.readAsBinaryString(e);
            });
          }
          function v2(e) {
            var t2 = N2(atob(e.data));
            return $([t2], { type: e.type });
          }
          function g2(e) {
            return e && e.__local_forage_encoded_blob;
          }
          function b2(e) {
            var t2 = this, r2 = t2._initReady().then(function() {
              var o2 = U2[t2._dbInfo.name];
              if (o2 && o2.dbReady)
                return o2.dbReady;
            });
            return B2(r2, e, e), r2;
          }
          function w2(e) {
            V(e);
            for (var t2 = U2[e.name], r2 = t2.forages, o2 = 0; o2 < r2.length; o2++) {
              var i2 = r2[o2];
              i2._dbInfo.db && (i2._dbInfo.db.close(), i2._dbInfo.db = null);
            }
            return e.db = null, ee(e).then(function(n2) {
              return e.db = n2, a2(e) ? fe(e) : n2;
            }).then(function(n2) {
              e.db = t2.db = n2;
              for (var f3 = 0; f3 < r2.length; f3++)
                r2[f3]._dbInfo.db = n2;
            }).catch(function(n2) {
              throw Q2(e, n2), n2;
            });
          }
          function T(e, t2, r2, o2) {
            o2 === void 0 && (o2 = 1);
            try {
              var i2 = e.db.transaction(e.storeName, t2);
              r2(null, i2);
            } catch (n2) {
              if (o2 > 0 && (!e.db || n2.name === "InvalidStateError" || n2.name === "NotFoundError"))
                return m.resolve().then(function() {
                  if (!e.db || n2.name === "NotFoundError" && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version)
                    return e.db && (e.version = e.db.version + 1), fe(e);
                }).then(function() {
                  return w2(e).then(function() {
                    T(e, t2, r2, o2 - 1);
                  });
                }).catch(r2);
              r2(n2);
            }
          }
          function G2() {
            return { forages: [], db: null, dbReady: null, deferredOperations: [] };
          }
          function ce(e) {
            var t2 = this, r2 = { db: null };
            if (e)
              for (var o2 in e)
                r2[o2] = e[o2];
            var i2 = U2[r2.name];
            i2 || (i2 = G2(), U2[r2.name] = i2), i2.forages.push(t2), t2._initReady || (t2._initReady = t2.ready, t2.ready = b2);
            var n2 = [];
            function f3() {
              return m.resolve();
            }
            for (var u2 = 0; u2 < i2.forages.length; u2++) {
              var c2 = i2.forages[u2];
              c2 !== t2 && n2.push(c2._initReady().catch(f3));
            }
            var l2 = i2.forages.slice(0);
            return m.all(n2).then(function() {
              return r2.db = i2.db, ee(r2);
            }).then(function(d2) {
              return r2.db = d2, a2(r2, t2._defaultConfig.version) ? fe(r2) : d2;
            }).then(function(d2) {
              r2.db = i2.db = d2, t2._dbInfo = r2;
              for (var y2 = 0; y2 < l2.length; y2++) {
                var R2 = l2[y2];
                R2 !== t2 && (R2._dbInfo.db = r2.db, R2._dbInfo.version = r2.version);
              }
            });
          }
          function ue(e, t2) {
            var r2 = this;
            e = z2(e);
            var o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                T(r2._dbInfo, te, function(f3, u2) {
                  if (f3)
                    return n2(f3);
                  try {
                    var c2 = u2.objectStore(r2._dbInfo.storeName), l2 = c2.get(e);
                    l2.onsuccess = function() {
                      var d2 = l2.result;
                      d2 === void 0 && (d2 = null), g2(d2) && (d2 = v2(d2)), i2(d2);
                    }, l2.onerror = function() {
                      n2(l2.error);
                    };
                  } catch (d2) {
                    n2(d2);
                  }
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function ve(e, t2) {
            var r2 = this, o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                T(r2._dbInfo, te, function(f3, u2) {
                  if (f3)
                    return n2(f3);
                  try {
                    var c2 = u2.objectStore(r2._dbInfo.storeName), l2 = c2.openCursor(), d2 = 1;
                    l2.onsuccess = function() {
                      var y2 = l2.result;
                      if (y2) {
                        var R2 = y2.value;
                        g2(R2) && (R2 = v2(R2));
                        var x2 = e(R2, y2.key, d2++);
                        x2 !== void 0 ? i2(x2) : y2.continue();
                      } else
                        i2();
                    }, l2.onerror = function() {
                      n2(l2.error);
                    };
                  } catch (y2) {
                    n2(y2);
                  }
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function ar(e, t2, r2) {
            var o2 = this;
            e = z2(e);
            var i2 = new m(function(n2, f3) {
              var u2;
              o2.ready().then(function() {
                return u2 = o2._dbInfo, se.call(t2) === "[object Blob]" ? O2(u2.db).then(function(c2) {
                  return c2 ? t2 : s2(t2);
                }) : t2;
              }).then(function(c2) {
                T(o2._dbInfo, h2, function(l2, d2) {
                  if (l2)
                    return f3(l2);
                  try {
                    var y2 = d2.objectStore(o2._dbInfo.storeName);
                    c2 === null && (c2 = void 0);
                    var R2 = y2.put(c2, e);
                    d2.oncomplete = function() {
                      c2 === void 0 && (c2 = null), n2(c2);
                    }, d2.onabort = d2.onerror = function() {
                      var x2 = R2.error ? R2.error : R2.transaction.error;
                      f3(x2);
                    };
                  } catch (x2) {
                    f3(x2);
                  }
                });
              }).catch(f3);
            });
            return _2(i2, r2), i2;
          }
          function fr(e, t2) {
            var r2 = this;
            e = z2(e);
            var o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                T(r2._dbInfo, h2, function(f3, u2) {
                  if (f3)
                    return n2(f3);
                  try {
                    var c2 = u2.objectStore(r2._dbInfo.storeName), l2 = c2.delete(e);
                    u2.oncomplete = function() {
                      i2();
                    }, u2.onerror = function() {
                      n2(l2.error);
                    }, u2.onabort = function() {
                      var d2 = l2.error ? l2.error : l2.transaction.error;
                      n2(d2);
                    };
                  } catch (d2) {
                    n2(d2);
                  }
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function ur(e) {
            var t2 = this, r2 = new m(function(o2, i2) {
              t2.ready().then(function() {
                T(t2._dbInfo, h2, function(n2, f3) {
                  if (n2)
                    return i2(n2);
                  try {
                    var u2 = f3.objectStore(t2._dbInfo.storeName), c2 = u2.clear();
                    f3.oncomplete = function() {
                      o2();
                    }, f3.onabort = f3.onerror = function() {
                      var l2 = c2.error ? c2.error : c2.transaction.error;
                      i2(l2);
                    };
                  } catch (l2) {
                    i2(l2);
                  }
                });
              }).catch(i2);
            });
            return _2(r2, e), r2;
          }
          function sr(e) {
            var t2 = this, r2 = new m(function(o2, i2) {
              t2.ready().then(function() {
                T(t2._dbInfo, te, function(n2, f3) {
                  if (n2)
                    return i2(n2);
                  try {
                    var u2 = f3.objectStore(t2._dbInfo.storeName), c2 = u2.count();
                    c2.onsuccess = function() {
                      o2(c2.result);
                    }, c2.onerror = function() {
                      i2(c2.error);
                    };
                  } catch (l2) {
                    i2(l2);
                  }
                });
              }).catch(i2);
            });
            return _2(r2, e), r2;
          }
          function cr(e, t2) {
            var r2 = this, o2 = new m(function(i2, n2) {
              if (e < 0) {
                i2(null);
                return;
              }
              r2.ready().then(function() {
                T(r2._dbInfo, te, function(f3, u2) {
                  if (f3)
                    return n2(f3);
                  try {
                    var c2 = u2.objectStore(r2._dbInfo.storeName), l2 = false, d2 = c2.openKeyCursor();
                    d2.onsuccess = function() {
                      var y2 = d2.result;
                      if (!y2) {
                        i2(null);
                        return;
                      }
                      e === 0 || l2 ? i2(y2.key) : (l2 = true, y2.advance(e));
                    }, d2.onerror = function() {
                      n2(d2.error);
                    };
                  } catch (y2) {
                    n2(y2);
                  }
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function lr(e) {
            var t2 = this, r2 = new m(function(o2, i2) {
              t2.ready().then(function() {
                T(t2._dbInfo, te, function(n2, f3) {
                  if (n2)
                    return i2(n2);
                  try {
                    var u2 = f3.objectStore(t2._dbInfo.storeName), c2 = u2.openKeyCursor(), l2 = [];
                    c2.onsuccess = function() {
                      var d2 = c2.result;
                      if (!d2) {
                        o2(l2);
                        return;
                      }
                      l2.push(d2.key), d2.continue();
                    }, c2.onerror = function() {
                      i2(c2.error);
                    };
                  } catch (d2) {
                    i2(d2);
                  }
                });
              }).catch(i2);
            });
            return _2(r2, e), r2;
          }
          function dr(e, t2) {
            t2 = Z2.apply(this, arguments);
            var r2 = this.config();
            e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r2.name, e.storeName = e.storeName || r2.storeName);
            var o2 = this, i2;
            if (!e.name)
              i2 = m.reject("Invalid arguments");
            else {
              var n2 = e.name === r2.name && o2._dbInfo.db, f3 = n2 ? m.resolve(o2._dbInfo.db) : ee(e).then(function(u2) {
                var c2 = U2[e.name], l2 = c2.forages;
                c2.db = u2;
                for (var d2 = 0; d2 < l2.length; d2++)
                  l2[d2]._dbInfo.db = u2;
                return u2;
              });
              e.storeName ? i2 = f3.then(function(u2) {
                if (!!u2.objectStoreNames.contains(e.storeName)) {
                  var c2 = u2.version + 1;
                  V(e);
                  var l2 = U2[e.name], d2 = l2.forages;
                  u2.close();
                  for (var y2 = 0; y2 < d2.length; y2++) {
                    var R2 = d2[y2];
                    R2._dbInfo.db = null, R2._dbInfo.version = c2;
                  }
                  var x2 = new m(function(C, K) {
                    var W2 = M2.open(e.name, c2);
                    W2.onerror = function(q2) {
                      var me = W2.result;
                      me.close(), K(q2);
                    }, W2.onupgradeneeded = function() {
                      var q2 = W2.result;
                      q2.deleteObjectStore(e.storeName);
                    }, W2.onsuccess = function() {
                      var q2 = W2.result;
                      q2.close(), C(q2);
                    };
                  });
                  return x2.then(function(C) {
                    l2.db = C;
                    for (var K = 0; K < d2.length; K++) {
                      var W2 = d2[K];
                      W2._dbInfo.db = C, j2(W2._dbInfo);
                    }
                  }).catch(function(C) {
                    throw (Q2(e, C) || m.resolve()).catch(function() {
                    }), C;
                  });
                }
              }) : i2 = f3.then(function(u2) {
                V(e);
                var c2 = U2[e.name], l2 = c2.forages;
                u2.close();
                for (var d2 = 0; d2 < l2.length; d2++) {
                  var y2 = l2[d2];
                  y2._dbInfo.db = null;
                }
                var R2 = new m(function(x2, C) {
                  var K = M2.deleteDatabase(e.name);
                  K.onerror = function() {
                    var W2 = K.result;
                    W2 && W2.close(), C(K.error);
                  }, K.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + e.name + '" until all open connections are closed');
                  }, K.onsuccess = function() {
                    var W2 = K.result;
                    W2 && W2.close(), x2(W2);
                  };
                });
                return R2.then(function(x2) {
                  c2.db = x2;
                  for (var C = 0; C < l2.length; C++) {
                    var K = l2[C];
                    j2(K._dbInfo);
                  }
                }).catch(function(x2) {
                  throw (Q2(e, x2) || m.resolve()).catch(function() {
                  }), x2;
                });
              });
            }
            return _2(i2, t2), i2;
          }
          var vr = { _driver: "asyncStorage", _initStorage: ce, _support: H2(), iterate: ve, getItem: ue, setItem: ar, removeItem: fr, clear: ur, length: sr, key: cr, keys: lr, dropInstance: dr };
          function hr() {
            return typeof openDatabase == "function";
          }
          var ie = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", mr = "~~local_forage_type~", Pe = /^~~local_forage_type~([^~]+)~/, ye = "__lfsc__:", Se = ye.length, Ae = "arbf", Re = "blob", Me = "si08", Fe = "ui08", Ue = "uic8", Ye = "si16", ze = "si32", We = "ur16", Ke = "ui32", He = "fl32", Ve = "fl64", Ge = Se + Ae.length, je = Object.prototype.toString;
          function Xe(e) {
            var t2 = e.length * 0.75, r2 = e.length, o2, i2 = 0, n2, f3, u2, c2;
            e[e.length - 1] === "=" && (t2--, e[e.length - 2] === "=" && t2--);
            var l2 = new ArrayBuffer(t2), d2 = new Uint8Array(l2);
            for (o2 = 0; o2 < r2; o2 += 4)
              n2 = ie.indexOf(e[o2]), f3 = ie.indexOf(e[o2 + 1]), u2 = ie.indexOf(e[o2 + 2]), c2 = ie.indexOf(e[o2 + 3]), d2[i2++] = n2 << 2 | f3 >> 4, d2[i2++] = (f3 & 15) << 4 | u2 >> 2, d2[i2++] = (u2 & 3) << 6 | c2 & 63;
            return l2;
          }
          function De(e) {
            var t2 = new Uint8Array(e), r2 = "", o2;
            for (o2 = 0; o2 < t2.length; o2 += 3)
              r2 += ie[t2[o2] >> 2], r2 += ie[(t2[o2] & 3) << 4 | t2[o2 + 1] >> 4], r2 += ie[(t2[o2 + 1] & 15) << 2 | t2[o2 + 2] >> 6], r2 += ie[t2[o2 + 2] & 63];
            return t2.length % 3 === 2 ? r2 = r2.substring(0, r2.length - 1) + "=" : t2.length % 3 === 1 && (r2 = r2.substring(0, r2.length - 2) + "=="), r2;
          }
          function yr(e, t2) {
            var r2 = "";
            if (e && (r2 = je.call(e)), e && (r2 === "[object ArrayBuffer]" || e.buffer && je.call(e.buffer) === "[object ArrayBuffer]")) {
              var o2, i2 = ye;
              e instanceof ArrayBuffer ? (o2 = e, i2 += Ae) : (o2 = e.buffer, r2 === "[object Int8Array]" ? i2 += Me : r2 === "[object Uint8Array]" ? i2 += Fe : r2 === "[object Uint8ClampedArray]" ? i2 += Ue : r2 === "[object Int16Array]" ? i2 += Ye : r2 === "[object Uint16Array]" ? i2 += We : r2 === "[object Int32Array]" ? i2 += ze : r2 === "[object Uint32Array]" ? i2 += Ke : r2 === "[object Float32Array]" ? i2 += He : r2 === "[object Float64Array]" ? i2 += Ve : t2(new Error("Failed to get type for BinaryArray"))), t2(i2 + De(o2));
            } else if (r2 === "[object Blob]") {
              var n2 = new FileReader();
              n2.onload = function() {
                var f3 = mr + e.type + "~" + De(this.result);
                t2(ye + Re + f3);
              }, n2.readAsArrayBuffer(e);
            } else
              try {
                t2(JSON.stringify(e));
              } catch (f3) {
                console.error("Couldn't convert value into a JSON string: ", e), t2(null, f3);
              }
          }
          function pr(e) {
            if (e.substring(0, Se) !== ye)
              return JSON.parse(e);
            var t2 = e.substring(Ge), r2 = e.substring(Se, Ge), o2;
            if (r2 === Re && Pe.test(t2)) {
              var i2 = t2.match(Pe);
              o2 = i2[1], t2 = t2.substring(i2[0].length);
            }
            var n2 = Xe(t2);
            switch (r2) {
              case Ae:
                return n2;
              case Re:
                return $([n2], { type: o2 });
              case Me:
                return new Int8Array(n2);
              case Fe:
                return new Uint8Array(n2);
              case Ue:
                return new Uint8ClampedArray(n2);
              case Ye:
                return new Int16Array(n2);
              case We:
                return new Uint16Array(n2);
              case ze:
                return new Int32Array(n2);
              case Ke:
                return new Uint32Array(n2);
              case He:
                return new Float32Array(n2);
              case Ve:
                return new Float64Array(n2);
              default:
                throw new Error("Unkown type: " + r2);
            }
          }
          var Ne = { serialize: yr, deserialize: pr, stringToBuffer: Xe, bufferToString: De };
          function Qe(e, t2, r2, o2) {
            e.executeSql("CREATE TABLE IF NOT EXISTS " + t2.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], r2, o2);
          }
          function gr(e) {
            var t2 = this, r2 = { db: null };
            if (e)
              for (var o2 in e)
                r2[o2] = typeof e[o2] != "string" ? e[o2].toString() : e[o2];
            var i2 = new m(function(n2, f3) {
              try {
                r2.db = openDatabase(r2.name, String(r2.version), r2.description, r2.size);
              } catch (u2) {
                return f3(u2);
              }
              r2.db.transaction(function(u2) {
                Qe(u2, r2, function() {
                  t2._dbInfo = r2, n2();
                }, function(c2, l2) {
                  f3(l2);
                });
              }, f3);
            });
            return r2.serializer = Ne, i2;
          }
          function ae(e, t2, r2, o2, i2, n2) {
            e.executeSql(r2, o2, i2, function(f3, u2) {
              u2.code === u2.SYNTAX_ERR ? f3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t2.storeName], function(c2, l2) {
                l2.rows.length ? n2(c2, u2) : Qe(c2, t2, function() {
                  c2.executeSql(r2, o2, i2, n2);
                }, n2);
              }, n2) : n2(f3, u2);
            }, n2);
          }
          function br(e, t2) {
            var r2 = this;
            e = z2(e);
            var o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                var f3 = r2._dbInfo;
                f3.db.transaction(function(u2) {
                  ae(u2, f3, "SELECT * FROM " + f3.storeName + " WHERE key = ? LIMIT 1", [e], function(c2, l2) {
                    var d2 = l2.rows.length ? l2.rows.item(0).value : null;
                    d2 && (d2 = f3.serializer.deserialize(d2)), i2(d2);
                  }, function(c2, l2) {
                    n2(l2);
                  });
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function _r(e, t2) {
            var r2 = this, o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                var f3 = r2._dbInfo;
                f3.db.transaction(function(u2) {
                  ae(u2, f3, "SELECT * FROM " + f3.storeName, [], function(c2, l2) {
                    for (var d2 = l2.rows, y2 = d2.length, R2 = 0; R2 < y2; R2++) {
                      var x2 = d2.item(R2), C = x2.value;
                      if (C && (C = f3.serializer.deserialize(C)), C = e(C, x2.key, R2 + 1), C !== void 0) {
                        i2(C);
                        return;
                      }
                    }
                    i2();
                  }, function(c2, l2) {
                    n2(l2);
                  });
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function Je(e, t2, r2, o2) {
            var i2 = this;
            e = z2(e);
            var n2 = new m(function(f3, u2) {
              i2.ready().then(function() {
                t2 === void 0 && (t2 = null);
                var c2 = t2, l2 = i2._dbInfo;
                l2.serializer.serialize(t2, function(d2, y2) {
                  y2 ? u2(y2) : l2.db.transaction(function(R2) {
                    ae(R2, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [e, d2], function() {
                      f3(c2);
                    }, function(x2, C) {
                      u2(C);
                    });
                  }, function(R2) {
                    if (R2.code === R2.QUOTA_ERR) {
                      if (o2 > 0) {
                        f3(Je.apply(i2, [e, c2, r2, o2 - 1]));
                        return;
                      }
                      u2(R2);
                    }
                  });
                });
              }).catch(u2);
            });
            return _2(n2, r2), n2;
          }
          function wr(e, t2, r2) {
            return Je.apply(this, [e, t2, r2, 1]);
          }
          function Er(e, t2) {
            var r2 = this;
            e = z2(e);
            var o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                var f3 = r2._dbInfo;
                f3.db.transaction(function(u2) {
                  ae(u2, f3, "DELETE FROM " + f3.storeName + " WHERE key = ?", [e], function() {
                    i2();
                  }, function(c2, l2) {
                    n2(l2);
                  });
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function Ir(e) {
            var t2 = this, r2 = new m(function(o2, i2) {
              t2.ready().then(function() {
                var n2 = t2._dbInfo;
                n2.db.transaction(function(f3) {
                  ae(f3, n2, "DELETE FROM " + n2.storeName, [], function() {
                    o2();
                  }, function(u2, c2) {
                    i2(c2);
                  });
                });
              }).catch(i2);
            });
            return _2(r2, e), r2;
          }
          function Sr(e) {
            var t2 = this, r2 = new m(function(o2, i2) {
              t2.ready().then(function() {
                var n2 = t2._dbInfo;
                n2.db.transaction(function(f3) {
                  ae(f3, n2, "SELECT COUNT(key) as c FROM " + n2.storeName, [], function(u2, c2) {
                    var l2 = c2.rows.item(0).c;
                    o2(l2);
                  }, function(u2, c2) {
                    i2(c2);
                  });
                });
              }).catch(i2);
            });
            return _2(r2, e), r2;
          }
          function Ar(e, t2) {
            var r2 = this, o2 = new m(function(i2, n2) {
              r2.ready().then(function() {
                var f3 = r2._dbInfo;
                f3.db.transaction(function(u2) {
                  ae(u2, f3, "SELECT key FROM " + f3.storeName + " WHERE id = ? LIMIT 1", [e + 1], function(c2, l2) {
                    var d2 = l2.rows.length ? l2.rows.item(0).key : null;
                    i2(d2);
                  }, function(c2, l2) {
                    n2(l2);
                  });
                });
              }).catch(n2);
            });
            return _2(o2, t2), o2;
          }
          function Rr(e) {
            var t2 = this, r2 = new m(function(o2, i2) {
              t2.ready().then(function() {
                var n2 = t2._dbInfo;
                n2.db.transaction(function(f3) {
                  ae(f3, n2, "SELECT key FROM " + n2.storeName, [], function(u2, c2) {
                    for (var l2 = [], d2 = 0; d2 < c2.rows.length; d2++)
                      l2.push(c2.rows.item(d2).key);
                    o2(l2);
                  }, function(u2, c2) {
                    i2(c2);
                  });
                });
              }).catch(i2);
            });
            return _2(r2, e), r2;
          }
          function Dr(e) {
            return new m(function(t2, r2) {
              e.transaction(function(o2) {
                o2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(i2, n2) {
                  for (var f3 = [], u2 = 0; u2 < n2.rows.length; u2++)
                    f3.push(n2.rows.item(u2).name);
                  t2({ db: e, storeNames: f3 });
                }, function(i2, n2) {
                  r2(n2);
                });
              }, function(o2) {
                r2(o2);
              });
            });
          }
          function Nr(e, t2) {
            t2 = Z2.apply(this, arguments);
            var r2 = this.config();
            e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r2.name, e.storeName = e.storeName || r2.storeName);
            var o2 = this, i2;
            return e.name ? i2 = new m(function(n2) {
              var f3;
              e.name === r2.name ? f3 = o2._dbInfo.db : f3 = openDatabase(e.name, "", "", 0), e.storeName ? n2({ db: f3, storeNames: [e.storeName] }) : n2(Dr(f3));
            }).then(function(n2) {
              return new m(function(f3, u2) {
                n2.db.transaction(function(c2) {
                  function l2(x2) {
                    return new m(function(C, K) {
                      c2.executeSql("DROP TABLE IF EXISTS " + x2, [], function() {
                        C();
                      }, function(W2, q2) {
                        K(q2);
                      });
                    });
                  }
                  for (var d2 = [], y2 = 0, R2 = n2.storeNames.length; y2 < R2; y2++)
                    d2.push(l2(n2.storeNames[y2]));
                  m.all(d2).then(function() {
                    f3();
                  }).catch(function(x2) {
                    u2(x2);
                  });
                }, function(c2) {
                  u2(c2);
                });
              });
            }) : i2 = m.reject("Invalid arguments"), _2(i2, t2), i2;
          }
          var Tr = { _driver: "webSQLStorage", _initStorage: gr, _support: hr(), iterate: _r, getItem: br, setItem: wr, removeItem: Er, clear: Ir, length: Sr, key: Ar, keys: Rr, dropInstance: Nr };
          function Br() {
            try {
              return typeof localStorage < "u" && "setItem" in localStorage && !!localStorage.setItem;
            } catch {
              return false;
            }
          }
          function $e(e, t2) {
            var r2 = e.name + "/";
            return e.storeName !== t2.storeName && (r2 += e.storeName + "/"), r2;
          }
          function xr() {
            var e = "_localforage_support_test";
            try {
              return localStorage.setItem(e, true), localStorage.removeItem(e), false;
            } catch {
              return true;
            }
          }
          function Or() {
            return !xr() || localStorage.length > 0;
          }
          function Cr(e) {
            var t2 = this, r2 = {};
            if (e)
              for (var o2 in e)
                r2[o2] = e[o2];
            return r2.keyPrefix = $e(e, t2._defaultConfig), Or() ? (t2._dbInfo = r2, r2.serializer = Ne, m.resolve()) : m.reject();
          }
          function Lr(e) {
            var t2 = this, r2 = t2.ready().then(function() {
              for (var o2 = t2._dbInfo.keyPrefix, i2 = localStorage.length - 1; i2 >= 0; i2--) {
                var n2 = localStorage.key(i2);
                n2.indexOf(o2) === 0 && localStorage.removeItem(n2);
              }
            });
            return _2(r2, e), r2;
          }
          function Pr(e, t2) {
            var r2 = this;
            e = z2(e);
            var o2 = r2.ready().then(function() {
              var i2 = r2._dbInfo, n2 = localStorage.getItem(i2.keyPrefix + e);
              return n2 && (n2 = i2.serializer.deserialize(n2)), n2;
            });
            return _2(o2, t2), o2;
          }
          function Mr(e, t2) {
            var r2 = this, o2 = r2.ready().then(function() {
              for (var i2 = r2._dbInfo, n2 = i2.keyPrefix, f3 = n2.length, u2 = localStorage.length, c2 = 1, l2 = 0; l2 < u2; l2++) {
                var d2 = localStorage.key(l2);
                if (d2.indexOf(n2) === 0) {
                  var y2 = localStorage.getItem(d2);
                  if (y2 && (y2 = i2.serializer.deserialize(y2)), y2 = e(y2, d2.substring(f3), c2++), y2 !== void 0)
                    return y2;
                }
              }
            });
            return _2(o2, t2), o2;
          }
          function Fr(e, t2) {
            var r2 = this, o2 = r2.ready().then(function() {
              var i2 = r2._dbInfo, n2;
              try {
                n2 = localStorage.key(e);
              } catch {
                n2 = null;
              }
              return n2 && (n2 = n2.substring(i2.keyPrefix.length)), n2;
            });
            return _2(o2, t2), o2;
          }
          function Ur(e) {
            var t2 = this, r2 = t2.ready().then(function() {
              for (var o2 = t2._dbInfo, i2 = localStorage.length, n2 = [], f3 = 0; f3 < i2; f3++) {
                var u2 = localStorage.key(f3);
                u2.indexOf(o2.keyPrefix) === 0 && n2.push(u2.substring(o2.keyPrefix.length));
              }
              return n2;
            });
            return _2(r2, e), r2;
          }
          function Yr(e) {
            var t2 = this, r2 = t2.keys().then(function(o2) {
              return o2.length;
            });
            return _2(r2, e), r2;
          }
          function zr(e, t2) {
            var r2 = this;
            e = z2(e);
            var o2 = r2.ready().then(function() {
              var i2 = r2._dbInfo;
              localStorage.removeItem(i2.keyPrefix + e);
            });
            return _2(o2, t2), o2;
          }
          function Wr(e, t2, r2) {
            var o2 = this;
            e = z2(e);
            var i2 = o2.ready().then(function() {
              t2 === void 0 && (t2 = null);
              var n2 = t2;
              return new m(function(f3, u2) {
                var c2 = o2._dbInfo;
                c2.serializer.serialize(t2, function(l2, d2) {
                  if (d2)
                    u2(d2);
                  else
                    try {
                      localStorage.setItem(c2.keyPrefix + e, l2), f3(n2);
                    } catch (y2) {
                      (y2.name === "QuotaExceededError" || y2.name === "NS_ERROR_DOM_QUOTA_REACHED") && u2(y2), u2(y2);
                    }
                });
              });
            });
            return _2(i2, r2), i2;
          }
          function Kr(e, t2) {
            if (t2 = Z2.apply(this, arguments), e = typeof e != "function" && e || {}, !e.name) {
              var r2 = this.config();
              e.name = e.name || r2.name, e.storeName = e.storeName || r2.storeName;
            }
            var o2 = this, i2;
            return e.name ? i2 = new m(function(n2) {
              e.storeName ? n2($e(e, o2._defaultConfig)) : n2(e.name + "/");
            }).then(function(n2) {
              for (var f3 = localStorage.length - 1; f3 >= 0; f3--) {
                var u2 = localStorage.key(f3);
                u2.indexOf(n2) === 0 && localStorage.removeItem(u2);
              }
            }) : i2 = m.reject("Invalid arguments"), _2(i2, t2), i2;
          }
          var Hr = { _driver: "localStorageWrapper", _initStorage: Cr, _support: Br(), iterate: Mr, getItem: Pr, setItem: Wr, removeItem: zr, clear: Lr, length: Yr, key: Fr, keys: Ur, dropInstance: Kr }, Vr = function(t2, r2) {
            return t2 === r2 || typeof t2 == "number" && typeof r2 == "number" && isNaN(t2) && isNaN(r2);
          }, Gr = function(t2, r2) {
            for (var o2 = t2.length, i2 = 0; i2 < o2; ) {
              if (Vr(t2[i2], r2))
                return true;
              i2++;
            }
            return false;
          }, Ze = Array.isArray || function(e) {
            return Object.prototype.toString.call(e) === "[object Array]";
          }, he = {}, qe = {}, le = { INDEXEDDB: vr, WEBSQL: Tr, LOCALSTORAGE: Hr }, jr = [le.INDEXEDDB._driver, le.WEBSQL._driver, le.LOCALSTORAGE._driver], pe = ["dropInstance"], Te = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(pe), Xr = { description: "", driver: jr.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
          function Qr(e, t2) {
            e[t2] = function() {
              var r2 = arguments;
              return e.ready().then(function() {
                return e[t2].apply(e, r2);
              });
            };
          }
          function Be() {
            for (var e = 1; e < arguments.length; e++) {
              var t2 = arguments[e];
              if (t2)
                for (var r2 in t2)
                  t2.hasOwnProperty(r2) && (Ze(t2[r2]) ? arguments[0][r2] = t2[r2].slice() : arguments[0][r2] = t2[r2]);
            }
            return arguments[0];
          }
          var Jr = function() {
            function e(t2) {
              Y2(this, e);
              for (var r2 in le)
                if (le.hasOwnProperty(r2)) {
                  var o2 = le[r2], i2 = o2._driver;
                  this[r2] = i2, he[i2] || this.defineDriver(o2);
                }
              this._defaultConfig = Be({}, Xr), this._config = Be({}, this._defaultConfig, t2), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
              });
            }
            return e.prototype.config = function(r2) {
              if ((typeof r2 > "u" ? "undefined" : P2(r2)) === "object") {
                if (this._ready)
                  return new Error("Can't call config() after localforage has been used.");
                for (var o2 in r2) {
                  if (o2 === "storeName" && (r2[o2] = r2[o2].replace(/\W/g, "_")), o2 === "version" && typeof r2[o2] != "number")
                    return new Error("Database version must be a number.");
                  this._config[o2] = r2[o2];
                }
                return "driver" in r2 && r2.driver ? this.setDriver(this._config.driver) : true;
              } else
                return typeof r2 == "string" ? this._config[r2] : this._config;
            }, e.prototype.defineDriver = function(r2, o2, i2) {
              var n2 = new m(function(f3, u2) {
                try {
                  var c2 = r2._driver, l2 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!r2._driver) {
                    u2(l2);
                    return;
                  }
                  for (var d2 = Te.concat("_initStorage"), y2 = 0, R2 = d2.length; y2 < R2; y2++) {
                    var x2 = d2[y2], C = !Gr(pe, x2);
                    if ((C || r2[x2]) && typeof r2[x2] != "function") {
                      u2(l2);
                      return;
                    }
                  }
                  var K = function() {
                    for (var me = function(qr) {
                      return function() {
                        var kr = new Error("Method " + qr + " is not implemented by the current driver"), ke = m.reject(kr);
                        return _2(ke, arguments[arguments.length - 1]), ke;
                      };
                    }, xe = 0, Zr = pe.length; xe < Zr; xe++) {
                      var Oe = pe[xe];
                      r2[Oe] || (r2[Oe] = me(Oe));
                    }
                  };
                  K();
                  var W2 = function(me) {
                    he[c2] && console.info("Redefining LocalForage driver: " + c2), he[c2] = r2, qe[c2] = me, f3();
                  };
                  "_support" in r2 ? r2._support && typeof r2._support == "function" ? r2._support().then(W2, u2) : W2(!!r2._support) : W2(true);
                } catch (q2) {
                  u2(q2);
                }
              });
              return B2(n2, o2, i2), n2;
            }, e.prototype.driver = function() {
              return this._driver || null;
            }, e.prototype.getDriver = function(r2, o2, i2) {
              var n2 = he[r2] ? m.resolve(he[r2]) : m.reject(new Error("Driver not found."));
              return B2(n2, o2, i2), n2;
            }, e.prototype.getSerializer = function(r2) {
              var o2 = m.resolve(Ne);
              return B2(o2, r2), o2;
            }, e.prototype.ready = function(r2) {
              var o2 = this, i2 = o2._driverSet.then(function() {
                return o2._ready === null && (o2._ready = o2._initDriver()), o2._ready;
              });
              return B2(i2, r2, r2), i2;
            }, e.prototype.setDriver = function(r2, o2, i2) {
              var n2 = this;
              Ze(r2) || (r2 = [r2]);
              var f3 = this._getSupportedDrivers(r2);
              function u2() {
                n2._config.driver = n2.driver();
              }
              function c2(y2) {
                return n2._extend(y2), u2(), n2._ready = n2._initStorage(n2._config), n2._ready;
              }
              function l2(y2) {
                return function() {
                  var R2 = 0;
                  function x2() {
                    for (; R2 < y2.length; ) {
                      var C = y2[R2];
                      return R2++, n2._dbInfo = null, n2._ready = null, n2.getDriver(C).then(c2).catch(x2);
                    }
                    u2();
                    var K = new Error("No available storage method found.");
                    return n2._driverSet = m.reject(K), n2._driverSet;
                  }
                  return x2();
                };
              }
              var d2 = this._driverSet !== null ? this._driverSet.catch(function() {
                return m.resolve();
              }) : m.resolve();
              return this._driverSet = d2.then(function() {
                var y2 = f3[0];
                return n2._dbInfo = null, n2._ready = null, n2.getDriver(y2).then(function(R2) {
                  n2._driver = R2._driver, u2(), n2._wrapLibraryMethodsWithReady(), n2._initDriver = l2(f3);
                });
              }).catch(function() {
                u2();
                var y2 = new Error("No available storage method found.");
                return n2._driverSet = m.reject(y2), n2._driverSet;
              }), B2(this._driverSet, o2, i2), this._driverSet;
            }, e.prototype.supports = function(r2) {
              return !!qe[r2];
            }, e.prototype._extend = function(r2) {
              Be(this, r2);
            }, e.prototype._getSupportedDrivers = function(r2) {
              for (var o2 = [], i2 = 0, n2 = r2.length; i2 < n2; i2++) {
                var f3 = r2[i2];
                this.supports(f3) && o2.push(f3);
              }
              return o2;
            }, e.prototype._wrapLibraryMethodsWithReady = function() {
              for (var r2 = 0, o2 = Te.length; r2 < o2; r2++)
                Qr(this, Te[r2]);
            }, e.prototype.createInstance = function(r2) {
              return new e(r2);
            }, e;
          }(), $r = new Jr();
          D2.exports = $r;
        }, { 3: 3 }] }, {}, [4])(4);
      });
    });
    var ir = er((_e, or) => {
      (function(p2, E2) {
        typeof _e == "object" && typeof or < "u" ? E2(_e) : typeof define == "function" && define.amd ? define("localforage-driver-memory", ["exports"], E2) : E2(p2.LocalforageDriverMemory = {});
      })(typeof self < "u" ? self : _e, function(p2) {
        "use strict";
        var E2 = "localforage-driver-memory";
        function I2(a2) {
          var s2 = typeof Symbol == "function" && a2[Symbol.iterator], v2 = 0;
          return s2 ? s2.call(a2) : { next: function() {
            return a2 && v2 >= a2.length && (a2 = void 0), { value: a2 && a2[v2++], done: !a2 };
          } };
        }
        function L2(a2, s2) {
          a2 = a2 || [], s2 = s2 || {};
          try {
            return new Blob(a2, s2);
          } catch (w2) {
            if (w2.name !== "TypeError")
              throw w2;
            for (var v2 = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, g2 = new v2(), b2 = 0; b2 < a2.length; b2 += 1)
              g2.append(a2[b2]);
            return g2.getBlob(s2.type);
          }
        }
        var D2 = /^~~local_forage_type~([^~]+)~/, X2 = 9, P2 = X2 + 4, Y2 = Object.prototype.toString;
        function A2(a2) {
          var s2 = a2.length * 0.75, v2 = a2.length;
          a2[a2.length - 1] === "=" && (s2--, a2[a2.length - 2] === "=" && s2--);
          for (var g2 = new ArrayBuffer(s2), b2 = new Uint8Array(g2), w2 = 0, T = 0; w2 < v2; w2 += 4) {
            var G2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[w2]), ce = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[w2 + 1]), ue = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[w2 + 2]), ve = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[w2 + 3]);
            b2[T++] = G2 << 2 | ce >> 4, b2[T++] = (ce & 15) << 4 | ue >> 2, b2[T++] = (ue & 3) << 6 | ve & 63;
          }
          return g2;
        }
        function M2(a2) {
          for (var s2 = new Uint8Array(a2), v2 = "", g2 = 0; g2 < s2.length; g2 += 3)
            v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[s2[g2] >> 2], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(s2[g2] & 3) << 4 | s2[g2 + 1] >> 4], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(s2[g2 + 1] & 15) << 2 | s2[g2 + 2] >> 6], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[s2[g2 + 2] & 63];
          return s2.length % 3 === 2 ? v2 = v2.substring(0, v2.length - 1) + "=" : s2.length % 3 === 1 && (v2 = v2.substring(0, v2.length - 2) + "=="), v2;
        }
        function H2(a2, s2) {
          var v2 = "";
          if (a2 && (v2 = Y2.call(a2)), a2 && (v2 === "[object ArrayBuffer]" || a2.buffer && Y2.call(a2.buffer) === "[object ArrayBuffer]")) {
            var g2 = void 0, b2 = "__lfsc__:";
            a2 instanceof ArrayBuffer ? (g2 = a2, b2 += "arbf") : (g2 = a2.buffer, v2 === "[object Int8Array]" ? b2 += "si08" : v2 === "[object Uint8Array]" ? b2 += "ui08" : v2 === "[object Uint8ClampedArray]" ? b2 += "uic8" : v2 === "[object Int16Array]" ? b2 += "si16" : v2 === "[object Uint16Array]" ? b2 += "ur16" : v2 === "[object Int32Array]" ? b2 += "si32" : v2 === "[object Uint32Array]" ? b2 += "ui32" : v2 === "[object Float32Array]" ? b2 += "fl32" : v2 === "[object Float64Array]" ? b2 += "fl64" : s2(new Error("Failed to get type for BinaryArray"))), s2(b2 + M2(g2));
          } else if (v2 === "[object Blob]") {
            var w2 = new FileReader();
            w2.onload = function() {
              var T = "~~local_forage_type~" + a2.type + "~" + M2(this.result);
              s2("__lfsc__:blob" + T);
            }, w2.readAsArrayBuffer(a2);
          } else
            try {
              s2(JSON.stringify(a2));
            } catch (T) {
              console.error("Couldn't convert value into a JSON string: ", a2), s2(null, T);
            }
        }
        function $(a2) {
          if (a2.substring(0, X2) !== "__lfsc__:")
            return JSON.parse(a2);
          var s2 = a2.substring(P2), v2 = a2.substring(X2, P2), g2;
          if (v2 === "blob" && D2.test(s2)) {
            var b2 = s2.match(D2);
            g2 = b2[1], s2 = s2.substring(b2[0].length);
          }
          var w2 = A2(s2);
          switch (v2) {
            case "arbf":
              return w2;
            case "blob":
              return L2([w2], { type: g2 });
            case "si08":
              return new Int8Array(w2);
            case "ui08":
              return new Uint8Array(w2);
            case "uic8":
              return new Uint8ClampedArray(w2);
            case "si16":
              return new Int16Array(w2);
            case "ur16":
              return new Uint16Array(w2);
            case "si32":
              return new Int32Array(w2);
            case "ui32":
              return new Uint32Array(w2);
            case "fl32":
              return new Float32Array(w2);
            case "fl64":
              return new Float64Array(w2);
            default:
              throw new Error("Unkown type: " + v2);
          }
        }
        function m(a2) {
          var s2, v2;
          if (a2 === null || typeof a2 != "object" || "isActiveClone" in a2)
            return a2;
          var g2 = a2 instanceof Date ? new Date(a2) : a2.constructor();
          try {
            for (var b2 = I2(Object.keys(a2)), w2 = b2.next(); !w2.done; w2 = b2.next()) {
              var T = w2.value;
              Object.prototype.hasOwnProperty.call(a2, T) && (a2.isActiveClone = null, g2[T] = m(a2[T]), delete a2.isActiveClone);
            }
          } catch (G2) {
            s2 = { error: G2 };
          } finally {
            try {
              w2 && !w2.done && (v2 = b2.return) && v2.call(b2);
            } finally {
              if (s2)
                throw s2.error;
            }
          }
          return g2;
        }
        function _2(a2, s2) {
          return (a2.name || s2.name) + "/" + (a2.storeName || s2.storeName) + "/";
        }
        function B2(a2, s2) {
          s2 && a2.then(function(v2) {
            s2(null, v2);
          }, function(v2) {
            s2(v2);
          });
        }
        function z2() {
          for (var a2 = [], s2 = 0; s2 < arguments.length; s2++)
            a2[s2] = arguments[s2];
          if (arguments.length && typeof arguments[arguments.length - 1] == "function")
            return arguments[arguments.length - 1];
        }
        function Z2(a2, s2) {
          var v2 = this;
          if (s2 = z2.apply(this, arguments), a2 = typeof a2 != "function" && a2 || {}, !a2.name) {
            var g2 = this.config();
            a2.name = a2.name || g2.name, a2.storeName = a2.storeName || g2.storeName;
          }
          var b2;
          return a2.name ? b2 = new Promise(function(w2) {
            a2.storeName ? w2(_2(a2, v2._defaultConfig)) : w2(a2.name + "/");
          }) : b2 = Promise.reject("Invalid arguments"), { promise: b2, callback: s2 };
        }
        function F2(a2) {
          return typeof a2 != "string" && (console.warn(a2 + " used as a key, but it is not a string."), a2 = String(a2)), a2;
        }
        var k2 = { bufferToString: M2, deserialize: $, serialize: H2, stringToBuffer: A2 }, U2 = {}, se = function() {
          function a2(s2) {
            this.kp = s2, this.data = {};
          }
          return a2.resolve = function(s2) {
            return U2[s2] || (U2[s2] = new a2(s2)), U2[s2];
          }, a2.prototype.clear = function() {
            this.data = {};
          }, a2.prototype.drop = function() {
            this.clear(), delete U2[this.kp];
          }, a2.prototype.get = function(s2) {
            return this.data[s2];
          }, a2.prototype.key = function(s2) {
            return this.keys()[s2];
          }, a2.prototype.keys = function() {
            return Object.keys(this.data);
          }, a2.prototype.rm = function(s2) {
            delete this.data[s2];
          }, a2.prototype.set = function(s2, v2) {
            this.data[s2] = v2;
          }, a2;
        }();
        function te(a2) {
          var s2 = a2 ? m(a2) : {}, v2 = _2(s2, this._defaultConfig), g2 = se.resolve(v2);
          return this._dbInfo = s2, this._dbInfo.serializer = k2, this._dbInfo.keyPrefix = v2, this._dbInfo.mStore = g2, Promise.resolve();
        }
        function h2(a2) {
          var s2 = this, v2 = this.ready().then(function() {
            s2._dbInfo.mStore.clear();
          });
          return B2(v2, a2), v2;
        }
        function N2(a2, s2) {
          var v2 = Z2.apply(this, arguments), g2 = v2.promise, b2 = v2.callback, w2 = g2.then(function(T) {
            se.resolve(T).drop();
          });
          return B2(w2, b2), g2;
        }
        function S2(a2, s2) {
          var v2 = this;
          a2 = F2(a2);
          var g2 = this.ready().then(function() {
            var b2 = v2._dbInfo.mStore.get(a2);
            return b2 == null ? null : v2._dbInfo.serializer.deserialize(b2);
          });
          return B2(g2, s2), g2;
        }
        function O2(a2, s2) {
          var v2 = this, g2 = this.ready().then(function() {
            for (var b2 = v2._dbInfo.mStore, w2 = b2.keys(), T = 0; T < w2.length; T++) {
              var G2 = b2.get(w2[T]);
              if (G2 && (G2 = v2._dbInfo.serializer.deserialize(G2)), G2 = a2(G2, w2[T], T + 1), G2 !== void 0)
                return G2;
            }
          });
          return B2(g2, s2), g2;
        }
        function V(a2, s2) {
          var v2 = this, g2 = this.ready().then(function() {
            var b2;
            try {
              b2 = v2._dbInfo.mStore.key(a2), b2 === void 0 && (b2 = null);
            } catch {
              b2 = null;
            }
            return b2;
          });
          return B2(g2, s2), g2;
        }
        function j2(a2) {
          var s2 = this, v2 = this.ready().then(function() {
            return s2._dbInfo.mStore.keys();
          });
          return B2(v2, a2), v2;
        }
        function Q2(a2) {
          var s2 = this.keys().then(function(v2) {
            return v2.length;
          });
          return B2(s2, a2), s2;
        }
        function J(a2, s2) {
          var v2 = this;
          a2 = F2(a2);
          var g2 = this.ready().then(function() {
            v2._dbInfo.mStore.rm(a2);
          });
          return B2(g2, s2), g2;
        }
        function ee(a2, s2, v2) {
          var g2 = this;
          a2 = F2(a2);
          var b2 = this.ready().then(function() {
            s2 === void 0 && (s2 = null);
            var w2 = s2;
            return new Promise(function(T, G2) {
              g2._dbInfo.serializer.serialize(s2, function(ce, ue) {
                if (ue)
                  G2(ue);
                else
                  try {
                    g2._dbInfo.mStore.set(a2, ce), T(w2);
                  } catch (ve) {
                    G2(ve);
                  }
              });
            });
          });
          return B2(b2, v2), b2;
        }
        var fe = true;
        p2._support = fe, p2._driver = E2, p2._initStorage = te, p2.clear = h2, p2.dropInstance = N2, p2.getItem = S2, p2.iterate = O2, p2.key = V, p2.keys = j2, p2.length = Q2, p2.removeItem = J, p2.setItem = ee, Object.defineProperty(p2, "__esModule", { value: true });
      });
    });
    var re = {};
    it(re, { Magic: () => ct });
    module.exports = at(re);
    var Ie = require_cjs2();
    var Ee = rr(nr());
    var Le = rr(ir());
    var oe = require_cjs2();
    var ft = { display: "none", position: "fixed", top: "0", right: "0", width: "100%", height: "100%", borderRadius: "0", border: "none", zIndex: "2147483647" };
    function ut(p2) {
      for (let [E2, I2] of Object.entries(ft))
        p2.style[E2] = I2;
    }
    function st(p2) {
      let E2 = [].slice.call(document.querySelectorAll(".magic-iframe"));
      return Boolean(E2.find((I2) => I2.src.includes(p2)));
    }
    var we = class extends oe.ViewController {
      constructor() {
        super(...arguments);
        this.activeElement = null;
      }
      init() {
        this.test = "hello", this.iframe = new Promise((I2) => {
          let L2 = () => {
            if (st(encodeURIComponent(this.parameters)))
              (0, oe.createDuplicateIframeWarning)().log();
            else {
              let D2 = document.createElement("iframe");
              D2.classList.add("magic-iframe"), D2.dataset.magicIframeLabel = (0, oe.createURL)(this.endpoint).host, D2.title = "Secure Modal", D2.src = (0, oe.createURL)(`/send?params=${encodeURIComponent(this.parameters)}`, this.endpoint).href, ut(D2), document.body.appendChild(D2), I2(D2);
            }
          };
          ["loaded", "interactive", "complete"].includes(document.readyState) ? L2() : window.addEventListener("load", L2, false);
        }), window.addEventListener("message", (I2) => {
          var L2;
          if (I2.origin === this.endpoint && I2.data && I2.data.msgType && this.messageHandlers.size) {
            I2.data.response = (L2 = I2.data.response) != null ? L2 : {};
            for (let D2 of this.messageHandlers.values())
              D2(I2);
          }
        });
      }
      showOverlay() {
        return de(this, null, function* () {
          let I2 = yield this.iframe;
          I2.style.display = "block", this.activeElement = document.activeElement, I2.focus();
        });
      }
      hideOverlay() {
        return de(this, null, function* () {
          var L2;
          let I2 = yield this.iframe;
          I2.style.display = "none", (L2 = this.activeElement) != null && L2.focus && this.activeElement.focus(), this.activeElement = null;
        });
      }
      _post(I2) {
        return de(this, null, function* () {
          let L2 = yield this.iframe;
          if (L2 && L2.contentWindow)
            L2.contentWindow.postMessage(I2, this.endpoint);
          else
            throw (0, oe.createModalNotReadyError)();
        });
      }
    };
    ne(re, require_cjs3(), module.exports);
    var ct = (0, Ie.createSDK)(Ie.SDKBase, { platform: "web", sdkName: "magic-sdk", version: "13.6.2", defaultEndpoint: "https://auth.magic.link/", ViewController: we, configureStorage: () => de(void 0, null, function* () {
      let p2 = Ee.default.createInstance({ name: "MagicAuthLocalStorageDB", storeName: "MagicAuthLocalStorage" });
      return yield p2.defineDriver(Le), yield p2.setDriver([Ee.default.INDEXEDDB, Ee.default.LOCALSTORAGE, Le._driver]), p2;
    }) });
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/MagicWeb3Connector.js
var require_MagicWeb3Connector = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/MagicWeb3Connector.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$keys = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _concat = _interopRequireDefault(require_concat4());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    var _AbstractWeb3Connector = _interopRequireDefault(require_AbstractWeb3Connector());
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context4, _context5;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty(_context4 = ownKeys5(Object(source), true)).call(_context4, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context5 = ownKeys5(Object(source))).call(_context5, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var MagicWeb3Connector = function(_AbstractWeb3Connecto) {
      (0, _inherits2.default)(MagicWeb3Connector2, _AbstractWeb3Connecto);
      var _super = _createSuper(MagicWeb3Connector2);
      function MagicWeb3Connector2() {
        var _context;
        var _this;
        (0, _classCallCheck2.default)(this, MagicWeb3Connector2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, (0, _concat.default)(_context = [this]).call(_context, args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "type", "MagicLink");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "deactivate", (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
          return _regenerator.default.wrap(function(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this.unsubscribeToEvents(_this.provider);
                  if (!_this.magicUser) {
                    _context2.next = 4;
                    break;
                  }
                  _context2.next = 4;
                  return _this.magicUser.user.logout();
                case 4:
                  _this.account = null;
                  _this.chainId = null;
                  _this.provider = null;
                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee);
        })));
        return _this;
      }
      (0, _createClass2.default)(MagicWeb3Connector2, [{
        key: "activate",
        value: function() {
          var _activate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            var _ref2, apiKey, newSession, email, showUI, redirectURI, network, locale, extensions, testMode, endpoint, magic, ether, Magic, _require, _window, _magic, _magic2, _magic2$user, loggedIn, signer, _yield$ether$getNetwo, chainId, address, _args2 = arguments;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _ref2 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, apiKey = _ref2.apiKey, newSession = _ref2.newSession, email = _ref2.email, showUI = _ref2.showUI, redirectURI = _ref2.redirectURI, network = _ref2.network, locale = _ref2.locale, extensions = _ref2.extensions, testMode = _ref2.testMode, endpoint = _ref2.endpoint;
                    magic = null;
                    ether = null;
                    if (email) {
                      _context3.next = 5;
                      break;
                    }
                    throw new Error('"email" not provided, please provide Email');
                  case 5:
                    if (apiKey) {
                      _context3.next = 7;
                      break;
                    }
                    throw new Error('"apiKey" not provided, please provide Api Key');
                  case 7:
                    if (network) {
                      _context3.next = 9;
                      break;
                    }
                    throw new Error('"network" not provided, please provide network');
                  case 9:
                    try {
                      Magic = (_require = require_cjs4()) === null || _require === void 0 ? void 0 : _require.Magic;
                    } catch (error) {
                    }
                    if (!Magic) {
                      Magic = (_window = window) === null || _window === void 0 ? void 0 : _window.Magic;
                    }
                    if (Magic) {
                      _context3.next = 13;
                      break;
                    }
                    throw new Error('Cannot enable via MagicLink: dependency "magic-sdk" is missing');
                  case 13:
                    _context3.prev = 13;
                    magic = new Magic(apiKey, _objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5({
                      network
                    }, locale && {
                      locale
                    }), extensions && {
                      extensions
                    }), testMode && {
                      testMode
                    }), endpoint && {
                      endpoint
                    }));
                    if (!newSession) {
                      _context3.next = 24;
                      break;
                    }
                    if (!((_magic = magic) !== null && _magic !== void 0 && _magic.user)) {
                      _context3.next = 24;
                      break;
                    }
                    _context3.prev = 17;
                    _context3.next = 20;
                    return (_magic2 = magic) === null || _magic2 === void 0 ? void 0 : (_magic2$user = _magic2.user) === null || _magic2$user === void 0 ? void 0 : _magic2$user.logout();
                  case 20:
                    _context3.next = 24;
                    break;
                  case 22:
                    _context3.prev = 22;
                    _context3.t0 = _context3["catch"](17);
                  case 24:
                    ether = new _ethers.ethers.providers.Web3Provider(magic.rpcProvider);
                    _context3.next = 27;
                    return magic.auth.loginWithMagicLink(_objectSpread5(_objectSpread5({
                      email
                    }, showUI && {
                      showUI
                    }), redirectURI && {
                      redirectURI
                    }));
                  case 27:
                    _context3.next = 32;
                    break;
                  case 29:
                    _context3.prev = 29;
                    _context3.t1 = _context3["catch"](13);
                    throw new Error("Error during enable via MagicLink, please double check network and apikey");
                  case 32:
                    _context3.next = 34;
                    return magic.user.isLoggedIn();
                  case 34:
                    loggedIn = _context3.sent;
                    if (!loggedIn) {
                      _context3.next = 50;
                      break;
                    }
                    signer = ether.getSigner();
                    _context3.next = 39;
                    return ether.getNetwork();
                  case 39:
                    _yield$ether$getNetwo = _context3.sent;
                    chainId = _yield$ether$getNetwo.chainId;
                    _context3.next = 43;
                    return signer.getAddress();
                  case 43:
                    address = _context3.sent.toLowerCase();
                    this.account = address;
                    this.provider = ether.provider;
                    this.chainId = "0x".concat(chainId.toString(16));
                    this.magicUser = magic;
                    this.subscribeToEvents(this.provider);
                    return _context3.abrupt("return", {
                      provider: this.provider,
                      account: this.account,
                      chainId: this.chainId
                    });
                  case 50:
                    throw new Error("Error during enable via MagicLink, login to magic failed");
                  case 51:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, this, [[13, 29], [17, 22]]);
          }));
          return function() {
            return _activate.apply(this, arguments);
          };
        }()
      }]);
      return MagicWeb3Connector2;
    }(_AbstractWeb3Connector.default);
    exports.default = MagicWeb3Connector;
  }
});

// node_modules/@web3auth/base-plugin/dist/basePlugin.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
var PLUGIN_NAMESPACES;
var init_basePlugin_esm = __esm({
  "node_modules/@web3auth/base-plugin/dist/basePlugin.esm.js"() {
    init_defineProperty();
    init_base_esm();
    PLUGIN_NAMESPACES = _objectSpread(_objectSpread({}, CHAIN_NAMESPACES), {}, {
      MULTICHAIN: "multichain"
    });
  }
});

// node_modules/@web3auth/core/dist/core.esm.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
var ADAPTER_CACHE_KEY, Web3AuthCore;
var init_core_esm = __esm({
  "node_modules/@web3auth/core/dist/core.esm.js"() {
    init_defineProperty();
    init_openloginJrpc_esm();
    init_base_esm();
    init_basePlugin_esm();
    ADAPTER_CACHE_KEY = "Web3Auth-cachedAdapter";
    Web3AuthCore = class extends SafeEventEmitter {
      constructor(options) {
        var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;
        super();
        _defineProperty(this, "coreOptions", void 0);
        _defineProperty(this, "connectedAdapterName", null);
        _defineProperty(this, "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(this, "cachedAdapter", null);
        _defineProperty(this, "walletAdapters", {});
        _defineProperty(this, "plugins", {});
        _defineProperty(this, "storage", "localStorage");
        if (options.enableLogging)
          log.enableAll();
        else
          log.disableAll();
        if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace))
          throw WalletInitializationError.invalidParams("Please provide a valid chainNamespace in chainConfig");
        if (options.storageKey === "session")
          this.storage = "sessionStorage";
        this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;
        this.coreOptions = _objectSpread2(_objectSpread2({}, options), {}, {
          chainConfig: _objectSpread2(_objectSpread2({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)
        });
        this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);
      }
      get provider() {
        if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {
          const adapter = this.walletAdapters[this.connectedAdapterName];
          return adapter.provider;
        }
        return null;
      }
      set provider(_2) {
        throw new Error("Not implemented");
      }
      async init() {
        const initPromises = Object.keys(this.walletAdapters).map((adapterName) => {
          this.subscribeToAdapterEvents(this.walletAdapters[adapterName]);
          if (!this.walletAdapters[adapterName].chainConfigProxy) {
            const providedChainConfig = this.coreOptions.chainConfig;
            if (!providedChainConfig.chainNamespace)
              throw WalletInitializationError.invalidParams("Please provide chainNamespace in chainConfig");
            const chainConfig = _objectSpread2(_objectSpread2({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);
            this.walletAdapters[adapterName].setChainConfig(chainConfig);
          }
          return this.walletAdapters[adapterName].init({
            autoConnect: this.cachedAdapter === adapterName
          }).catch((e) => log.error(e));
        });
        this.status = ADAPTER_STATUS.READY;
        await Promise.all(initPromises);
      }
      configureAdapter(adapter) {
        this.checkInitRequirements();
        const providedChainConfig = this.coreOptions.chainConfig;
        if (!providedChainConfig.chainNamespace)
          throw WalletInitializationError.invalidParams("Please provide chainNamespace in chainConfig");
        const adapterAlreadyExists = this.walletAdapters[adapter.name];
        if (adapterAlreadyExists)
          throw WalletInitializationError.duplicateAdapterError("Wallet adapter for ".concat(adapter.name, " already exists"));
        if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace)
          throw WalletInitializationError.incompatibleChainNameSpace("This wallet adapter belongs to ".concat(adapter.adapterNamespace, " which is incompatible with currently used namespace: ").concat(providedChainConfig.chainNamespace));
        if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {
          adapter.setChainConfig(providedChainConfig);
        }
        this.walletAdapters[adapter.name] = adapter;
        return this;
      }
      clearCache() {
        if (!storageAvailable(this.storage))
          return;
        window[this.storage].removeItem(ADAPTER_CACHE_KEY);
        this.cachedAdapter = null;
      }
      /**
       * Connect to a specific wallet adapter
       * @param walletName - Key of the walletAdapter to use.
       */
      async connectTo(walletName, loginParams) {
        if (!this.walletAdapters[walletName])
          throw WalletInitializationError.notFound("Please add wallet adapter for ".concat(walletName, " wallet, before connecting"));
        const provider = await this.walletAdapters[walletName].connect(loginParams);
        return provider;
      }
      async logout() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          cleanup: false
        };
        if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)
          throw WalletLoginError.notConnectedError("No wallet is connected");
        await this.walletAdapters[this.connectedAdapterName].disconnect(options);
      }
      async getUserInfo() {
        log.debug("Getting user info", this.status, this.connectedAdapterName);
        if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)
          throw WalletLoginError.notConnectedError("No wallet is connected");
        return this.walletAdapters[this.connectedAdapterName].getUserInfo();
      }
      async authenticateUser() {
        if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)
          throw WalletLoginError.notConnectedError("No wallet is connected");
        return this.walletAdapters[this.connectedAdapterName].authenticateUser();
      }
      async addPlugin(plugin) {
        if (this.plugins[plugin.name])
          throw new Error("Plugin ".concat(plugin.name, " already exist"));
        if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace)
          throw new Error("This plugin belongs to ".concat(plugin.pluginNamespace, " namespace which is incompatible with currently used namespace: ").concat(this.coreOptions.chainConfig.chainNamespace));
        this.plugins[plugin.name] = plugin;
        await plugin.initWithWeb3Auth(this);
        return this;
      }
      subscribeToAdapterEvents(walletAdapter) {
        walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async (data) => {
          this.status = ADAPTER_STATUS.CONNECTED;
          this.connectedAdapterName = data.adapter;
          this.cacheWallet(data.adapter);
          log.debug("connected", this.status, this.connectedAdapterName);
          await Promise.all(Object.values(this.plugins).map((plugin) => {
            return plugin.connect().catch((error) => {
              if (error.code === 5211) {
                return;
              }
              log.error(error);
            });
          }));
          this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread2({}, data));
        });
        walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async (data) => {
          this.status = ADAPTER_STATUS.READY;
          if (storageAvailable(this.storage)) {
            const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);
            if (this.connectedAdapterName === cachedAdapter) {
              this.clearCache();
            }
          }
          log.debug("disconnected", this.status, this.connectedAdapterName);
          await Promise.all(Object.values(this.plugins).map((plugin) => {
            return plugin.disconnect().catch((error) => {
              if (error.code === 5211) {
                return;
              }
              log.error(error);
            });
          }));
          this.connectedAdapterName = null;
          this.emit(ADAPTER_EVENTS.DISCONNECTED, data);
        });
        walletAdapter.on(ADAPTER_EVENTS.CONNECTING, (data) => {
          this.status = ADAPTER_STATUS.CONNECTING;
          this.emit(ADAPTER_EVENTS.CONNECTING, data);
          log.debug("connecting", this.status, this.connectedAdapterName);
        });
        walletAdapter.on(ADAPTER_EVENTS.ERRORED, (data) => {
          this.status = ADAPTER_STATUS.ERRORED;
          this.clearCache();
          this.emit(ADAPTER_EVENTS.ERRORED, data);
          log.debug("errored", this.status, this.connectedAdapterName);
        });
        walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, (data) => {
          log.debug("adapter data updated", data);
          this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);
        });
      }
      checkInitRequirements() {
        if (this.status === ADAPTER_STATUS.CONNECTING)
          throw WalletInitializationError.notReady("Already pending connection");
        if (this.status === ADAPTER_STATUS.CONNECTED)
          throw WalletInitializationError.notReady("Already connected");
        if (this.status === ADAPTER_STATUS.READY)
          throw WalletInitializationError.notReady("Adapter is already initialized");
      }
      cacheWallet(walletName) {
        if (!storageAvailable(this.storage))
          return;
        window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);
        this.cachedAdapter = walletName;
      }
    };
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key2) {
      return this.has(key2) && delete this.__data__[key2];
    }
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
    }
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
    }
    function hashSet(key2, value) {
      var data = this.__data__;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key2) {
      return getMapData(this, key2)["delete"](key2);
    }
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    function mapCacheSet(key2, value) {
      getMapData(this, key2).set(key2, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key2) {
      return this.__data__["delete"](key2);
    }
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    function stackSet(key2, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key2, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && (key2 == "length" || isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty.call(object, key2) && eq4(objValue, value)) || value === void 0 && !(key2 in object)) {
        object[key2] = value;
      }
    }
    function assocIndexOf(array, key2) {
      var length = array.length;
      while (length--) {
        if (eq4(array[length][0], key2)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key2, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key2, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, isDeep, isFull, customizer, key3, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
        assignValue(object, key2, newValue === void 0 ? source[key2] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key2) {
      var data = map.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq4(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  }
});

// node_modules/qr.js/lib/mode.js
var require_mode = __commonJS({
  "node_modules/qr.js/lib/mode.js"(exports, module) {
    module.exports = {
      MODE_NUMBER: 1 << 0,
      MODE_ALPHA_NUM: 1 << 1,
      MODE_8BIT_BYTE: 1 << 2,
      MODE_KANJI: 1 << 3
    };
  }
});

// node_modules/qr.js/lib/8BitByte.js
var require_BitByte = __commonJS({
  "node_modules/qr.js/lib/8BitByte.js"(exports, module) {
    var mode = require_mode();
    function QR8bitByte(data) {
      this.mode = mode.MODE_8BIT_BYTE;
      this.data = data;
    }
    QR8bitByte.prototype = {
      getLength: function(buffer) {
        return this.data.length;
      },
      write: function(buffer) {
        for (var i2 = 0; i2 < this.data.length; i2++) {
          buffer.put(this.data.charCodeAt(i2), 8);
        }
      }
    };
    module.exports = QR8bitByte;
  }
});

// node_modules/qr.js/lib/ErrorCorrectLevel.js
var require_ErrorCorrectLevel = __commonJS({
  "node_modules/qr.js/lib/ErrorCorrectLevel.js"(exports, module) {
    module.exports = {
      L: 1,
      M: 0,
      Q: 3,
      H: 2
    };
  }
});

// node_modules/qr.js/lib/RSBlock.js
var require_RSBlock = __commonJS({
  "node_modules/qr.js/lib/RSBlock.js"(exports, module) {
    var ECL = require_ErrorCorrectLevel();
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [
      // L
      // M
      // Q
      // H
      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],
      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],
      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],
      // 4		
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],
      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],
      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],
      // 7		
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],
      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],
      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],
      // 10		
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],
      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],
      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],
      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],
      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],
      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12],
      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],
      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],
      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],
      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],
      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],
      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],
      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],
      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],
      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],
      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],
      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],
      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],
      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],
      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],
      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],
      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],
      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],
      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],
      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],
      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],
      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],
      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],
      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],
      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],
      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = new Array();
      for (var i2 = 0; i2 < length; i2++) {
        var count = rsBlock[i2 * 3 + 0];
        var totalCount = rsBlock[i2 * 3 + 1];
        var dataCount = rsBlock[i2 * 3 + 2];
        for (var j2 = 0; j2 < count; j2++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case ECL.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case ECL.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case ECL.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case ECL.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    module.exports = QRRSBlock;
  }
});

// node_modules/qr.js/lib/BitBuffer.js
var require_BitBuffer = __commonJS({
  "node_modules/qr.js/lib/BitBuffer.js"(exports, module) {
    function QRBitBuffer() {
      this.buffer = new Array();
      this.length = 0;
    }
    QRBitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
      },
      put: function(num, length) {
        for (var i2 = 0; i2 < length; i2++) {
          this.putBit((num >>> length - i2 - 1 & 1) == 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = QRBitBuffer;
  }
});

// node_modules/qr.js/lib/math.js
var require_math = __commonJS({
  "node_modules/qr.js/lib/math.js"(exports, module) {
    var QRMath = {
      glog: function(n2) {
        if (n2 < 1) {
          throw new Error("glog(" + n2 + ")");
        }
        return QRMath.LOG_TABLE[n2];
      },
      gexp: function(n2) {
        while (n2 < 0) {
          n2 += 255;
        }
        while (n2 >= 256) {
          n2 -= 255;
        }
        return QRMath.EXP_TABLE[n2];
      },
      EXP_TABLE: new Array(256),
      LOG_TABLE: new Array(256)
    };
    for (i2 = 0; i2 < 8; i2++) {
      QRMath.EXP_TABLE[i2] = 1 << i2;
    }
    var i2;
    for (i2 = 8; i2 < 256; i2++) {
      QRMath.EXP_TABLE[i2] = QRMath.EXP_TABLE[i2 - 4] ^ QRMath.EXP_TABLE[i2 - 5] ^ QRMath.EXP_TABLE[i2 - 6] ^ QRMath.EXP_TABLE[i2 - 8];
    }
    var i2;
    for (i2 = 0; i2 < 255; i2++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i2]] = i2;
    }
    var i2;
    module.exports = QRMath;
  }
});

// node_modules/qr.js/lib/Polynomial.js
var require_Polynomial = __commonJS({
  "node_modules/qr.js/lib/Polynomial.js"(exports, module) {
    var math = require_math();
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset++;
      }
      this.num = new Array(num.length - offset + shift);
      for (var i2 = 0; i2 < num.length - offset; i2++) {
        this.num[i2] = num[i2 + offset];
      }
    }
    QRPolynomial.prototype = {
      get: function(index) {
        return this.num[index];
      },
      getLength: function() {
        return this.num.length;
      },
      multiply: function(e) {
        var num = new Array(this.getLength() + e.getLength() - 1);
        for (var i2 = 0; i2 < this.getLength(); i2++) {
          for (var j2 = 0; j2 < e.getLength(); j2++) {
            num[i2 + j2] ^= math.gexp(math.glog(this.get(i2)) + math.glog(e.get(j2)));
          }
        }
        return new QRPolynomial(num, 0);
      },
      mod: function(e) {
        if (this.getLength() - e.getLength() < 0) {
          return this;
        }
        var ratio = math.glog(this.get(0)) - math.glog(e.get(0));
        var num = new Array(this.getLength());
        for (var i2 = 0; i2 < this.getLength(); i2++) {
          num[i2] = this.get(i2);
        }
        for (var i2 = 0; i2 < e.getLength(); i2++) {
          num[i2] ^= math.gexp(math.glog(e.get(i2)) + ratio);
        }
        return new QRPolynomial(num, 0).mod(e);
      }
    };
    module.exports = QRPolynomial;
  }
});

// node_modules/qr.js/lib/util.js
var require_util = __commonJS({
  "node_modules/qr.js/lib/util.js"(exports, module) {
    var Mode = require_mode();
    var Polynomial = require_Polynomial();
    var math = require_math();
    var QRMaskPattern = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var QRUtil = {
      PATTERN_POSITION_TABLE: [
        [],
        [6, 18],
        [6, 22],
        [6, 26],
        [6, 30],
        [6, 34],
        [6, 22, 38],
        [6, 24, 42],
        [6, 26, 46],
        [6, 28, 50],
        [6, 30, 54],
        [6, 32, 58],
        [6, 34, 62],
        [6, 26, 46, 66],
        [6, 26, 48, 70],
        [6, 26, 50, 74],
        [6, 30, 54, 78],
        [6, 30, 56, 82],
        [6, 30, 58, 86],
        [6, 34, 62, 90],
        [6, 28, 50, 72, 94],
        [6, 26, 50, 74, 98],
        [6, 30, 54, 78, 102],
        [6, 28, 54, 80, 106],
        [6, 32, 58, 84, 110],
        [6, 30, 58, 86, 114],
        [6, 34, 62, 90, 118],
        [6, 26, 50, 74, 98, 122],
        [6, 30, 54, 78, 102, 126],
        [6, 26, 52, 78, 104, 130],
        [6, 30, 56, 82, 108, 134],
        [6, 34, 60, 86, 112, 138],
        [6, 30, 58, 86, 114, 142],
        [6, 34, 62, 90, 118, 146],
        [6, 30, 54, 78, 102, 126, 150],
        [6, 24, 50, 76, 102, 128, 154],
        [6, 28, 54, 80, 106, 132, 158],
        [6, 32, 58, 84, 110, 136, 162],
        [6, 26, 54, 82, 110, 138, 166],
        [6, 30, 58, 86, 114, 142, 170]
      ],
      G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
      G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
      G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
      getBCHTypeInfo: function(data) {
        var d2 = data << 10;
        while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
          d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
        }
        return (data << 10 | d2) ^ QRUtil.G15_MASK;
      },
      getBCHTypeNumber: function(data) {
        var d2 = data << 12;
        while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
          d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
        }
        return data << 12 | d2;
      },
      getBCHDigit: function(data) {
        var digit = 0;
        while (data != 0) {
          digit++;
          data >>>= 1;
        }
        return digit;
      },
      getPatternPosition: function(typeNumber) {
        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
      },
      getMask: function(maskPattern, i2, j2) {
        switch (maskPattern) {
          case QRMaskPattern.PATTERN000:
            return (i2 + j2) % 2 == 0;
          case QRMaskPattern.PATTERN001:
            return i2 % 2 == 0;
          case QRMaskPattern.PATTERN010:
            return j2 % 3 == 0;
          case QRMaskPattern.PATTERN011:
            return (i2 + j2) % 3 == 0;
          case QRMaskPattern.PATTERN100:
            return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 == 0;
          case QRMaskPattern.PATTERN101:
            return i2 * j2 % 2 + i2 * j2 % 3 == 0;
          case QRMaskPattern.PATTERN110:
            return (i2 * j2 % 2 + i2 * j2 % 3) % 2 == 0;
          case QRMaskPattern.PATTERN111:
            return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 == 0;
          default:
            throw new Error("bad maskPattern:" + maskPattern);
        }
      },
      getErrorCorrectPolynomial: function(errorCorrectLength) {
        var a2 = new Polynomial([1], 0);
        for (var i2 = 0; i2 < errorCorrectLength; i2++) {
          a2 = a2.multiply(new Polynomial([1, math.gexp(i2)], 0));
        }
        return a2;
      },
      getLengthInBits: function(mode, type) {
        if (1 <= type && type < 10) {
          switch (mode) {
            case Mode.MODE_NUMBER:
              return 10;
            case Mode.MODE_ALPHA_NUM:
              return 9;
            case Mode.MODE_8BIT_BYTE:
              return 8;
            case Mode.MODE_KANJI:
              return 8;
            default:
              throw new Error("mode:" + mode);
          }
        } else if (type < 27) {
          switch (mode) {
            case Mode.MODE_NUMBER:
              return 12;
            case Mode.MODE_ALPHA_NUM:
              return 11;
            case Mode.MODE_8BIT_BYTE:
              return 16;
            case Mode.MODE_KANJI:
              return 10;
            default:
              throw new Error("mode:" + mode);
          }
        } else if (type < 41) {
          switch (mode) {
            case Mode.MODE_NUMBER:
              return 14;
            case Mode.MODE_ALPHA_NUM:
              return 13;
            case Mode.MODE_8BIT_BYTE:
              return 16;
            case Mode.MODE_KANJI:
              return 12;
            default:
              throw new Error("mode:" + mode);
          }
        } else {
          throw new Error("type:" + type);
        }
      },
      getLostPoint: function(qrCode) {
        var moduleCount = qrCode.getModuleCount();
        var lostPoint = 0;
        for (var row = 0; row < moduleCount; row++) {
          for (var col = 0; col < moduleCount; col++) {
            var sameCount = 0;
            var dark = qrCode.isDark(row, col);
            for (var r2 = -1; r2 <= 1; r2++) {
              if (row + r2 < 0 || moduleCount <= row + r2) {
                continue;
              }
              for (var c2 = -1; c2 <= 1; c2++) {
                if (col + c2 < 0 || moduleCount <= col + c2) {
                  continue;
                }
                if (r2 == 0 && c2 == 0) {
                  continue;
                }
                if (dark == qrCode.isDark(row + r2, col + c2)) {
                  sameCount++;
                }
              }
            }
            if (sameCount > 5) {
              lostPoint += 3 + sameCount - 5;
            }
          }
        }
        for (var row = 0; row < moduleCount - 1; row++) {
          for (var col = 0; col < moduleCount - 1; col++) {
            var count = 0;
            if (qrCode.isDark(row, col))
              count++;
            if (qrCode.isDark(row + 1, col))
              count++;
            if (qrCode.isDark(row, col + 1))
              count++;
            if (qrCode.isDark(row + 1, col + 1))
              count++;
            if (count == 0 || count == 4) {
              lostPoint += 3;
            }
          }
        }
        for (var row = 0; row < moduleCount; row++) {
          for (var col = 0; col < moduleCount - 6; col++) {
            if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
              lostPoint += 40;
            }
          }
        }
        for (var col = 0; col < moduleCount; col++) {
          for (var row = 0; row < moduleCount - 6; row++) {
            if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
              lostPoint += 40;
            }
          }
        }
        var darkCount = 0;
        for (var col = 0; col < moduleCount; col++) {
          for (var row = 0; row < moduleCount; row++) {
            if (qrCode.isDark(row, col)) {
              darkCount++;
            }
          }
        }
        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
        lostPoint += ratio * 10;
        return lostPoint;
      }
    };
    module.exports = QRUtil;
  }
});

// node_modules/qr.js/lib/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/qr.js/lib/QRCode.js"(exports, module) {
    var BitByte = require_BitByte();
    var RSBlock = require_RSBlock();
    var BitBuffer = require_BitBuffer();
    var util = require_util();
    var Polynomial = require_Polynomial();
    function QRCode2(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    var proto = QRCode2.prototype;
    proto.addData = function(data) {
      var newData = new BitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    };
    proto.isDark = function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    };
    proto.getModuleCount = function() {
      return this.moduleCount;
    };
    proto.make = function() {
      if (this.typeNumber < 1) {
        var typeNumber = 1;
        for (typeNumber = 1; typeNumber < 40; typeNumber++) {
          var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
          var buffer = new BitBuffer();
          var totalDataCount = 0;
          for (var i2 = 0; i2 < rsBlocks.length; i2++) {
            totalDataCount += rsBlocks[i2].dataCount;
          }
          for (var i2 = 0; i2 < this.dataList.length; i2++) {
            var data = this.dataList[i2];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          if (buffer.getLengthInBits() <= totalDataCount * 8)
            break;
        }
        this.typeNumber = typeNumber;
      }
      this.makeImpl(false, this.getBestMaskPattern());
    };
    proto.makeImpl = function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCode2.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    };
    proto.setupPositionProbePattern = function(row, col) {
      for (var r2 = -1; r2 <= 7; r2++) {
        if (row + r2 <= -1 || this.moduleCount <= row + r2)
          continue;
        for (var c2 = -1; c2 <= 7; c2++) {
          if (col + c2 <= -1 || this.moduleCount <= col + c2)
            continue;
          if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
            this.modules[row + r2][col + c2] = true;
          } else {
            this.modules[row + r2][col + c2] = false;
          }
        }
      }
    };
    proto.getBestMaskPattern = function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i2 = 0; i2 < 8; i2++) {
        this.makeImpl(true, i2);
        var lostPoint = util.getLostPoint(this);
        if (i2 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i2;
        }
      }
      return pattern;
    };
    proto.createMovieClip = function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y2 = row * cs;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x2 = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x2, y2);
            qr_mc.lineTo(x2 + cs, y2);
            qr_mc.lineTo(x2 + cs, y2 + cs);
            qr_mc.lineTo(x2, y2 + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    };
    proto.setupTimingPattern = function() {
      for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
        if (this.modules[r2][6] != null) {
          continue;
        }
        this.modules[r2][6] = r2 % 2 == 0;
      }
      for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
        if (this.modules[6][c2] != null) {
          continue;
        }
        this.modules[6][c2] = c2 % 2 == 0;
      }
    };
    proto.setupPositionAdjustPattern = function() {
      var pos = util.getPatternPosition(this.typeNumber);
      for (var i2 = 0; i2 < pos.length; i2++) {
        for (var j2 = 0; j2 < pos.length; j2++) {
          var row = pos[i2];
          var col = pos[j2];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r2 = -2; r2 <= 2; r2++) {
            for (var c2 = -2; c2 <= 2; c2++) {
              if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
                this.modules[row + r2][col + c2] = true;
              } else {
                this.modules[row + r2][col + c2] = false;
              }
            }
          }
        }
      }
    };
    proto.setupTypeNumber = function(test) {
      var bits = util.getBCHTypeNumber(this.typeNumber);
      for (var i2 = 0; i2 < 18; i2++) {
        var mod = !test && (bits >> i2 & 1) == 1;
        this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (var i2 = 0; i2 < 18; i2++) {
        var mod = !test && (bits >> i2 & 1) == 1;
        this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;
      }
    };
    proto.setupTypeInfo = function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = util.getBCHTypeInfo(data);
      for (var i2 = 0; i2 < 15; i2++) {
        var mod = !test && (bits >> i2 & 1) == 1;
        if (i2 < 6) {
          this.modules[i2][8] = mod;
        } else if (i2 < 8) {
          this.modules[i2 + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i2][8] = mod;
        }
      }
      for (var i2 = 0; i2 < 15; i2++) {
        var mod = !test && (bits >> i2 & 1) == 1;
        if (i2 < 8) {
          this.modules[8][this.moduleCount - i2 - 1] = mod;
        } else if (i2 < 9) {
          this.modules[8][15 - i2 - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i2 - 1] = mod;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    };
    proto.mapData = function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c2 = 0; c2 < 2; c2++) {
            if (this.modules[row][col - c2] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask = util.getMask(maskPattern, row, col - c2);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c2] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };
    QRCode2.PAD0 = 236;
    QRCode2.PAD1 = 17;
    QRCode2.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer = new BitBuffer();
      for (var i2 = 0; i2 < dataList.length; i2++) {
        var data = dataList[i2];
        buffer.put(data.mode, 4);
        buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
        data.write(buffer);
      }
      var totalDataCount = 0;
      for (var i2 = 0; i2 < rsBlocks.length; i2++) {
        totalDataCount += rsBlocks[i2].dataCount;
      }
      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }
      while (true) {
        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(QRCode2.PAD0, 8);
        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(QRCode2.PAD1, 8);
      }
      return QRCode2.createBytes(buffer, rsBlocks);
    };
    QRCode2.createBytes = function(buffer, rsBlocks) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r2 = 0; r2 < rsBlocks.length; r2++) {
        var dcCount = rsBlocks[r2].dataCount;
        var ecCount = rsBlocks[r2].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r2] = new Array(dcCount);
        for (var i2 = 0; i2 < dcdata[r2].length; i2++) {
          dcdata[r2][i2] = 255 & buffer.buffer[i2 + offset];
        }
        offset += dcCount;
        var rsPoly = util.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new Polynomial(dcdata[r2], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r2] = new Array(rsPoly.getLength() - 1);
        for (var i2 = 0; i2 < ecdata[r2].length; i2++) {
          var modIndex = i2 + modPoly.getLength() - ecdata[r2].length;
          ecdata[r2][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i2 = 0; i2 < rsBlocks.length; i2++) {
        totalCodeCount += rsBlocks[i2].totalCount;
      }
      var data = new Array(totalCodeCount);
      var index = 0;
      for (var i2 = 0; i2 < maxDcCount; i2++) {
        for (var r2 = 0; r2 < rsBlocks.length; r2++) {
          if (i2 < dcdata[r2].length) {
            data[index++] = dcdata[r2][i2];
          }
        }
      }
      for (var i2 = 0; i2 < maxEcCount; i2++) {
        for (var r2 = 0; r2 < rsBlocks.length; r2++) {
          if (i2 < ecdata[r2].length) {
            data[index++] = ecdata[r2][i2];
          }
        }
      }
      return data;
    };
    module.exports = QRCode2;
  }
});

// node_modules/object-assign/index.js
var require_object_assign2 = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from = Object(arguments[s2]);
        for (var key2 in from) {
          if (hasOwnProperty.call(from, key2)) {
            to[key2] = from[key2];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign2();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x2, y2) {
        if (x2 === y2) {
          return x2 !== 0 || 1 / x2 === 1 / y2;
        } else {
          return x2 !== x2 && y2 !== y2;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate6) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate6(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate6(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate6(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createElementTypeChecker() {
        function validate6(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createElementTypeTypeChecker() {
        function validate6(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate6(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate6(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key2, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate6);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate6(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key2 in propValue) {
            if (has(propValue, key2)) {
              var error = typeChecker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate6(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate6);
      }
      function createNodeChecker() {
        function validate6(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function invalidValidatorError(componentName, location, propFullName, key2, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key2 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate6(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key2 in shapeTypes) {
            var checker = shapeTypes[key2];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
            }
            var error = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate6(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key2 in allKeys) {
            var checker = shapeTypes[key2];
            if (has(shapeTypes, key2) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key2 + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate6);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-qr-code/lib/QRCodeSvg/index.js
var require_QRCodeSvg = __commonJS({
  "node_modules/react-qr-code/lib/QRCodeSvg/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    var _propTypes = require_prop_types();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i2 in obj) {
        if (keys.indexOf(i2) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i2))
          continue;
        target[i2] = obj[i2];
      }
      return target;
    }
    var propTypes = {
      bgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]).isRequired,
      bgD: _propTypes2.default.string.isRequired,
      fgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]).isRequired,
      fgD: _propTypes2.default.string.isRequired,
      size: _propTypes2.default.number.isRequired,
      title: _propTypes2.default.string,
      viewBoxSize: _propTypes2.default.number.isRequired,
      xmlns: _propTypes2.default.string
    };
    var defaultProps = {
      title: void 0,
      xmlns: "http://www.w3.org/2000/svg"
    };
    var QRCodeSvg = (0, _react.forwardRef)(function(_ref, ref) {
      var bgColor = _ref.bgColor, bgD = _ref.bgD, fgD = _ref.fgD, fgColor = _ref.fgColor, size = _ref.size, title = _ref.title, viewBoxSize = _ref.viewBoxSize, props = _objectWithoutProperties(_ref, ["bgColor", "bgD", "fgD", "fgColor", "size", "title", "viewBoxSize"]);
      return _react2.default.createElement(
        "svg",
        _extends({}, props, { height: size, ref, viewBox: "0 0 " + viewBoxSize + " " + viewBoxSize, width: size }),
        title ? _react2.default.createElement(
          "title",
          null,
          title
        ) : null,
        _react2.default.createElement("path", { d: bgD, fill: bgColor }),
        _react2.default.createElement("path", { d: fgD, fill: fgColor })
      );
    });
    QRCodeSvg.displayName = "QRCodeSvg";
    QRCodeSvg.propTypes = propTypes;
    QRCodeSvg.defaultProps = defaultProps;
    exports.default = QRCodeSvg;
  }
});

// node_modules/react-qr-code/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-qr-code/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.QRCode = void 0;
    var _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    var _QRCode = require_QRCode();
    var _QRCode2 = _interopRequireDefault(_QRCode);
    var _ErrorCorrectLevel = require_ErrorCorrectLevel();
    var _ErrorCorrectLevel2 = _interopRequireDefault(_ErrorCorrectLevel);
    var _propTypes = require_prop_types();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _QRCodeSvg = require_QRCodeSvg();
    var _QRCodeSvg2 = _interopRequireDefault(_QRCodeSvg);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i2 in obj) {
        if (keys.indexOf(i2) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i2))
          continue;
        target[i2] = obj[i2];
      }
      return target;
    }
    var propTypes = {
      bgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),
      fgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),
      level: _propTypes2.default.string,
      size: _propTypes2.default.number,
      value: _propTypes2.default.string.isRequired
    };
    var defaultProps = {
      bgColor: "#FFFFFF",
      fgColor: "#000000",
      level: "L",
      size: 256
    };
    var QRCode2 = (0, _react.forwardRef)(function(_ref, ref) {
      var bgColor = _ref.bgColor, fgColor = _ref.fgColor, level = _ref.level, size = _ref.size, value = _ref.value, props = _objectWithoutProperties(_ref, ["bgColor", "fgColor", "level", "size", "value"]);
      var qrcode = new _QRCode2.default(-1, _ErrorCorrectLevel2.default[level]);
      qrcode.addData(value);
      qrcode.make();
      var cells = qrcode.modules;
      return _react2.default.createElement(_QRCodeSvg2.default, _extends({}, props, {
        bgColor,
        bgD: cells.map(function(row, rowIndex) {
          return row.map(function(cell, cellIndex) {
            return !cell ? "M " + cellIndex + " " + rowIndex + " l 1 0 0 1 -1 0 Z" : "";
          }).join(" ");
        }).join(" "),
        fgColor,
        fgD: cells.map(function(row, rowIndex) {
          return row.map(function(cell, cellIndex) {
            return cell ? "M " + cellIndex + " " + rowIndex + " l 1 0 0 1 -1 0 Z" : "";
          }).join(" ");
        }).join(" "),
        ref,
        size,
        viewBoxSize: cells.length
      }));
    });
    exports.QRCode = QRCode2;
    QRCode2.displayName = "QRCode";
    QRCode2.propTypes = propTypes;
    QRCode2.defaultProps = defaultProps;
    exports.default = QRCode2;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key2 in arg) {
          if (hasOwn.call(arg, key2) && arg[key2]) {
            classes = appendClass(classes, key2);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/@web3auth/ui/dist/ui.esm.js
function styleInject(css, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
function Icon(props) {
  const {
    iconName,
    height = "auto",
    width = "auto"
  } = props;
  return icons[iconName] ? (0, import_jsx_runtime.jsx)("img", {
    height,
    width,
    src: icons[iconName].image,
    alt: iconName
  }) : null;
}
function Image$1(props) {
  const {
    imageId,
    height = "auto",
    width = "auto"
  } = props;
  return (0, import_jsx_runtime.jsx)("img", {
    src: "https://images.web3auth.io/".concat(imageId, ".svg"),
    height,
    width,
    alt: imageId
  });
}
function DetailedLoader(props) {
  const {
    adapter,
    appLogo = DEFAULT_LOGO_URL$2,
    message,
    modalStatus,
    onClose
  } = props;
  const web3authIcon = (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: "web3auth"
  });
  const providerIcon = (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: "login-".concat(adapter)
  });
  (0, import_react.useEffect)(() => {
    log.debug("adapter loader re-rendering");
    if (modalStatus === MODAL_STATUS.CONNECTED) {
      setTimeout(() => {
        onClose();
      }, 3e3);
    }
  }, [modalStatus, onClose]);
  return modalStatus !== MODAL_STATUS.INITIALIZED ? (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-modal-loader w3a-modal__loader",
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-modal__loader-content",
      children: [(0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-modal__loader-info",
        children: [modalStatus === MODAL_STATUS.CONNECTING && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsxs)("div", {
            className: "w3a-modal__loader-bridge",
            children: [(0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__loader-app-logo",
              children: (0, import_jsx_runtime.jsx)("img", {
                src: appLogo,
                alt: ""
              })
            }), (0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__connector",
              children: (0, import_jsx_runtime.jsxs)("div", {
                className: "w3a-modal__connector-beat",
                children: [(0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {})]
              })
            }), (0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__loader-adapter",
              children: providerIcon
            })]
          }), (0, import_jsx_runtime.jsx)("div", {
            children: (0, import_jsx_runtime.jsxs)("div", {
              className: "w3a-modal__loader-bridge-message",
              children: ["Verify on your ", (0, import_jsx_runtime.jsx)("span", {
                children: adapter
              }), " account to continue"]
            })
          })]
        }), modalStatus === ADAPTER_STATUS.CONNECTED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message",
          children: message
        }), modalStatus === ADAPTER_STATUS.ERRORED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message w3a-spinner-message--error",
          children: message
        })]
      }), (0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-spinner-power",
        children: [(0, import_jsx_runtime.jsx)("div", {
          children: "Self-custodial login by"
        }), web3authIcon]
      })]
    }), (modalStatus === ADAPTER_STATUS.CONNECTED || modalStatus === ADAPTER_STATUS.ERRORED) && (0, import_jsx_runtime.jsx)("button", {
      type: "button",
      className: "w3a-header__button w3ajs-loader-close-btn",
      onClick: onClose,
      children: closeIcon$1
    })]
  }) : null;
}
function Loader(props) {
  const {
    message,
    modalStatus,
    label,
    onClose,
    canEmit = true
  } = props;
  const web3authIcon = (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: "web3auth"
  });
  (0, import_react.useEffect)(() => {
    log.debug("loader re-rendering");
    if (modalStatus === MODAL_STATUS.CONNECTED && canEmit) {
      setTimeout(() => {
        onClose();
      }, 3e3);
    }
  }, [canEmit, modalStatus, onClose]);
  return modalStatus !== MODAL_STATUS.INITIALIZED ? (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-modal-loader w3a-modal__loader",
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-modal__loader-content",
      children: [(0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-modal__loader-info",
        children: [modalStatus === MODAL_STATUS.CONNECTING && (0, import_jsx_runtime.jsxs)("div", {
          className: "w3ajs-modal-loader__spinner w3a-spinner",
          children: [(0, import_jsx_runtime.jsx)("div", {
            className: "w3a-spinner__head"
          }), (0, import_jsx_runtime.jsx)("div", {
            className: "w3a-spinner__mask"
          })]
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__label w3a-spinner-label",
          children: label
        }), modalStatus === ADAPTER_STATUS.CONNECTED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message",
          children: message
        }), modalStatus === ADAPTER_STATUS.ERRORED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message w3a-spinner-message--error",
          children: message
        })]
      }), (0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-spinner-power",
        children: [(0, import_jsx_runtime.jsx)("div", {
          children: "Self-custodial login by"
        }), web3authIcon]
      })]
    }), (modalStatus === ADAPTER_STATUS.CONNECTED || modalStatus === ADAPTER_STATUS.ERRORED) && (0, import_jsx_runtime.jsx)("button", {
      type: "button",
      className: "w3a-header__button w3ajs-loader-close-btn",
      onClick: onClose,
      children: closeIcon
    })]
  }) : null;
}
function formatIOSMobile(params) {
  const encodedUri = encodeURIComponent(params.uri);
  if (params.universalLink) {
    return "".concat(params.universalLink, "/wc?uri=").concat(encodedUri);
  }
  if (params.deepLink) {
    return "".concat(params.deepLink).concat(params.deepLink.endsWith(":") ? "//" : "/", "wc?uri=").concat(encodedUri);
  }
  return "";
}
function formatMobileRegistryEntry(entry, walletConnectUri, os) {
  let platform = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "mobile";
  const universalLink = entry[platform].universal || "";
  const deepLink = entry[platform].native || "";
  return {
    name: entry.name || "",
    logo: entry.logo || "",
    universalLink,
    deepLink,
    href: os === bowser_default.OS_MAP.iOS ? formatIOSMobile({
      uri: walletConnectUri,
      universalLink,
      deepLink
    }) : walletConnectUri
  };
}
function formatMobileRegistry(registry, walletConnectUri, os) {
  let platform = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "mobile";
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, walletConnectUri, os, platform));
}
function WalletConnect(props) {
  const {
    walletConnectUri,
    wcAdapters
  } = props;
  const [links, setLinks] = (0, import_react.useState)([]);
  const deviceDetails = (0, import_react.useMemo)(() => {
    const browser = bowser_default.getParser(window.navigator.userAgent);
    return {
      platform: browser.getPlatformType(),
      os: browser.getOSName()
    };
  }, []);
  (0, import_react.useEffect)(() => {
    if (deviceDetails.platform === bowser_default.PLATFORMS_MAP.mobile) {
      const mobileLinks = formatMobileRegistry(wcAdapters, walletConnectUri, deviceDetails.os, deviceDetails.platform);
      setLinks(mobileLinks);
    }
  }, [wcAdapters, deviceDetails.os, deviceDetails.platform, walletConnectUri]);
  return (0, import_jsx_runtime.jsx)("div", {
    className: "w3ajs-wallet-connect w3a-wallet-connect",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: "w3ajs-wallet-connect__container w3a-wallet-connect__container".concat(deviceDetails.os === bowser_default.OS_MAP.Android ? " w3a-wallet-connect__container--android" : ""),
      children: [(0, import_jsx_runtime.jsx)("div", {
        className: "w3a-wallet-connect__logo",
        children: walletConnectIcon
      }), deviceDetails.platform === bowser_default.PLATFORMS_MAP.desktop ? (0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-wallet-connect__container-desktop",
        children: [(0, import_jsx_runtime.jsx)("div", {
          children: "Scan QR code with a WalletConnect-compatible wallet"
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-wallet-connect-qr w3a-wallet-connect-qr",
          children: (0, import_jsx_runtime.jsx)(import_react_qr_code.default, {
            size: 200,
            value: walletConnectUri
          })
        })]
      }) : (0, import_jsx_runtime.jsx)("div", {
        className: "w3a-wallet-connect__container-btn-group",
        children: links.map((link) => {
          return deviceDetails.os === bowser_default.OS_MAP.iOS ? (0, import_jsx_runtime.jsx)("div", {
            className: "w3a-wallet-connect__container-ios",
            children: (0, import_jsx_runtime.jsxs)("a", {
              href: link.href,
              rel: "noopener noreferrer",
              target: "_blank",
              children: [(0, import_jsx_runtime.jsx)("button", {
                type: "button",
                className: "w3a-button w3a-button--icon",
                children: (0, import_jsx_runtime.jsx)("img", {
                  src: link.logo,
                  height: "auto",
                  width: "auto",
                  alt: "login-".concat(link.name)
                })
              }), (0, import_jsx_runtime.jsx)("p", {
                className: "w3a-adapter-item__label",
                children: link.name
              })]
            }, link.name)
          }) : (0, import_jsx_runtime.jsx)("div", {
            className: "w3a-wallet-connect__container-android",
            children: (0, import_jsx_runtime.jsx)("a", {
              href: link.href,
              rel: "noopener noreferrer",
              target: "_blank",
              children: (0, import_jsx_runtime.jsx)("button", {
                type: "button",
                className: "w3a-button",
                children: "Connect"
              })
            }, link.name)
          });
        })
      })]
    })
  });
}
function ExternalWallet(props) {
  const {
    hideExternalWallets,
    handleExternalWalletClick,
    config = {},
    walletConnectUri,
    showBackButton,
    modalStatus,
    wcAdapters
  } = props;
  const [isLoaded, setIsLoaded] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    var _config$WALLET_ADAPTE;
    log.debug("loaded external wallets", config, walletConnectUri);
    const wcAvailable = (((_config$WALLET_ADAPTE = config[WALLET_ADAPTERS.WALLET_CONNECT_V1]) === null || _config$WALLET_ADAPTE === void 0 ? void 0 : _config$WALLET_ADAPTE.showOnModal) || false) !== false;
    if (wcAvailable && !walletConnectUri) {
      handleExternalWalletClick({
        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1
      });
    } else if (Object.keys(config).length > 0) {
      setIsLoaded(true);
    }
  }, [config, handleExternalWalletClick, walletConnectUri]);
  return (0, import_jsx_runtime.jsx)("div", {
    className: "w3ajs-external-wallet w3a-group",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-external-container w3ajs-external-container",
      children: [showBackButton && (0, import_jsx_runtime.jsxs)("button", {
        type: "button",
        className: "w3a-external-back w3ajs-external-back",
        onClick: hideExternalWallets,
        children: [(0, import_jsx_runtime.jsx)(Icon, {
          iconName: "arrow-left"
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3a-group__title",
          children: "Back"
        })]
      }), !isLoaded && (0, import_jsx_runtime.jsx)(Loader, {
        modalStatus: MODAL_STATUS.CONNECTING,
        canEmit: false
      }), Object.keys(config).map((adapter) => {
        if (adapter === WALLET_ADAPTERS.WALLET_CONNECT_V1 || adapter === WALLET_ADAPTERS.WALLET_CONNECT_V2) {
          return (0, import_jsx_runtime.jsx)(WalletConnect$1, {
            walletConnectUri,
            wcAdapters
          }, adapter);
        }
        return null;
      }), modalStatus === MODAL_STATUS.INITIALIZED && (0, import_jsx_runtime.jsx)("ul", {
        className: "w3a-adapter-list w3ajs-wallet-adapters",
        children: Object.keys(config).map((adapter) => {
          var _config$adapter;
          if (adapter === WALLET_ADAPTERS.WALLET_CONNECT_V1 || adapter === WALLET_ADAPTERS.WALLET_CONNECT_V2) {
            return null;
          }
          const providerIcon = (0, import_jsx_runtime.jsx)(Image$1, {
            imageId: "login-".concat(adapter)
          });
          return (0, import_jsx_runtime.jsxs)("li", {
            className: "w3a-adapter-item",
            children: [(0, import_jsx_runtime.jsx)("button", {
              type: "button",
              onClick: () => handleExternalWalletClick({
                adapter
              }),
              className: "w3a-button w3a-button--icon",
              children: providerIcon
            }), (0, import_jsx_runtime.jsx)("p", {
              className: "w3a-adapter-item__label",
              children: ((_config$adapter = config[adapter]) === null || _config$adapter === void 0 ? void 0 : _config$adapter.label) || adapter
            })]
          }, adapter);
        })
      })]
    })
  });
}
function Footer(props) {
  const {
    version: version28
  } = props;
  const web3authIcon = (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: "web3auth",
    height: "14px",
    width: "auto"
  });
  return (0, import_jsx_runtime.jsx)("div", {
    className: "w3a-modal__footer",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-footer",
      children: [(0, import_jsx_runtime.jsxs)("div", {
        children: [(0, import_jsx_runtime.jsxs)("div", {
          className: "w3a-footer__links",
          children: [(0, import_jsx_runtime.jsx)("a", {
            href: "https://docs.web3auth.io/legal/terms-and-conditions",
            children: "Terms of use"
          }), (0, import_jsx_runtime.jsx)("span", {
            children: "|"
          }), (0, import_jsx_runtime.jsx)("a", {
            href: "https://docs.web3auth.io/legal/privacy-policy",
            children: "Privacy policy"
          })]
        }), (0, import_jsx_runtime.jsx)("p", {
          children: version28
        })]
      }), (0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-footer__secured",
        children: [(0, import_jsx_runtime.jsx)("div", {
          children: "Self-custodial login by"
        }), web3authIcon]
      })]
    })
  });
}
function Header(props) {
  const {
    isDark
  } = (0, import_react.useContext)(ThemedContext);
  const {
    appLogo = DEFAULT_LOGO_URL$1,
    onClose
  } = props;
  const web3authIcon = (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: "web3auth".concat(isDark ? "-light" : "")
  });
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "w3a-modal__header",
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-header",
      children: [appLogo ? (0, import_jsx_runtime.jsx)("img", {
        className: "w3a-header__logo",
        src: appLogo,
        alt: ""
      }) : web3authIcon, (0, import_jsx_runtime.jsxs)("div", {
        children: [(0, import_jsx_runtime.jsx)("div", {
          className: "w3a-header__title",
          children: "Sign in"
        }), (0, import_jsx_runtime.jsx)("p", {
          className: "w3a-header__subtitle",
          children: "Select one of the following to continue"
        })]
      })]
    }), (0, import_jsx_runtime.jsx)("button", {
      type: "button",
      onClick: onClose,
      className: "w3a-header__button w3ajs-close-btn",
      children: (0, import_jsx_runtime.jsx)(Icon, {
        iconName: "close"
      })
    })]
  });
}
function SocialLoginEmail(props) {
  const {
    handleSocialLoginClick,
    adapter
  } = props;
  const [isValidEmail, setIsValidEmail] = (0, import_react.useState)(false);
  const handleEmailSubmit = (e) => {
    e.preventDefault();
    const email = e.target[0].value;
    if (email)
      handleSocialLoginClick({
        adapter,
        loginParams: {
          loginProvider: "email_passwordless",
          login_hint: email
        }
      });
  };
  const handleEmailChange = (e) => {
    const email = e.target.value;
    const emailValid = email.match(/^([\w.%+-]+)@([\w-]+\.)+([\w]{2,})$/i);
    setIsValidEmail(!!emailValid);
  };
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-email-passwordless w3a-group w3a-group--email",
    children: [(0, import_jsx_runtime.jsx)("div", {
      className: "w3a-group__title",
      children: "EMAIL"
    }), (0, import_jsx_runtime.jsxs)("form", {
      className: "w3ajs-email-passwordless-form",
      onSubmit: (e) => handleEmailSubmit(e),
      children: [(0, import_jsx_runtime.jsx)("input", {
        className: "w3a-text-field",
        type: "email",
        name: "email",
        required: true,
        placeholder: "Email",
        onChange: (e) => handleEmailChange(e)
      }), (0, import_jsx_runtime.jsx)("button", {
        disabled: !isValidEmail,
        className: "w3a-button",
        type: "submit",
        children: "Continue with Email"
      })]
    })]
  });
}
function SocialLogins(props) {
  const [canShowMore, setCanShowMore] = (0, import_react.useState)(false);
  const {
    socialLoginsConfig = {
      loginMethods: {},
      loginMethodsOrder: [],
      adapter: ""
    },
    handleSocialLoginClick
  } = props;
  const {
    isDark
  } = (0, import_react.useContext)(ThemedContext);
  const [isExpanded, setIsExpanded] = (0, import_react.useState)(false);
  const expandClickHandler = () => {
    setIsExpanded(!isExpanded);
  };
  (0, import_react.useEffect)(() => {
    const maxOptions = Object.keys(socialLoginsConfig.loginMethods).filter((loginMethodKey) => {
      return socialLoginsConfig.loginMethods[loginMethodKey].showOnModal;
    });
    setCanShowMore(maxOptions.length > 5);
  }, [socialLoginsConfig.loginMethods]);
  const adapterListClass = (0, import_classnames.default)("w3a-adapter-list", "w3ajs-socials-adapters", !isExpanded ? " w3a-adapter-list--shrink" : "");
  const adapterButtonClass = (0, import_classnames.default)("w3a-button-expand", "w3ajs-button-expand", isExpanded ? "w3a-button--rotate" : "");
  const adapterExpandText = isExpanded ? "View less options" : "View more options";
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-social-logins w3a-group",
    children: [(0, import_jsx_runtime.jsx)("div", {
      className: "w3a-group__title",
      children: "CONTINUE WITH"
    }), (0, import_jsx_runtime.jsx)("ul", {
      className: adapterListClass,
      children: Object.keys(socialLoginsConfig.loginMethods).map((method) => {
        const providerIcon = (0, import_jsx_runtime.jsx)(Image$1, {
          imageId: "login-".concat(method).concat(isDark && hasLightIcons.includes(method) ? "-light" : "")
        });
        if (socialLoginsConfig.loginMethods[method].showOnModal === false || method === "webauthn" || method === "jwt" || method === "email_passwordless") {
          return null;
        }
        const orderIndex = socialLoginsConfig.loginMethodsOrder.indexOf(method) + 1;
        const order = orderIndex || Object.keys(socialLoginsConfig.loginMethods).length + 1;
        return (0, import_jsx_runtime.jsx)("li", {
          className: "w3a-adapter-item",
          style: {
            order
          },
          children: (0, import_jsx_runtime.jsx)("button", {
            type: "button",
            onClick: () => handleSocialLoginClick({
              adapter: socialLoginsConfig.adapter,
              loginParams: {
                loginProvider: method
              }
            }),
            className: "w3a-button w3a-button--icon",
            children: providerIcon
          })
        }, method);
      })
    }), canShowMore && (0, import_jsx_runtime.jsxs)("button", {
      type: "button",
      className: adapterButtonClass,
      style: {
        display: "flex"
      },
      onClick: expandClickHandler,
      children: [(0, import_jsx_runtime.jsx)(Icon, {
        iconName: "expand".concat(isDark ? "-light" : "")
      }), (0, import_jsx_runtime.jsx)("span", {
        className: "w3ajs-button-expand-text",
        children: adapterExpandText
      })]
    })]
  });
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function Modal(props) {
  var _modalState$socialLog3, _modalState$socialLog6, _modalState$socialLog7;
  const {
    isDark
  } = (0, import_react.useContext)(ThemedContext);
  const [modalTransitionClasses, setModalTransitionClasses] = (0, import_react.useState)(["w3a-modal__inner"]);
  const [modalState, setModalState] = (0, import_react.useState)({
    externalWalletsVisibility: false,
    status: MODAL_STATUS.INITIALIZED,
    hasExternalWallets: false,
    externalWalletsInitialized: false,
    modalVisibility: false,
    modalVisibilityDelayed: false,
    postLoadingMessage: "",
    walletConnectUri: "",
    socialLoginsConfig: {
      loginMethods: {},
      loginMethodsOrder: [],
      adapter: ""
    },
    externalWalletsConfig: {},
    detailedLoaderAdapter: "",
    showExternalWalletsOnly: false,
    wcAdapters: []
  });
  const {
    stateListener,
    appLogo,
    version: version28,
    handleSocialLoginClick,
    handleExternalWalletClick,
    handleShowExternalWallets,
    closeModal
  } = props;
  const DETAILED_ADAPTERS = [WALLET_ADAPTERS.PHANTOM, WALLET_ADAPTERS.METAMASK];
  (0, import_react.useEffect)(() => {
    stateListener.emit("MOUNTED");
    stateListener.on("STATE_UPDATED", (newModalState) => {
      log.debug("state updated", newModalState);
      setModalState((prevState) => {
        const mergedState = (0, import_lodash.default)((0, import_lodash2.default)(prevState, newModalState));
        return mergedState;
      });
    });
  }, [stateListener]);
  (0, import_react.useEffect)(() => {
    let timeOutId;
    if (modalState.modalVisibility) {
      setModalState((prevState) => {
        return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
          modalVisibilityDelayed: modalState.modalVisibility
        });
      });
      timeOutId = window.setTimeout(() => {
        setModalTransitionClasses(["w3a-modal__inner", modalState.modalVisibility ? "w3a-modal__inner--active" : ""]);
      }, 100);
    } else {
      setModalTransitionClasses(["w3a-modal__inner", modalState.modalVisibility ? "w3a-modal__inner--active" : ""]);
      timeOutId = window.setTimeout(() => {
        setModalState((prevState) => {
          return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
            modalVisibilityDelayed: modalState.modalVisibility
          });
        });
      }, 250);
    }
    return () => {
      clearTimeout(timeOutId);
    };
  }, [modalState.modalVisibility]);
  const onCloseLoader = (0, import_react.useCallback)(() => {
    if (modalState.status === MODAL_STATUS.CONNECTED) {
      closeModal();
    }
    if (modalState.status === MODAL_STATUS.ERRORED) {
      setModalState((prevState) => {
        return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
          modalVisibility: true,
          status: MODAL_STATUS.INITIALIZED
        });
      });
    }
  }, [closeModal, modalState.status]);
  const preHandleExternalWalletClick = (params) => {
    const {
      adapter
    } = params;
    if (DETAILED_ADAPTERS.includes(adapter))
      setModalState((prevState) => {
        return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
          detailedLoaderAdapter: adapter
        });
      });
    else if (adapter !== WALLET_ADAPTERS.WALLET_CONNECT_V1)
      setModalState((prevState) => {
        return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
          detailedLoaderAdapter: ""
        });
      });
    handleExternalWalletClick(params);
  };
  const preHandleSocialWalletClick = (params) => {
    setModalState((prevState) => {
      return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
        detailedLoaderAdapter: ""
      });
    });
    handleSocialLoginClick(params);
  };
  const externalWalletButton = (0, import_jsx_runtime.jsx)("div", {
    className: "w3ajs-external-wallet w3a-group",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-external-toggle w3ajs-external-toggle",
      children: [(0, import_jsx_runtime.jsx)("div", {
        className: "w3a-group__title",
        children: "EXTERNAL WALLET"
      }), (0, import_jsx_runtime.jsx)("button", {
        type: "button",
        className: "w3a-button w3ajs-external-toggle__button",
        onClick: () => {
          handleShowExternalWallets(modalState.externalWalletsInitialized);
          setModalState((prevState) => {
            return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
              externalWalletsVisibility: true
            });
          });
        },
        children: "Connect with Wallet"
      })]
    })
  });
  const areSocialLoginsVisible = (0, import_react.useMemo)(() => {
    var _modalState$socialLog, _modalState$socialLog2;
    if (modalState.showExternalWalletsOnly)
      return false;
    if (Object.keys(((_modalState$socialLog = modalState.socialLoginsConfig) === null || _modalState$socialLog === void 0 ? void 0 : _modalState$socialLog.loginMethods) || {}).length === 0)
      return false;
    const isAnySocialLoginVisible = Object.entries(((_modalState$socialLog2 = modalState.socialLoginsConfig) === null || _modalState$socialLog2 === void 0 ? void 0 : _modalState$socialLog2.loginMethods) || {}).some((_ref) => {
      let [k2, v2] = _ref;
      return k2 !== LOGIN_PROVIDER.EMAIL_PASSWORDLESS && v2.showOnModal !== false;
    });
    if (isAnySocialLoginVisible)
      return true;
    return false;
  }, [modalState.showExternalWalletsOnly, (_modalState$socialLog3 = modalState.socialLoginsConfig) === null || _modalState$socialLog3 === void 0 ? void 0 : _modalState$socialLog3.loginMethods]);
  log.info("modal state", modalState, areSocialLoginsVisible);
  const isEmailPassworedlessLoginVisible = (0, import_react.useMemo)(() => {
    var _modalState$socialLog4, _modalState$socialLog5;
    return (_modalState$socialLog4 = modalState.socialLoginsConfig) === null || _modalState$socialLog4 === void 0 ? void 0 : (_modalState$socialLog5 = _modalState$socialLog4.loginMethods[LOGIN_PROVIDER.EMAIL_PASSWORDLESS]) === null || _modalState$socialLog5 === void 0 ? void 0 : _modalState$socialLog5.showOnModal;
  }, [(_modalState$socialLog6 = modalState.socialLoginsConfig) === null || _modalState$socialLog6 === void 0 ? void 0 : _modalState$socialLog6.loginMethods]);
  const modalClassName = "w3a-modal ".concat(isDark ? "" : " w3a-modal--light");
  return modalState.modalVisibilityDelayed && (0, import_jsx_runtime.jsx)("div", {
    id: "w3a-modal",
    className: modalClassName,
    style: {
      display: "flex"
    },
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: modalTransitionClasses.join(" "),
      children: [(0, import_jsx_runtime.jsx)(memoizedHeader, {
        onClose: closeModal,
        appLogo
      }), modalState.status !== MODAL_STATUS.INITIALIZED ? (0, import_jsx_runtime.jsx)("div", {
        className: "w3a-modal__content w3ajs-content",
        children: modalState.detailedLoaderAdapter ? (0, import_jsx_runtime.jsx)(DetailedLoader, {
          onClose: onCloseLoader,
          appLogo,
          modalStatus: modalState.status,
          message: modalState.postLoadingMessage,
          adapter: modalState.detailedLoaderAdapter
        }) : (0, import_jsx_runtime.jsx)(Loader, {
          onClose: onCloseLoader,
          modalStatus: modalState.status,
          message: modalState.postLoadingMessage
        })
      }) : (0, import_jsx_runtime.jsx)("div", {
        className: "w3a-modal__content w3ajs-content",
        children: (areSocialLoginsVisible || isEmailPassworedlessLoginVisible) && !modalState.externalWalletsVisibility ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [areSocialLoginsVisible ? (0, import_jsx_runtime.jsx)(SocialLogins, {
            handleSocialLoginClick: (params) => preHandleSocialWalletClick(params),
            socialLoginsConfig: modalState.socialLoginsConfig
          }) : null, isEmailPassworedlessLoginVisible && (0, import_jsx_runtime.jsx)(SocialLoginEmail, {
            adapter: (_modalState$socialLog7 = modalState.socialLoginsConfig) === null || _modalState$socialLog7 === void 0 ? void 0 : _modalState$socialLog7.adapter,
            handleSocialLoginClick: (params) => preHandleSocialWalletClick(params)
          }), modalState.hasExternalWallets && externalWalletButton]
        }) : (0, import_jsx_runtime.jsx)(ExternalWallet, {
          modalStatus: modalState.status,
          showBackButton: areSocialLoginsVisible,
          handleExternalWalletClick: (params) => preHandleExternalWalletClick(params),
          walletConnectUri: modalState.walletConnectUri,
          wcAdapters: modalState.wcAdapters,
          config: modalState.externalWalletsConfig,
          hideExternalWallets: () => setModalState((prevState) => {
            return _objectSpread$1(_objectSpread$1({}, prevState), {}, {
              externalWalletsVisibility: false
            });
          })
        })
      }), (0, import_jsx_runtime.jsx)(Footer$1, {
        version: version28
      })]
    })
  });
}
function createWrapper$1() {
  const wrapper = document.createElement("section");
  wrapper.setAttribute("id", "w3a-container");
  document.body.appendChild(wrapper);
  return wrapper;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys3(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
var import_jsx_runtime, import_react_dom, import_lodash, import_lodash2, import_react, import_react_qr_code, import_classnames, OPENLOGIN_PROVIDERS, LOGIN_MODAL_EVENTS, MODAL_STATUS, css_248z$1, ThemedContext, CircleArrowLeft, Close, Expand, ExpandLight, icons, DEFAULT_LOGO_URL$2, closeIcon$1, closeIcon, walletConnectIcon, WalletConnect$1, Footer$1, DEFAULT_LOGO_URL$1, memoizedHeader, hasLightIcons, DEFAULT_LOGO_URL, LoginModal, css_248z, getAdapterSocialLogins;
var init_ui_esm = __esm({
  "node_modules/@web3auth/ui/dist/ui.esm.js"() {
    init_openlogin_esm();
    init_defineProperty();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    init_openloginJrpc_esm();
    init_base_esm();
    import_react_dom = __toESM(require_react_dom());
    import_lodash = __toESM(require_lodash2());
    import_lodash2 = __toESM(require_lodash());
    import_react = __toESM(require_react());
    init_bowser();
    import_react_qr_code = __toESM(require_lib());
    import_classnames = __toESM(require_classnames());
    OPENLOGIN_PROVIDERS = Object.values(LOGIN_PROVIDER).filter((x2) => x2 !== LOGIN_PROVIDER.WEBAUTHN && x2 !== LOGIN_PROVIDER.JWT);
    LOGIN_MODAL_EVENTS = {
      INIT_EXTERNAL_WALLETS: "INIT_EXTERNAL_WALLETS",
      LOGIN: "LOGIN",
      DISCONNECT: "DISCONNECT",
      MODAL_VISIBILITY: "MODAL_VISIBILITY"
    };
    MODAL_STATUS = {
      INITIALIZED: "initialized",
      CONNECTED: "connected",
      CONNECTING: "connecting",
      ERRORED: "errored"
    };
    css_248z$1 = '/* devanagari */\n@font-face {\n  font-family: "Poppins";\n  font-style: normal;\n  font-weight: 600;\n  src: url(https://fonts.gstatic.com/s/poppins/v15/pxiByp8kv8JHgFVrLEj6Z11lFd2JQEl8qw.woff2) format("woff2");\n  unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;\n}\n/* latin-ext */\n@font-face {\n  font-family: "Poppins";\n  font-style: normal;\n  font-weight: 600;\n  src: url(https://fonts.gstatic.com/s/poppins/v15/pxiByp8kv8JHgFVrLEj6Z1JlFd2JQEl8qw.woff2) format("woff2");\n  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n  font-family: "Poppins";\n  font-style: normal;\n  font-weight: 600;\n  src: url(https://fonts.gstatic.com/s/poppins/v15/pxiByp8kv8JHgFVrLEj6Z1xlFd2JQEk.woff2) format("woff2");\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212,\n    U+2215, U+FEFF, U+FFFD;\n}\n\n/* latin-ext */\n@font-face {\n  font-family: "DM Sans";\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.gstatic.com/s/dmsans/v6/rP2Hp2ywxg089UriCZ2IHTWEBlwu8Q.woff2) format("woff2");\n  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n  font-family: "DM Sans";\n  font-style: normal;\n  font-weight: 400;\n  src: url(https://fonts.gstatic.com/s/dmsans/v6/rP2Hp2ywxg089UriCZOIHTWEBlw.woff2) format("woff2");\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212,\n    U+2215, U+FEFF, U+FFFD;\n}\n\n/* Modal */\n#w3a-modal {\n  --bg1: #0f1222;\n  --bg2: #24262e;\n  --text-color1: #d3d3d4;\n  --text-color2: #ffffff;\n\n  --text-header: "Poppins", Helvetica, sans-serif;\n  --text-body: "DM Sans", Helvetica, sans-serif;\n\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  padding: 15px;\n  background: rgba(33, 33, 33, 0.46);\n  color: var(--text-color1);\n  font-family: var(--text-body);\n}\n\n#w3a-modal.w3a-modal--hidden {\n  display: none;\n}\n\n#w3a-modal p,\n#w3a-modal form,\n#w3a-modal button {\n  margin: 0;\n  padding: 0;\n}\n\n#w3a-modal .w3a-modal__inner {\n  width: 100%;\n  max-width: 375px;\n  overflow: hidden;\n  border-radius: 6px;\n  position: relative;\n  max-height: 95%;\n  overflow-y: auto;\n  opacity: 0;\n  transition: 200ms cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform-origin: center center;\n  min-height: 350px;\n}\n\n#w3a-modal .w3a-modal__inner.w3a-modal__inner--active {\n  opacity: 1;\n  transition: 200ms cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform-origin: center center;\n}\n\n#w3a-modal .w3a-modal__header {\n  padding: 25px 34px;\n  background: var(--bg1);\n  box-shadow: 0px 4px 28px rgba(3, 100, 255, 0.05);\n  position: relative;\n}\n#w3a-modal .w3a-modal__content {\n  padding: 30px 34px;\n  background: var(--bg2);\n}\n#w3a-modal .w3a-modal__footer {\n  padding: 16px 34px;\n  background: var(--bg1);\n}\n\n/* SPINNER */\n/* Loader */\n#w3a-modal .w3a-modal__loader {\n  background: var(--bg2);\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 10;\n}\n\n#w3a-modal .w3a-modal__loader.w3a-modal__loader--hidden {\n  display: none;\n}\n\n#w3a-modal .w3a-modal__loader-content {\n  text-align: center;\n  margin-bottom: 80px;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n\n#w3a-modal .w3a-modal__loader-info {\n  flex-grow: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  padding: 0 30px;\n}\n\n#w3a-modal .w3a-spinner-label {\n  margin-top: 10px;\n  font-size: 16px;\n  font-weight: 500;\n  color: #0364ff;\n}\n\n#w3a-modal .w3a-spinner-message {\n  margin-top: 10px;\n  font-size: 16px;\n}\n#w3a-modal .w3a-spinner-message:first-letter {\n  text-transform: capitalize;\n}\n#w3a-modal .w3a-spinner-message.w3a-spinner-message--error {\n  color: #fb4a61;\n}\n\n#w3a-modal button.w3a-logout {\n  background: none;\n  border: 0;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  margin-bottom: 30px;\n  cursor: pointer;\n  margin-top: 20px;\n  color: #0364ff;\n}\n\n#w3a-modal .w3a-spinner-power {\n  margin-top: auto;\n  font-size: 12px;\n  line-height: 1.2em;\n  color: #b7b8bd;\n}\n#w3a-modal .w3a-spinner-power > img {\n  height: 32px;\n  width: auto;\n  display: inline;\n}\n\n#w3a-modal .w3a-spinner {\n  display: inline-block;\n  position: relative;\n  background-color: #0364ff;\n  height: 60px;\n  width: 60px;\n  border-radius: 50%;\n  background: conic-gradient(transparent, #0364ff);\n  animation: rotate 1s linear infinite;\n}\n\n#w3a-modal .w3a-spinner__mask,\n#w3a-modal .w3a-spinner__head {\n  content: "";\n  position: absolute;\n  border-radius: 50%;\n}\n\n#w3a-modal .w3a-spinner__mask {\n  width: 50px;\n  height: 50px;\n  top: 5px;\n  left: 5px;\n  background-color: var(--bg2);\n}\n\n#w3a-modal .w3a-spinner__head {\n  height: 5px;\n  width: 5px;\n  background-color: #0364ff;\n  top: 0;\n  left: 26px;\n}\n\n@keyframes rotate {\n  from {\n    transform: rotateZ(0);\n  }\n  to {\n    transform: rotateZ(360deg);\n  }\n}\n\n\n/* Header */\n#w3a-modal .w3a-header {\n  display: flex;\n  color: var(--text-color2);\n  align-items: center;\n}\n#w3a-modal .w3a-header__logo {\n  height: auto;\n  width: 40px;\n  margin-right: 16px;\n}\n#w3a-modal .w3a-header__title {\n  font-family: var(--text-header);\n  font-weight: 600;\n  font-size: 20px;\n  line-height: 1.5em;\n}\n#w3a-modal p.w3a-header__subtitle {\n  font-size: 14px;\n  line-height: 1.5em;\n  font-weight: 400;\n}\n#w3a-modal button.w3a-header__button {\n  cursor: pointer;\n  position: absolute;\n  background: none;\n  padding: 0;\n  border: 0;\n  top: 20px;\n  right: 26px;\n}\n\n/* BODY */\n#w3a-modal .w3a-group {\n  margin-bottom: 24px;\n}\n#w3a-modal .w3a-group:last-child {\n  margin-bottom: 0;\n}\n\n#w3a-modal .w3a-group.w3a-group--hidden,\n#w3a-modal .w3a-group.w3a-group--social-hidden,\n#w3a-modal .w3a-group.w3a-group--email-hidden,\n#w3a-modal .w3a-group.w3a-group--ext-wallet-hidden {\n  display: none;\n}\n\n#w3a-modal .w3a-group:not(.w3a-group--hidden):not(:last-child),\n#w3a-modal .w3a-group:not(.w3a-group--social-hidden):not(:last-child),\n#w3a-modal .w3a-group:not(.w3a-group--email-hidden):not(:last-child),\n#w3a-modal .w3a-group:not(.w3a-group--ext-wallet-hidden):not(:last-child) {\n  border-bottom: 0.5px solid #5c6c7f;\n  padding-bottom: 24px;\n}\n\n#w3a-modal div.w3a-group__title {\n  font-family: var(--text-header);\n  font-weight: 400;\n  font-size: 14px;\n  line-height: 1.5em;\n  margin-bottom: 8px;\n}\n\n/* Adapter List */\n#w3a-modal ul.w3a-adapter-list {\n  display: flex;\n  align-items: center;\n  padding: 0;\n  margin: 0;\n  gap: 16px;\n  overflow-y: hidden;\n  flex-wrap: wrap;\n  margin-bottom: 16px;\n  max-height: 500px;\n  transition: max-height 0.4s ease-in;\n}\n\n#w3a-modal ul.w3a-adapter-list.w3a-adapter-list--shrink {\n  max-height: 48px;\n  transition: max-height 0.4s ease-out;\n}\n\n#w3a-modal ul.w3a-adapter-list.w3a-adapter-list--hidden {\n  display: none;\n}\n\n#w3a-modal li.w3a-adapter-item {\n  list-style: none;\n  margin-bottom: 30px;\n}\n\n#w3a-modal .w3a-adapter-item--hide {\n  display: none;\n}\n\n#w3a-modal .w3a-adapter-item__label {\n  font-size: 12px;\n  color: #5c6c7f;\n  text-align: center;\n  margin: 8px 0 0 !important;\n  text-transform: capitalize;\n  position: absolute;\n  transform: translate(-6px);\n  width: 60px;\n}\n\n/* Buttons */\n#w3a-modal button.w3a-button {\n  background-color: #2f3136;\n  border: 1px solid #404145;\n  box-sizing: border-box;\n  box-shadow: 2px 2px 12px rgba(3, 100, 255, 0.05);\n  border-radius: 24px;\n  height: 48px;\n  width: 100%;\n  padding: 8px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-family: var(--text-body);\n  font-style: normal;\n  font-weight: 400;\n  font-size: 16px;\n  color: var(--text-color2);\n  cursor: pointer;\n}\n\n#w3a-modal button.w3a-button:hover {\n  background: #595857;\n}\n\n#w3a-modal button.w3a-button:active {\n  background: #6f717a;\n}\n\n#w3a-modal button.w3a-button:disabled {\n  background: #27282d;\n  color: #6f717a;\n}\n\n#w3a-modal button.w3a-button:focus-visible {\n  outline: 1px solid #daf0ff;\n  outline-offset: -1px;\n}\n\n#w3a-modal button.w3a-button--icon {\n  width: 48px;\n}\n\n#w3a-modal button.w3a-button--left {\n  justify-content: start;\n  padding: 8px 16px;\n}\n\n#w3a-modal button.w3a-button--left > img {\n  height: 30px;\n  width: auto;\n}\n\n#w3a-modal button.w3a-button--left > div.w3a-button__name {\n  max-width: 180px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  text-transform: capitalize;\n}\n\n#w3a-modal button.w3a-button--left > div.w3a-button__note {\n  margin-left: 8px;\n  color: #b7b8bd;\n  margin-left: auto;\n}\n\n#w3a-modal .w3a-button__image {\n  max-width: 100%;\n  max-height: 100%;\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), visibility 0s;\n}\n\n#w3a-modal button.w3a-button.w3a-button--rotate .w3a-button__image {\n  transform: rotate(180deg);\n}\n\n#w3a-modal .w3a-button--left .w3a-button__image {\n  margin-right: 12px;\n}\n\n#w3a-modal button.w3a-button-expand {\n  height: unset;\n  width: auto;\n  margin-left: auto;\n  font-size: 12px;\n  margin-top: 16px;\n  display: flex;\n  border: 8px;\n  color: var(--text-color2);\n  align-items: center;\n  cursor: pointer;\n  border-radius: 12px;\n  cursor: pointer;\n  padding: 0 10px 0 8px;\n  background: transparent;\n}\n\n#w3a-modal button.w3a-button-expand svg {\n  width: 12px;\n  height: auto;\n  margin-right: 4px;\n}\n\n#w3a-modal .w3a-external-toggle {\n  display: block;\n}\n\n#w3a-modal .w3a-external-toggle.w3a-external-toggle--hidden {\n  display: none;\n}\n\n#w3a-modal .w3a-external-container {\n  display: block;\n  margin-bottom: 34px;\n}\n\n#w3a-modal .w3a-external-container.w3a-external-container--hidden {\n  display: none;\n}\n\n#w3a-modal .w3a-external-group {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 12px;\n  margin-bottom: 16px;\n}\n\n#w3a-modal .w3a-external-group__left {\n  flex-grow: 1;\n}\n\n#w3a-modal button.w3a-external-back {\n  background: none;\n  border: 0;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  margin-bottom: 30px;\n  cursor: pointer;\n  color: var(--text-color1);\n}\n\n#w3a-modal .w3a-external-back:focus-visible {\n  outline: 1px solid #daf0ff;\n}\n\n#w3a-modal .w3a-external-back .w3a-group__title {\n  margin-bottom: 0;\n  margin-left: 5px;\n}\n\n#w3a-modal .w3a-external-loader {\n  display: flex;\n  justify-content: center;\n}\n\n#w3a-modal .w3a-wallet-connect {\n  display: block;\n  text-align: center;\n  margin-bottom: 16px;\n}\n\n#w3a-modal .w3a-wallet-connect.w3a-wallet-connect--hidden {\n  display: none;\n}\n\n#w3a-modal .w3a-wallet-connect__container {\n  background: #ffffff;\n  border-radius: 10px;\n  color: var(--text-color1);\n  font-size: 10px;\n  width: fit-content;\n  margin: auto;\n  min-width: 250px;\n  padding: 16px 12px;\n}\n\n#w3a-modal .w3a-wallet-connect__container-desktop,\n#w3a-modal .w3a-wallet-connect__container-android {\n  margin: auto;\n}\n\n#w3a-modal .w3a-wallet-connect__container-btn-group {\n  display: flex;\n  gap: 18px;\n}\n\n#w3a-modal .w3a-wallet-connect__container-ios {\n  display: flex;\n  grid-gap: 30px 20px;\n  padding: 0 0 28px;\n  box-sizing: border-box;\n  flex-wrap: wrap;\n}\n\n#w3a-modal .w3a-wallet-connect-qr {\n  margin: 16px 16px;\n  padding: inherit;\n}\n\n#w3a-modal .w3a-wallet-connect__container-android a {\n  text-decoration: none;\n}\n\n#w3a-modal .w3a-wallet-connect__container-android .w3a-button {\n  background-color: rgb(64, 153, 255) !important;\n  color: #ffffff !important;\n  height: auto;\n  font-size: 14px;\n  padding: 8px 16px;\n  width: auto;\n  margin: auto;\n}\n\n#w3a-modal .w3a-wallet-connect__logo > img {\n  text-align: center;\n  width: 115px;\n  margin-bottom: 16px;\n}\n\n/* Text Field */\n#w3a-modal .w3a-text-field {\n  background: #393938;\n  border: 1px solid #27282d;\n  box-sizing: border-box;\n  box-shadow: inset 2px 2px 10px rgba(0, 0, 0, 0.4);\n  border-radius: 24px;\n  padding: 0 28px;\n  height: 48px;\n  width: 100%;\n  font-family: var(--text-body);\n  font-size: 16px;\n  color: var(--text-color2);\n  margin-bottom: 16px;\n}\n\n#w3a-modal .w3a-text-field:active {\n  background: #0f1222;\n}\n\n#w3a-modal .w3a-text-field:focus-visible {\n  outline: 1px solid #daf0ff;\n  outline-offset: -1px;\n}\n\n/* Footer Components */\n#w3a-modal .w3a-footer {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-size: 10px;\n  line-height: 150%;\n  color: var(--text-color2);\n}\n\n#w3a-modal .w3a-footer__links {\n  padding: 0;\n  margin: 0;\n}\n\n#w3a-modal .w3a-footer__links a {\n  color: var(--text-color1);\n  text-decoration: none;\n}\n\n#w3a-modal .w3a-footer__links a:focus-visible {\n  outline: 1px solid #daf0ff;\n}\n\n#w3a-modal .w3a-footer__links span {\n  margin: 0 2px;\n}\n\n#w3a-modal .w3a-footer__secured {\n  text-align: right;\n  color: #b7b8bd;\n}\n#w3a-modal .w3a-footer__secured > img {\n  height: 14px;\n  width: auto;\n}\n\n/* Loader Bridge */\n#w3a-modal .w3a-modal__loader-bridge {\n  display: flex;\n  margin-bottom: 14px;\n}\n\n#w3a-modal .w3a-modal__loader-bridge-message span {\n  text-transform: capitalize;\n}\n\n#w3a-modal .w3a-modal__loader-app-logo {\n  display: flex;\n  padding: 8px;\n}\n\n#w3a-modal .w3a-modal__loader-app-logo img {\n  width: 64px;\n  height: auto;\n}\n\n#w3a-modal .w3a-modal__loader-adapter img {\n  width: 84px;\n  height: auto;\n}\n\n#w3a-modal .w3a-modal__connector {\n  display: flex;\n  align-items: center;\n}\n\n.w3a-modal__connector-beat {\n  display: inline-block;\n  position: relative;\n  width: 80px;\n  height: 80px;\n}\n\n.w3a-modal__connector-beat div {\n  position: absolute;\n  top: 33px;\n  width: 13px;\n  height: 13px;\n  border-radius: 50%;\n  background: #808080;\n  animation-timing-function: cubic-bezier(0, 1, 1, 0);\n}\n\n.w3a-modal__connector-beat div:nth-child(1) {\n  left: 8px;\n  animation: beat1 2.4s infinite;\n}\n\n.w3a-modal__connector-beat div:nth-child(2) {\n  left: 8px;\n  animation: beat2 2.4s infinite;\n}\n\n.w3a-modal__connector-beat div:nth-child(3) {\n  left: 8px;\n  animation: beat3 2.4s infinite;\n}\n\n.w3a-modal__connector-beat div:nth-child(4) {\n  left: 32px;\n  animation: beat4 2.4s infinite;\n}\n\n.w3a-modal__connector-beat div:nth-child(5) {\n  left: 56px;\n  animation: beat5 2.4s infinite;\n}\n\n@keyframes beat1 {\n  0% {\n    transform: scale(0);\n  }\n\n  25% {\n    transform: scale(0);\n  }\n\n  50% {\n    transform: scale(1);\n  }\n\n  75% {\n    transform: scale(0);\n  }\n\n  100% {\n    transform: scale(0);\n  }\n}\n\n@keyframes beat2 {\n  0% {\n    transform: scale(0);\n  }\n\n  25% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: translate(24px, 0);\n  }\n\n  75% {\n    transform: translate(0, 0);\n  }\n\n  100% {\n    transform: translate(0, 0) scale(0);\n  }\n}\n\n@keyframes beat3 {\n  0% {\n    transform: translate(0, 0);\n  }\n\n  25% {\n    transform: translate(24px, 0);\n  }\n\n  50% {\n    transform: translate(48px, 0);\n  }\n\n  75% {\n    transform: translate(24px, 0);\n  }\n\n  100% {\n    transform: translate(0, 0);\n  }\n}\n\n@keyframes beat4 {\n  0% {\n    transform: translate(0, 0);\n  }\n\n  25% {\n    transform: translate(24px, 0);\n  }\n\n  50% {\n    transform: translate(24px, 0) scale(0);\n  }\n\n  75% {\n    transform: translate(24px, 0) scale(1);\n  }\n\n  100% {\n    transform: translate(0, 0);\n  }\n}\n\n@keyframes beat5 {\n  0% {\n    transform: scale(1);\n  }\n\n  25% {\n    transform: scale(0);\n  }\n\n  50% {\n    transform: scale(0);\n  }\n\n  75% {\n    transform: scale(0);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n}\n\n/* LIGHT MODE */\n#w3a-modal.w3a-modal--light {\n  --bg1: #ffffff;\n  --bg2: #f9f9fb;\n  --text-color1: #a2a5b5;\n  --text-color2: #5c6c7f;\n}\n\n#w3a-modal .w3a-group:not(.w3a-group--hidden):not(:last-child),\n#w3a-modal .w3a-group:not(.w3a-group--social-hidden):not(:last-child),\n#w3a-modal .w3a-group:not(.w3a-group--email-hidden):not(:last-child),\n#w3a-modal .w3a-group:not(.w3a-group--ext-wallet-hidden):not(:last-child) {\n  border-bottom: 0.5px solid #b7b8bd;\n  padding-bottom: 24px;\n}\n\n#w3a-modal.w3a-modal--light button.w3a-button {\n  background-color: #ffffff;\n  border: 1px solid #f3f3f4;\n  box-shadow: none;\n  color: #595857;\n}\n\n#w3a-modal.w3a-modal--light button.w3a-button:disabled {\n  color: #b7b8bd;\n}\n\n#w3a-modal.w3a-modal--light button.w3a-button:focus-visible {\n  outline: 1px solid #0f1222;\n}\n\n#w3a-modal.w3a-modal--light .w3a-text-field {\n  background: #ffffff;\n  border: 1px solid #ffffff;\n  box-shadow: inset 2px 2px 10px rgba(0, 0, 0, 0.1);\n  color: #b7b8bd;\n}\n\n#w3a-modal.w3a-modal--light .w3a-text-field:active {\n  color: #0f1222;\n  outline: 1px solid #0f1222;\n}\n\n#w3a-modal.w3a-modal--light .w3a-text-field:focus-visible {\n  color: #0f1222;\n  outline: 1px solid #0f1222;\n}\n\n#w3a-modal.w3a-modal--light .w3a-footer__links a:focus-visible {\n  outline: 1px solid #0f1222;\n}\n\n#w3a-modal.w3a-modal--light .w3a-external-back:focus-visible {\n  outline: 1px solid #0f1222;\n}\n';
    styleInject(css_248z$1);
    ThemedContext = (0, import_react.createContext)({
      isDark: true
      // default value
    });
    CircleArrowLeft = "data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cg%20id%3D%2224%20%2F%20arrows%20%2F%20circle-arrow-left%22%3E%3Cpath%20id%3D%22icon%22%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M12%2023C5.92487%2023%201%2018.0751%201%2012C1%205.92487%205.92487%201%2012%201C18.0751%201%2023%205.92487%2023%2012C23%2018.0751%2018.0751%2023%2012%2023ZM12%2021C16.9706%2021%2021%2016.9706%2021%2012C21%207.02944%2016.9706%203%2012%203C7.02944%203%203%207.02944%203%2012C3%2016.9706%207.02944%2021%2012%2021ZM17%2011H10.4142L12.7071%208.70711L11.2929%207.29289L6.58579%2012L11.2929%2016.7071L12.7071%2015.2929L10.4142%2013H17V11Z%22%20fill%3D%22%23D3D3D4%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E";
    Close = "data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M13.4142%2012L19.7782%2018.364L18.364%2019.7782L12%2013.4143L5.63604%2019.7782L4.22183%2018.364L10.5858%2012L4.22183%205.63608L5.63604%204.22187L12%2010.5858L18.364%204.22187L19.7782%205.63608L13.4142%2012Z%22%20fill%3D%22%23DFDFDF%22%2F%3E%3C%2Fsvg%3E";
    Expand = "data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M12.0991%2015.6785C11.694%2016.1072%2011.0119%2016.1072%2010.6068%2015.6785L4.98828%209.73136C4.36988%209.0768%204.83393%208%205.73441%208L16.9715%208C17.872%208%2018.336%209.0768%2017.7176%209.73136L12.0991%2015.6785Z%22%20fill%3D%22%23B7B8BD%22%2F%3E%3C%2Fsvg%3E";
    ExpandLight = "data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M12.0991%2015.6785C11.694%2016.1072%2011.0119%2016.1072%2010.6068%2015.6785L4.98828%209.73136C4.36988%209.0768%204.83393%208%205.73441%208L16.9715%208C17.872%208%2018.336%209.0768%2017.7176%209.73136L12.0991%2015.6785Z%22%20fill%3D%22%23FFFFFF%22%2F%3E%3C%2Fsvg%3E";
    icons = {
      "arrow-left": {
        image: CircleArrowLeft
      },
      close: {
        image: Close
      },
      "expand-light": {
        image: ExpandLight
      },
      expand: {
        image: Expand
      }
    };
    DEFAULT_LOGO_URL$2 = "https://images.web3auth.io/web3auth-logo.svg";
    closeIcon$1 = (0, import_jsx_runtime.jsx)(Icon, {
      iconName: "close"
    });
    closeIcon = (0, import_jsx_runtime.jsx)(Icon, {
      iconName: "close"
    });
    walletConnectIcon = (0, import_jsx_runtime.jsx)(Image$1, {
      imageId: "wallet-connect",
      width: "114px"
    });
    WalletConnect$1 = (0, import_react.memo)(WalletConnect);
    Footer$1 = (0, import_react.memo)(Footer);
    DEFAULT_LOGO_URL$1 = "https://images.web3auth.io/web3auth-logo.svg";
    memoizedHeader = (0, import_react.memo)(Header, (prevProps, nextProps) => {
      if (prevProps.appLogo !== nextProps.appLogo) {
        return true;
      }
      return false;
    });
    memoizedHeader.displayName = "Header";
    hasLightIcons = ["apple", "github"];
    log.enableAll();
    DEFAULT_LOGO_URL = "https://images.web3auth.io/web3auth-logo.svg";
    LoginModal = class extends SafeEventEmitter {
      constructor(_ref) {
        let {
          appLogo,
          version: version28,
          adapterListener,
          theme = "light",
          displayErrorsOnModal = true
        } = _ref;
        super();
        _defineProperty(this, "appLogo", void 0);
        _defineProperty(this, "version", void 0);
        _defineProperty(this, "isDark", void 0);
        _defineProperty(this, "stateEmitter", void 0);
        _defineProperty(this, "displayErrorsOnModal", true);
        _defineProperty(this, "initModal", async () => {
          const darkState = {
            isDark: this.isDark
          };
          return new Promise((resolve) => {
            this.stateEmitter.once("MOUNTED", () => {
              log.info("rendered");
              this.setState({
                status: MODAL_STATUS.INITIALIZED
              });
              return resolve();
            });
            (0, import_react_dom.render)((0, import_jsx_runtime.jsx)(ThemedContext.Provider, {
              value: darkState,
              children: (0, import_jsx_runtime.jsx)(Modal, {
                closeModal: this.closeModal,
                stateListener: this.stateEmitter,
                handleShowExternalWallets: (externalWalletsInitialized) => this.handleShowExternalWallets(externalWalletsInitialized),
                handleExternalWalletClick: (params) => this.handleExternalWalletClick(params),
                handleSocialLoginClick: (params) => this.handleSocialLoginClick(params),
                appLogo: this.appLogo,
                version: this.version
              })
            }), createWrapper$1());
          });
        });
        _defineProperty(this, "addSocialLogins", (adapter, loginMethods, loginMethodsOrder) => {
          this.setState({
            socialLoginsConfig: {
              adapter,
              loginMethods,
              loginMethodsOrder
            }
          });
          log.info("addSocialLogins", adapter, loginMethods, loginMethodsOrder);
        });
        _defineProperty(this, "addWalletLogins", (externalWalletsConfig, options) => {
          this.setState({
            externalWalletsConfig,
            externalWalletsInitialized: true,
            showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly),
            externalWalletsVisibility: true
          });
        });
        _defineProperty(this, "open", () => {
          this.setState({
            modalVisibility: true
          });
          this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, true);
        });
        _defineProperty(this, "closeModal", () => {
          this.setState({
            modalVisibility: false,
            externalWalletsVisibility: false
          });
          this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, false);
        });
        _defineProperty(this, "initExternalWalletContainer", () => {
          this.setState({
            hasExternalWallets: true
          });
        });
        _defineProperty(this, "handleShowExternalWallets", (status) => {
          this.emit(LOGIN_MODAL_EVENTS.INIT_EXTERNAL_WALLETS, {
            externalWalletsInitialized: status
          });
        });
        _defineProperty(this, "handleExternalWalletClick", (params) => {
          log.info("external wallet clicked", params);
          const {
            adapter
          } = params;
          this.emit(LOGIN_MODAL_EVENTS.LOGIN, {
            adapter
          });
        });
        _defineProperty(this, "handleSocialLoginClick", (params) => {
          log.info("social login clicked", params);
          const {
            adapter,
            loginParams
          } = params;
          this.emit(LOGIN_MODAL_EVENTS.LOGIN, {
            adapter,
            loginParams: {
              loginProvider: loginParams.loginProvider,
              login_hint: loginParams.login_hint
            }
          });
        });
        _defineProperty(this, "setState", (newState) => {
          this.stateEmitter.emit("STATE_UPDATED", newState);
        });
        _defineProperty(this, "updateWalletConnect", (walletConnectUri, wcAdapters) => {
          if (!walletConnectUri)
            return;
          this.setState({
            walletConnectUri,
            wcAdapters
          });
        });
        _defineProperty(this, "handleAdapterData", (adapterData) => {
          if (adapterData.adapterName === WALLET_ADAPTERS.WALLET_CONNECT_V1) {
            const walletConnectData = adapterData.data;
            this.updateWalletConnect(walletConnectData.uri, walletConnectData.extensionAdapters);
          }
        });
        _defineProperty(this, "subscribeCoreEvents", (listener) => {
          listener.on(ADAPTER_EVENTS.CONNECTING, (data) => {
            log.info("connecting with adapter", data);
            if ((data === null || data === void 0 ? void 0 : data.adapter) !== WALLET_ADAPTERS.WALLET_CONNECT_V1 && (data === null || data === void 0 ? void 0 : data.adapter) !== WALLET_ADAPTERS.WALLET_CONNECT_V2) {
              this.setState({
                status: MODAL_STATUS.CONNECTING
              });
            }
          });
          listener.on(ADAPTER_EVENTS.CONNECTED, (data) => {
            log.debug("connected with adapter", data);
            if (!data.reconnected) {
              this.setState({
                status: MODAL_STATUS.CONNECTED,
                modalVisibility: true,
                postLoadingMessage: "You are connected with your account"
              });
            } else {
              this.setState({
                status: MODAL_STATUS.CONNECTED
              });
            }
          });
          listener.on(ADAPTER_EVENTS.ERRORED, (error) => {
            log.error("error", error, error.message);
            if (error.code === 5e3) {
              if (this.displayErrorsOnModal)
                this.setState({
                  modalVisibility: true,
                  postLoadingMessage: error.message || "Something went wrong!",
                  status: MODAL_STATUS.ERRORED
                });
              else
                this.setState({
                  modalVisibility: false
                });
            } else {
              this.setState({
                modalVisibility: true,
                status: MODAL_STATUS.INITIALIZED
              });
            }
          });
          listener.on(ADAPTER_EVENTS.DISCONNECTED, () => {
            this.setState({
              status: MODAL_STATUS.INITIALIZED,
              externalWalletsVisibility: false
            });
          });
          listener.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, (adapterData) => {
            this.handleAdapterData(adapterData);
          });
        });
        this.appLogo = appLogo || DEFAULT_LOGO_URL;
        this.version = version28;
        this.isDark = theme === "dark";
        this.stateEmitter = new SafeEventEmitter();
        this.displayErrorsOnModal = displayErrorsOnModal;
        this.subscribeCoreEvents(adapterListener);
      }
    };
    css_248z = '/* devanagari */\n@font-face {\n    font-family: "Poppins";\n    font-style: normal;\n    font-weight: 600;\n    src: url(https://fonts.gstatic.com/s/poppins/v15/pxiByp8kv8JHgFVrLEj6Z11lFd2JQEl8qw.woff2) format("woff2");\n    unicode-range: U+0900-097F, U+1CD0-1CF6, U+1CF8-1CF9, U+200C-200D, U+20A8, U+20B9, U+25CC, U+A830-A839, U+A8E0-A8FB;\n}\n/* latin-ext */\n@font-face {\n    font-family: "Poppins";\n    font-style: normal;\n    font-weight: 600;\n    src: url(https://fonts.gstatic.com/s/poppins/v15/pxiByp8kv8JHgFVrLEj6Z1JlFd2JQEl8qw.woff2) format("woff2");\n    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n    font-family: "Poppins";\n    font-style: normal;\n    font-weight: 600;\n    src: url(https://fonts.gstatic.com/s/poppins/v15/pxiByp8kv8JHgFVrLEj6Z1xlFd2JQEk.woff2) format("woff2");\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC,\n        U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n}\n\n/* latin-ext */\n@font-face {\n    font-family: "DM Sans";\n    font-style: normal;\n    font-weight: 400;\n    src: url(https://fonts.gstatic.com/s/dmsans/v6/rP2Hp2ywxg089UriCZ2IHTWEBlwu8Q.woff2) format("woff2");\n    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n    font-family: "DM Sans";\n    font-style: normal;\n    font-weight: 400;\n    src: url(https://fonts.gstatic.com/s/dmsans/v6/rP2Hp2ywxg089UriCZOIHTWEBlw.woff2) format("woff2");\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC,\n        U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n}\n\n/* Modal */\n#w3a-network-modal {\n    --bg1: #ffffff;\n    --bg2: #f9f9fb;\n    --text-color1: #a2a5b5;\n    --text-color2: #5c6c7f;\n\n    --text-header: "Poppins", Helvetica, sans-serif;\n    --text-body: "DM Sans", Helvetica, sans-serif;\n\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    padding: 15px;\n    color: var(--text-color1);\n    font-family: var(--text-body);\n    background: black;\n}\n\n#w3a-network-modal button.w3a-button {\n    background-color: #ffffff;\n    border: 1px solid #f3f3f4;\n    box-shadow: none;\n    box-sizing: border-box;\n    border-radius: 24px;\n    height: 48px;\n    width: 100%;\n    padding: 8px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-family: var(--text-body);\n    font-style: normal;\n    font-weight: 400;\n    font-size: 16px;\n    color: #b7b8bd;\n    cursor: pointer;\n}\n\n#w3a-network-modal .w3a-switch-network {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f9f9fb;\n    box-sizing: border-box;\n    border-radius: 10px;\n    width: 375px;\n    padding: 20px;\n    font-family: var(--text-body);\n}\n\n#w3a-network-modal .w3a-switch-network__title {\n    font-family: var(--text-header);\n    font-size: 20px;\n    color: var(--text-color2);\n    margin-bottom: 16px;\n    text-align: center;\n}\n\n#w3a-network-modal .w3a-switch-network__link {\n    font-size: 12px;\n    color: #b7b8bd;\n    background-color: #fff;\n    height: 24px;\n    border-radius: 12px;\n    padding: 4px 16px;\n}\n\n#w3a-network-modal .w3a-switch-network__connect {\n    display: flex;\n    margin: 40px auto 0;\n}\n\n#w3a-network-modal .w3a-switch-network__connect > div {\n    text-align: center;\n    font-size: 10px;\n    color: var(--text-color2);\n}\n\n.w3a-switch-network__connect-divider {\n    margin-top: 20px;\n}\n\n#w3a-network-modal .w3a-switch-network__logo {\n    background: #ffffff;\n    box-shadow: 2px 2px 12px rgba(3, 100, 255, 0.05);\n    border-radius: 50%;\n    width: 58px;\n    height: 58px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 0 auto 6px;\n}\n\n#w3a-network-modal .w3a-switch-network__logo img {\n    width: 34px;\n    height: 34px;\n}\n\n#w3a-network-modal .w3a-switch-network__buttons {\n    display: flex;\n    column-gap: 16px;\n    width: 100%;\n    margin-top: 60px;\n}\n\n#w3a-network-modal .w3a-button.w3a-button--primary {\n    background-color: #0364ff;\n    color: #fff;\n}\n';
    styleInject(css_248z);
    getAdapterSocialLogins = function(adapterName, adapter) {
      let loginMethodsConfig = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const finalLoginMethodsConfig = {};
      if (adapterName === WALLET_ADAPTERS.OPENLOGIN) {
        OPENLOGIN_PROVIDERS.forEach((loginMethod) => {
          const currentLoginMethodConfig = loginMethodsConfig[loginMethod] || {
            name: loginMethod,
            showOnMobile: true,
            showOnModal: true,
            showOnDesktop: true
          };
          finalLoginMethodsConfig[loginMethod] = _objectSpread3({}, currentLoginMethodConfig);
        });
        log.debug("OpenLogin login method ui config", finalLoginMethodsConfig);
      } else {
        throw new Error("".concat(adapterName, " is not a valid adapter"));
      }
      return finalLoginMethodsConfig;
    };
  }
});

// node_modules/@web3auth/web3auth/dist/web3auth.esm.js
var web3auth_esm_exports = {};
__export(web3auth_esm_exports, {
  Web3Auth: () => Web3Auth,
  defaultEvmDappModalConfig: () => defaultEvmDappModalConfig,
  defaultEvmWalletModalConfig: () => defaultEvmWalletModalConfig,
  defaultOtherModalConfig: () => defaultOtherModalConfig,
  defaultSolanaDappModalConfig: () => defaultSolanaDappModalConfig,
  defaultSolanaWalletModalConfig: () => defaultSolanaWalletModalConfig
});
function ownKeys$12(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$12(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$12(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys4(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
var defaultSolanaDappModalConfig, defaultEvmDappModalConfig, defaultSolanaWalletModalConfig, defaultEvmWalletModalConfig, defaultOtherModalConfig, getDefaultAdapterModule, Web3Auth;
var init_web3auth_esm = __esm({
  "node_modules/@web3auth/web3auth/dist/web3auth.esm.js"() {
    init_base_esm();
    init_defineProperty();
    init_core_esm();
    init_ui_esm();
    defaultSolanaDappModalConfig = {
      chainNamespace: CHAIN_NAMESPACES.SOLANA,
      adapters: {
        [SOLANA_ADAPTERS.TORUS_SOLANA]: {
          label: "Torus Wallet",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        },
        [SOLANA_ADAPTERS.OPENLOGIN]: {
          label: "OpenLogin",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        },
        [SOLANA_ADAPTERS.PHANTOM]: {
          label: "Phantom",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        }
      }
    };
    defaultEvmDappModalConfig = {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      adapters: {
        [EVM_ADAPTERS.TORUS_EVM]: {
          label: "Torus Wallet",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        },
        [EVM_ADAPTERS.METAMASK]: {
          label: "MetaMask",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        },
        [EVM_ADAPTERS.OPENLOGIN]: {
          label: "OpenLogin",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        },
        [EVM_ADAPTERS.WALLET_CONNECT_V1]: {
          label: "Wallet Connect",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        }
      }
    };
    defaultSolanaWalletModalConfig = {
      chainNamespace: CHAIN_NAMESPACES.SOLANA,
      adapters: {
        [SOLANA_ADAPTERS.OPENLOGIN]: {
          label: "OpenLogin",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        }
      }
    };
    defaultEvmWalletModalConfig = {
      chainNamespace: CHAIN_NAMESPACES.EIP155,
      adapters: {
        [EVM_ADAPTERS.OPENLOGIN]: {
          label: "OpenLogin",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        }
      }
    };
    defaultOtherModalConfig = {
      chainNamespace: CHAIN_NAMESPACES.OTHER,
      adapters: {
        [EVM_ADAPTERS.OPENLOGIN]: {
          label: "OpenLogin",
          showOnModal: true,
          showOnMobile: true,
          showOnDesktop: true
        }
      }
    };
    getDefaultAdapterModule = async (params) => {
      const {
        name: name2,
        customChainConfig,
        clientId
      } = params;
      if (!Object.values(CHAIN_NAMESPACES).includes(customChainConfig.chainNamespace))
        throw new Error("Invalid chainNamespace: ".concat(customChainConfig.chainNamespace));
      const finalChainConfig = _objectSpread$12(_objectSpread$12({}, getChainConfig(customChainConfig.chainNamespace, customChainConfig === null || customChainConfig === void 0 ? void 0 : customChainConfig.chainId)), customChainConfig || {});
      if (name2 === WALLET_ADAPTERS.TORUS_EVM) {
        const {
          TorusWalletAdapter
        } = await import("./torusEvmAdapter.esm-U32PMUXZ.js");
        const adapter = new TorusWalletAdapter({
          chainConfig: finalChainConfig
        });
        return adapter;
      } else if (name2 === WALLET_ADAPTERS.TORUS_SOLANA) {
        const {
          SolanaWalletAdapter
        } = await import("./torusSolanaAdapter.esm-6I4TQVEL.js");
        const adapter = new SolanaWalletAdapter({
          chainConfig: finalChainConfig
        });
        return adapter;
      } else if (name2 === WALLET_ADAPTERS.METAMASK) {
        const {
          MetamaskAdapter
        } = await import("./metamaskAdapter.esm-Y5XNBLRV.js");
        const adapter = new MetamaskAdapter({
          chainConfig: finalChainConfig
        });
        return adapter;
      } else if (name2 === WALLET_ADAPTERS.PHANTOM) {
        const {
          PhantomAdapter
        } = await import("./phantomAdapter.esm-UJQVQLS6.js");
        const adapter = new PhantomAdapter({
          chainConfig: finalChainConfig
        });
        return adapter;
      } else if (name2 === WALLET_ADAPTERS.WALLET_CONNECT_V1) {
        const {
          WalletConnectV1Adapter
        } = await import("./walletConnectV1Adapter.esm-TKQIMNDI.js");
        const adapter = new WalletConnectV1Adapter({
          chainConfig: finalChainConfig
        });
        return adapter;
      } else if (name2 === WALLET_ADAPTERS.OPENLOGIN) {
        const {
          OpenloginAdapter,
          getOpenloginDefaultOptions
        } = await import("./openloginAdapter.esm-HT3EXDMB.js");
        const defaultOptions = getOpenloginDefaultOptions(customChainConfig.chainNamespace, customChainConfig === null || customChainConfig === void 0 ? void 0 : customChainConfig.chainId);
        const adapter = new OpenloginAdapter(_objectSpread$12(_objectSpread$12({}, defaultOptions), {}, {
          chainConfig: _objectSpread$12(_objectSpread$12({}, defaultOptions.chainConfig || {}), finalChainConfig),
          adapterSettings: _objectSpread$12(_objectSpread$12({}, defaultOptions.adapterSettings), {}, {
            clientId
          })
        }));
        return adapter;
      }
      throw new Error("Invalid wallet adapter name");
    };
    Web3Auth = class extends Web3AuthCore {
      constructor(options) {
        var _this$options$uiConfi, _this$options$uiConfi2;
        super(options);
        _defineProperty(this, "loginModal", void 0);
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "modalConfig", defaultEvmDappModalConfig);
        this.options = _objectSpread4({}, options);
        const providedChainConfig = this.options.chainConfig;
        if (providedChainConfig.chainNamespace === CHAIN_NAMESPACES.SOLANA) {
          if (options.authMode === "WALLET") {
            this.modalConfig = defaultSolanaWalletModalConfig;
          } else {
            this.modalConfig = defaultSolanaDappModalConfig;
          }
        } else if (providedChainConfig.chainNamespace === CHAIN_NAMESPACES.EIP155) {
          if (options.authMode === "WALLET") {
            this.modalConfig = defaultEvmWalletModalConfig;
          } else {
            this.modalConfig = defaultEvmDappModalConfig;
          }
        } else if (providedChainConfig.chainNamespace === CHAIN_NAMESPACES.OTHER) {
          this.modalConfig = defaultOtherModalConfig;
        } else {
          throw new Error("Invalid chainNamespace provided: ".concat(providedChainConfig.chainNamespace));
        }
        this.loginModal = new LoginModal({
          theme: (_this$options$uiConfi = this.options.uiConfig) === null || _this$options$uiConfi === void 0 ? void 0 : _this$options$uiConfi.theme,
          appLogo: ((_this$options$uiConfi2 = this.options.uiConfig) === null || _this$options$uiConfi2 === void 0 ? void 0 : _this$options$uiConfi2.appLogo) || "",
          version: "",
          adapterListener: this,
          displayErrorsOnModal: this.options.displayErrorsOnModal
        });
        this.subscribeToLoginModalEvents();
      }
      async initModal(params) {
        super.checkInitRequirements();
        await this.loginModal.initModal();
        const providedChainConfig = this.options.chainConfig;
        const allAdapters = [.../* @__PURE__ */ new Set([...Object.keys(this.modalConfig.adapters || {}), ...Object.keys(this.walletAdapters)])];
        const adapterConfigurationPromises = allAdapters.map(async (adapterName) => {
          var _this$modalConfig$ada, _params$modalConfig, _this$modalConfig$ada2, _this$modalConfig$ada3;
          let adapterConfig = ((_this$modalConfig$ada = this.modalConfig.adapters) === null || _this$modalConfig$ada === void 0 ? void 0 : _this$modalConfig$ada[adapterName]) || {
            label: adapterName,
            showOnModal: true,
            showOnMobile: true,
            showOnDesktop: true
          };
          if (params !== null && params !== void 0 && (_params$modalConfig = params.modalConfig) !== null && _params$modalConfig !== void 0 && _params$modalConfig[adapterName]) {
            adapterConfig = _objectSpread4(_objectSpread4({}, adapterConfig), params.modalConfig[adapterName]);
          }
          this.modalConfig.adapters[adapterName] = adapterConfig;
          const adapter = this.walletAdapters[adapterName];
          log.debug("adapter config", adapterName, (_this$modalConfig$ada2 = this.modalConfig.adapters) === null || _this$modalConfig$ada2 === void 0 ? void 0 : _this$modalConfig$ada2[adapterName].showOnModal, adapter);
          if (!adapter && (_this$modalConfig$ada3 = this.modalConfig.adapters) !== null && _this$modalConfig$ada3 !== void 0 && _this$modalConfig$ada3[adapterName].showOnModal) {
            const ad = await getDefaultAdapterModule({
              name: adapterName,
              customChainConfig: this.options.chainConfig,
              clientId: this.options.clientId
            });
            this.walletAdapters[adapterName] = ad;
            return adapterName;
          } else if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.IN_APP || (adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.EXTERNAL || adapterName === this.cachedAdapter) {
            var _this$modalConfig$ada4;
            if (!((_this$modalConfig$ada4 = this.modalConfig.adapters) !== null && _this$modalConfig$ada4 !== void 0 && _this$modalConfig$ada4[adapterName].showOnModal))
              return;
            if (adapterName === WALLET_ADAPTERS.OPENLOGIN) {
              this.walletAdapters[adapterName].setAdapterSettings({
                clientId: this.options.clientId,
                sessionTime: this.options.sessionTime
              });
            } else {
              this.walletAdapters[adapterName].setAdapterSettings({
                sessionTime: this.options.sessionTime
              });
            }
            if (!adapter.chainConfigProxy) {
              var _this$coreOptions$cha;
              const chainConfig = _objectSpread4(_objectSpread4({}, getChainConfig(providedChainConfig.chainNamespace, (_this$coreOptions$cha = this.coreOptions.chainConfig) === null || _this$coreOptions$cha === void 0 ? void 0 : _this$coreOptions$cha.chainId)), this.coreOptions.chainConfig);
              this.walletAdapters[adapterName].setChainConfig(chainConfig);
            }
            return adapterName;
          }
        });
        const adapterNames = await Promise.all(adapterConfigurationPromises);
        const hasInAppWallets = Object.values(this.walletAdapters).some((adapter) => {
          var _this$modalConfig$ada5;
          if (adapter.type !== ADAPTER_CATEGORY.IN_APP)
            return false;
          if (this.modalConfig.adapters[adapter.name].showOnModal !== true)
            return false;
          if (!this.modalConfig.adapters[adapter.name].loginMethods)
            return true;
          const mergedLoginMethods = getAdapterSocialLogins(adapter.name, this.walletAdapters[adapter.name], (_this$modalConfig$ada5 = this.modalConfig.adapters[adapter.name]) === null || _this$modalConfig$ada5 === void 0 ? void 0 : _this$modalConfig$ada5.loginMethods);
          if (Object.values(mergedLoginMethods).some((method) => method.showOnModal))
            return true;
          return false;
        });
        log.debug(hasInAppWallets, this.walletAdapters, "hasInAppWallets");
        const initPromises = adapterNames.map(async (adapterName) => {
          if (!adapterName)
            return;
          try {
            const adapter = this.walletAdapters[adapterName];
            if (this.cachedAdapter !== adapterName && adapter.type === ADAPTER_CATEGORY.EXTERNAL) {
              return;
            }
            this.subscribeToAdapterEvents(adapter);
            if (adapter.status === ADAPTER_STATUS.NOT_READY)
              await adapter.init({
                autoConnect: this.cachedAdapter === adapterName
              });
            if (adapter.type === ADAPTER_CATEGORY.IN_APP) {
              this.initializeInAppWallet(adapterName);
            }
          } catch (error) {
            log.error(error, "error while initializing adapter");
          }
        });
        this.status = ADAPTER_STATUS.READY;
        await Promise.all(initPromises);
        const hasExternalWallets = allAdapters.some((adapterName) => {
          var _this$walletAdapters$, _this$modalConfig$ada6;
          return ((_this$walletAdapters$ = this.walletAdapters[adapterName]) === null || _this$walletAdapters$ === void 0 ? void 0 : _this$walletAdapters$.type) === ADAPTER_CATEGORY.EXTERNAL && ((_this$modalConfig$ada6 = this.modalConfig.adapters) === null || _this$modalConfig$ada6 === void 0 ? void 0 : _this$modalConfig$ada6[adapterName].showOnModal);
        });
        if (hasExternalWallets) {
          this.loginModal.initExternalWalletContainer();
        }
        if (!hasInAppWallets && hasExternalWallets) {
          await this.initExternalWalletAdapters(false, {
            showExternalWalletsOnly: true
          });
        }
      }
      async connect() {
        if (this.provider)
          return this.provider;
        this.loginModal.open();
        return new Promise((resolve, reject) => {
          this.once(ADAPTER_EVENTS.CONNECTED, () => {
            return resolve(this.provider);
          });
          this.once(ADAPTER_EVENTS.ERRORED, (err) => {
            return reject(err);
          });
        });
      }
      async initExternalWalletAdapters(externalWalletsInitialized, options) {
        if (externalWalletsInitialized)
          return;
        const adaptersConfig = {};
        const adaptersData = {};
        const adapterPromises = Object.keys(this.walletAdapters).map(async (adapterName) => {
          try {
            const adapter = this.walletAdapters[adapterName];
            if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.EXTERNAL) {
              log.debug("init external wallet", this.cachedAdapter, adapterName);
              this.subscribeToAdapterEvents(adapter);
              if (this.cachedAdapter === adapterName) {
                return;
              }
              if (adapter.status === ADAPTER_STATUS.NOT_READY)
                await adapter.init({
                  autoConnect: this.cachedAdapter === adapterName
                });
              adaptersConfig[adapterName] = this.modalConfig.adapters[adapterName];
              adaptersData[adapterName] = adapter.adapterData || {};
              return adapterName;
            }
          } catch (error) {
            log.error(error, "error while initializing adapter");
          }
        });
        const adapterInitResults = await Promise.all(adapterPromises);
        const finalAdaptersConfig = {};
        adapterInitResults.forEach((result) => {
          if (result) {
            finalAdaptersConfig[result] = adaptersConfig[result];
          }
        });
        this.loginModal.addWalletLogins(finalAdaptersConfig, {
          showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
        });
      }
      initializeInAppWallet(adapterName) {
        log.info("adapterInitResults", adapterName);
        if (this.walletAdapters[adapterName].type === ADAPTER_CATEGORY.IN_APP) {
          var _this$modalConfig$ada7, _this$options$uiConfi3;
          this.loginModal.addSocialLogins(adapterName, getAdapterSocialLogins(adapterName, this.walletAdapters[adapterName], (_this$modalConfig$ada7 = this.modalConfig.adapters[adapterName]) === null || _this$modalConfig$ada7 === void 0 ? void 0 : _this$modalConfig$ada7.loginMethods), ((_this$options$uiConfi3 = this.options.uiConfig) === null || _this$options$uiConfi3 === void 0 ? void 0 : _this$options$uiConfi3.loginMethodsOrder) || OPENLOGIN_PROVIDERS);
        }
      }
      subscribeToLoginModalEvents() {
        this.loginModal.on(LOGIN_MODAL_EVENTS.LOGIN, async (params) => {
          try {
            await this.connectTo(params.adapter, params.loginParams);
          } catch (error) {
            log.error("Error while connecting to adapter: ".concat(params.adapter), error);
          }
        });
        this.loginModal.on(LOGIN_MODAL_EVENTS.INIT_EXTERNAL_WALLETS, async (params) => {
          await this.initExternalWalletAdapters(params.externalWalletsInitialized);
        });
        this.loginModal.on(LOGIN_MODAL_EVENTS.DISCONNECT, async () => {
          try {
            await this.logout();
          } catch (error) {
            log.error("Error while disconnecting", error);
          }
        });
        this.loginModal.on(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, async (visibility) => {
          var _this$walletAdapters$2;
          log.debug("is login modal visible", visibility);
          this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, visibility);
          const walletConnectStatus = (_this$walletAdapters$2 = this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1]) === null || _this$walletAdapters$2 === void 0 ? void 0 : _this$walletAdapters$2.status;
          if (visibility && walletConnectStatus === ADAPTER_STATUS.READY) {
            try {
              this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1].connect();
            } catch (error) {
              log.error("Error while disconnecting to wallet connect in core", error);
            }
          }
        });
      }
    };
  }
});

// node_modules/moralis-v1/lib/browser/Web3Connector/Web3AuthConnector.js
var require_Web3AuthConnector = __commonJS({
  "node_modules/moralis-v1/lib/browser/Web3Connector/Web3AuthConnector.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$keys = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Web3Auth = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _concat = _interopRequireDefault(require_concat4());
    var _promise = _interopRequireDefault(require_promise3());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    var _verifyChainId = _interopRequireDefault(require_verifyChainId());
    var _AbstractWeb3Connector = _interopRequireDefault(require_AbstractWeb3Connector());
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context5, _context6;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty(_context5 = ownKeys5(Object(source), true)).call(_context5, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context6 = ownKeys5(Object(source))).call(_context6, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Web3Auth2 = function(_AbstractWeb3Connecto) {
      (0, _inherits2.default)(Web3Auth3, _AbstractWeb3Connecto);
      var _super = _createSuper(Web3Auth3);
      function Web3Auth3() {
        var _context;
        var _this;
        (0, _classCallCheck2.default)(this, Web3Auth3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, (0, _concat.default)(_context = [this]).call(_context, args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "type", "web3Auth");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "connect", function(web3auth) {
          return new _promise.default(function(resolve, reject) {
            (function(web3auth2) {
              web3auth2.loginModal.on("MODAL_VISIBILITY", function() {
                var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(visibility) {
                  return _regenerator.default.wrap(function(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          if (!visibility) {
                            reject(new Error("Web3Auth: User closed login modal."));
                          }
                        case 1:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee);
                }));
                return function() {
                  return _ref.apply(this, arguments);
                };
              }());
            })(web3auth);
            web3auth.connect().then(resolve).catch(reject);
          });
        });
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "activate", (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
          var _ref3, _ref3$chainId, chainId, clientId, theme, appLogo, loginMethodsOrder, rpcTarget, displayName, blockExplorer, ticker, tickerName, _Web3Auth, _require, _window, _window$Web3auth, ethChainConfig, web3auth, provider, _web3auth, _web3auth2, _web3auth3, isSocialLogin, ether, signer, values, providerChainId, _args2 = arguments;
          return _regenerator.default.wrap(function(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _ref3 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref3$chainId = _ref3.chainId, chainId = _ref3$chainId === void 0 ? "0x1" : _ref3$chainId, clientId = _ref3.clientId, theme = _ref3.theme, appLogo = _ref3.appLogo, loginMethodsOrder = _ref3.loginMethodsOrder, rpcTarget = _ref3.rpcTarget, displayName = _ref3.displayName, blockExplorer = _ref3.blockExplorer, ticker = _ref3.ticker, tickerName = _ref3.tickerName;
                  if (clientId) {
                    _context3.next = 3;
                    break;
                  }
                  throw new Error('"clientId" not provided, please provide clientId');
                case 3:
                  try {
                    _Web3Auth = (_require = (init_web3auth_esm(), __toCommonJS(web3auth_esm_exports))) === null || _require === void 0 ? void 0 : _require.Web3Auth;
                  } catch (_unused) {
                  }
                  if (!_Web3Auth) {
                    _Web3Auth = (_window = window) === null || _window === void 0 ? void 0 : (_window$Web3auth = _window.Web3auth) === null || _window$Web3auth === void 0 ? void 0 : _window$Web3auth.Web3Auth;
                  }
                  if (_Web3Auth) {
                    _context3.next = 7;
                    break;
                  }
                  throw new Error('"@web3auth/web3auth" not installed, please install');
                case 7:
                  ethChainConfig = _objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5({
                    chainNamespace: "eip155",
                    chainId: (0, _verifyChainId.default)(chainId)
                  }, rpcTarget && {
                    rpcTarget
                  }), displayName && {
                    displayName
                  }), blockExplorer && {
                    blockExplorer
                  }), ticker && {
                    ticker
                  }), tickerName && {
                    tickerName
                  });
                  try {
                    web3auth = new _Web3Auth({
                      chainConfig: ethChainConfig,
                      uiConfig: {
                        theme: theme !== null && theme !== void 0 ? theme : "dark",
                        appLogo: appLogo !== null && appLogo !== void 0 ? appLogo : "https://moralis.io/wp-content/uploads/2021/05/moralisWhiteLogo.svg",
                        loginMethodsOrder
                      },
                      clientId
                    });
                  } catch (_unused2) {
                  }
                  if (web3auth) {
                    _context3.next = 11;
                    break;
                  }
                  throw new Error("Could not connect via Web3Auth, error during initializing Web3Auth");
                case 11:
                  _context3.next = 13;
                  return web3auth.initModal();
                case 13:
                  provider = null;
                  _context3.next = 16;
                  return _this.connect(web3auth);
                case 16:
                  provider = _context3.sent;
                  if (provider) {
                    _context3.next = 19;
                    break;
                  }
                  throw new Error("Could not connect via Web3Auth, error in connecting to provider");
                case 19:
                  _context3.prev = 19;
                  isSocialLogin = (_web3auth = web3auth) !== null && _web3auth !== void 0 && _web3auth.provider ? false : true;
                  ether = new _ethers.ethers.providers.Web3Provider((_web3auth2 = web3auth) !== null && _web3auth2 !== void 0 && _web3auth2.provider ? web3auth.provider : web3auth);
                  signer = ether.getSigner();
                  _context3.next = 25;
                  return _promise.default.all([ether.getNetwork(), signer.getAddress()]);
                case 25:
                  values = _context3.sent;
                  providerChainId = values[0].chainId;
                  _this.account = values[1].toLocaleLowerCase();
                  _this.chainId = "0x".concat(providerChainId.toString(16));
                  _this.provider = isSocialLogin ? ether : (_web3auth3 = web3auth) === null || _web3auth3 === void 0 ? void 0 : _web3auth3.provider;
                  _this.web3Instance = web3auth;
                  _this.subscribeToEvents(_this.provider);
                  return _context3.abrupt("return", {
                    chainId: _this.chainId,
                    account: _this.account,
                    provider: _this.provider
                  });
                case 35:
                  _context3.prev = 35;
                  _context3.t0 = _context3["catch"](19);
                  throw new Error("Could not connect via Web3Auth, error while authenticating");
                case 38:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee2, null, [[19, 35]]);
        })));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "deactivate", (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
          return _regenerator.default.wrap(function(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this.unsubscribeToEvents(_this.provider);
                  if (!_this.web3Instance) {
                    _context4.next = 4;
                    break;
                  }
                  _context4.next = 4;
                  return _this.web3Instance.logout();
                case 4:
                  _this.account = null;
                  _this.chainId = null;
                  _this.provider = null;
                case 7:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee3);
        })));
        return _this;
      }
      return (0, _createClass2.default)(Web3Auth3);
    }(_AbstractWeb3Connector.default);
    exports.Web3Auth = Web3Auth2;
  }
});

// node_modules/moralis-v1/lib/browser/MoralisWeb3.js
var require_MoralisWeb3 = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisWeb3.js"(exports) {
    "use strict";
    var _typeof3 = require_typeof();
    var _sliceInstanceProperty = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray = require_is_array4();
    var _WeakMap = require_weak_map3();
    var _Object$defineProperty = require_define_property3();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _filter = _interopRequireDefault(require_filter4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _concat = _interopRequireDefault(require_concat4());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _map = _interopRequireDefault(require_map10());
    var _trim = _interopRequireDefault(require_trim4());
    var _find = _interopRequireDefault(require_find4());
    var _every = _interopRequireDefault(require_every4());
    var _values = _interopRequireDefault(require_values3());
    var _bind = _interopRequireDefault(require_bind8());
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    var _events = _interopRequireDefault(require_events());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _MoralisErd = _interopRequireDefault(require_MoralisErd());
    var _MoralisDot = _interopRequireDefault(require_MoralisDot());
    var _MoralisSol = _interopRequireDefault(require_MoralisSol());
    var _TransferUtils = _interopRequireDefault(require_TransferUtils());
    var _Cloud = require_Cloud();
    var _createSigningData = _interopRequireDefault(require_createSigningData());
    var _WalletConnectWeb3Connector = _interopRequireDefault(require_WalletConnectWeb3Connector());
    var _InjectedWeb3Connector = _interopRequireDefault(require_InjectedWeb3Connector());
    var _NetworkWeb3Connector = _interopRequireDefault(require_NetworkWeb3Connector());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _InternalWeb3Provider = _interopRequireWildcard(require_InternalWeb3Provider());
    var _detectProvider = _interopRequireDefault(require_dist());
    var _MagicWeb3Connector = _interopRequireDefault(require_MagicWeb3Connector());
    var _Web3AuthConnector = require_Web3AuthConnector();
    var _context30;
    var _context31;
    var _context32;
    var _context33;
    var _context34;
    var _context35;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof _WeakMap !== "function")
        return null;
      var cacheBabelInterop = new _WeakMap();
      var cacheNodeInterop = new _WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      for (var key2 in obj) {
        if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
          var desc = _Object$defineProperty && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key2) : null;
          if (desc && (desc.get || desc.set)) {
            _Object$defineProperty(newObj, key2, desc);
          } else {
            newObj[key2] = obj[key2];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context36;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty(_context36 = Object.prototype.toString.call(o2)).call(_context36, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var MoralisEmitter = new _events.default();
    var ERROR_WEB3_MISSING = "Missing web3 instance, make sure to call Moralis.enableWeb3() or Moralis.authenticate()";
    var MoralisWeb3 = function() {
      function MoralisWeb32() {
        (0, _classCallCheck2.default)(this, MoralisWeb32);
      }
      (0, _createClass2.default)(MoralisWeb32, null, [{
        key: "addListener",
        value: (
          // Ethers.js instance that will be set after calling enableWeb3
          // Internal web3 provider, containing the Ethers.js Web3 library for internal usage for handling transactions, contracts etc.
          function(eventName, listener) {
            MoralisEmitter.on(eventName, listener);
            return function() {
              return MoralisEmitter.removeListener(eventName, listener);
            };
          }
        )
      }, {
        key: "on",
        value: function(eventName, listener) {
          MoralisEmitter.on(eventName, listener);
          return function() {
            return MoralisEmitter.removeListener(eventName, listener);
          };
        }
      }, {
        key: "once",
        value: function(eventName, listener) {
          MoralisEmitter.once(eventName, listener);
          return function() {
            return MoralisEmitter.removeListener(eventName, listener);
          };
        }
      }, {
        key: "removeListener",
        value: function(eventName, listener) {
          return MoralisEmitter.removeListener(eventName, listener);
        }
      }, {
        key: "off",
        value: function(eventName, listener) {
          return MoralisEmitter.off(eventName, listener);
        }
      }, {
        key: "removeAllListeners",
        value: function(eventName, listener) {
          return MoralisEmitter.removeAllListeners(eventName, listener);
        }
      }, {
        key: "isWeb3Enabled",
        value: function() {
          return this.ensureWeb3IsInstalled();
        }
      }, {
        key: "handleWeb3AccountChanged",
        value: function(account) {
          MoralisEmitter.emit(_InternalWeb3Provider.InternalWeb3Events.ACCOUNT_CHANGED, account);
        }
      }, {
        key: "handleWeb3ChainChanged",
        value: function(chainId) {
          var _this$internalWeb3Pro;
          this.web3 = (_this$internalWeb3Pro = this.internalWeb3Provider) === null || _this$internalWeb3Pro === void 0 ? void 0 : _this$internalWeb3Pro.web3;
          MoralisEmitter.emit(_InternalWeb3Provider.InternalWeb3Events.CHAIN_CHANGED, chainId);
        }
      }, {
        key: "handleWeb3Connect",
        value: function(connectInfo) {
          MoralisEmitter.emit(_InternalWeb3Provider.InternalWeb3Events.PROVIDER_CONNECT, connectInfo);
        }
      }, {
        key: "handleWeb3Disconnect",
        value: function(error) {
          if ((error === null || error === void 0 ? void 0 : error.message) === "MetaMask: Disconnected from chain. Attempting to connect.") {
            return;
          }
          this.cleanup();
          MoralisEmitter.emit(_InternalWeb3Provider.InternalWeb3Events.PROVIDER_DISCONNECT, error);
        }
      }, {
        key: "enableWeb3",
        value: function() {
          var _enableWeb = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var _this = this;
            var options, _options$connector, Connector, connector, anyNetwork, provider, chainId, account, internalWeb3, _yield$this$internalW, web3, _args = arguments;
            return _regenerator.default.wrap(function(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    if (!this.isEnablingWeb3) {
                      _context.next = 3;
                      break;
                    }
                    throw new Error("Cannot execute Moralis.enableWeb3(), as Moralis Moralis.enableWeb3() already has been called, but is not finished yet ");
                  case 3:
                    _context.prev = 3;
                    this.isEnablingWeb3 = true;
                    if (this.speedyNodeApiKey) {
                      options.speedyNodeApiKey = this.speedyNodeApiKey;
                      options.provider = "network";
                    }
                    Connector = (_options$connector = options === null || options === void 0 ? void 0 : options.connector) !== null && _options$connector !== void 0 ? _options$connector : MoralisWeb32.getWeb3Connector(options === null || options === void 0 ? void 0 : options.provider);
                    connector = new Connector(options);
                    anyNetwork = (options === null || options === void 0 ? void 0 : options.anyNetwork) === true ? true : false;
                    this.internalWeb3Provider = new _InternalWeb3Provider.default(connector, anyNetwork, options.privateKey);
                    this.internalWeb3Provider.on(_InternalWeb3Provider.InternalWeb3Events.ACCOUNT_CHANGED, function(args) {
                      return _this.handleWeb3AccountChanged(args);
                    });
                    this.internalWeb3Provider.on(_InternalWeb3Provider.InternalWeb3Events.CHAIN_CHANGED, function(args) {
                      return _this.handleWeb3ChainChanged(args);
                    });
                    this.internalWeb3Provider.on(_InternalWeb3Provider.InternalWeb3Events.PROVIDER_CONNECT, function(args) {
                      return _this.handleWeb3Connect(args);
                    });
                    this.internalWeb3Provider.on(_InternalWeb3Provider.InternalWeb3Events.PROVIDER_DISCONNECT, function(args) {
                      return _this.handleWeb3Disconnect(args);
                    });
                    _context.prev = 14;
                    _context.next = 17;
                    return this.internalWeb3Provider.activate(options);
                  case 17:
                    _yield$this$internalW = _context.sent;
                    provider = _yield$this$internalW.provider;
                    chainId = _yield$this$internalW.chainId;
                    account = _yield$this$internalW.account;
                    internalWeb3 = _yield$this$internalW.web3;
                    if (provider) {
                      _context.next = 24;
                      break;
                    }
                    throw new Error("Failed to activate, no provider returned");
                  case 24:
                    _context.next = 31;
                    break;
                  case 26:
                    _context.prev = 26;
                    _context.t0 = _context["catch"](14);
                    _context.next = 30;
                    return this.cleanup();
                  case 30:
                    throw _context.t0;
                  case 31:
                    web3 = internalWeb3;
                    this.web3 = internalWeb3;
                    MoralisEmitter.emit(_InternalWeb3Provider.InternalWeb3Events.WEB3_ENABLED, {
                      chainId,
                      account,
                      connector,
                      provider,
                      web3
                    });
                    return _context.abrupt("return", web3);
                  case 37:
                    _context.prev = 37;
                    _context.t1 = _context["catch"](3);
                    throw _context.t1;
                  case 40:
                    _context.prev = 40;
                    this.isEnablingWeb3 = false;
                    return _context.finish(40);
                  case 43:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3, 37, 40, 43], [14, 26]]);
          }));
          return function() {
            return _enableWeb.apply(this, arguments);
          };
        }()
      }, {
        key: "isDotAuth",
        value: function(options) {
          switch (options === null || options === void 0 ? void 0 : options.type) {
            case "dot":
            case "polkadot":
            case "kusama":
              return true;
            default:
              return false;
          }
        }
      }, {
        key: "isElrondAuth",
        value: function(options) {
          switch (options === null || options === void 0 ? void 0 : options.type) {
            case "erd":
            case "elrond":
              return true;
            default:
              return false;
          }
        }
      }, {
        key: "isSolAuth",
        value: function(options) {
          switch (options === null || options === void 0 ? void 0 : options.type) {
            case "sol":
              return true;
            default:
              return false;
          }
        }
      }, {
        key: "getWeb3Connector",
        value: function(provider) {
          switch (provider) {
            case "walletconnect":
            case "walletConnect":
            case "wc":
              return _WalletConnectWeb3Connector.default;
            case "network":
              return _NetworkWeb3Connector.default;
            case "magicLink":
              return _MagicWeb3Connector.default;
            case "web3Auth":
              return _Web3AuthConnector.Web3Auth;
            default:
              return _InjectedWeb3Connector.default;
          }
        }
      }, {
        key: "deactivateWeb3",
        value: function() {
          var _deactivateWeb = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.cleanup());
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          return function() {
            return _deactivateWeb.apply(this, arguments);
          };
        }()
        /**
         * Cleanup previously established provider
         */
      }, {
        key: "cleanup",
        value: function() {
          var _cleanup = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!this.isEnablingWeb3) {
                      _context3.next = 5;
                      break;
                    }
                    this.isEnablingWeb3 = false;
                    this.internalWeb3Provider = null;
                    this.web3 = null;
                    return _context3.abrupt("return");
                  case 5:
                    if (this.web3 && this.internalWeb3Provider) {
                      MoralisEmitter.emit(_InternalWeb3Provider.InternalWeb3Events.WEB3_DEACTIVATED, {
                        connector: this.internalWeb3Provider.connector,
                        provider: this.internalWeb3Provider.provider
                      });
                    }
                    if (!this.internalWeb3Provider) {
                      _context3.next = 18;
                      break;
                    }
                    this.internalWeb3Provider.removeListener(_InternalWeb3Provider.InternalWeb3Events.ACCOUNT_CHANGED, this.handleWeb3AccountChanged);
                    this.internalWeb3Provider.removeListener(_InternalWeb3Provider.InternalWeb3Events.CHAIN_CHANGED, this.handleWeb3ChainChanged);
                    this.internalWeb3Provider.removeListener(_InternalWeb3Provider.InternalWeb3Events.PROVIDER_CONNECT, this.handleWeb3Connect);
                    this.internalWeb3Provider.removeListener(_InternalWeb3Provider.InternalWeb3Events.PROVIDER_DISCONNECT, this.handleWeb3Disconnect);
                    _context3.prev = 11;
                    _context3.next = 14;
                    return this.internalWeb3Provider.deactivate();
                  case 14:
                    _context3.next = 18;
                    break;
                  case 16:
                    _context3.prev = 16;
                    _context3.t0 = _context3["catch"](11);
                  case 18:
                    this.internalWeb3Provider = null;
                    this.web3 = null;
                  case 20:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[11, 16]]);
          }));
          return function() {
            return _cleanup.apply(this, arguments);
          };
        }()
      }, {
        key: "authenticate",
        value: function() {
          var _authenticate = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(options) {
            var isLoggedIn, _this$getInternalWeb, account, internalWeb3, signer, message, data, ethAddress, signature2, authData, user;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return _ParseUser.default.currentAsync();
                  case 2:
                    isLoggedIn = _context4.sent;
                    if (!isLoggedIn) {
                      _context4.next = 6;
                      break;
                    }
                    _context4.next = 6;
                    return _ParseUser.default.logOut();
                  case 6:
                    if (!MoralisWeb32.isDotAuth(options)) {
                      _context4.next = 8;
                      break;
                    }
                    return _context4.abrupt("return", _MoralisDot.default.authenticate(options));
                  case 8:
                    if (!MoralisWeb32.isElrondAuth(options)) {
                      _context4.next = 10;
                      break;
                    }
                    return _context4.abrupt("return", _MoralisErd.default.authenticate(options));
                  case 10:
                    if (!MoralisWeb32.isSolAuth(options)) {
                      _context4.next = 12;
                      break;
                    }
                    return _context4.abrupt("return", _MoralisSol.default.authenticate(options));
                  case 12:
                    _context4.next = 14;
                    return this.enableWeb3(options);
                  case 14:
                    _this$getInternalWeb = this.getInternalWeb3Provider(), account = _this$getInternalWeb.account, internalWeb3 = _this$getInternalWeb.web3, signer = _this$getInternalWeb.signer;
                    if (account) {
                      _context4.next = 17;
                      break;
                    }
                    throw new Error("Cannot authenticate, no account returned from provider");
                  case 17:
                    message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisWeb32.getSigningData();
                    _context4.next = 20;
                    return (0, _createSigningData.default)(message);
                  case 20:
                    data = _context4.sent;
                    ethAddress = account.toLowerCase();
                    if (ethAddress) {
                      _context4.next = 24;
                      break;
                    }
                    throw new Error("Address not found");
                  case 24:
                    _context4.next = 26;
                    return signer.signMessage(data);
                  case 26:
                    signature2 = _context4.sent;
                    if (signature2) {
                      _context4.next = 29;
                      break;
                    }
                    throw new Error("Data not signed");
                  case 29:
                    authData = {
                      id: ethAddress,
                      signature: signature2,
                      data
                    };
                    _context4.next = 32;
                    return _ParseUser.default.logInWith("moralisEth", {
                      authData
                    });
                  case 32:
                    user = _context4.sent;
                    if (user) {
                      _context4.next = 35;
                      break;
                    }
                    throw new Error("Could not get user");
                  case 35:
                    _context4.next = 37;
                    return user.setACL(new _ParseACL.default(user));
                  case 37:
                    user.addAllUnique("accounts", [ethAddress]);
                    user.set("ethAddress", ethAddress);
                    _context4.next = 41;
                    return user.save(null, options);
                  case 41:
                    return _context4.abrupt("return", user);
                  case 42:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          return function() {
            return _authenticate.apply(this, arguments);
          };
        }()
      }, {
        key: "link",
        value: function() {
          var _link = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(account, options) {
            var _this$getInternalWeb2, signer, message, user, ethAddress, EthAddress, query, ethAddressRecord, data, signature2, authData;
            return _regenerator.default.wrap(function(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _this$getInternalWeb2 = this.getInternalWeb3Provider(), signer = _this$getInternalWeb2.signer;
                    message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisWeb32.getSigningData();
                    _context5.next = 4;
                    return _ParseUser.default.currentAsync();
                  case 4:
                    user = _context5.sent;
                    ethAddress = account.toLowerCase();
                    EthAddress = _ParseObject.default.extend("_EthAddress");
                    query = new _ParseQuery.default(EthAddress);
                    _context5.next = 10;
                    return query.get(ethAddress).catch(function() {
                      return null;
                    });
                  case 10:
                    ethAddressRecord = _context5.sent;
                    if (ethAddressRecord) {
                      _context5.next = 23;
                      break;
                    }
                    _context5.next = 14;
                    return (0, _createSigningData.default)(message);
                  case 14:
                    data = _context5.sent;
                    _context5.next = 17;
                    return signer.signMessage(data);
                  case 17:
                    signature2 = _context5.sent;
                    if (signature2) {
                      _context5.next = 20;
                      break;
                    }
                    throw new Error("Data not signed");
                  case 20:
                    authData = {
                      id: ethAddress,
                      signature: signature2,
                      data
                    };
                    _context5.next = 23;
                    return user.linkWith("moralisEth", {
                      authData
                    });
                  case 23:
                    user.addAllUnique("accounts", [ethAddress]);
                    user.set("ethAddress", ethAddress);
                    _context5.next = 27;
                    return user.save(null, options);
                  case 27:
                    return _context5.abrupt("return", user);
                  case 28:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          return function() {
            return _link.apply(this, arguments);
          };
        }()
      }, {
        key: "unlink",
        value: function() {
          var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(account) {
            var _user$get;
            var accountsLower, EthAddress, query, ethAddressRecord, user, accounts, nextAccounts;
            return _regenerator.default.wrap(function(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    accountsLower = account.toLowerCase();
                    EthAddress = _ParseObject.default.extend("_EthAddress");
                    query = new _ParseQuery.default(EthAddress);
                    _context6.next = 5;
                    return query.get(accountsLower);
                  case 5:
                    ethAddressRecord = _context6.sent;
                    _context6.next = 8;
                    return ethAddressRecord.destroy();
                  case 8:
                    _context6.next = 10;
                    return _ParseUser.default.currentAsync();
                  case 10:
                    user = _context6.sent;
                    accounts = (_user$get = user.get("accounts")) !== null && _user$get !== void 0 ? _user$get : [];
                    nextAccounts = (0, _filter.default)(accounts).call(accounts, function(v2) {
                      return v2 !== accountsLower;
                    });
                    user.set("accounts", nextAccounts);
                    user.set("ethAddress", nextAccounts[0]);
                    _context6.next = 17;
                    return user._unlinkFrom("moralisEth");
                  case 17:
                    _context6.next = 19;
                    return user.save();
                  case 19:
                    return _context6.abrupt("return", user);
                  case 20:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));
          return function() {
            return _unlink.apply(this, arguments);
          };
        }()
      }, {
        key: "initPlugins",
        value: function() {
          var _initPlugins = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee8(installedPlugins) {
            var _this2 = this;
            var specs, allPlugins;
            return _regenerator.default.wrap(function(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.t0 = installedPlugins;
                    if (_context10.t0) {
                      _context10.next = 5;
                      break;
                    }
                    _context10.next = 4;
                    return (0, _Cloud.run)("getPluginSpecs");
                  case 4:
                    _context10.t0 = _context10.sent;
                  case 5:
                    specs = _context10.t0;
                    if (!this.Plugins)
                      this.Plugins = {};
                    if (specs) {
                      _context10.next = 9;
                      break;
                    }
                    return _context10.abrupt("return");
                  case 9:
                    allPlugins = this.Plugins;
                    (0, _forEach.default)(specs).call(specs, function(plugin) {
                      var _context7;
                      allPlugins[plugin.name] = {};
                      (0, _forEach.default)(_context7 = plugin.functions).call(_context7, function(f3) {
                        allPlugins[plugin.name][f3] = function() {
                          var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7(params, options) {
                            var _context8;
                            var response, error, triggerReturn;
                            return _regenerator.default.wrap(function(_context9) {
                              while (1) {
                                switch (_context9.prev = _context9.next) {
                                  case 0:
                                    if (!options)
                                      options = {};
                                    _context9.next = 3;
                                    return (0, _Cloud.run)((0, _concat.default)(_context8 = "".concat(plugin.name, "_")).call(_context8, f3), params);
                                  case 3:
                                    response = _context9.sent;
                                    if (response.data.success) {
                                      _context9.next = 7;
                                      break;
                                    }
                                    error = (0, _stringify.default)(response.data.data, null, 2);
                                    throw new Error("Something went wrong\n".concat(error));
                                  case 7:
                                    if (!(options.disableTriggers !== true)) {
                                      _context9.next = 13;
                                      break;
                                    }
                                    _context9.next = 10;
                                    return _this2.handleTriggers(response.data.result.triggers, response.data.result.data);
                                  case 10:
                                    triggerReturn = _context9.sent;
                                    if (!triggerReturn) {
                                      _context9.next = 13;
                                      break;
                                    }
                                    return _context9.abrupt("return", triggerReturn);
                                  case 13:
                                    return _context9.abrupt("return", response.data.result);
                                  case 14:
                                  case "end":
                                    return _context9.stop();
                                }
                              }
                            }, _callee7);
                          }));
                          return function() {
                            return _ref.apply(this, arguments);
                          };
                        }();
                      });
                    });
                    this.Plugins = allPlugins;
                  case 12:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee8, this);
          }));
          return function() {
            return _initPlugins.apply(this, arguments);
          };
        }()
      }, {
        key: "handleTriggers",
        value: function() {
          var _handleTriggers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee9(triggersArray, payload) {
            var _this3 = this;
            var _loop, i2, _ret;
            return _regenerator.default.wrap(function(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    if (triggersArray) {
                      _context14.next = 2;
                      break;
                    }
                    return _context14.abrupt("return");
                  case 2:
                    _loop = _regenerator.default.mark(function _loop2(i3) {
                      var _triggersArray$i, _triggersArray$i$data, _triggersArray$i2, _triggersArray$i2$dat, _triggersArray$i$data2, _triggersArray$i3, _triggersArray$i3$dat, _triggersArray$i4, _triggersArray$i4$dat, _triggersArray$i5, _triggersArray$i6, _triggersArray$i7, _triggersArray$i8, _triggersArray$i9, _triggersArray$i10, _triggersArray$i11, _triggersArray$i12, _triggersArray$i13, _triggersArray$i14, _triggersArray$i15, _triggersArray$i16, _triggersArray$i17, _triggersArray$i18, _triggersArray$i20, _triggersArray$i22, _triggersArray$i23, _triggersArray$i24;
                      var message, _response, _context11, _context12, _triggersArray$i19, _JSON$parse, domain, types, _message, signature2, result, _JSON$parse2, _domain, _types, _message2;
                      return _regenerator.default.wrap(function(_context13) {
                        while (1) {
                          switch (_context13.prev = _context13.next) {
                            case 0:
                              _context13.t0 = triggersArray[i3].name;
                              _context13.next = _context13.t0 === "openUrl" ? 3 : _context13.t0 === "web3Transaction" ? 5 : _context13.t0 === "web3Sign" ? 18 : _context13.t0 === "callPluginEndpoint" ? 33 : _context13.t0 === "web3SignV4" ? 55 : 80;
                              break;
                            case 3:
                              if (triggersArray[i3].newTab)
                                window.open(triggersArray[i3].url);
                              else
                                window.open(triggersArray[i3].url, "_self");
                              return _context13.abrupt("break", 81);
                            case 5:
                              _context13.next = 7;
                              return _this3.getInternalWeb3Provider().signer.sendTransaction({
                                from: (_triggersArray$i = triggersArray[i3]) === null || _triggersArray$i === void 0 ? void 0 : (_triggersArray$i$data = _triggersArray$i.data) === null || _triggersArray$i$data === void 0 ? void 0 : _triggersArray$i$data.from,
                                to: (_triggersArray$i2 = triggersArray[i3]) === null || _triggersArray$i2 === void 0 ? void 0 : (_triggersArray$i2$dat = _triggersArray$i2.data) === null || _triggersArray$i2$dat === void 0 ? void 0 : _triggersArray$i2$dat.to,
                                value: _ethers.ethers.BigNumber.from((_triggersArray$i$data2 = (_triggersArray$i3 = triggersArray[i3]) === null || _triggersArray$i3 === void 0 ? void 0 : (_triggersArray$i3$dat = _triggersArray$i3.data) === null || _triggersArray$i3$dat === void 0 ? void 0 : _triggersArray$i3$dat.value) !== null && _triggersArray$i$data2 !== void 0 ? _triggersArray$i$data2 : 0),
                                data: (_triggersArray$i4 = triggersArray[i3]) === null || _triggersArray$i4 === void 0 ? void 0 : (_triggersArray$i4$dat = _triggersArray$i4.data) === null || _triggersArray$i4$dat === void 0 ? void 0 : _triggersArray$i4$dat.data
                              });
                            case 7:
                              _response = _context13.sent;
                              if (!(((_triggersArray$i5 = triggersArray[i3]) === null || _triggersArray$i5 === void 0 ? void 0 : _triggersArray$i5.shouldAwait) === true)) {
                                _context13.next = 12;
                                break;
                              }
                              _context13.next = 11;
                              return _response.wait();
                            case 11:
                              _response = _context13.sent;
                            case 12:
                              if (((_triggersArray$i6 = triggersArray[i3]) === null || _triggersArray$i6 === void 0 ? void 0 : _triggersArray$i6.saveResponse) === true)
                                _this3.memoryCard.save(_response);
                              if (!(((_triggersArray$i7 = triggersArray[i3]) === null || _triggersArray$i7 === void 0 ? void 0 : _triggersArray$i7.shouldReturnPayload) === true)) {
                                _context13.next = 15;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: {
                                  payload,
                                  response: _response
                                }
                              });
                            case 15:
                              if (!(((_triggersArray$i8 = triggersArray[i3]) === null || _triggersArray$i8 === void 0 ? void 0 : _triggersArray$i8.shouldReturnResponse) === true)) {
                                _context13.next = 17;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: _response
                              });
                            case 17:
                              return _context13.abrupt("break", 81);
                            case 18:
                              if (triggersArray[i3].message) {
                                _context13.next = 20;
                                break;
                              }
                              throw new Error("web3Sign trigger does not have a message to sign");
                            case 20:
                              if (triggersArray[i3].signer) {
                                _context13.next = 22;
                                break;
                              }
                              throw new Error("web3Sign trigger signer address missing or invalid");
                            case 22:
                              message = JSON.parse(triggersArray[i3].message);
                              delete message.types.EIP712Domain;
                              _context13.next = 26;
                              return _this3.getInternalWeb3Provider().signer._signTypedData(message.domain, message.types, message.message);
                            case 26:
                              _response = _context13.sent;
                              if (((_triggersArray$i9 = triggersArray[i3]) === null || _triggersArray$i9 === void 0 ? void 0 : _triggersArray$i9.saveResponse) === true)
                                _this3.memoryCard.save(_response);
                              if (!(((_triggersArray$i10 = triggersArray[i3]) === null || _triggersArray$i10 === void 0 ? void 0 : _triggersArray$i10.shouldReturnPayload) === true)) {
                                _context13.next = 30;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: {
                                  payload,
                                  response: _response
                                }
                              });
                            case 30:
                              if (!(((_triggersArray$i11 = triggersArray[i3]) === null || _triggersArray$i11 === void 0 ? void 0 : _triggersArray$i11.shouldReturnResponse) === true)) {
                                _context13.next = 32;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: _response
                              });
                            case 32:
                              return _context13.abrupt("break", 81);
                            case 33:
                              if (triggersArray[i3].pluginName) {
                                _context13.next = 35;
                                break;
                              }
                              throw new Error("callPluginEndpoint trigger does not have an plugin name to call");
                            case 35:
                              if (triggersArray[i3].endpoint) {
                                _context13.next = 37;
                                break;
                              }
                              throw new Error("callPluginEndpoint trigger does not have an endpoint to call");
                            case 37:
                              if (!(((_triggersArray$i12 = triggersArray[i3]) === null || _triggersArray$i12 === void 0 ? void 0 : _triggersArray$i12.shouldAwait) === true)) {
                                _context13.next = 42;
                                break;
                              }
                              if (triggersArray[i3].useSavedResponse === true) {
                                triggersArray[i3].params[triggersArray[i3].savedResponseAs] = _this3.memoryCard.get(triggersArray[i3].savedResponseAt);
                              }
                              _context13.next = 41;
                              return (0, _Cloud.run)((0, _concat.default)(_context11 = "".concat(triggersArray[i3].pluginName, "_")).call(_context11, triggersArray[i3].endpoint), triggersArray[i3].params);
                            case 41:
                              _response = _context13.sent;
                            case 42:
                              if (((_triggersArray$i13 = triggersArray[i3]) === null || _triggersArray$i13 === void 0 ? void 0 : _triggersArray$i13.shouldAwait) === false) {
                                if (triggersArray[i3].useSavedResponse === true) {
                                  triggersArray[i3].params[triggersArray[i3].savedResponseAs] = _this3.memoryCard.get(triggersArray[i3].savedResponseAt);
                                }
                                _response = (0, _Cloud.run)((0, _concat.default)(_context12 = "".concat(triggersArray[i3].pluginName, "_")).call(_context12, triggersArray[i3].endpoint), triggersArray[i3].params);
                              }
                              if (!(triggersArray[i3].runResponseTrigger === true)) {
                                _context13.next = 47;
                                break;
                              }
                              _context13.next = 46;
                              return _this3.handleTriggers(_response.data.result.triggers, _response.data.result.data);
                            case 46:
                              _response = _context13.sent;
                            case 47:
                              if (((_triggersArray$i14 = triggersArray[i3]) === null || _triggersArray$i14 === void 0 ? void 0 : _triggersArray$i14.saveResponse) === true)
                                _this3.memoryCard.save(_response);
                              if (!(((_triggersArray$i15 = triggersArray[i3]) === null || _triggersArray$i15 === void 0 ? void 0 : _triggersArray$i15.runResponseTrigger) === false)) {
                                _context13.next = 50;
                                break;
                              }
                              return _context13.abrupt("return", "continue");
                            case 50:
                              if (!(((_triggersArray$i16 = triggersArray[i3]) === null || _triggersArray$i16 === void 0 ? void 0 : _triggersArray$i16.shouldReturnPayload) === true)) {
                                _context13.next = 52;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: {
                                  payload: "payload",
                                  response: _response
                                }
                              });
                            case 52:
                              if (!(((_triggersArray$i17 = triggersArray[i3]) === null || _triggersArray$i17 === void 0 ? void 0 : _triggersArray$i17.shouldReturnResponse) === true)) {
                                _context13.next = 54;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: _response
                              });
                            case 54:
                              return _context13.abrupt("break", 81);
                            case 55:
                              if (triggersArray[i3].parameters) {
                                _context13.next = 57;
                                break;
                              }
                              throw new Error("web3SignV4 trigger does not have `parameters` to sign");
                            case 57:
                              if (triggersArray[i3].from) {
                                _context13.next = 59;
                                break;
                              }
                              throw new Error("web3SignV4 trigger does not have a `from` address");
                            case 59:
                              if (!(((_triggersArray$i18 = triggersArray[i3]) === null || _triggersArray$i18 === void 0 ? void 0 : _triggersArray$i18.shouldAwait) === true)) {
                                _context13.next = 74;
                                break;
                              }
                              _context13.prev = 60;
                              _JSON$parse = JSON.parse(triggersArray[i3].parameters[1]), domain = _JSON$parse.domain, types = _JSON$parse.types, _message = _JSON$parse.message;
                              if (types.EIP712Domain) {
                                delete types.EIP712Domain;
                              }
                              _context13.next = 65;
                              return _this3.getInternalWeb3Provider().signer._signTypedData(domain, types, _message);
                            case 65:
                              signature2 = _context13.sent;
                              result = {
                                result: signature2
                              };
                              if (((_triggersArray$i19 = triggersArray[i3]) === null || _triggersArray$i19 === void 0 ? void 0 : _triggersArray$i19.saveResponse) === true)
                                _this3.memoryCard.save(result);
                              _response = result;
                              _context13.next = 74;
                              break;
                            case 71:
                              _context13.prev = 71;
                              _context13.t1 = _context13["catch"](60);
                              throw new Error(_context13.t1.message || _context13.t1);
                            case 74:
                              if (((_triggersArray$i20 = triggersArray[i3]) === null || _triggersArray$i20 === void 0 ? void 0 : _triggersArray$i20.shouldAwait) === false) {
                                _JSON$parse2 = JSON.parse(triggersArray[i3].parameters[1]), _domain = _JSON$parse2.domain, _types = _JSON$parse2.types, _message2 = _JSON$parse2.message;
                                if (_types.EIP712Domain) {
                                  delete _types.EIP712Domain;
                                }
                                _this3.getInternalWeb3Provider().signer._signTypedData(_domain, _types, _message2).then(function(signature3) {
                                  var _triggersArray$i21;
                                  var result2 = {
                                    result: signature3
                                  };
                                  if (((_triggersArray$i21 = triggersArray[i3]) === null || _triggersArray$i21 === void 0 ? void 0 : _triggersArray$i21.saveResponse) === true)
                                    _this3.memoryCard.save(result2);
                                  _response = result2;
                                }).catch(function(error) {
                                  throw new Error(error.message || error);
                                });
                              }
                              if (!(((_triggersArray$i22 = triggersArray[i3]) === null || _triggersArray$i22 === void 0 ? void 0 : _triggersArray$i22.shouldReturnPayload) === true)) {
                                _context13.next = 77;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: {
                                  payload,
                                  response: _response
                                }
                              });
                            case 77:
                              if (!(((_triggersArray$i23 = triggersArray[i3]) === null || _triggersArray$i23 === void 0 ? void 0 : _triggersArray$i23.shouldReturnResponse) === true)) {
                                _context13.next = 79;
                                break;
                              }
                              return _context13.abrupt("return", {
                                v: _response
                              });
                            case 79:
                              return _context13.abrupt("break", 81);
                            case 80:
                              throw new Error('Unknown trigger: "'.concat((_triggersArray$i24 = triggersArray[i3]) === null || _triggersArray$i24 === void 0 ? void 0 : _triggersArray$i24.name, '"'));
                            case 81:
                            case "end":
                              return _context13.stop();
                          }
                        }
                      }, _loop2, null, [[60, 71]]);
                    });
                    i2 = 0;
                  case 4:
                    if (!(i2 < triggersArray.length)) {
                      _context14.next = 14;
                      break;
                    }
                    return _context14.delegateYield(_loop(i2), "t0", 6);
                  case 6:
                    _ret = _context14.t0;
                    if (!(_ret === "continue")) {
                      _context14.next = 9;
                      break;
                    }
                    return _context14.abrupt("continue", 11);
                  case 9:
                    if (!((0, _typeof2.default)(_ret) === "object")) {
                      _context14.next = 11;
                      break;
                    }
                    return _context14.abrupt("return", _ret.v);
                  case 11:
                    i2++;
                    _context14.next = 4;
                    break;
                  case 14:
                    this.memoryCard.deleteSaved();
                  case 15:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee9, this);
          }));
          return function() {
            return _handleTriggers.apply(this, arguments);
          };
        }()
      }, {
        key: "getAllERC20",
        value: function() {
          var _getAllERC = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee10() {
            var _ref2, chain, address, result, _args11 = arguments;
            return _regenerator.default.wrap(function(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _ref2 = _args11.length > 0 && _args11[0] !== void 0 ? _args11[0] : {}, chain = _ref2.chain, address = _ref2.address;
                    _context15.next = 3;
                    return (0, _Cloud.run)("getAllERC20", {
                      chain,
                      address
                    });
                  case 3:
                    result = _context15.sent;
                    return _context15.abrupt("return", result);
                  case 5:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee10);
          }));
          return function() {
            return _getAllERC.apply(this, arguments);
          };
        }()
      }, {
        key: "getERC20",
        value: function() {
          var _getERC = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee11() {
            var _ref3, chain, address, symbol, tokenAddress, result, _args12 = arguments;
            return _regenerator.default.wrap(function(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    _ref3 = _args12.length > 0 && _args12[0] !== void 0 ? _args12[0] : {}, chain = _ref3.chain, address = _ref3.address, symbol = _ref3.symbol, tokenAddress = _ref3.tokenAddress;
                    result = (0, _Cloud.run)("getERC20", {
                      chain,
                      address,
                      symbol,
                      tokenAddress
                    });
                    return _context16.abrupt("return", result);
                  case 3:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee11);
          }));
          return function() {
            return _getERC.apply(this, arguments);
          };
        }()
      }, {
        key: "getNFTs",
        value: function() {
          var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$chain = _ref4.chain, chain = _ref4$chain === void 0 ? "Eth" : _ref4$chain, _ref4$address = _ref4.address, address = _ref4$address === void 0 ? "" : _ref4$address;
          return (0, _Cloud.run)("getNFTs_old", {
            chain,
            address
          });
        }
      }, {
        key: "getNFTsCount",
        value: function() {
          var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref5$chain = _ref5.chain, chain = _ref5$chain === void 0 ? "Eth" : _ref5$chain, _ref5$address = _ref5.address, address = _ref5$address === void 0 ? "" : _ref5$address;
          return (0, _Cloud.run)("getNFTsCount_old", {
            chain,
            address
          });
        }
      }, {
        key: "getTransactions",
        value: function() {
          var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref6$chain = _ref6.chain, chain = _ref6$chain === void 0 ? "Eth" : _ref6$chain, _ref6$address = _ref6.address, address = _ref6$address === void 0 ? "" : _ref6$address, _ref6$order = _ref6.order, order = _ref6$order === void 0 ? "desc" : _ref6$order;
          return (0, _Cloud.run)("getTransactions", {
            chain,
            address,
            order
          });
        }
      }, {
        key: "getTransactionsCount",
        value: function() {
          var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$chain = _ref7.chain, chain = _ref7$chain === void 0 ? "Eth" : _ref7$chain, _ref7$address = _ref7.address, address = _ref7$address === void 0 ? "" : _ref7$address;
          return (0, _Cloud.run)("getTransactionsCount", {
            chain,
            address
          });
        }
      }, {
        key: "transfer",
        value: function() {
          var _transfer = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee12() {
            var _ref8, _ref8$type, type, _ref8$receiver, receiver, _ref8$contractAddress, contractAddress, contract_address, _ref8$amount, amount, _ref8$tokenId, tokenId, token_id, _ref8$system, system, options, _this$getInternalWeb3, internalWeb3, sender, signer, transferOperation, customToken, result, _args13 = arguments;
            return _regenerator.default.wrap(function(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _ref8 = _args13.length > 0 && _args13[0] !== void 0 ? _args13[0] : {}, _ref8$type = _ref8.type, type = _ref8$type === void 0 ? "native" : _ref8$type, _ref8$receiver = _ref8.receiver, receiver = _ref8$receiver === void 0 ? "" : _ref8$receiver, _ref8$contractAddress = _ref8.contractAddress, contractAddress = _ref8$contractAddress === void 0 ? "" : _ref8$contractAddress, contract_address = _ref8.contract_address, _ref8$amount = _ref8.amount, amount = _ref8$amount === void 0 ? "" : _ref8$amount, _ref8$tokenId = _ref8.tokenId, tokenId = _ref8$tokenId === void 0 ? "" : _ref8$tokenId, token_id = _ref8.token_id, _ref8$system = _ref8.system, system = _ref8$system === void 0 ? "evm" : _ref8$system;
                    contractAddress = contractAddress || contract_address;
                    tokenId = tokenId || token_id;
                    options = {
                      receiver,
                      contractAddress,
                      amount,
                      tokenId,
                      system
                    };
                    _TransferUtils.default.isSupportedType(type);
                    _TransferUtils.default.validateInput(type, options);
                    _this$getInternalWeb3 = this.getInternalWeb3Provider(), internalWeb3 = _this$getInternalWeb3.web3, sender = _this$getInternalWeb3.account, signer = _this$getInternalWeb3.signer;
                    if (sender) {
                      _context17.next = 9;
                      break;
                    }
                    throw new Error("Sender address not found");
                  case 9:
                    if (tokenId)
                      _TransferUtils.default.isUint256(tokenId);
                    if (type !== "native") {
                      customToken = new _ethers.ethers.Contract(contractAddress, _TransferUtils.default.abi[type], signer);
                    }
                    _context17.t0 = type;
                    _context17.next = _context17.t0 === "native" ? 14 : _context17.t0 === "erc20" ? 16 : _context17.t0 === "erc721" ? 18 : _context17.t0 === "erc1155" ? 20 : 22;
                    break;
                  case 14:
                    transferOperation = signer.sendTransaction({
                      to: receiver,
                      value: _ethers.ethers.BigNumber.from(amount)
                    });
                    return _context17.abrupt("break", 23);
                  case 16:
                    transferOperation = customToken.transfer(receiver, amount, {
                      from: sender
                    });
                    return _context17.abrupt("break", 23);
                  case 18:
                    transferOperation = customToken.safeTransferFrom(sender, receiver, "".concat(tokenId), {
                      from: sender
                    });
                    return _context17.abrupt("break", 23);
                  case 20:
                    transferOperation = customToken.safeTransferFrom(sender, receiver, "".concat(tokenId), amount, "0x", {
                      from: sender
                    });
                    return _context17.abrupt("break", 23);
                  case 22:
                    throw new Error('Unknown transfer type: "'.concat(type, '"'));
                  case 23:
                    _context17.next = 25;
                    return transferOperation;
                  case 25:
                    result = _context17.sent;
                    return _context17.abrupt("return", result);
                  case 27:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee12, this);
          }));
          return function() {
            return _transfer.apply(this, arguments);
          };
        }()
      }, {
        key: "executeFunction",
        value: function() {
          var _executeFunction = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee13() {
            var _functionData, _context25, _context26;
            var _ref9, contractAddress, abi, functionName, msgValue, _ref9$params, params, _ref9$overrides, overrides, contractOptions, _this$getInternalWeb4, account, internalWeb3, provider, signerOrProvider, overloadedFunction, functionData, _context18, _context19, nameWithoutTopics, topics, functionDataArray, possibleTopics, _functionDataArray, _possibleTopics, stateMutability, isReadFunction, currentAddress, errors, _iterator, _step, input, value, parsedInputs, contract, contractMethod, response, _args14 = arguments;
            return _regenerator.default.wrap(function(_context27) {
              while (1) {
                switch (_context27.prev = _context27.next) {
                  case 0:
                    _ref9 = _args14.length > 0 && _args14[0] !== void 0 ? _args14[0] : {}, contractAddress = _ref9.contractAddress, abi = _ref9.abi, functionName = _ref9.functionName, msgValue = _ref9.msgValue, _ref9$params = _ref9.params, params = _ref9$params === void 0 ? {} : _ref9$params, _ref9$overrides = _ref9.overrides, overrides = _ref9$overrides === void 0 ? {} : _ref9$overrides;
                    contractOptions = {};
                    _this$getInternalWeb4 = this.getInternalWeb3Provider(), account = _this$getInternalWeb4.account, internalWeb3 = _this$getInternalWeb4.web3, provider = _this$getInternalWeb4.provider, signerOrProvider = _this$getInternalWeb4.signerOrProvider;
                    overloadedFunction = functionName.match(/^(.+)\((.*)\)$/);
                    if (!overloadedFunction) {
                      _context27.next = 16;
                      break;
                    }
                    nameWithoutTopics = overloadedFunction[1];
                    topics = (0, _filter.default)(_context18 = (0, _map.default)(_context19 = overloadedFunction[2].split(",")).call(_context19, function(topic) {
                      return (0, _trim.default)(topic).call(topic);
                    })).call(_context18, function(topic) {
                      return !!topic;
                    });
                    functionDataArray = (0, _filter.default)(abi).call(abi, function(x2) {
                      return x2.name === nameWithoutTopics;
                    });
                    if (!(functionDataArray.length === 0)) {
                      _context27.next = 10;
                      break;
                    }
                    throw new Error("Function does not exist in abi");
                  case 10:
                    functionData = (0, _find.default)(functionDataArray).call(functionDataArray, function(data) {
                      var _data$inputs$length, _context20;
                      return ((_data$inputs$length = data === null || data === void 0 ? void 0 : data.inputs.length) !== null && _data$inputs$length !== void 0 ? _data$inputs$length : 0) === topics.length && (0, _every.default)(_context20 = data.inputs).call(_context20, function(input2, index) {
                        return input2.type === topics[index];
                      });
                    });
                    if (functionData) {
                      _context27.next = 14;
                      break;
                    }
                    possibleTopics = (0, _map.default)(functionDataArray).call(functionDataArray, function(data) {
                      var _context21, _context22;
                      return (0, _concat.default)(_context21 = "".concat(data.name, "(")).call(_context21, (0, _map.default)(_context22 = data.inputs).call(_context22, function(input2) {
                        return input2.type;
                      }).join(","), ")");
                    });
                    throw new Error("Function with the provided topic does not exist in abi. Possible funcationNames: ".concat(possibleTopics.join(" ,")));
                  case 14:
                    _context27.next = 23;
                    break;
                  case 16:
                    _functionDataArray = (0, _filter.default)(abi).call(abi, function(x2) {
                      return x2.name === functionName;
                    });
                    if (!(_functionDataArray.length === 0)) {
                      _context27.next = 19;
                      break;
                    }
                    throw new Error("Function does not exist in abi");
                  case 19:
                    if (!(_functionDataArray.length > 1)) {
                      _context27.next = 22;
                      break;
                    }
                    _possibleTopics = (0, _map.default)(_functionDataArray).call(_functionDataArray, function(data) {
                      var _context23, _context24;
                      return (0, _concat.default)(_context23 = "".concat(data.name, "(")).call(_context23, (0, _map.default)(_context24 = data.inputs).call(_context24, function(input2) {
                        return input2.type;
                      }).join(","), ")");
                    });
                    throw new Error("Multiple function definitions found in the abi. Please include the topic in the functionName. Possible funcationNames: ".concat(_possibleTopics.join(" ,")));
                  case 22:
                    functionData = _functionDataArray[0];
                  case 23:
                    stateMutability = (_functionData = functionData) === null || _functionData === void 0 ? void 0 : _functionData.stateMutability;
                    isReadFunction = stateMutability === "view" || stateMutability === "pure";
                    if (isReadFunction) {
                      _context27.next = 31;
                      break;
                    }
                    if (params.from) {
                      _context27.next = 31;
                      break;
                    }
                    currentAddress = account;
                    if (currentAddress) {
                      _context27.next = 30;
                      break;
                    }
                    throw new Error("From address is required");
                  case 30:
                    contractOptions.from = currentAddress;
                  case 31:
                    errors = [];
                    _iterator = _createForOfIteratorHelper(functionData.inputs);
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        input = _step.value;
                        value = params[input.name];
                        if (!value && typeof value !== "number" && typeof value !== "boolean" && input.name !== "") {
                          errors.push("".concat(input.name, " is required"));
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    if (!(errors.length > 0)) {
                      _context27.next = 36;
                      break;
                    }
                    throw errors;
                  case 36:
                    parsedInputs = (0, _map.default)(_context25 = functionData.inputs).call(_context25, function(x2) {
                      return params[x2.name];
                    });
                    contract = new _ethers.ethers.Contract(contractAddress, abi, signerOrProvider);
                    contractMethod = contract[functionName];
                    if (contractMethod) {
                      _context27.next = 41;
                      break;
                    }
                    throw new Error('Cannot find function "'.concat(functionName, '" on the contract'));
                  case 41:
                    _context27.next = 43;
                    return contractMethod.apply(void 0, (0, _concat.default)(_context26 = (0, _toConsumableArray2.default)((0, _values.default)(parsedInputs))).call(_context26, [msgValue ? {
                      value: _ethers.ethers.BigNumber.from("".concat(msgValue))
                    } : {}]));
                  case 43:
                    response = _context27.sent;
                    return _context27.abrupt("return", response);
                  case 45:
                  case "end":
                    return _context27.stop();
                }
              }
            }, _callee13, this);
          }));
          return function() {
            return _executeFunction.apply(this, arguments);
          };
        }()
      }, {
        key: "getSigningData",
        value: function() {
          return "Moralis Authentication";
        }
      }, {
        key: "ensureWeb3IsInstalled",
        value: function() {
          return this.internalWeb3Provider && this.internalWeb3Provider.web3 ? true : false;
        }
        /**
         * Gets the internalWeb3Provider with validation to make sure it has been instansiated with 'enableWeb3()'
         */
      }, {
        key: "getInternalWeb3Provider",
        value: function() {
          if (!this.ensureWeb3IsInstalled())
            throw new Error(ERROR_WEB3_MISSING);
          return this.internalWeb3Provider;
        }
        /**
         * Gets web3 from the internalWeb3Provider with validation to make sure it has been instansiated with 'enableWeb3()'
         */
      }, {
        key: "getInternalWeb3",
        value: function() {
          return this.getInternalWeb3Provider().web3;
        }
      }, {
        key: "provider",
        get: function() {
          var _this$internalWeb3Pro2, _this$internalWeb3Pro3;
          return (_this$internalWeb3Pro2 = (_this$internalWeb3Pro3 = this.internalWeb3Provider) === null || _this$internalWeb3Pro3 === void 0 ? void 0 : _this$internalWeb3Pro3.provider) !== null && _this$internalWeb3Pro2 !== void 0 ? _this$internalWeb3Pro2 : null;
        }
      }, {
        key: "connector",
        get: function() {
          var _this$internalWeb3Pro4, _this$internalWeb3Pro5;
          return (_this$internalWeb3Pro4 = (_this$internalWeb3Pro5 = this.internalWeb3Provider) === null || _this$internalWeb3Pro5 === void 0 ? void 0 : _this$internalWeb3Pro5.connector) !== null && _this$internalWeb3Pro4 !== void 0 ? _this$internalWeb3Pro4 : null;
        }
      }, {
        key: "connectorType",
        get: function() {
          var _this$connector$type, _this$connector;
          return (_this$connector$type = (_this$connector = this.connector) === null || _this$connector === void 0 ? void 0 : _this$connector.type) !== null && _this$connector$type !== void 0 ? _this$connector$type : null;
        }
      }, {
        key: "network",
        get: function() {
          var _this$connector$netwo, _this$connector2;
          return (_this$connector$netwo = (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.network) !== null && _this$connector$netwo !== void 0 ? _this$connector$netwo : null;
        }
      }, {
        key: "account",
        get: function() {
          var _this$internalWeb3Pro6, _this$internalWeb3Pro7;
          return (_this$internalWeb3Pro6 = (_this$internalWeb3Pro7 = this.internalWeb3Provider) === null || _this$internalWeb3Pro7 === void 0 ? void 0 : _this$internalWeb3Pro7.account) !== null && _this$internalWeb3Pro6 !== void 0 ? _this$internalWeb3Pro6 : null;
        }
      }, {
        key: "chainId",
        get: function() {
          var _this$internalWeb3Pro8, _this$internalWeb3Pro9;
          return (_this$internalWeb3Pro8 = (_this$internalWeb3Pro9 = this.internalWeb3Provider) === null || _this$internalWeb3Pro9 === void 0 ? void 0 : _this$internalWeb3Pro9.chainId) !== null && _this$internalWeb3Pro8 !== void 0 ? _this$internalWeb3Pro8 : null;
        }
      }, {
        key: "getChainId",
        value: function() {
          return this.chainId;
        }
      }, {
        key: "web3Library",
        get: function() {
          return _ethers.ethers;
        }
      }, {
        key: "_forwardToConnector",
        value: function(methodName, args) {
          var _this$getInternalWeb5 = this.getInternalWeb3Provider(), connector = _this$getInternalWeb5.connector;
          var hasMethod = Boolean(connector[methodName]);
          if (!hasMethod) {
            var _context28;
            throw new Error((0, _concat.default)(_context28 = "Cannot call ".concat(methodName, ', as it does not exist on connector type "')).call(_context28, connector.type, '"'));
          }
          return connector[methodName].apply(connector, (0, _toConsumableArray2.default)(args));
        }
      }, {
        key: "switchNetwork",
        value: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return this._forwardToConnector("switchNetwork", args);
        }
      }, {
        key: "addNetwork",
        value: function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return this._forwardToConnector("addNetwork", args);
        }
      }, {
        key: "isMetaMaskInstalled",
        value: function() {
          var _isMetaMaskInstalled = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee14() {
            return _regenerator.default.wrap(function(_context29) {
              while (1) {
                switch (_context29.prev = _context29.next) {
                  case 0:
                    _context29.next = 2;
                    return (0, _detectProvider.default)();
                  case 2:
                    if (!_context29.sent) {
                      _context29.next = 6;
                      break;
                    }
                    _context29.t0 = true;
                    _context29.next = 7;
                    break;
                  case 6:
                    _context29.t0 = false;
                  case 7:
                    return _context29.abrupt("return", _context29.t0);
                  case 8:
                  case "end":
                    return _context29.stop();
                }
              }
            }, _callee14);
          }));
          return function() {
            return _isMetaMaskInstalled.apply(this, arguments);
          };
        }()
      }]);
      return MoralisWeb32;
    }();
    (0, _defineProperty2.default)(MoralisWeb3, "speedyNodeApiKey", void 0);
    (0, _defineProperty2.default)(MoralisWeb3, "web3", null);
    (0, _defineProperty2.default)(MoralisWeb3, "internalWeb3Provider", null);
    (0, _defineProperty2.default)(MoralisWeb3, "Plugins", {});
    (0, _defineProperty2.default)(MoralisWeb3, "isEnablingWeb3", false);
    (0, _defineProperty2.default)(MoralisWeb3, "memoryCard", {
      save: function(what) {
        this.saved = what;
      },
      get: function(where) {
        if (!this.saved)
          throw new Error("Nothing saved to memory card");
        if (where.length === 0)
          return this.getSaved();
        var tmp;
        var savedTmp = this.saved;
        for (var i2 = 0; i2 < where.length; i2++) {
          tmp = savedTmp[where[i2]];
          savedTmp = tmp;
        }
        return savedTmp;
      },
      getSaved: function() {
        return this.saved;
      },
      deleteSaved: function() {
        this.saved = void 0;
      }
    });
    MoralisWeb3.onConnect = (0, _bind.default)(_context30 = MoralisWeb3.on).call(_context30, MoralisWeb3, _InternalWeb3Provider.InternalWeb3Events.PROVIDER_CONNECT);
    MoralisWeb3.onDisconnect = (0, _bind.default)(_context31 = MoralisWeb3.on).call(_context31, MoralisWeb3, _InternalWeb3Provider.InternalWeb3Events.PROVIDER_DISCONNECT);
    MoralisWeb3.onWeb3Enabled = (0, _bind.default)(_context32 = MoralisWeb3.on).call(_context32, MoralisWeb3, _InternalWeb3Provider.InternalWeb3Events.WEB3_ENABLED);
    MoralisWeb3.onWeb3Deactivated = (0, _bind.default)(_context33 = MoralisWeb3.on).call(_context33, MoralisWeb3, _InternalWeb3Provider.InternalWeb3Events.WEB3_DEACTIVATED);
    MoralisWeb3.onChainChanged = (0, _bind.default)(_context34 = MoralisWeb3.on).call(_context34, MoralisWeb3, _InternalWeb3Provider.InternalWeb3Events.CHAIN_CHANGED);
    MoralisWeb3.onAccountChanged = (0, _bind.default)(_context35 = MoralisWeb3.on).call(_context35, MoralisWeb3, _InternalWeb3Provider.InternalWeb3Events.ACCOUNT_CHANGED);
    var _default = MoralisWeb3;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/StorageController.browser.js
var require_StorageController_browser = __commonJS({
  "node_modules/moralis-v1/lib/browser/StorageController.browser.js"(exports, module) {
    "use strict";
    var StorageController = {
      async: 0,
      getItem: function(path) {
        return localStorage.getItem(path);
      },
      setItem: function(path, value) {
        try {
          localStorage.setItem(path, value);
        } catch (e) {
          console.log(e.message);
        }
      },
      removeItem: function(path) {
        localStorage.removeItem(path);
      },
      getAllKeys: function() {
        var keys = [];
        for (var i2 = 0; i2 < localStorage.length; i2 += 1) {
          keys.push(localStorage.key(i2));
        }
        return keys;
      },
      clear: function() {
        localStorage.clear();
      }
    };
    module.exports = StorageController;
  }
});

// node_modules/moralis-v1/lib/browser/Storage.js
var require_Storage = __commonJS({
  "node_modules/moralis-v1/lib/browser/Storage.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _promise = _interopRequireDefault(require_promise3());
    var _concat = _interopRequireDefault(require_concat4());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var Storage = {
      async: function() {
        var controller = _CoreManager.default.getStorageController();
        return !!controller.async;
      },
      getItem: function(path) {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          throw new Error("Synchronous storage is not supported by the current storage controller");
        }
        return controller.getItem(path);
      },
      getItemAsync: function(path) {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          return controller.getItemAsync(path);
        }
        return _promise.default.resolve(controller.getItem(path));
      },
      setItem: function(path, value) {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          throw new Error("Synchronous storage is not supported by the current storage controller");
        }
        return controller.setItem(path, value);
      },
      setItemAsync: function(path, value) {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          return controller.setItemAsync(path, value);
        }
        return _promise.default.resolve(controller.setItem(path, value));
      },
      removeItem: function(path) {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          throw new Error("Synchronous storage is not supported by the current storage controller");
        }
        return controller.removeItem(path);
      },
      removeItemAsync: function(path) {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          return controller.removeItemAsync(path);
        }
        return _promise.default.resolve(controller.removeItem(path));
      },
      getAllKeys: function() {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          throw new Error("Synchronous storage is not supported by the current storage controller");
        }
        return controller.getAllKeys();
      },
      getAllKeysAsync: function() {
        var controller = _CoreManager.default.getStorageController();
        if (controller.async === 1) {
          return controller.getAllKeysAsync();
        }
        return _promise.default.resolve(controller.getAllKeys());
      },
      generatePath: function(path) {
        var _context;
        if (!_CoreManager.default.get("APPLICATION_ID")) {
          throw new Error("You need to call Moralis.start with an applicationId before using Moralis.");
        }
        if (typeof path !== "string") {
          throw new Error("Tried to get a Storage path that was not a String.");
        }
        if (path[0] === "/") {
          path = path.substr(1);
        }
        return (0, _concat.default)(_context = "Parse/".concat(_CoreManager.default.get("APPLICATION_ID"), "/")).call(_context, path);
      },
      _clear: function() {
        var controller = _CoreManager.default.getStorageController();
        if (controller.hasOwnProperty("clear")) {
          controller.clear();
        }
      }
    };
    module.exports = Storage;
    _CoreManager.default.setStorageController(require_StorageController_browser());
  }
});

// node_modules/moralis-v1/lib/browser/ParseUser.js
var require_ParseUser = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseUser.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty2 = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty2(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _promise = _interopRequireDefault(require_promise3());
    var _defineProperty2 = _interopRequireDefault(require_define_property3());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _get2 = _interopRequireDefault(require_get7());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _AnonymousUtils = _interopRequireDefault(require_AnonymousUtils());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _isRevocableSession = _interopRequireDefault(require_isRevocableSession());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _ParseObject2 = _interopRequireDefault(require_ParseObject());
    var _ParseSession = _interopRequireDefault(require_ParseSession());
    var _MoralisWeb = _interopRequireDefault(require_MoralisWeb3());
    var _Storage = _interopRequireDefault(require_Storage());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var CURRENT_USER_KEY = "currentUser";
    var canUseCurrentUser = !_CoreManager.default.get("IS_NODE");
    var currentUserCacheMatchesDisk = false;
    var currentUserCache = null;
    var authProviders = {};
    var ParseUser = function(_ParseObject) {
      (0, _inherits2.default)(ParseUser2, _ParseObject);
      var _super = _createSuper(ParseUser2);
      function ParseUser2(attributes) {
        var _this;
        (0, _classCallCheck2.default)(this, ParseUser2);
        _this = _super.call(this, "_User");
        if (attributes && (0, _typeof2.default)(attributes) === "object") {
          if (!_this.set(attributes || {})) {
            throw new Error("Can't create an invalid Parse User");
          }
        }
        return _this;
      }
      (0, _createClass2.default)(ParseUser2, [{
        key: "_upgradeToRevocableSession",
        value: function(options) {
          options = options || {};
          var upgradeOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            upgradeOptions.useMasterKey = options.useMasterKey;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.upgradeToRevocableSession(this, upgradeOptions);
        }
        /**
         * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling
         * your users to sign up or log into your application using their existing identities.
         * Since 2.9.0
         *
         * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}
         * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}
         * @param {object} options
         * <ul>
         *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}
         *   <li>If provider is AuthProvider, options is saveOpts
         * </ul>
         * @param {object} saveOpts useMasterKey / sessionToken
         * @returns {Promise} A promise that is fulfilled with the user is linked
         */
      }, {
        key: "linkWith",
        value: function(provider, options) {
          var _this2 = this;
          var saveOpts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || "";
          var authType;
          if (typeof provider === "string") {
            authType = provider;
            if (authProviders[provider]) {
              provider = authProviders[provider];
            } else {
              var authProvider = {
                restoreAuthentication: function() {
                  return true;
                },
                getAuthType: function() {
                  return authType;
                }
              };
              authProviders[authProvider.getAuthType()] = authProvider;
              provider = authProvider;
            }
          } else {
            authType = provider.getAuthType();
          }
          if (options && options.hasOwnProperty("authData")) {
            var authData = this.get("authData") || {};
            if ((0, _typeof2.default)(authData) !== "object") {
              throw new Error("Invalid type: authData field should be an object");
            }
            authData[authType] = options.authData;
            var controller = _CoreManager.default.getUserController();
            return controller.linkWith(this, authData, saveOpts);
          }
          return new _promise.default(function(resolve, reject) {
            provider.authenticate({
              success: function(provider2, result) {
                var opts = {};
                opts.authData = result;
                _this2.linkWith(provider2, opts, saveOpts).then(function() {
                  resolve(_this2);
                }, function(error) {
                  reject(error);
                });
              },
              error: function(provider2, _error) {
                reject(_error);
              }
            });
          });
        }
        /**
         * @param provider
         * @param options
         * @param saveOpts
         * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}
         * @returns {Promise}
         */
      }, {
        key: "_linkWith",
        value: function(provider, options) {
          var saveOpts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this.linkWith(provider, options, saveOpts);
        }
        /**
         * Synchronizes auth data for a provider (e.g. puts the access token in the
         * right place to be used by the Facebook SDK).
         *
         * @param provider
         */
      }, {
        key: "_synchronizeAuthData",
        value: function(provider) {
          if (!this.isCurrent() || !provider) {
            return;
          }
          var authType;
          if (typeof provider === "string") {
            authType = provider;
            provider = authProviders[authType];
          } else {
            authType = provider.getAuthType();
          }
          var authData = this.get("authData");
          if (!provider || !authData || (0, _typeof2.default)(authData) !== "object") {
            return;
          }
          var success = provider.restoreAuthentication(authData[authType]);
          if (!success) {
            this._unlinkFrom(provider);
          }
        }
        /**
         * Synchronizes authData for all providers.
         */
      }, {
        key: "_synchronizeAllAuthData",
        value: function() {
          var authData = this.get("authData");
          if ((0, _typeof2.default)(authData) !== "object") {
            return;
          }
          for (var _key in authData) {
            this._synchronizeAuthData(_key);
          }
        }
        /**
         * Removes null values from authData (which exist temporarily for unlinking)
         */
      }, {
        key: "_cleanupAuthData",
        value: function() {
          if (!this.isCurrent()) {
            return;
          }
          var authData = this.get("authData");
          if ((0, _typeof2.default)(authData) !== "object") {
            return;
          }
          for (var _key2 in authData) {
            if (!authData[_key2]) {
              delete authData[_key2];
            }
          }
        }
        /**
         * Unlinks a user from a service.
         *
         * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}
         * @param {object} options MasterKey / SessionToken
         * @returns {Promise} A promise that is fulfilled when the unlinking
         *     finishes.
         */
      }, {
        key: "_unlinkFrom",
        value: function(provider, options) {
          var _this3 = this;
          return this.linkWith(provider, {
            authData: null
          }, options).then(function() {
            _this3._synchronizeAuthData(provider);
            return _promise.default.resolve(_this3);
          });
        }
        /**
         * Checks whether a user is linked to a service.
         *
         * @param {object} provider service to link to
         * @returns {boolean} true if link was successful
         */
      }, {
        key: "_isLinked",
        value: function(provider) {
          var authType;
          if (typeof provider === "string") {
            authType = provider;
          } else {
            authType = provider.getAuthType();
          }
          var authData = this.get("authData") || {};
          if ((0, _typeof2.default)(authData) !== "object") {
            return false;
          }
          return !!authData[authType];
        }
        /**
         * Deauthenticates all providers.
         */
      }, {
        key: "_logOutWithAll",
        value: function() {
          var authData = this.get("authData");
          if ((0, _typeof2.default)(authData) !== "object") {
            return;
          }
          for (var _key3 in authData) {
            this._logOutWith(_key3);
          }
        }
        /**
         * Deauthenticates a single provider (e.g. removing access tokens from the
         * Facebook SDK).
         *
         * @param {object} provider service to logout of
         */
      }, {
        key: "_logOutWith",
        value: function(provider) {
          if (!this.isCurrent()) {
            return;
          }
          if (typeof provider === "string") {
            provider = authProviders[provider];
          }
          if (provider && provider.deauthenticate) {
            provider.deauthenticate();
          }
        }
        /**
         * Class instance method used to maintain specific keys when a fetch occurs.
         * Used to ensure that the session token is not lost.
         *
         * @returns {object} sessionToken
         */
      }, {
        key: "_preserveFieldsOnFetch",
        value: function() {
          return {
            sessionToken: this.get("sessionToken")
          };
        }
        /**
         * Returns true if <code>current</code> would return this user.
         *
         * @returns {boolean} true if user is cached on disk
         */
      }, {
        key: "isCurrent",
        value: function() {
          var current = ParseUser2.current();
          return !!current && current.id === this.id;
        }
        /**
         * Returns get("username").
         *
         * @returns {string}
         */
      }, {
        key: "getUsername",
        value: function() {
          var username = this.get("username");
          if (username == null || typeof username === "string") {
            return username;
          }
          return "";
        }
        /**
         * Calls set("username", username, options) and returns the result.
         *
         * @param {string} username
         */
      }, {
        key: "setUsername",
        value: function(username) {
          var authData = this.get("authData");
          if (authData && (0, _typeof2.default)(authData) === "object" && authData.hasOwnProperty("anonymous")) {
            authData.anonymous = null;
          }
          this.set("username", username);
        }
        /**
         * Calls set("password", password, options) and returns the result.
         *
         * @param {string} password User's Password
         */
      }, {
        key: "setPassword",
        value: function(password) {
          this.set("password", password);
        }
        /**
         * Returns get("email").
         *
         * @returns {string} User's Email
         */
      }, {
        key: "getEmail",
        value: function() {
          var email = this.get("email");
          if (email == null || typeof email === "string") {
            return email;
          }
          return "";
        }
        /**
         * Calls set("email", email) and returns the result.
         *
         * @param {string} email
         * @returns {boolean}
         */
      }, {
        key: "setEmail",
        value: function(email) {
          return this.set("email", email);
        }
        /**
         * Returns the session token for this user, if the user has been logged in,
         * or if it is the result of a query with the master key. Otherwise, returns
         * undefined.
         *
         * @returns {string} the session token, or undefined
         */
      }, {
        key: "getSessionToken",
        value: function() {
          var token = this.get("sessionToken");
          if (token == null || typeof token === "string") {
            return token;
          }
          return "";
        }
        /**
         * Checks whether this user is the current user and has been authenticated.
         *
         * @returns {boolean} whether this user is the current user and is logged in.
         */
      }, {
        key: "authenticated",
        value: function() {
          var current = ParseUser2.current();
          return !!this.get("sessionToken") && !!current && current.id === this.id;
        }
        /**
         * Signs up a new user. You should call this instead of save for
         * new Parse.Users. This will create a new Parse.User on the server, and
         * also persist the session on disk so that you can access the user using
         * <code>current</code>.
         *
         * <p>A username and password must be set before calling signUp.</p>
         *
         * @param {object} attrs Extra fields to set on the new user, or null.
         * @param {object} options
         * @returns {Promise} A promise that is fulfilled when the signup
         *     finishes.
         */
      }, {
        key: "signUp",
        value: function(attrs, options) {
          options = options || {};
          var signupOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            signupOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("installationId")) {
            signupOptions.installationId = options.installationId;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.signUp(this, attrs, signupOptions);
        }
        /**
         * Logs in a Parse.User. On success, this saves the session to disk,
         * so you can retrieve the currently logged in user using
         * <code>current</code>.
         *
         * <p>A username and password must be set before calling logIn.</p>
         *
         * @param {object} options
         * @returns {Promise} A promise that is fulfilled with the user when
         *     the login is complete.
         */
      }, {
        key: "logIn",
        value: function(options) {
          options = options || {};
          var loginOptions = {
            usePost: true
          };
          if (options.hasOwnProperty("useMasterKey")) {
            loginOptions.useMasterKey = options.useMasterKey;
          }
          if (options.hasOwnProperty("installationId")) {
            loginOptions.installationId = options.installationId;
          }
          if (options.hasOwnProperty("usePost")) {
            loginOptions.usePost = options.usePost;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.logIn(this, loginOptions);
        }
        /**
         * Wrap the default save behavior with functionality to save to local
         * storage if this is current user.
         *
         * @param {...any} args
         * @returns {Promise}
         */
      }, {
        key: "save",
        value: function() {
          var _this4 = this;
          for (var _len = arguments.length, args = new Array(_len), _key4 = 0; _key4 < _len; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser2.prototype), "save", this).apply(this, args).then(function() {
            if (_this4.isCurrent()) {
              return _CoreManager.default.getUserController().updateUserOnDisk(_this4);
            }
            return _this4;
          });
        }
        /**
         * Wrap the default destroy behavior with functionality that logs out
         * the current user when it is destroyed
         *
         * @param {...any} args
         * @returns {Parse.User}
         */
      }, {
        key: "destroy",
        value: function() {
          var _this5 = this;
          for (var _len2 = arguments.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {
            args[_key5] = arguments[_key5];
          }
          return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser2.prototype), "destroy", this).apply(this, args).then(function() {
            if (_this5.isCurrent()) {
              return _CoreManager.default.getUserController().removeUserFromDisk();
            }
            return _this5;
          });
        }
        /**
         * Wrap the default fetch behavior with functionality to save to local
         * storage if this is current user.
         *
         * @param {...any} args
         * @returns {Parse.User}
         */
      }, {
        key: "fetch",
        value: function() {
          var _this6 = this;
          for (var _len3 = arguments.length, args = new Array(_len3), _key6 = 0; _key6 < _len3; _key6++) {
            args[_key6] = arguments[_key6];
          }
          return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser2.prototype), "fetch", this).apply(this, args).then(function() {
            if (_this6.isCurrent()) {
              return _CoreManager.default.getUserController().updateUserOnDisk(_this6);
            }
            return _this6;
          });
        }
        /**
         * Wrap the default fetchWithInclude behavior with functionality to save to local
         * storage if this is current user.
         *
         * @param {...any} args
         * @returns {Parse.User}
         */
      }, {
        key: "fetchWithInclude",
        value: function() {
          var _this7 = this;
          for (var _len4 = arguments.length, args = new Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {
            args[_key7] = arguments[_key7];
          }
          return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser2.prototype), "fetchWithInclude", this).apply(this, args).then(function() {
            if (_this7.isCurrent()) {
              return _CoreManager.default.getUserController().updateUserOnDisk(_this7);
            }
            return _this7;
          });
        }
        /**
         * Verify whether a given password is the password of the current user.
         *
         * @param {string} password A password to be verified
         * @param {object} options
         * @returns {Promise} A promise that is fulfilled with a user
         *  when the password is correct.
         */
      }, {
        key: "verifyPassword",
        value: function(password, options) {
          var username = this.getUsername() || "";
          return ParseUser2.verifyPassword(username, password, options);
        }
      }], [{
        key: "readOnlyAttributes",
        value: function() {
          return ["sessionToken"];
        }
        /**
         * Adds functionality to the existing Parse.User class.
         *
         * @param {object} protoProps A set of properties to add to the prototype
         * @param {object} classProps A set of static properties to add to the class
         * @static
         * @returns {Parse.User} The newly extended Parse.User class
         */
      }, {
        key: "extend",
        value: function(protoProps, classProps) {
          if (protoProps) {
            for (var _prop in protoProps) {
              if (_prop !== "className") {
                (0, _defineProperty2.default)(ParseUser2.prototype, _prop, {
                  value: protoProps[_prop],
                  enumerable: false,
                  writable: true,
                  configurable: true
                });
              }
            }
          }
          if (classProps) {
            for (var _prop2 in classProps) {
              if (_prop2 !== "className") {
                (0, _defineProperty2.default)(ParseUser2, _prop2, {
                  value: classProps[_prop2],
                  enumerable: false,
                  writable: true,
                  configurable: true
                });
              }
            }
          }
          return ParseUser2;
        }
        /**
         * Retrieves the currently logged in ParseUser with a valid session,
         * either from memory or localStorage, if necessary.
         *
         * @static
         * @returns {Parse.Object} The currently logged in Parse.User.
         */
      }, {
        key: "current",
        value: function() {
          if (!canUseCurrentUser) {
            return null;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.currentUser();
        }
        /**
         * Retrieves the currently logged in ParseUser from asynchronous Storage.
         *
         * @static
         * @returns {Promise} A Promise that is resolved with the currently
         *   logged in Parse User
         */
      }, {
        key: "currentAsync",
        value: function() {
          if (!canUseCurrentUser) {
            return _promise.default.resolve(null);
          }
          var controller = _CoreManager.default.getUserController();
          return controller.currentUserAsync();
        }
        /**
         * Signs up a new user with a username (or email) and password.
         * This will create a new Parse.User on the server, and also persist the
         * session in localStorage so that you can access the user using
         * {@link #current}.
         *
         * @param {string} username The username (or email) to sign up with.
         * @param {string} password The password to sign up with.
         * @param {object} attrs Extra fields to set on the new user.
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is fulfilled with the user when
         *     the signup completes.
         */
      }, {
        key: "signUp",
        value: function(username, password, attrs, options) {
          attrs = attrs || {};
          attrs.username = username;
          attrs.password = password;
          var user = new this(attrs);
          return user.signUp({}, options);
        }
        /**
         * Logs in a user with a username (or email) and password. On success, this
         * saves the session to disk, so you can retrieve the currently logged in
         * user using <code>current</code>.
         *
         * @param {string} username The username (or email) to log in with.
         * @param {string} password The password to log in with.
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is fulfilled with the user when
         *     the login completes.
         */
      }, {
        key: "logIn",
        value: function(username, password, options) {
          if (typeof username !== "string") {
            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Username must be a string."));
          }
          if (typeof password !== "string") {
            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Password must be a string."));
          }
          var user = new this();
          user._finishFetch({
            username,
            password
          });
          return user.logIn(options);
        }
      }, {
        key: "loginOrSignup",
        value: function(username, password) {
          var _this8 = this;
          return this.logIn(username, password).catch(function(err) {
            if (err.code === 101) {
              var newUser = new _this8();
              newUser.set("username", username);
              newUser.set("password", password);
              return newUser.signUp();
            }
            throw err;
          });
        }
        /**
         * Logs in a user with a session token. On success, this saves the session
         * to disk, so you can retrieve the currently logged in user using
         * <code>current</code>.
         *
         * @param {string} sessionToken The sessionToken to log in with.
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is fulfilled with the user when
         *     the login completes.
         */
      }, {
        key: "become",
        value: function(sessionToken, options) {
          if (!canUseCurrentUser) {
            throw new Error("It is not memory-safe to become a user in a server environment");
          }
          options = options || {};
          var becomeOptions = {
            sessionToken
          };
          if (options.hasOwnProperty("useMasterKey")) {
            becomeOptions.useMasterKey = options.useMasterKey;
          }
          var controller = _CoreManager.default.getUserController();
          var user = new this();
          return controller.become(user, becomeOptions);
        }
        /**
         * Retrieves a user with a session token.
         *
         * @param {string} sessionToken The sessionToken to get user with.
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is fulfilled with the user is fetched.
         */
      }, {
        key: "me",
        value: function(sessionToken) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var controller = _CoreManager.default.getUserController();
          var meOptions = {
            sessionToken
          };
          if (options.useMasterKey) {
            meOptions.useMasterKey = options.useMasterKey;
          }
          var user = new this();
          return controller.me(user, meOptions);
        }
        /**
         * Logs in a user with a session token. On success, this saves the session
         * to disk, so you can retrieve the currently logged in user using
         * <code>current</code>. If there is no session token the user will not logged in.
         *
         * @param {object} userJSON The JSON map of the User's data
         * @static
         * @returns {Promise} A promise that is fulfilled with the user when
         *     the login completes.
         */
      }, {
        key: "hydrate",
        value: function(userJSON) {
          var controller = _CoreManager.default.getUserController();
          var user = new this();
          return controller.hydrate(user, userJSON);
        }
        /**
         * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}
         *
         * @param provider
         * @param options
         * @param saveOpts
         * @static
         * @returns {Promise}
         */
      }, {
        key: "logInWith",
        value: function(provider, options, saveOpts) {
          var user = new this();
          return user.linkWith(provider, options, saveOpts);
        }
        /**
         * Logs out the currently logged in user session. This will remove the
         * session from disk, log out of linked services, and future calls to
         * <code>current</code> will return <code>null</code>.
         *
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is resolved when the session is
         *   destroyed on the server.
         */
      }, {
        key: "logOut",
        value: function() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var controller = _CoreManager.default.getUserController();
          return controller.logOut(options);
        }
        /**
         * Requests a password reset email to be sent to the specified email address
         * associated with the user account. This email allows the user to securely
         * reset their password on the Parse site.
         *
         * @param {string} email The email address associated with the user that
         *     forgot their password.
         * @param {object} options
         * @static
         * @returns {Promise}
         */
      }, {
        key: "requestPasswordReset",
        value: function(email, options) {
          options = options || {};
          var requestOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            requestOptions.useMasterKey = options.useMasterKey;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.requestPasswordReset(email, requestOptions);
        }
        /**
         * Request an email verification.
         *
         * @param {string} email The email address associated with the user that
         *     forgot their password.
         * @param {object} options
         * @static
         * @returns {Promise}
         */
      }, {
        key: "requestEmailVerification",
        value: function(email, options) {
          options = options || {};
          var requestOptions = {};
          if (options.hasOwnProperty("useMasterKey")) {
            requestOptions.useMasterKey = options.useMasterKey;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.requestEmailVerification(email, requestOptions);
        }
        /**
         * Verify whether a given password is the password of the current user.
         *
         * @param {string} username  A username to be used for identificaiton
         * @param {string} password A password to be verified
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is fulfilled with a user
         *  when the password is correct.
         */
      }, {
        key: "verifyPassword",
        value: function(username, password, options) {
          if (typeof username !== "string") {
            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Username must be a string."));
          }
          if (typeof password !== "string") {
            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Password must be a string."));
          }
          options = options || {};
          var verificationOption = {};
          if (options.hasOwnProperty("useMasterKey")) {
            verificationOption.useMasterKey = options.useMasterKey;
          }
          var controller = _CoreManager.default.getUserController();
          return controller.verifyPassword(username, password, verificationOption);
        }
        /**
         * Allow someone to define a custom User class without className
         * being rewritten to _User. The default behavior is to rewrite
         * User to _User for legacy reasons. This allows developers to
         * override that behavior.
         *
         * @param {boolean} isAllowed Whether or not to allow custom User class
         * @static
         */
      }, {
        key: "allowCustomUserClass",
        value: function(isAllowed) {
          _CoreManager.default.set("PERFORM_USER_REWRITE", !isAllowed);
        }
        /**
         * Allows a legacy application to start using revocable sessions. If the
         * current session token is not revocable, a request will be made for a new,
         * revocable session.
         * It is not necessary to call this method from cloud code unless you are
         * handling user signup or login from the server side. In a cloud code call,
         * this function will not attempt to upgrade the current token.
         *
         * @param {object} options
         * @static
         * @returns {Promise} A promise that is resolved when the process has
         *   completed. If a replacement session token is requested, the promise
         *   will be resolved after a new token has been fetched.
         */
      }, {
        key: "enableRevocableSession",
        value: function(options) {
          options = options || {};
          _CoreManager.default.set("FORCE_REVOCABLE_SESSION", true);
          if (canUseCurrentUser) {
            var current = ParseUser2.current();
            if (current) {
              return current._upgradeToRevocableSession(options);
            }
          }
          return _promise.default.resolve();
        }
        /**
         * Enables the use of become or the current user in a server
         * environment. These features are disabled by default, since they depend on
         * global objects that are not memory-safe for most servers.
         *
         * @static
         */
      }, {
        key: "enableUnsafeCurrentUser",
        value: function() {
          canUseCurrentUser = true;
        }
        /**
         * Disables the use of become or the current user in any environment.
         * These features are disabled on servers by default, since they depend on
         * global objects that are not memory-safe for most servers.
         *
         * @static
         */
      }, {
        key: "disableUnsafeCurrentUser",
        value: function() {
          canUseCurrentUser = false;
        }
        /**
         * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider
         * is automatically created for you.
         *
         * For advanced authentication, you can register an Auth provider to
         * implement custom authentication, deauthentication.
         *
         * @param provider
         * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}
         * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}
         * @static
         */
      }, {
        key: "_registerAuthenticationProvider",
        value: function(provider) {
          authProviders[provider.getAuthType()] = provider;
          ParseUser2.currentAsync().then(function(current) {
            if (current) {
              current._synchronizeAuthData(provider.getAuthType());
            }
          });
        }
        /**
         * @param provider
         * @param options
         * @param saveOpts
         * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}
         * @static
         * @returns {Promise}
         */
      }, {
        key: "_logInWith",
        value: function(provider, options, saveOpts) {
          var user = new this();
          return user.linkWith(provider, options, saveOpts);
        }
      }, {
        key: "_clearCache",
        value: function() {
          currentUserCache = null;
          currentUserCacheMatchesDisk = false;
        }
      }, {
        key: "_setCurrentUserCache",
        value: function(user) {
          currentUserCache = user;
        }
      }]);
      return ParseUser2;
    }(_ParseObject2.default);
    _ParseObject2.default.registerSubclass("_User", ParseUser);
    var DefaultController = {
      updateUserOnDisk: function(user) {
        var path = _Storage.default.generatePath(CURRENT_USER_KEY);
        var json = user.toJSON();
        delete json.password;
        json.className = "_User";
        var userData = (0, _stringify.default)(json);
        if (_CoreManager.default.get("ENCRYPTED_USER")) {
          var crypto3 = _CoreManager.default.getCryptoController();
          userData = crypto3.encrypt(json, _CoreManager.default.get("ENCRYPTED_KEY"));
        }
        return _Storage.default.setItemAsync(path, userData).then(function() {
          return user;
        });
      },
      removeUserFromDisk: function() {
        var path = _Storage.default.generatePath(CURRENT_USER_KEY);
        currentUserCacheMatchesDisk = true;
        currentUserCache = null;
        return _Storage.default.removeItemAsync(path);
      },
      setCurrentUser: function(user) {
        var _this9 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
          var currentUser;
          return _regenerator.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this9.currentUserAsync();
                case 2:
                  currentUser = _context.sent;
                  if (!(currentUser && !user.equals(currentUser) && _AnonymousUtils.default.isLinked(currentUser))) {
                    _context.next = 6;
                    break;
                  }
                  _context.next = 6;
                  return currentUser.destroy({
                    sessionToken: currentUser.getSessionToken()
                  });
                case 6:
                  currentUserCache = user;
                  user._cleanupAuthData();
                  user._synchronizeAllAuthData();
                  return _context.abrupt("return", DefaultController.updateUserOnDisk(user));
                case 10:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      currentUser: function() {
        if (currentUserCache) {
          return currentUserCache;
        }
        if (currentUserCacheMatchesDisk) {
          return null;
        }
        if (_Storage.default.async()) {
          throw new Error("Cannot call currentUser() when using a platform with an async storage system. Call currentUserAsync() instead.");
        }
        var path = _Storage.default.generatePath(CURRENT_USER_KEY);
        var userData = _Storage.default.getItem(path);
        currentUserCacheMatchesDisk = true;
        if (!userData) {
          currentUserCache = null;
          return null;
        }
        if (_CoreManager.default.get("ENCRYPTED_USER")) {
          var crypto3 = _CoreManager.default.getCryptoController();
          userData = crypto3.decrypt(userData, _CoreManager.default.get("ENCRYPTED_KEY"));
        }
        userData = JSON.parse(userData);
        if (!userData.className) {
          userData.className = "_User";
        }
        if (userData._id) {
          if (userData.objectId !== userData._id) {
            userData.objectId = userData._id;
          }
          delete userData._id;
        }
        if (userData._sessionToken) {
          userData.sessionToken = userData._sessionToken;
          delete userData._sessionToken;
        }
        var current = _ParseObject2.default.fromJSON(userData);
        currentUserCache = current;
        current._synchronizeAllAuthData();
        return current;
      },
      currentUserAsync: function() {
        if (currentUserCache) {
          return _promise.default.resolve(currentUserCache);
        }
        if (currentUserCacheMatchesDisk) {
          return _promise.default.resolve(null);
        }
        var path = _Storage.default.generatePath(CURRENT_USER_KEY);
        return _Storage.default.getItemAsync(path).then(function(userData) {
          currentUserCacheMatchesDisk = true;
          if (!userData) {
            currentUserCache = null;
            return _promise.default.resolve(null);
          }
          if (_CoreManager.default.get("ENCRYPTED_USER")) {
            var crypto3 = _CoreManager.default.getCryptoController();
            userData = crypto3.decrypt(userData.toString(), _CoreManager.default.get("ENCRYPTED_KEY"));
          }
          userData = JSON.parse(userData);
          if (!userData.className) {
            userData.className = "_User";
          }
          if (userData._id) {
            if (userData.objectId !== userData._id) {
              userData.objectId = userData._id;
            }
            delete userData._id;
          }
          if (userData._sessionToken) {
            userData.sessionToken = userData._sessionToken;
            delete userData._sessionToken;
          }
          var current = _ParseObject2.default.fromJSON(userData);
          currentUserCache = current;
          current._synchronizeAllAuthData();
          return _promise.default.resolve(current);
        });
      },
      signUp: function(user, attrs, options) {
        var username = attrs && attrs.username || user.get("username");
        var password = attrs && attrs.password || user.get("password");
        if (!username || !username.length) {
          return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Cannot sign up user with an empty username."));
        }
        if (!password || !password.length) {
          return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, "Cannot sign up user with an empty password."));
        }
        return user.save(attrs, options).then(function() {
          user._finishFetch({
            password: void 0
          });
          if (canUseCurrentUser) {
            return DefaultController.setCurrentUser(user);
          }
          return user;
        });
      },
      logIn: function(user, options) {
        var RESTController = _CoreManager.default.getRESTController();
        var stateController = _CoreManager.default.getObjectStateController();
        var auth = {
          username: user.get("username"),
          password: user.get("password")
        };
        return RESTController.request(options.usePost ? "POST" : "GET", "login", auth, options).then(function(response) {
          user._migrateId(response.objectId);
          user._setExisted(true);
          stateController.setPendingOp(user._getStateIdentifier(), "username", void 0);
          stateController.setPendingOp(user._getStateIdentifier(), "password", void 0);
          response.password = void 0;
          user._finishFetch(response);
          if (!canUseCurrentUser) {
            return _promise.default.resolve(user);
          }
          return DefaultController.setCurrentUser(user);
        });
      },
      become: function(user, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "users/me", {}, options).then(function(response) {
          user._finishFetch(response);
          user._setExisted(true);
          return DefaultController.setCurrentUser(user);
        });
      },
      hydrate: function(user, userJSON) {
        user._finishFetch(userJSON);
        user._setExisted(true);
        if (userJSON.sessionToken && canUseCurrentUser) {
          return DefaultController.setCurrentUser(user);
        }
        return _promise.default.resolve(user);
      },
      me: function(user, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "users/me", {}, options).then(function(response) {
          user._finishFetch(response);
          user._setExisted(true);
          return user;
        });
      },
      logOut: function(options) {
        var Moralis = require_Parse();
        Moralis.cleanup();
        var RESTController = _CoreManager.default.getRESTController();
        if (options.sessionToken) {
          return RESTController.request("POST", "logout", {}, options);
        }
        return DefaultController.currentUserAsync().then(function(currentUser) {
          var path = _Storage.default.generatePath(CURRENT_USER_KEY);
          var promise = _Storage.default.removeItemAsync(path);
          if (currentUser !== null) {
            var isAnonymous = _AnonymousUtils.default.isLinked(currentUser);
            var currentSession = currentUser.getSessionToken();
            if (currentSession && (0, _isRevocableSession.default)(currentSession)) {
              promise = promise.then(function() {
                if (isAnonymous) {
                  return currentUser.destroy({
                    sessionToken: currentSession
                  });
                }
              }).then(function() {
                return RESTController.request("POST", "logout", {}, {
                  sessionToken: currentSession
                });
              });
            }
            currentUser._logOutWithAll();
            currentUser._finishFetch({
              sessionToken: void 0
            });
            currentUser._clearServerData();
          }
          currentUserCacheMatchesDisk = true;
          currentUserCache = null;
          return promise;
        });
      },
      requestPasswordReset: function(email, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("POST", "requestPasswordReset", {
          email
        }, options);
      },
      upgradeToRevocableSession: function(user, options) {
        var token = user.getSessionToken();
        if (!token) {
          return _promise.default.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, "Cannot upgrade a user with no session token"));
        }
        options.sessionToken = token;
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("POST", "upgradeToRevocableSession", {}, options).then(function(result) {
          var session = new _ParseSession.default();
          session._finishFetch(result);
          user._finishFetch({
            sessionToken: session.getSessionToken()
          });
          if (user.isCurrent()) {
            return DefaultController.setCurrentUser(user);
          }
          return _promise.default.resolve(user);
        });
      },
      linkWith: function(user, authData, options) {
        return user.save({
          authData
        }, options).then(function() {
          if (canUseCurrentUser) {
            return DefaultController.setCurrentUser(user);
          }
          return user;
        });
      },
      verifyPassword: function(username, password, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "verifyPassword", {
          username,
          password
        }, options);
      },
      requestEmailVerification: function(email, options) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("POST", "verificationEmailRequest", {
          email
        }, options);
      }
    };
    _CoreManager.default.setUserController(DefaultController);
    var _default = ParseUser;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParseACL.js
var require_ParseACL = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseACL.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _keys = _interopRequireDefault(require_keys3());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _ParseRole = _interopRequireDefault(require_ParseRole());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var PUBLIC_KEY = "*";
    var ParseACL = function() {
      function ParseACL2(arg1) {
        (0, _classCallCheck2.default)(this, ParseACL2);
        (0, _defineProperty2.default)(this, "permissionsById", void 0);
        this.permissionsById = {};
        if (arg1 && (0, _typeof2.default)(arg1) === "object") {
          if (arg1 instanceof _ParseUser.default) {
            this.setReadAccess(arg1, true);
            this.setWriteAccess(arg1, true);
          } else {
            for (var _userId in arg1) {
              var accessList = arg1[_userId];
              this.permissionsById[_userId] = {};
              for (var _permission in accessList) {
                var allowed = accessList[_permission];
                if (_permission !== "read" && _permission !== "write") {
                  throw new TypeError("Tried to create an ACL with an invalid permission type.");
                }
                if (typeof allowed !== "boolean") {
                  throw new TypeError("Tried to create an ACL with an invalid permission value.");
                }
                this.permissionsById[_userId][_permission] = allowed;
              }
            }
          }
        } else if (typeof arg1 === "function") {
          throw new TypeError("ParseACL constructed with a function. Did you forget ()?");
        }
      }
      (0, _createClass2.default)(ParseACL2, [{
        key: "toJSON",
        value: function() {
          var permissions = {};
          for (var p2 in this.permissionsById) {
            permissions[p2] = this.permissionsById[p2];
          }
          return permissions;
        }
        /**
         * Returns whether this ACL is equal to another object
         *
         * @param {ParseACL} other The other object's ACL to compare to
         * @returns {boolean}
         */
      }, {
        key: "equals",
        value: function(other) {
          if (!(other instanceof ParseACL2)) {
            return false;
          }
          var users = (0, _keys.default)(this.permissionsById);
          var otherUsers = (0, _keys.default)(other.permissionsById);
          if (users.length !== otherUsers.length) {
            return false;
          }
          for (var u2 in this.permissionsById) {
            if (!other.permissionsById[u2]) {
              return false;
            }
            if (this.permissionsById[u2].read !== other.permissionsById[u2].read) {
              return false;
            }
            if (this.permissionsById[u2].write !== other.permissionsById[u2].write) {
              return false;
            }
          }
          return true;
        }
      }, {
        key: "_setAccess",
        value: function(accessType, userId, allowed) {
          if (userId instanceof _ParseUser.default) {
            userId = userId.id;
          } else if (userId instanceof _ParseRole.default) {
            var name2 = userId.getName();
            if (!name2) {
              throw new TypeError("Role must have a name");
            }
            userId = "role:".concat(name2);
          }
          if (typeof userId !== "string") {
            throw new TypeError("userId must be a string.");
          }
          if (typeof allowed !== "boolean") {
            throw new TypeError("allowed must be either true or false.");
          }
          var permissions = this.permissionsById[userId];
          if (!permissions) {
            if (!allowed) {
              return;
            }
            permissions = {};
            this.permissionsById[userId] = permissions;
          }
          if (allowed) {
            this.permissionsById[userId][accessType] = true;
          } else {
            delete permissions[accessType];
            if ((0, _keys.default)(permissions).length === 0) {
              delete this.permissionsById[userId];
            }
          }
        }
      }, {
        key: "_getAccess",
        value: function(accessType, userId) {
          if (userId instanceof _ParseUser.default) {
            userId = userId.id;
            if (!userId) {
              throw new Error("Cannot get access for a ParseUser without an ID");
            }
          } else if (userId instanceof _ParseRole.default) {
            var name2 = userId.getName();
            if (!name2) {
              throw new TypeError("Role must have a name");
            }
            userId = "role:".concat(name2);
          }
          var permissions = this.permissionsById[userId];
          if (!permissions) {
            return false;
          }
          return !!permissions[accessType];
        }
        /**
         * Sets whether the given user is allowed to read this object.
         *
         * @param userId An instance of Parse.User or its objectId.
         * @param {boolean} allowed Whether that user should have read access.
         */
      }, {
        key: "setReadAccess",
        value: function(userId, allowed) {
          this._setAccess("read", userId, allowed);
        }
        /**
         * Get whether the given user id is *explicitly* allowed to read this object.
         * Even if this returns false, the user may still be able to access it if
         * getPublicReadAccess returns true or a role that the user belongs to has
         * write access.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role.
         * @returns {boolean}
         */
      }, {
        key: "getReadAccess",
        value: function(userId) {
          return this._getAccess("read", userId);
        }
        /**
         * Sets whether the given user id is allowed to write this object.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role..
         * @param {boolean} allowed Whether that user should have write access.
         */
      }, {
        key: "setWriteAccess",
        value: function(userId, allowed) {
          this._setAccess("write", userId, allowed);
        }
        /**
         * Gets whether the given user id is *explicitly* allowed to write this object.
         * Even if this returns false, the user may still be able to write it if
         * getPublicWriteAccess returns true or a role that the user belongs to has
         * write access.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role.
         * @returns {boolean}
         */
      }, {
        key: "getWriteAccess",
        value: function(userId) {
          return this._getAccess("write", userId);
        }
        /**
         * Sets whether the public is allowed to read this object.
         *
         * @param {boolean} allowed
         */
      }, {
        key: "setPublicReadAccess",
        value: function(allowed) {
          this.setReadAccess(PUBLIC_KEY, allowed);
        }
        /**
         * Gets whether the public is allowed to read this object.
         *
         * @returns {boolean}
         */
      }, {
        key: "getPublicReadAccess",
        value: function() {
          return this.getReadAccess(PUBLIC_KEY);
        }
        /**
         * Sets whether the public is allowed to write this object.
         *
         * @param {boolean} allowed
         */
      }, {
        key: "setPublicWriteAccess",
        value: function(allowed) {
          this.setWriteAccess(PUBLIC_KEY, allowed);
        }
        /**
         * Gets whether the public is allowed to write this object.
         *
         * @returns {boolean}
         */
      }, {
        key: "getPublicWriteAccess",
        value: function() {
          return this.getWriteAccess(PUBLIC_KEY);
        }
        /**
         * Gets whether users belonging to the given role are allowed
         * to read this object. Even if this returns false, the role may
         * still be able to write it if a parent role has read access.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @returns {boolean} true if the role has read access. false otherwise.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "getRoleReadAccess",
        value: function(role) {
          if (role instanceof _ParseRole.default) {
            role = role.getName();
          }
          if (typeof role !== "string") {
            throw new TypeError("role must be a ParseRole or a String");
          }
          return this.getReadAccess("role:".concat(role));
        }
        /**
         * Gets whether users belonging to the given role are allowed
         * to write this object. Even if this returns false, the role may
         * still be able to write it if a parent role has write access.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @returns {boolean} true if the role has write access. false otherwise.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "getRoleWriteAccess",
        value: function(role) {
          if (role instanceof _ParseRole.default) {
            role = role.getName();
          }
          if (typeof role !== "string") {
            throw new TypeError("role must be a ParseRole or a String");
          }
          return this.getWriteAccess("role:".concat(role));
        }
        /**
         * Sets whether users belonging to the given role are allowed
         * to read this object.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @param {boolean} allowed Whether the given role can read this object.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "setRoleReadAccess",
        value: function(role, allowed) {
          if (role instanceof _ParseRole.default) {
            role = role.getName();
          }
          if (typeof role !== "string") {
            throw new TypeError("role must be a ParseRole or a String");
          }
          this.setReadAccess("role:".concat(role), allowed);
        }
        /**
         * Sets whether users belonging to the given role are allowed
         * to write this object.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @param {boolean} allowed Whether the given role can write this object.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "setRoleWriteAccess",
        value: function(role, allowed) {
          if (role instanceof _ParseRole.default) {
            role = role.getName();
          }
          if (typeof role !== "string") {
            throw new TypeError("role must be a ParseRole or a String");
          }
          this.setWriteAccess("role:".concat(role), allowed);
        }
      }]);
      return ParseACL2;
    }();
    var _default = ParseACL;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/decode.js
var require_decode = __commonJS({
  "node_modules/moralis-v1/lib/browser/decode.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = decode3;
    var _isArray = _interopRequireDefault(require_is_array4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _ParseACL = _interopRequireDefault(require_ParseACL());
    var _ParseFile = _interopRequireDefault(require_ParseFile());
    var _ParseGeoPoint = _interopRequireDefault(require_ParseGeoPoint());
    var _ParsePolygon = _interopRequireDefault(require_ParsePolygon());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseOp = require_ParseOp();
    var _ParseRelation = _interopRequireDefault(require_ParseRelation());
    function decode3(value) {
      if (value === null || (0, _typeof2.default)(value) !== "object") {
        return value;
      }
      if ((0, _isArray.default)(value)) {
        var dup = [];
        (0, _forEach.default)(value).call(value, function(v2, i2) {
          dup[i2] = decode3(v2);
        });
        return dup;
      }
      if (typeof value.__op === "string") {
        return (0, _ParseOp.opFromJSON)(value);
      }
      if (value.__type === "Pointer" && value.className) {
        return _ParseObject.default.fromJSON(value);
      }
      if (value.__type === "Object" && value.className) {
        return _ParseObject.default.fromJSON(value);
      }
      if (value.__type === "Relation") {
        var relation = new _ParseRelation.default(null, null);
        relation.targetClassName = value.className;
        return relation;
      }
      if (value.__type === "Date") {
        return new Date(value.iso);
      }
      if (value.__type === "File") {
        return _ParseFile.default.fromJSON(value);
      }
      if (value.__type === "GeoPoint") {
        return new _ParseGeoPoint.default({
          latitude: value.latitude,
          longitude: value.longitude
        });
      }
      if (value.__type === "Polygon") {
        return new _ParsePolygon.default(value.coordinates);
      }
      var copy = {};
      for (var k2 in value) {
        copy[k2] = decode3(value[k2]);
      }
      return copy;
    }
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto3;
        if (typeof window !== "undefined" && window.crypto) {
          crypto3 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto3 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto3 = globalThis.crypto;
        }
        if (!crypto3 && typeof window !== "undefined" && window.msCrypto) {
          crypto3 = window.msCrypto;
        }
        if (!crypto3 && typeof global !== "undefined" && global.crypto) {
          crypto3 = global.crypto;
        }
        if (!crypto3 && typeof __require === "function") {
          try {
            crypto3 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto3) {
            if (typeof crypto3.getRandomValues === "function") {
              try {
                return crypto3.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto3.randomBytes === "function") {
              try {
                return crypto3.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words2 = this.words;
            var sigBytes = this.sigBytes;
            words2[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words2.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words2 = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words2.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words2, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words2[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words2 = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words2[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words2, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words2[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words2 = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words2[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words2, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash3 = this._doFinalize();
            return hash3;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key2) {
              return new C_algo.HMAC.init(hasher, key2).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words2[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words2[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words2[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map.length; j2++) {
                reverseMap[map.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words2 = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words2[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words2, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset + 0];
            var M_offset_1 = M2[offset + 1];
            var M_offset_2 = M2[offset + 2];
            var M_offset_3 = M2[offset + 3];
            var M_offset_4 = M2[offset + 4];
            var M_offset_5 = M2[offset + 5];
            var M_offset_6 = M2[offset + 6];
            var M_offset_7 = M2[offset + 7];
            var M_offset_8 = M2[offset + 8];
            var M_offset_9 = M2[offset + 9];
            var M_offset_10 = M2[offset + 10];
            var M_offset_11 = M2[offset + 11];
            var M_offset_12 = M2[offset + 12];
            var M_offset_13 = M2[offset + 13];
            var M_offset_14 = M2[offset + 14];
            var M_offset_15 = M2[offset + 15];
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            a2 = FF(a2, b2, c2, d2, M_offset_0, 7, T[0]);
            d2 = FF(d2, a2, b2, c2, M_offset_1, 12, T[1]);
            c2 = FF(c2, d2, a2, b2, M_offset_2, 17, T[2]);
            b2 = FF(b2, c2, d2, a2, M_offset_3, 22, T[3]);
            a2 = FF(a2, b2, c2, d2, M_offset_4, 7, T[4]);
            d2 = FF(d2, a2, b2, c2, M_offset_5, 12, T[5]);
            c2 = FF(c2, d2, a2, b2, M_offset_6, 17, T[6]);
            b2 = FF(b2, c2, d2, a2, M_offset_7, 22, T[7]);
            a2 = FF(a2, b2, c2, d2, M_offset_8, 7, T[8]);
            d2 = FF(d2, a2, b2, c2, M_offset_9, 12, T[9]);
            c2 = FF(c2, d2, a2, b2, M_offset_10, 17, T[10]);
            b2 = FF(b2, c2, d2, a2, M_offset_11, 22, T[11]);
            a2 = FF(a2, b2, c2, d2, M_offset_12, 7, T[12]);
            d2 = FF(d2, a2, b2, c2, M_offset_13, 12, T[13]);
            c2 = FF(c2, d2, a2, b2, M_offset_14, 17, T[14]);
            b2 = FF(b2, c2, d2, a2, M_offset_15, 22, T[15]);
            a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T[16]);
            d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T[17]);
            c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T[18]);
            b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T[19]);
            a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T[20]);
            d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T[21]);
            c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T[22]);
            b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T[23]);
            a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T[24]);
            d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T[25]);
            c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T[26]);
            b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T[27]);
            a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T[28]);
            d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T[29]);
            c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T[30]);
            b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T[31]);
            a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T[32]);
            d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T[33]);
            c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T[34]);
            b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T[35]);
            a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T[36]);
            d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T[37]);
            c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T[38]);
            b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T[39]);
            a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T[40]);
            d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T[41]);
            c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T[42]);
            b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T[43]);
            a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T[44]);
            d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T[45]);
            c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T[46]);
            b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T[47]);
            a2 = II(a2, b2, c2, d2, M_offset_0, 6, T[48]);
            d2 = II(d2, a2, b2, c2, M_offset_7, 10, T[49]);
            c2 = II(c2, d2, a2, b2, M_offset_14, 15, T[50]);
            b2 = II(b2, c2, d2, a2, M_offset_5, 21, T[51]);
            a2 = II(a2, b2, c2, d2, M_offset_12, 6, T[52]);
            d2 = II(d2, a2, b2, c2, M_offset_3, 10, T[53]);
            c2 = II(c2, d2, a2, b2, M_offset_10, 15, T[54]);
            b2 = II(b2, c2, d2, a2, M_offset_1, 21, T[55]);
            a2 = II(a2, b2, c2, d2, M_offset_8, 6, T[56]);
            d2 = II(d2, a2, b2, c2, M_offset_15, 10, T[57]);
            c2 = II(c2, d2, a2, b2, M_offset_6, 15, T[58]);
            b2 = II(b2, c2, d2, a2, M_offset_13, 21, T[59]);
            a2 = II(a2, b2, c2, d2, M_offset_4, 6, T[60]);
            d2 = II(d2, a2, b2, c2, M_offset_11, 10, T[61]);
            c2 = II(c2, d2, a2, b2, M_offset_2, 15, T[62]);
            b2 = II(b2, c2, d2, a2, M_offset_9, 21, T[63]);
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash3 = this._hash;
            var H2 = hash3.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H2[i2];
              H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash3;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 & c2 | ~b2 & d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function GG(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 & d2 | c2 & ~d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function HH(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 ^ c2 ^ d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function II(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (c2 ^ (b2 | ~d2)) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            var e = H2[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W2[i2] = M2[offset + i2] | 0;
              } else {
                var n2 = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
                W2[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a2 << 5 | a2 >>> 27) + e + W2[i2];
              if (i2 < 20) {
                t2 += (b2 & c2 | ~b2 & d2) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b2 ^ c2 ^ d2) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
              } else {
                t2 += (b2 ^ c2 ^ d2) - 899497514;
              }
              e = d2;
              d2 = c2;
              c2 = b2 << 30 | b2 >>> 2;
              b2 = a2;
              a2 = t2;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key2) {
            hasher = this._hasher = new hasher.init();
            if (typeof key2 == "string") {
              key2 = Utf8.parse(key2);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key2.sigBytes > hasherBlockSizeBytes) {
              key2 = hasher.finalize(key2);
            }
            key2.clamp();
            var oKey = this._oKey = key2.clone();
            var iKey = this._iKey = key2.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key2, cfg) {
            return this.create(this._ENC_XFORM_MODE, key2, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key2, cfg) {
            return this.create(this._DEC_XFORM_MODE, key2, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key2, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key2;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key2) {
              if (typeof key2 == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key2, cfg) {
                  return selectCipherStrategy(key2).encrypt(cipher, message, key2, cfg);
                },
                decrypt: function(ciphertext, key2, cfg) {
                  return selectCipherStrategy(key2).decrypt(cipher, ciphertext, key2, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words2, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words2, offset, blockSize);
              cipher.encryptBlock(words2, offset);
              this._prevBlock = words2.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words2, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words2.slice(offset, offset + blockSize);
              cipher.decryptBlock(words2, offset);
              xorBlock.call(this, words2, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words2, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words2[offset + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding2 = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding2);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words2, offset) {
            this._mode.processBlock(words2, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding2 = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding2.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding2.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key2, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key: key2,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key2, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key2 = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key2.words.slice(keySize), ivSize * 4);
            key2.sigBytes = keySize * 4;
            return CipherParams.create({ key: key2, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d2[i2] = i2 << 1;
            } else {
              d2[i2] = i2 << 1 ^ 283;
            }
          }
          var x2 = 0;
          var xi = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x2] = sx;
            INV_SBOX[sx] = x2;
            var x22 = d2[x2];
            var x4 = d2[x22];
            var x8 = d2[x4];
            var t2 = d2[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x2] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x2] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x2] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x2] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x2) {
              x2 = xi = 1;
            } else {
              x2 = x22 ^ d2[d2[d2[x8 ^ x22]]];
              xi ^= d2[d2[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key2 = this._keyPriorReset = this._key;
            var keyWords = key2.words;
            var keySize = key2.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M2, offset) {
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
            this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
          },
          _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M2[offset] ^ keySchedule[0];
            var s1 = M2[offset + 1] ^ keySchedule[1];
            var s2 = M2[offset + 2] ^ keySchedule[2];
            var s3 = M2[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M2[offset] = t0;
            M2[offset + 1] = t1;
            M2[offset + 2] = t2;
            M2[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/crypto-js/enc-utf8.js
var require_enc_utf8 = __commonJS({
  "node_modules/crypto-js/enc-utf8.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.enc.Utf8;
    });
  }
});

// node_modules/moralis-v1/lib/browser/CryptoController.js
var require_CryptoController = __commonJS({
  "node_modules/moralis-v1/lib/browser/CryptoController.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _stringify = _interopRequireDefault(require_stringify3());
    var AES;
    var ENC;
    AES = require_aes();
    ENC = require_enc_utf8();
    var CryptoController = {
      encrypt: function(obj, secretKey) {
        var encrypted = AES.encrypt((0, _stringify.default)(obj), secretKey);
        return encrypted.toString();
      },
      decrypt: function(encryptedText, secretKey) {
        var decryptedStr = AES.decrypt(encryptedText, secretKey).toString(ENC);
        return decryptedStr;
      }
    };
    module.exports = CryptoController;
  }
});

// node_modules/moralis-v1/lib/browser/InstallationController.js
var require_InstallationController = __commonJS({
  "node_modules/moralis-v1/lib/browser/InstallationController.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _promise = _interopRequireDefault(require_promise3());
    var _Storage = _interopRequireDefault(require_Storage());
    var _require = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    var uuidv4 = _require.v4;
    var iidCache = null;
    var InstallationController = {
      currentInstallationId: function() {
        if (typeof iidCache === "string") {
          return _promise.default.resolve(iidCache);
        }
        var path = _Storage.default.generatePath("installationId");
        return _Storage.default.getItemAsync(path).then(function(iid) {
          if (!iid) {
            iid = uuidv4();
            return _Storage.default.setItemAsync(path, iid).then(function() {
              iidCache = iid;
              return iid;
            });
          }
          iidCache = iid;
          return iid;
        });
      },
      _clearCache: function() {
        iidCache = null;
      },
      _setInstallationIdCache: function(iid) {
        iidCache = iid;
      }
    };
    module.exports = InstallationController;
  }
});

// node_modules/core-js-pure/internals/engine-is-bun.js
var require_engine_is_bun = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-bun.js"(exports, module) {
    "use strict";
    module.exports = typeof Bun == "function" && Bun && typeof Bun.version == "string";
  }
});

// node_modules/core-js-pure/internals/schedulers-fix.js
var require_schedulers_fix = __commonJS({
  "node_modules/core-js-pure/internals/schedulers-fix.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var isCallable = require_is_callable();
    var ENGINE_IS_BUN = require_engine_is_bun();
    var USER_AGENT = require_engine_user_agent();
    var arraySlice = require_array_slice();
    var validateArgumentsLength = require_validate_arguments_length();
    var Function2 = global2.Function;
    var WRAP = /MSIE .\./.test(USER_AGENT) || ENGINE_IS_BUN && function() {
      var version28 = global2.Bun.version.split(".");
      return version28.length < 3 || version28[0] === "0" && (version28[1] < 3 || version28[1] === "3" && version28[2] === "0");
    }();
    module.exports = function(scheduler, hasTimeArg) {
      var firstParamIndex = hasTimeArg ? 2 : 1;
      return WRAP ? function(handler, timeout) {
        var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
        var fn2 = isCallable(handler) ? handler : Function2(handler);
        var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
        var callback = boundArgs ? function() {
          apply(fn2, this, params);
        } : fn2;
        return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
      } : scheduler;
    };
  }
});

// node_modules/core-js-pure/modules/web.set-interval.js
var require_web_set_interval = __commonJS({
  "node_modules/core-js-pure/modules/web.set-interval.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var schedulersFix = require_schedulers_fix();
    var setInterval2 = schedulersFix(global2.setInterval, true);
    $({ global: true, bind: true, forced: global2.setInterval !== setInterval2 }, {
      setInterval: setInterval2
    });
  }
});

// node_modules/core-js-pure/modules/web.set-timeout.js
var require_web_set_timeout = __commonJS({
  "node_modules/core-js-pure/modules/web.set-timeout.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var schedulersFix = require_schedulers_fix();
    var setTimeout2 = schedulersFix(global2.setTimeout, true);
    $({ global: true, bind: true, forced: global2.setTimeout !== setTimeout2 }, {
      setTimeout: setTimeout2
    });
  }
});

// node_modules/core-js-pure/modules/web.timers.js
var require_web_timers = __commonJS({
  "node_modules/core-js-pure/modules/web.timers.js"() {
    "use strict";
    require_web_set_interval();
    require_web_set_timeout();
  }
});

// node_modules/core-js-pure/stable/set-timeout.js
var require_set_timeout = __commonJS({
  "node_modules/core-js-pure/stable/set-timeout.js"(exports, module) {
    "use strict";
    require_web_timers();
    var path = require_path();
    module.exports = path.setTimeout;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/set-timeout.js
var require_set_timeout2 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/set-timeout.js"(exports, module) {
    module.exports = require_set_timeout();
  }
});

// node_modules/moralis-v1/lib/browser/RESTController.js
var require_RESTController = __commonJS({
  "node_modules/moralis-v1/lib/browser/RESTController.js"(exports, module) {
    "use strict";
    var _Object$keys = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _promise = _interopRequireDefault(require_promise3());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _includes = _interopRequireDefault(require_includes5());
    var _setTimeout2 = _interopRequireDefault(require_set_timeout2());
    var _concat = _interopRequireDefault(require_concat4());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _promiseUtils = require_promiseUtils();
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context5, _context6;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty(_context5 = ownKeys5(Object(source), true)).call(_context5, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context6 = ownKeys5(Object(source))).call(_context6, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    var _require = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    var uuidv4 = _require.v4;
    var XHR = null;
    if (typeof XMLHttpRequest !== "undefined") {
      XHR = XMLHttpRequest;
    }
    var useXDomainRequest = false;
    if (typeof XDomainRequest !== "undefined" && !("withCredentials" in new XMLHttpRequest())) {
      useXDomainRequest = true;
    }
    function ajaxIE9(method, url, data, headers, options) {
      return new _promise.default(function(resolve, reject) {
        var xdr = new XDomainRequest();
        xdr.onload = function() {
          var response;
          try {
            response = JSON.parse(xdr.responseText);
          } catch (e) {
            reject(e);
          }
          if (response) {
            resolve({
              response
            });
          }
        };
        xdr.onerror = xdr.ontimeout = function() {
          var fakeResponse = {
            responseText: (0, _stringify.default)({
              code: _ParseError.default.X_DOMAIN_REQUEST,
              error: "IE's XDomainRequest does not supply error info."
            })
          };
          reject(fakeResponse);
        };
        xdr.onprogress = function() {
          if (options && typeof options.progress === "function") {
            options.progress(xdr.responseText);
          }
        };
        xdr.open(method, url);
        xdr.send(data);
        if (options && typeof options.requestTask === "function") {
          options.requestTask(xdr);
        }
      });
    }
    var RESTController = {
      ajax: function(method, url, data, headers, options) {
        var _context;
        if (useXDomainRequest) {
          return ajaxIE9(method, url, data, headers, options);
        }
        var promise = (0, _promiseUtils.resolvingPromise)();
        var isIdempotent = _CoreManager.default.get("IDEMPOTENCY") && (0, _includes.default)(_context = ["POST", "PUT"]).call(_context, method);
        var requestId = isIdempotent ? uuidv4() : "";
        var attempts = 0;
        var dispatch = function dispatch2() {
          if (XHR == null) {
            throw new Error("Cannot make a request: No definition of XMLHttpRequest was found.");
          }
          var handled = false;
          var xhr = new XHR();
          xhr.onreadystatechange = function() {
            if (xhr.readyState !== 4 || handled || xhr._aborted) {
              return;
            }
            handled = true;
            if (xhr.status >= 200 && xhr.status < 300) {
              var response;
              try {
                response = JSON.parse(xhr.responseText);
                if (typeof xhr.getResponseHeader === "function") {
                  var _context2;
                  if ((0, _includes.default)(_context2 = xhr.getAllResponseHeaders() || "").call(_context2, "x-parse-job-status-id: ")) {
                    response = xhr.getResponseHeader("x-parse-job-status-id");
                  }
                }
              } catch (e) {
                promise.reject(e.toString());
              }
              if (response) {
                promise.resolve({
                  response,
                  status: xhr.status,
                  xhr
                });
              }
            } else if (xhr.status >= 500 || xhr.status === 0) {
              if (++attempts < _CoreManager.default.get("REQUEST_ATTEMPT_LIMIT")) {
                var delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));
                (0, _setTimeout2.default)(dispatch2, delay);
              } else if (xhr.status === 0) {
                promise.reject("Unable to connect to the Parse API");
              } else {
                promise.reject(xhr);
              }
            } else {
              promise.reject(xhr);
            }
          };
          headers = headers || {};
          if (typeof headers["Content-Type"] !== "string") {
            headers["Content-Type"] = "text/plain";
          }
          if (_CoreManager.default.get("IS_NODE")) {
            var _context3;
            headers["User-Agent"] = (0, _concat.default)(_context3 = "Parse/".concat(_CoreManager.default.get("VERSION"), " (NodeJS ")).call(_context3, process.versions.node, ")");
          }
          if (isIdempotent) {
            headers["X-Parse-Request-Id"] = requestId;
          }
          if (_CoreManager.default.get("SERVER_AUTH_TYPE") && _CoreManager.default.get("SERVER_AUTH_TOKEN")) {
            var _context4;
            headers.Authorization = (0, _concat.default)(_context4 = "".concat(_CoreManager.default.get("SERVER_AUTH_TYPE"), " ")).call(_context4, _CoreManager.default.get("SERVER_AUTH_TOKEN"));
          }
          var customHeaders = _CoreManager.default.get("REQUEST_HEADERS");
          for (var key2 in customHeaders) {
            headers[key2] = customHeaders[key2];
          }
          function handleProgress(type, event) {
            if (options && typeof options.progress === "function") {
              if (event.lengthComputable) {
                options.progress(event.loaded / event.total, event.loaded, event.total, {
                  type
                });
              } else {
                options.progress(null, null, null, {
                  type
                });
              }
            }
          }
          xhr.onprogress = function(event) {
            handleProgress("download", event);
          };
          if (xhr.upload) {
            xhr.upload.onprogress = function(event) {
              handleProgress("upload", event);
            };
          }
          xhr.open(method, url, true);
          for (var h2 in headers) {
            xhr.setRequestHeader(h2, headers[h2]);
          }
          xhr.onabort = function() {
            promise.resolve({
              response: {
                results: []
              },
              status: 0,
              xhr
            });
          };
          xhr.send(data);
          if (options && typeof options.requestTask === "function") {
            options.requestTask(xhr);
          }
        };
        dispatch();
        return promise;
      },
      request: function(method, path, data, options) {
        options = options || {};
        var url = _CoreManager.default.get("SERVER_URL");
        if (url[url.length - 1] !== "/") {
          url += "/";
        }
        url += path;
        var payload = {};
        if (data && (0, _typeof2.default)(data) === "object") {
          for (var k2 in data) {
            payload[k2] = data[k2];
          }
        }
        var _options = options, context = _options.context;
        if (context !== void 0) {
          payload._context = context;
        }
        if (method !== "POST") {
          payload._method = method;
          method = "POST";
        }
        payload._ApplicationId = _CoreManager.default.get("APPLICATION_ID");
        var jsKey = _CoreManager.default.get("JAVASCRIPT_KEY");
        if (jsKey) {
          payload._JavaScriptKey = jsKey;
        }
        payload._ClientVersion = _CoreManager.default.get("VERSION");
        var _options2 = options, useMasterKey = _options2.useMasterKey;
        if (typeof useMasterKey === "undefined") {
          useMasterKey = _CoreManager.default.get("USE_MASTER_KEY");
        }
        if (useMasterKey) {
          if (_CoreManager.default.get("MASTER_KEY")) {
            delete payload._JavaScriptKey;
            payload._MasterKey = _CoreManager.default.get("MASTER_KEY");
          }
        }
        if (_CoreManager.default.get("FORCE_REVOCABLE_SESSION")) {
          payload._RevocableSession = "1";
        }
        var _options3 = options, installationId = _options3.installationId;
        var installationIdPromise;
        if (installationId && typeof installationId === "string") {
          installationIdPromise = _promise.default.resolve(installationId);
        } else {
          var installationController = _CoreManager.default.getInstallationController();
          installationIdPromise = installationController.currentInstallationId();
        }
        return installationIdPromise.then(function(iid) {
          payload._InstallationId = iid;
          var userController = _CoreManager.default.getUserController();
          if (options && typeof options.sessionToken === "string") {
            return _promise.default.resolve(options.sessionToken);
          }
          if (userController) {
            return userController.currentUserAsync().then(function(user) {
              if (user) {
                return _promise.default.resolve(user.getSessionToken());
              }
              return _promise.default.resolve(null);
            });
          }
          return _promise.default.resolve(null);
        }).then(function(token) {
          if (token) {
            payload._SessionToken = token;
          }
          var payloadString = (0, _stringify.default)(payload);
          return RESTController.ajax(method, url, payloadString, {}, options).then(function(_ref) {
            var response = _ref.response, status = _ref.status;
            if (options.returnStatus) {
              return _objectSpread5(_objectSpread5({}, response), {}, {
                _status: status
              });
            }
            return response;
          });
        }).catch(RESTController.handleError);
      },
      handleError: function(response) {
        var error;
        if (response && response.responseText) {
          try {
            var errorJSON = JSON.parse(response.responseText);
            error = new _ParseError.default(errorJSON.code, errorJSON.error);
          } catch (e) {
            error = new _ParseError.default(_ParseError.default.INVALID_JSON, "Received an error with invalid JSON from Parse: ".concat(response.responseText));
          }
        } else {
          var message = response.message ? response.message : response;
          error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, "XMLHttpRequest failed: ".concat((0, _stringify.default)(message)));
        }
        return _promise.default.reject(error);
      },
      _setXHR: function(xhr) {
        XHR = xhr;
      },
      _getXHR: function() {
        return XHR;
      }
    };
    module.exports = RESTController;
  }
});

// node_modules/moralis-v1/lib/browser/filterConsole.js
var require_filterConsole = __commonJS({
  "node_modules/moralis-v1/lib/browser/filterConsole.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _filter = _interopRequireDefault(require_filter4());
    var _includes = _interopRequireDefault(require_includes5());
    var filteredWarnings = [
      // Optional dependencies, where we handle the dependency check on run-time
      "Module not found: Can't resolve '@walletconnect/web3-provider'",
      "Module not found: Can't resolve 'magic-sdk'",
      "Module not found: Can't resolve '@web3auth/web3auth'"
    ];
    var filterConsole = function() {
      var preservedConsoleWarn = console.warn;
      console.warn = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var value = args ? args[0] : null;
        if (!value || typeof value !== "string") {
          return preservedConsoleWarn.apply(console, args);
        }
        value = value.replace("’", "'").replace("‘", "'").replace("’", "'");
        if ((0, _filter.default)(filteredWarnings).call(filteredWarnings, function(filter) {
          return (0, _includes.default)(value).call(value, filter);
        }).length >= 1) {
          return;
        }
        return preservedConsoleWarn.apply(console, args);
      };
    };
    module.exports = {
      filterConsole
    };
  }
});

// node_modules/core-js-pure/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "node_modules/core-js-pure/modules/es.regexp.exec.js"() {
  }
});

// node_modules/core-js-pure/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "node_modules/core-js-pure/modules/es.string.replace.js"() {
  }
});

// node_modules/core-js-pure/es/symbol/replace.js
var require_replace = __commonJS({
  "node_modules/core-js-pure/es/symbol/replace.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    require_es_symbol_replace();
    require_es_string_replace();
    var WrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    module.exports = WrappedWellKnownSymbolModule.f("replace");
  }
});

// node_modules/core-js-pure/stable/symbol/replace.js
var require_replace2 = __commonJS({
  "node_modules/core-js-pure/stable/symbol/replace.js"(exports, module) {
    "use strict";
    var parent = require_replace();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/symbol/replace.js
var require_replace3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/symbol/replace.js"(exports, module) {
    module.exports = require_replace2();
  }
});

// node_modules/core-js-pure/modules/es.number.is-nan.js
var require_es_number_is_nan = __commonJS({
  "node_modules/core-js-pure/modules/es.number.is-nan.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Number", stat: true }, {
      isNaN: function isNaN2(number) {
        return number !== number;
      }
    });
  }
});

// node_modules/core-js-pure/es/number/is-nan.js
var require_is_nan = __commonJS({
  "node_modules/core-js-pure/es/number/is-nan.js"(exports, module) {
    "use strict";
    require_es_number_is_nan();
    var path = require_path();
    module.exports = path.Number.isNaN;
  }
});

// node_modules/core-js-pure/stable/number/is-nan.js
var require_is_nan2 = __commonJS({
  "node_modules/core-js-pure/stable/number/is-nan.js"(exports, module) {
    "use strict";
    var parent = require_is_nan();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/number/is-nan.js
var require_is_nan3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/number/is-nan.js"(exports, module) {
    module.exports = require_is_nan2();
  }
});

// node_modules/moralis-v1/lib/browser/utils.js
var require_utils = __commonJS({
  "node_modules/moralis-v1/lib/browser/utils.js"(exports, module) {
    "use strict";
    var _typeof = require_typeof();
    var _WeakMap = require_weak_map3();
    var _reduceInstanceProperty = require_reduce4();
    var _Object$keys2 = require_keys3();
    var _Object$create = require_create7();
    var _Symbol$replace = require_replace3();
    var _sliceInstanceProperty = require_slice4();
    var _interopRequireDefault = require_interopRequireDefault();
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _setPrototypeOf2 = _interopRequireDefault(require_setPrototypeOf());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _freeze = _interopRequireDefault(require_freeze3());
    var _map = _interopRequireDefault(require_map10());
    var _entries = _interopRequireDefault(require_entries3());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _keys = _interopRequireDefault(require_keys3());
    var _isNan = _interopRequireDefault(require_is_nan3());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _RESTController = _interopRequireDefault(require_RESTController());
    function _wrapRegExp() {
      _wrapRegExp = function(re, groups) {
        return new BabelRegExp(re, void 0, groups);
      };
      var _super = RegExp.prototype, _groups = new _WeakMap();
      function BabelRegExp(re, flags, groups) {
        var _this = new RegExp(re, flags);
        return _groups.set(_this, groups || _groups.get(re)), (0, _setPrototypeOf2.default)(_this, BabelRegExp.prototype);
      }
      function buildGroups(result, re) {
        var _context10;
        var g2 = _groups.get(re);
        return _reduceInstanceProperty(_context10 = _Object$keys2(g2)).call(_context10, function(groups, name2) {
          return groups[name2] = result[g2[name2]], groups;
        }, _Object$create(null));
      }
      return (0, _inherits2.default)(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function(str) {
        var result = _super.exec.call(this, str);
        return result && (result.groups = buildGroups(result, this)), result;
      }, BabelRegExp.prototype[_Symbol$replace] = function(str, substitution) {
        if ("string" == typeof substitution) {
          var groups = _groups.get(this);
          return _super[_Symbol$replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function(_2, name2) {
            return "$" + groups[name2];
          }));
        }
        if ("function" == typeof substitution) {
          var _this = this;
          return _super[_Symbol$replace].call(this, str, function() {
            var args = arguments;
            return "object" != _typeof(args[args.length - 1]) && (args = _sliceInstanceProperty([]).call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
          });
        }
        return _super[_Symbol$replace].call(this, str, substitution);
      }, _wrapRegExp.apply(this, arguments);
    }
    var DEEP_INDEX_API_HOST = "deep-index.moralis.io";
    var DEEP_INDEX_SWAGGER_PATH = "/api-docs/v2/swagger.json";
    var TrackingEventName = (0, _freeze.default)({
      START_FUNCTION: "Moralis SDK start"
    });
    var fetchSwaggerJson = function() {
      var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
        var _yield$RESTController, response;
        return _regenerator.default.wrap(function(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _RESTController.default.ajax("GET", "https://".concat(DEEP_INDEX_API_HOST).concat(DEEP_INDEX_SWAGGER_PATH));
              case 2:
                _yield$RESTController = _context.sent;
                response = _yield$RESTController.response;
                return _context.abrupt("return", response);
              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function() {
        return _ref.apply(this, arguments);
      };
    }();
    var getPathByTag = function(swaggerJSON) {
      var _context2;
      var pathByTag = {};
      var pathDetails = {};
      (0, _map.default)(_context2 = (0, _entries.default)(swaggerJSON.paths)).call(_context2, function(_ref2) {
        var _context3;
        var _ref3 = (0, _slicedToArray2.default)(_ref2, 2), pathName = _ref3[0], requestData = _ref3[1];
        return (0, _forEach.default)(_context3 = (0, _entries.default)(requestData)).call(_context3, function(_ref4) {
          var _ref5 = (0, _slicedToArray2.default)(_ref4, 2), method = _ref5[0], data = _ref5[1];
          var tags = data.tags;
          if (tags.length > 0) {
            if (!pathByTag[tags[0]]) {
              pathByTag[tags[0]] = [];
            }
            pathByTag[tags[0]].push(data.operationId);
            pathDetails[data.operationId] = {
              method,
              pathName,
              data
            };
          }
        });
      });
      return {
        pathByTag,
        pathDetails
      };
    };
    var fetchEndpoints = function() {
      var _ref6 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var _context4;
        var swaggerJSON, _yield$getPathByTag, pathDetails, data;
        return _regenerator.default.wrap(function(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return fetchSwaggerJson();
              case 2:
                swaggerJSON = _context5.sent;
                _context5.next = 5;
                return getPathByTag(swaggerJSON);
              case 5:
                _yield$getPathByTag = _context5.sent;
                pathDetails = _yield$getPathByTag.pathDetails;
                data = [];
                (0, _forEach.default)(_context4 = (0, _keys.default)(pathDetails)).call(_context4, function(x2) {
                  var item = pathDetails[x2];
                  var endpoint = {
                    method: item.method.toUpperCase(),
                    group: item.data.tags[0],
                    name: x2,
                    url: item.pathName.split("{").join(":").split("}").join("")
                  };
                  data.push(endpoint);
                });
                return _context5.abrupt("return", data);
              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee2);
      }));
      return function() {
        return _ref6.apply(this, arguments);
      };
    }();
    var isSemanticVersionLarger = function(version1, version28) {
      var _context6, _context7;
      var _version1$split = version1.split("-"), _version1$split2 = (0, _slicedToArray2.default)(_version1$split, 2), version1Main = _version1$split2[0], version1Pre = _version1$split2[1];
      var version1Arr = (0, _map.default)(_context6 = version1Main.split(".")).call(_context6, function(s2) {
        return Number(s2);
      });
      var _version2$split = version28.split("-"), _version2$split2 = (0, _slicedToArray2.default)(_version2$split, 2), version2Main = _version2$split2[0], version2Pre = _version2$split2[1];
      var version2Arr = (0, _map.default)(_context7 = version2Main.split(".")).call(_context7, function(s2) {
        return Number(s2);
      });
      for (var index = 0; index < 3; index++) {
        var compare1 = version1Arr[index];
        var compare2 = version2Arr[index];
        if (compare1 > compare2)
          return true;
        if (compare1 < compare2)
          return false;
        if (!(0, _isNan.default)(compare1) && (0, _isNan.default)(compare2))
          return true;
        if ((0, _isNan.default)(compare1) && !(0, _isNan.default)(compare2))
          return false;
      }
      if (version1Pre && version2Pre) {
        var _version1Pre$split$, _version2Pre$split$;
        var version1PreNumber = (_version1Pre$split$ = version1Pre.split(".")[1]) !== null && _version1Pre$split$ !== void 0 ? _version1Pre$split$ : 0;
        var version2PreNumber = (_version2Pre$split$ = version2Pre.split(".")[1]) !== null && _version2Pre$split$ !== void 0 ? _version2Pre$split$ : 0;
        return version1PreNumber > version2PreNumber;
      }
      if (version2Pre) {
        return true;
      }
      return false;
    };
    var checkForSdkUpdates = function() {
      var _ref7 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
        var _yield$RESTController2, response, latestVersion, installedVersion;
        return _regenerator.default.wrap(function(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return _RESTController.default.ajax("GET", "https://www.unpkg.com/moralis-v1/package.json");
              case 3:
                _yield$RESTController2 = _context8.sent;
                response = _yield$RESTController2.response;
                latestVersion = response.version;
                installedVersion = "1.12.0";
                if (isSemanticVersionLarger(latestVersion, installedVersion))
                  console.warn("Moralis: You are not using the latest version of the 'moralis-v1' SDK. Please update it as soon as possible to enjoy the newest features. Most recent version: ".concat(latestVersion));
                _context8.next = 12;
                break;
              case 10:
                _context8.prev = 10;
                _context8.t0 = _context8["catch"](0);
              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee3, null, [[0, 10]]);
      }));
      return function() {
        return _ref7.apply(this, arguments);
      };
    }();
    var trackEvent = function() {
      var _ref8 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(name2, subdomain, options) {
        var _yield$RESTController3, response;
        return _regenerator.default.wrap(function(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return _RESTController.default.ajax("POST", "https://internal-api.moralis.io/api/functions/trackEvent", (0, _stringify.default)({
                  subdomain,
                  event: name2,
                  options
                }), {
                  Accept: "application/json",
                  "Content-Type": "application/json"
                });
              case 3:
                _yield$RESTController3 = _context9.sent;
                response = _yield$RESTController3.response;
                return _context9.abrupt("return", response.result);
              case 8:
                _context9.prev = 8;
                _context9.t0 = _context9["catch"](0);
              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee4, null, [[0, 8]]);
      }));
      return function() {
        return _ref8.apply(this, arguments);
      };
    }();
    var validServerUrlRegex = _wrapRegExp(/^https?:\/\/([0-9A-Z_a-z]+\.[0-9A-Z_a-z]+\.[0-9A-Z_a-z]+)(:[0-9]{4})?\/server\/?$/, {
      subdomain: 1
    });
    var validateServerUrl = function(serverUrl) {
      return validServerUrlRegex.test(serverUrl);
    };
    var getSubdomain = function(serverUrl) {
      var _match$groups$subdoma, _match$groups;
      var isValidServerUrl = validateServerUrl(serverUrl);
      if (!isValidServerUrl) {
        return null;
      }
      var match = validServerUrlRegex.exec(serverUrl);
      return (_match$groups$subdoma = match === null || match === void 0 ? void 0 : (_match$groups = match.groups) === null || _match$groups === void 0 ? void 0 : _match$groups.subdomain) !== null && _match$groups$subdoma !== void 0 ? _match$groups$subdoma : null;
    };
    module.exports = {
      fetchSwaggerJson,
      getPathByTag,
      fetchEndpoints,
      checkForSdkUpdates,
      trackEvent,
      TrackingEventName,
      getSubdomain
    };
  }
});

// node_modules/moralis-v1/lib/browser/Analytics.js
var require_Analytics = __commonJS({
  "node_modules/moralis-v1/lib/browser/Analytics.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.track = track;
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    function track(name2, dimensions) {
      name2 = name2 || "";
      name2 = name2.replace(/^\s*/, "");
      name2 = name2.replace(/\s*$/, "");
      if (name2.length === 0) {
        throw new TypeError("A name for the custom event must be provided");
      }
      for (var _key in dimensions) {
        if (typeof _key !== "string" || typeof dimensions[_key] !== "string") {
          throw new TypeError('track() dimensions expects keys and values of type "string".');
        }
      }
      return _CoreManager.default.getAnalyticsController().track(name2, dimensions);
    }
    var DefaultController = {
      track: function(name2, dimensions) {
        var path = "events/".concat(name2);
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("POST", path, {
          dimensions
        });
      }
    };
    _CoreManager.default.setAnalyticsController(DefaultController);
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/map.js
var require_map11 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/map.js"(exports, module) {
    module.exports = require_map2();
  }
});

// node_modules/core-js-pure/es/array/virtual/entries.js
var require_entries4 = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/entries.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_object_to_string();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "entries");
  }
});

// node_modules/core-js-pure/stable/array/virtual/entries.js
var require_entries5 = __commonJS({
  "node_modules/core-js-pure/stable/array/virtual/entries.js"(exports, module) {
    "use strict";
    var parent = require_entries4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/stable/instance/entries.js
var require_entries6 = __commonJS({
  "node_modules/core-js-pure/stable/instance/entries.js"(exports, module) {
    "use strict";
    require_web_dom_collections_iterator();
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_entries5();
    var ArrayPrototype = Array.prototype;
    var DOMIterables = {
      DOMTokenList: true,
      NodeList: true
    };
    module.exports = function(it) {
      var own = it.entries;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.entries || hasOwn(DOMIterables, classof(it)) ? method : own;
    };
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/entries.js
var require_entries7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/entries.js"(exports, module) {
    module.exports = require_entries6();
  }
});

// node_modules/moralis-v1/lib/browser/ParseCLP.js
var require_ParseCLP = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseCLP.js"(exports) {
    "use strict";
    var _sliceInstanceProperty2 = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray2 = require_is_array4();
    var _Object$keys2 = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _map = _interopRequireDefault(require_map11());
    var _includes = _interopRequireDefault(require_includes5());
    var _every = _interopRequireDefault(require_every4());
    var _entries = _interopRequireDefault(require_entries7());
    var _slice = _interopRequireDefault(require_slice4());
    var _keys = _interopRequireDefault(require_keys3());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _ParseRole = _interopRequireDefault(require_ParseRole());
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys2(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context3, _context4;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty(_context3 = ownKeys5(Object(source), true)).call(_context3, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys5(Object(source))).call(_context4, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray2(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context2;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o2)).call(_context2, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var PUBLIC_KEY = "*";
    var VALID_PERMISSIONS = new _map.default();
    VALID_PERMISSIONS.set("get", {});
    VALID_PERMISSIONS.set("find", {});
    VALID_PERMISSIONS.set("count", {});
    VALID_PERMISSIONS.set("create", {});
    VALID_PERMISSIONS.set("update", {});
    VALID_PERMISSIONS.set("delete", {});
    VALID_PERMISSIONS.set("addField", {});
    var VALID_PERMISSIONS_EXTENDED = new _map.default();
    VALID_PERMISSIONS_EXTENDED.set("protectedFields", {});
    var ParseCLP = function() {
      function ParseCLP2(userId) {
        var _this = this;
        (0, _classCallCheck2.default)(this, ParseCLP2);
        (0, _defineProperty2.default)(this, "permissionsMap", void 0);
        this.permissionsMap = {};
        var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)), _step;
        try {
          var _loop = function() {
            var _step$value = (0, _slicedToArray2.default)(_step.value, 2), operation2 = _step$value[0], group2 = _step$value[1];
            _this.permissionsMap[operation2] = _objectSpread5({}, group2);
            var action = operation2.charAt(0).toUpperCase() + (0, _slice.default)(operation2).call(operation2, 1);
            _this["get".concat(action, "RequiresAuthentication")] = function() {
              return this._getAccess(operation2, "requiresAuthentication");
            };
            _this["set".concat(action, "RequiresAuthentication")] = function(allowed2) {
              this._setAccess(operation2, "requiresAuthentication", allowed2);
            };
            _this["get".concat(action, "PointerFields")] = function() {
              return this._getAccess(operation2, "pointerFields", false);
            };
            _this["set".concat(action, "PointerFields")] = function(pointerFields) {
              this._setArrayAccess(operation2, "pointerFields", pointerFields);
            };
            _this["get".concat(action, "Access")] = function(entity) {
              return this._getAccess(operation2, entity);
            };
            _this["set".concat(action, "Access")] = function(entity, allowed2) {
              this._setAccess(operation2, entity, allowed2);
            };
            _this["getPublic".concat(action, "Access")] = function() {
              return this["get".concat(action, "Access")](PUBLIC_KEY);
            };
            _this["setPublic".concat(action, "Access")] = function(allowed2) {
              this["set".concat(action, "Access")](PUBLIC_KEY, allowed2);
            };
            _this["getRole".concat(action, "Access")] = function(role) {
              return this["get".concat(action, "Access")](this._getRoleName(role));
            };
            _this["setRole".concat(action, "Access")] = function(role, allowed2) {
              this["set".concat(action, "Access")](this._getRoleName(role), allowed2);
            };
          };
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2), operation = _step2$value[0], group = _step2$value[1];
            this.permissionsMap[operation] = _objectSpread5({}, group);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (userId && (0, _typeof2.default)(userId) === "object") {
          if (userId instanceof _ParseUser.default) {
            this.setReadAccess(userId, true);
            this.setWriteAccess(userId, true);
          } else if (userId instanceof _ParseRole.default) {
            this.setRoleReadAccess(userId, true);
            this.setRoleWriteAccess(userId, true);
          } else {
            for (var _permission in userId) {
              var _context;
              var users = userId[_permission];
              var isValidPermission = !!VALID_PERMISSIONS.get(_permission);
              var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);
              var isValidGroupPermission = (0, _includes.default)(_context = ["readUserFields", "writeUserFields"]).call(_context, _permission);
              if (typeof _permission !== "string" || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {
                throw new TypeError("Tried to create an CLP with an invalid permission type.");
              }
              if (isValidGroupPermission) {
                if ((0, _every.default)(users).call(users, function(pointer) {
                  return typeof pointer === "string";
                })) {
                  this.permissionsMap[_permission] = users;
                  continue;
                } else {
                  throw new TypeError("Tried to create an CLP with an invalid permission value.");
                }
              }
              for (var user in users) {
                var allowed = users[user];
                if (typeof allowed !== "boolean" && !isValidPermissionExtended && user !== "pointerFields") {
                  throw new TypeError("Tried to create an CLP with an invalid permission value.");
                }
                this.permissionsMap[_permission][user] = allowed;
              }
            }
          }
        } else if (typeof userId === "function") {
          throw new TypeError("ParseCLP constructed with a function. Did you forget ()?");
        }
      }
      (0, _createClass2.default)(ParseCLP2, [{
        key: "toJSON",
        value: function() {
          return _objectSpread5({}, this.permissionsMap);
        }
        /**
         * Returns whether this CLP is equal to another object
         *
         * @param other The other object to compare to
         * @returns {boolean}
         */
      }, {
        key: "equals",
        value: function(other) {
          if (!(other instanceof ParseCLP2)) {
            return false;
          }
          var permissions = (0, _keys.default)(this.permissionsMap);
          var otherPermissions = (0, _keys.default)(other.permissionsMap);
          if (permissions.length !== otherPermissions.length) {
            return false;
          }
          for (var _permission2 in this.permissionsMap) {
            if (!other.permissionsMap[_permission2]) {
              return false;
            }
            var users = (0, _keys.default)(this.permissionsMap[_permission2]);
            var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);
            if (users.length !== otherUsers.length) {
              return false;
            }
            for (var user in this.permissionsMap[_permission2]) {
              if (!other.permissionsMap[_permission2][user]) {
                return false;
              }
              if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {
                return false;
              }
            }
          }
          return true;
        }
      }, {
        key: "_getRoleName",
        value: function(role) {
          var name2 = role;
          if (role instanceof _ParseRole.default) {
            name2 = role.getName();
          }
          if (typeof name2 !== "string") {
            throw new TypeError("role must be a Parse.Role or a String");
          }
          return "role:".concat(name2);
        }
      }, {
        key: "_parseEntity",
        value: function(entity) {
          var userId = entity;
          if (userId instanceof _ParseUser.default) {
            userId = userId.id;
            if (!userId) {
              throw new Error("Cannot get access for a Parse.User without an id.");
            }
          } else if (userId instanceof _ParseRole.default) {
            userId = this._getRoleName(userId);
          }
          if (typeof userId !== "string") {
            throw new TypeError("userId must be a string.");
          }
          return userId;
        }
      }, {
        key: "_setAccess",
        value: function(permission, userId, allowed) {
          userId = this._parseEntity(userId);
          if (typeof allowed !== "boolean") {
            throw new TypeError("allowed must be either true or false.");
          }
          var permissions = this.permissionsMap[permission][userId];
          if (!permissions) {
            if (!allowed) {
              return;
            }
            this.permissionsMap[permission][userId] = {};
          }
          if (allowed) {
            this.permissionsMap[permission][userId] = true;
          } else {
            delete this.permissionsMap[permission][userId];
          }
        }
      }, {
        key: "_getAccess",
        value: function(permission, userId) {
          var returnBoolean = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          userId = this._parseEntity(userId);
          var permissions = this.permissionsMap[permission][userId];
          if (returnBoolean) {
            if (!permissions) {
              return false;
            }
            return !!this.permissionsMap[permission][userId];
          }
          return permissions;
        }
      }, {
        key: "_setArrayAccess",
        value: function(permission, userId, fields) {
          userId = this._parseEntity(userId);
          var permissions = this.permissionsMap[permission][userId];
          if (!permissions) {
            this.permissionsMap[permission][userId] = [];
          }
          if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {
            delete this.permissionsMap[permission][userId];
          } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function(field) {
            return typeof field === "string";
          })) {
            this.permissionsMap[permission][userId] = fields;
          } else {
            throw new TypeError("fields must be an array of strings or undefined.");
          }
        }
      }, {
        key: "_setGroupPointerPermission",
        value: function(operation, pointerFields) {
          var fields = this.permissionsMap[operation];
          if (!fields) {
            this.permissionsMap[operation] = [];
          }
          if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {
            delete this.permissionsMap[operation];
          } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function(field) {
            return typeof field === "string";
          })) {
            this.permissionsMap[operation] = pointerFields;
          } else {
            throw new TypeError("".concat(operation, ".pointerFields must be an array of strings or undefined."));
          }
        }
      }, {
        key: "_getGroupPointerPermissions",
        value: function(operation) {
          return this.permissionsMap[operation];
        }
        /**
         * Sets user pointer fields to allow permission for get/count/find operations.
         *
         * @param {string[]} pointerFields User pointer fields
         */
      }, {
        key: "setReadUserFields",
        value: function(pointerFields) {
          this._setGroupPointerPermission("readUserFields", pointerFields);
        }
        /**
         * @returns {string[]} User pointer fields
         */
      }, {
        key: "getReadUserFields",
        value: function() {
          return this._getGroupPointerPermissions("readUserFields");
        }
        /**
         * Sets user pointer fields to allow permission for create/delete/update/addField operations
         *
         * @param {string[]} pointerFields User pointer fields
         */
      }, {
        key: "setWriteUserFields",
        value: function(pointerFields) {
          this._setGroupPointerPermission("writeUserFields", pointerFields);
        }
        /**
         * @returns {string[]} User pointer fields
         */
      }, {
        key: "getWriteUserFields",
        value: function() {
          return this._getGroupPointerPermissions("writeUserFields");
        }
        /**
         * Sets whether the given user is allowed to retrieve fields from this class.
         *
         * @param userId An instance of Parse.User or its objectId.
         * @param {string[]} fields fields to be protected
         */
      }, {
        key: "setProtectedFields",
        value: function(userId, fields) {
          this._setArrayAccess("protectedFields", userId, fields);
        }
        /**
         * Returns array of fields are accessable to this user.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role.
         * @returns {string[]}
         */
      }, {
        key: "getProtectedFields",
        value: function(userId) {
          return this._getAccess("protectedFields", userId, false);
        }
        /**
         * Sets whether the given user is allowed to read from this class.
         *
         * @param userId An instance of Parse.User or its objectId.
         * @param {boolean} allowed whether that user should have read access.
         */
      }, {
        key: "setReadAccess",
        value: function(userId, allowed) {
          this._setAccess("find", userId, allowed);
          this._setAccess("get", userId, allowed);
          this._setAccess("count", userId, allowed);
        }
        /**
         * Get whether the given user id is *explicitly* allowed to read from this class.
         * Even if this returns false, the user may still be able to access it if
         * getPublicReadAccess returns true or a role that the user belongs to has
         * write access.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role.
         * @returns {boolean}
         */
      }, {
        key: "getReadAccess",
        value: function(userId) {
          return this._getAccess("find", userId) && this._getAccess("get", userId) && this._getAccess("count", userId);
        }
        /**
         * Sets whether the given user id is allowed to write to this class.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role..
         * @param {boolean} allowed Whether that user should have write access.
         */
      }, {
        key: "setWriteAccess",
        value: function(userId, allowed) {
          this._setAccess("create", userId, allowed);
          this._setAccess("update", userId, allowed);
          this._setAccess("delete", userId, allowed);
          this._setAccess("addField", userId, allowed);
        }
        /**
         * Gets whether the given user id is *explicitly* allowed to write to this class.
         * Even if this returns false, the user may still be able to write it if
         * getPublicWriteAccess returns true or a role that the user belongs to has
         * write access.
         *
         * @param userId An instance of Parse.User or its objectId, or a Parse.Role.
         * @returns {boolean}
         */
      }, {
        key: "getWriteAccess",
        value: function(userId) {
          return this._getAccess("create", userId) && this._getAccess("update", userId) && this._getAccess("delete", userId) && this._getAccess("addField", userId);
        }
        /**
         * Sets whether the public is allowed to read from this class.
         *
         * @param {boolean} allowed
         */
      }, {
        key: "setPublicReadAccess",
        value: function(allowed) {
          this.setReadAccess(PUBLIC_KEY, allowed);
        }
        /**
         * Gets whether the public is allowed to read from this class.
         *
         * @returns {boolean}
         */
      }, {
        key: "getPublicReadAccess",
        value: function() {
          return this.getReadAccess(PUBLIC_KEY);
        }
        /**
         * Sets whether the public is allowed to write to this class.
         *
         * @param {boolean} allowed
         */
      }, {
        key: "setPublicWriteAccess",
        value: function(allowed) {
          this.setWriteAccess(PUBLIC_KEY, allowed);
        }
        /**
         * Gets whether the public is allowed to write to this class.
         *
         * @returns {boolean}
         */
      }, {
        key: "getPublicWriteAccess",
        value: function() {
          return this.getWriteAccess(PUBLIC_KEY);
        }
        /**
         * Sets whether the public is allowed to protect fields in this class.
         *
         * @param {string[]} fields
         */
      }, {
        key: "setPublicProtectedFields",
        value: function(fields) {
          this.setProtectedFields(PUBLIC_KEY, fields);
        }
        /**
         * Gets whether the public is allowed to read fields from this class.
         *
         * @returns {string[]}
         */
      }, {
        key: "getPublicProtectedFields",
        value: function() {
          return this.getProtectedFields(PUBLIC_KEY);
        }
        /**
         * Gets whether users belonging to the given role are allowed
         * to read from this class. Even if this returns false, the role may
         * still be able to write it if a parent role has read access.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @returns {boolean} true if the role has read access. false otherwise.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "getRoleReadAccess",
        value: function(role) {
          return this.getReadAccess(this._getRoleName(role));
        }
        /**
         * Gets whether users belonging to the given role are allowed
         * to write to this user. Even if this returns false, the role may
         * still be able to write it if a parent role has write access.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @returns {boolean} true if the role has write access. false otherwise.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "getRoleWriteAccess",
        value: function(role) {
          return this.getWriteAccess(this._getRoleName(role));
        }
        /**
         * Sets whether users belonging to the given role are allowed
         * to read from this class.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @param {boolean} allowed Whether the given role can read this object.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "setRoleReadAccess",
        value: function(role, allowed) {
          this.setReadAccess(this._getRoleName(role), allowed);
        }
        /**
         * Sets whether users belonging to the given role are allowed
         * to write to this class.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @param {boolean} allowed Whether the given role can write this object.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "setRoleWriteAccess",
        value: function(role, allowed) {
          this.setWriteAccess(this._getRoleName(role), allowed);
        }
        /**
         * Gets whether users belonging to the given role are allowed
         * to count to this user. Even if this returns false, the role may
         * still be able to count it if a parent role has count access.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @returns {string[]}
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "getRoleProtectedFields",
        value: function(role) {
          return this.getProtectedFields(this._getRoleName(role));
        }
        /**
         * Sets whether users belonging to the given role are allowed
         * to set access field in this class.
         *
         * @param role The name of the role, or a Parse.Role object.
         * @param {string[]} fields Fields to be protected by Role.
         * @throws {TypeError} If role is neither a Parse.Role nor a String.
         */
      }, {
        key: "setRoleProtectedFields",
        value: function(role, fields) {
          this.setProtectedFields(this._getRoleName(role), fields);
        }
      }]);
      return ParseCLP2;
    }();
    var _default = ParseCLP;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParseConfig.js
var require_ParseConfig = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseConfig.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _promise = _interopRequireDefault(require_promise3());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _decode2 = _interopRequireDefault(require_decode());
    var _encode3 = _interopRequireDefault(require_encode());
    var _escape2 = _interopRequireDefault(require_escape());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _Storage = _interopRequireDefault(require_Storage());
    var ParseConfig = function() {
      function ParseConfig2() {
        (0, _classCallCheck2.default)(this, ParseConfig2);
        (0, _defineProperty2.default)(this, "attributes", void 0);
        (0, _defineProperty2.default)(this, "_escapedAttributes", void 0);
        this.attributes = {};
        this._escapedAttributes = {};
      }
      (0, _createClass2.default)(ParseConfig2, [{
        key: "get",
        value: function(attr) {
          return this.attributes[attr];
        }
        /**
         * Gets the HTML-escaped value of an attribute.
         *
         * @param {string} attr The name of an attribute.
         * @returns {string}
         */
      }, {
        key: "escape",
        value: function(attr) {
          var html = this._escapedAttributes[attr];
          if (html) {
            return html;
          }
          var val = this.attributes[attr];
          var escaped = "";
          if (val != null) {
            escaped = (0, _escape2.default)(val.toString());
          }
          this._escapedAttributes[attr] = escaped;
          return escaped;
        }
        /**
         * Retrieves the most recently-fetched configuration object, either from
         * memory or from local storage if necessary.
         *
         * @static
         * @returns {Parse.Config} The most recently-fetched Parse.Config if it
         *     exists, else an empty Parse.Config.
         */
      }], [{
        key: "current",
        value: function() {
          var controller = _CoreManager.default.getConfigController();
          return controller.current();
        }
        /**
         * Gets a new configuration object from the server.
         *
         * @static
         * @param {object} options
         * Valid options are:<ul>
         *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to
         *     be used for this request.
         * </ul>
         * @returns {Promise} A promise that is resolved with a newly-created
         *     configuration object when the get completes.
         */
      }, {
        key: "get",
        value: function() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var controller = _CoreManager.default.getConfigController();
          return controller.get(options);
        }
        /**
         * Save value keys to the server.
         *
         * @static
         * @param {object} attrs The config parameters and values.
         * @param {object} masterKeyOnlyFlags The flags that define whether config parameters listed
         * in `attrs` should be retrievable only by using the master key.
         * For example: `param1: true` makes `param1` only retrievable by using the master key.
         * If a parameter is not provided or set to `false`, it can be retrieved without
         * using the master key.
         * @returns {Promise} A promise that is resolved with a newly-created
         *     configuration object or with the current with the update.
         */
      }, {
        key: "save",
        value: function(attrs, masterKeyOnlyFlags) {
          var controller = _CoreManager.default.getConfigController();
          return controller.save(attrs, masterKeyOnlyFlags).then(function() {
            return controller.get({
              useMasterKey: true
            });
          }, function(error) {
            return _promise.default.reject(error);
          });
        }
        /**
         * Used for testing
         *
         * @private
         */
      }, {
        key: "_clearCache",
        value: function() {
          currentConfig = null;
        }
      }]);
      return ParseConfig2;
    }();
    var currentConfig = null;
    var CURRENT_CONFIG_KEY = "currentConfig";
    function decodePayload(data) {
      try {
        var json = JSON.parse(data);
        if (json && (0, _typeof2.default)(json) === "object") {
          return (0, _decode2.default)(json);
        }
      } catch (e) {
        return null;
      }
    }
    var DefaultController = {
      current: function() {
        if (currentConfig) {
          return currentConfig;
        }
        var config = new ParseConfig();
        var storagePath = _Storage.default.generatePath(CURRENT_CONFIG_KEY);
        if (!_Storage.default.async()) {
          var configData = _Storage.default.getItem(storagePath);
          if (configData) {
            var attributes = decodePayload(configData);
            if (attributes) {
              config.attributes = attributes;
              currentConfig = config;
            }
          }
          return config;
        }
        return _Storage.default.getItemAsync(storagePath).then(function(configData2) {
          if (configData2) {
            var _attributes = decodePayload(configData2);
            if (_attributes) {
              config.attributes = _attributes;
              currentConfig = config;
            }
          }
          return config;
        });
      },
      get: function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("GET", "config", {}, options).then(function(response) {
          if (!response || !response.params) {
            var error = new _ParseError.default(_ParseError.default.INVALID_JSON, "Config JSON response invalid.");
            return _promise.default.reject(error);
          }
          var config = new ParseConfig();
          config.attributes = {};
          for (var attr in response.params) {
            config.attributes[attr] = (0, _decode2.default)(response.params[attr]);
          }
          currentConfig = config;
          return _Storage.default.setItemAsync(_Storage.default.generatePath(CURRENT_CONFIG_KEY), (0, _stringify.default)(response.params)).then(function() {
            return config;
          });
        });
      },
      save: function(attrs, masterKeyOnlyFlags) {
        var RESTController = _CoreManager.default.getRESTController();
        var encodedAttrs = {};
        for (var _key in attrs) {
          encodedAttrs[_key] = (0, _encode3.default)(attrs[_key]);
        }
        return RESTController.request("PUT", "config", {
          params: encodedAttrs,
          masterKeyOnly: masterKeyOnlyFlags
        }, {
          useMasterKey: true
        }).then(function(response) {
          if (response && response.result) {
            return _promise.default.resolve();
          }
          var error = new _ParseError.default(_ParseError.default.INTERNAL_SERVER_ERROR, "Error occured updating Config.");
          return _promise.default.reject(error);
        });
      }
    };
    _CoreManager.default.setConfigController(DefaultController);
    var _default = ParseConfig;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/FacebookUtils.js
var require_FacebookUtils = __commonJS({
  "node_modules/moralis-v1/lib/browser/FacebookUtils.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ParseUser = _interopRequireDefault(require_ParseUser());
    var initialized = false;
    var requestedPermissions;
    var initOptions;
    var provider = {
      authenticate: function(options) {
        var _this = this;
        if (typeof FB === "undefined") {
          options.error(this, "Facebook SDK not found.");
        }
        FB.login(function(response) {
          if (response.authResponse) {
            if (options.success) {
              options.success(_this, {
                id: response.authResponse.userID,
                access_token: response.authResponse.accessToken,
                expiration_date: new Date(response.authResponse.expiresIn * 1e3 + (/* @__PURE__ */ new Date()).getTime()).toJSON()
              });
            }
          } else {
            if (options.error) {
              options.error(_this, response);
            }
          }
        }, {
          scope: requestedPermissions
        });
      },
      restoreAuthentication: function(authData) {
        if (authData) {
          var newOptions = {};
          if (initOptions) {
            for (var key2 in initOptions) {
              newOptions[key2] = initOptions[key2];
            }
          }
          newOptions.status = false;
          var existingResponse = FB.getAuthResponse();
          if (existingResponse && existingResponse.userID !== authData.id) {
            FB.logout();
          }
          FB.init(newOptions);
        }
        return true;
      },
      getAuthType: function() {
        return "facebook";
      },
      deauthenticate: function() {
        this.restoreAuthentication(null);
      }
    };
    var FacebookUtils = {
      /**
       * Initializes Parse Facebook integration.  Call this function after you
       * have loaded the Facebook Javascript SDK with the same parameters
       * as you would pass to<code>
       * <a href=
       * "https://developers.facebook.com/docs/reference/javascript/FB.init/">
       * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you
       * with these arguments.
       *
       * @function init
       * @name Parse.FacebookUtils.init
       * @param {object} options Facebook options argument as described here:
       *   <a href=
       *   "https://developers.facebook.com/docs/reference/javascript/FB.init/">
       *   FB.init()</a>. The status flag will be coerced to 'false' because it
       *   interferes with Parse Facebook integration. Call FB.getLoginStatus()
       *   explicitly if this behavior is required by your application.
       */
      init: function(options) {
        if (typeof FB === "undefined") {
          throw new Error("The Facebook JavaScript SDK must be loaded before calling init.");
        }
        initOptions = {};
        if (options) {
          for (var key2 in options) {
            initOptions[key2] = options[key2];
          }
        }
        if (initOptions.status && typeof console !== "undefined") {
          var warn = console.warn || console.log || function() {
          };
          warn.call(console, 'The "status" flag passed into FB.init, when set to true, can interfere with Parse Facebook integration, so it has been suppressed. Please call FB.getLoginStatus() explicitly if you require this behavior.');
        }
        initOptions.status = false;
        FB.init(initOptions);
        _ParseUser.default._registerAuthenticationProvider(provider);
        initialized = true;
      },
      /**
       * Gets whether the user has their account linked to Facebook.
       *
       * @function isLinked
       * @name Parse.FacebookUtils.isLinked
       * @param {Parse.User} user User to check for a facebook link.
       *     The user must be logged in on this device.
       * @returns {boolean} <code>true</code> if the user has their account
       *     linked to Facebook.
       */
      isLinked: function(user) {
        return user._isLinked("facebook");
      },
      /**
       * Logs in a user using Facebook. This method delegates to the Facebook
       * SDK to authenticate the user, and then automatically logs in (or
       * creates, in the case where it is a new user) a Parse.User.
       *
       * Standard API:
       *
       * <code>logIn(permission: string, authData: Object);</code>
       *
       * Advanced API: Used for handling your own oAuth tokens
       * {@link https://docs.parseplatform.org/rest/guide/#linking-users}
       *
       * <code>logIn(authData: Object, options?: Object);</code>
       *
       * @function logIn
       * @name Parse.FacebookUtils.logIn
       * @param {(string | object)} permissions The permissions required for Facebook
       *    log in.  This is a comma-separated string of permissions.
       *    Alternatively, supply a Facebook authData object as described in our
       *    REST API docs if you want to handle getting facebook auth tokens
       *    yourself.
       * @param {object} options MasterKey / SessionToken. Alternatively can be used for authData if permissions is a string
       * @returns {Promise}
       */
      logIn: function(permissions, options) {
        if (!permissions || typeof permissions === "string") {
          if (!initialized) {
            throw new Error("You must initialize FacebookUtils before calling logIn.");
          }
          requestedPermissions = permissions;
          return _ParseUser.default.logInWith("facebook", options);
        }
        return _ParseUser.default.logInWith("facebook", {
          authData: permissions
        }, options);
      },
      /**
       * Links Facebook to an existing PFUser. This method delegates to the
       * Facebook SDK to authenticate the user, and then automatically links
       * the account to the Parse.User.
       *
       * Standard API:
       *
       * <code>link(user: Parse.User, permission: string, authData?: Object);</code>
       *
       * Advanced API: Used for handling your own oAuth tokens
       * {@link https://docs.parseplatform.org/rest/guide/#linking-users}
       *
       * <code>link(user: Parse.User, authData: Object, options?: FullOptions);</code>
       *
       * @function link
       * @name Parse.FacebookUtils.link
       * @param {Parse.User} user User to link to Facebook. This must be the
       *     current user.
       * @param {(string | object)} permissions The permissions required for Facebook
       *    log in.  This is a comma-separated string of permissions.
       *    Alternatively, supply a Facebook authData object as described in our
       *    REST API docs if you want to handle getting facebook auth tokens
       *    yourself.
       * @param {object} options MasterKey / SessionToken. Alternatively can be used for authData if permissions is a string
       * @returns {Promise}
       */
      link: function(user, permissions, options) {
        if (!permissions || typeof permissions === "string") {
          if (!initialized) {
            throw new Error("You must initialize FacebookUtils before calling link.");
          }
          requestedPermissions = permissions;
          return user.linkWith("facebook", options);
        }
        return user.linkWith("facebook", {
          authData: permissions
        }, options);
      },
      /**
       * Unlinks the Parse.User from a Facebook account.
       *
       * @function unlink
       * @name Parse.FacebookUtils.unlink
       * @param {Parse.User} user User to unlink from Facebook. This must be the
       *     current user.
       * @param {object} options Standard options object with success and error
       *    callbacks.
       * @returns {Promise}
       */
      unlink: function(user, options) {
        if (!initialized) {
          throw new Error("You must initialize FacebookUtils before calling unlink.");
        }
        return user._unlinkFrom("facebook", options);
      },
      // Used for testing purposes
      _getAuthProvider: function() {
        return provider;
      }
    };
    var _default = FacebookUtils;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParseInstallation.js
var require_ParseInstallation = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseInstallation.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _ParseObject2 = _interopRequireDefault(require_ParseObject());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Installation = function(_ParseObject) {
      (0, _inherits2.default)(Installation2, _ParseObject);
      var _super = _createSuper(Installation2);
      function Installation2(attributes) {
        var _this;
        (0, _classCallCheck2.default)(this, Installation2);
        _this = _super.call(this, "_Installation");
        if (attributes && (0, _typeof2.default)(attributes) === "object") {
          if (!_this.set(attributes || {})) {
            throw new Error("Can't create an invalid Installation");
          }
        }
        return _this;
      }
      return (0, _createClass2.default)(Installation2);
    }(_ParseObject2.default);
    exports.default = Installation;
    _ParseObject2.default.registerSubclass("_Installation", Installation);
  }
});

// node_modules/core-js-pure/modules/es.set.constructor.js
var require_es_set_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.set.constructor.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Set", function(init2) {
      return function Set2() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js-pure/modules/es.set.js
var require_es_set = __commonJS({
  "node_modules/core-js-pure/modules/es.set.js"() {
    "use strict";
    require_es_set_constructor();
  }
});

// node_modules/core-js-pure/es/set/index.js
var require_set = __commonJS({
  "node_modules/core-js-pure/es/set/index.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_object_to_string();
    require_es_set();
    require_es_string_iterator();
    var path = require_path();
    module.exports = path.Set;
  }
});

// node_modules/core-js-pure/stable/set/index.js
var require_set2 = __commonJS({
  "node_modules/core-js-pure/stable/set/index.js"(exports, module) {
    "use strict";
    var parent = require_set();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/set.js
var require_set3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/set.js"(exports, module) {
    module.exports = require_set2();
  }
});

// node_modules/moralis-v1/lib/browser/LocalDatastoreController.js
var require_LocalDatastoreController = __commonJS({
  "node_modules/moralis-v1/lib/browser/LocalDatastoreController.js"(exports, module) {
    "use strict";
    var _sliceInstanceProperty = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray = require_is_array4();
    var _interopRequireDefault = require_interopRequireDefault();
    var _stringify = _interopRequireDefault(require_stringify3());
    var _reduce = _interopRequireDefault(require_reduce4());
    var _promise = _interopRequireDefault(require_promise3());
    var _map = _interopRequireDefault(require_map10());
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _LocalDatastoreUtils = require_LocalDatastoreUtils();
    var _Storage = _interopRequireDefault(require_Storage());
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context7;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty(_context7 = Object.prototype.toString.call(o2)).call(_context7, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var LocalDatastoreController = {
      fromPinWithName: function(name2) {
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
          var values, objects;
          return _regenerator.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _Storage.default.getItemAsync(name2);
                case 2:
                  values = _context.sent;
                  if (values) {
                    _context.next = 5;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 5:
                  objects = JSON.parse(values);
                  return _context.abrupt("return", objects);
                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      pinWithName: function(name2, value) {
        var values = (0, _stringify.default)(value);
        return _Storage.default.setItemAsync(name2, values);
      },
      unPinWithName: function(name2) {
        return _Storage.default.removeItemAsync(name2);
      },
      getAllContents: function() {
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
          var keys;
          return _regenerator.default.wrap(function(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _Storage.default.getAllKeysAsync();
                case 2:
                  keys = _context3.sent;
                  return _context3.abrupt("return", (0, _reduce.default)(keys).call(keys, function() {
                    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(previousPromise, key2) {
                      var LDS, value;
                      return _regenerator.default.wrap(function(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return previousPromise;
                            case 2:
                              LDS = _context2.sent;
                              if (!(0, _LocalDatastoreUtils.isLocalDatastoreKey)(key2)) {
                                _context2.next = 8;
                                break;
                              }
                              _context2.next = 6;
                              return _Storage.default.getItemAsync(key2);
                            case 6:
                              value = _context2.sent;
                              try {
                                LDS[key2] = JSON.parse(value);
                              } catch (error) {
                                console.error("Error getAllContents: ", error);
                              }
                            case 8:
                              return _context2.abrupt("return", LDS);
                            case 9:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }));
                    return function() {
                      return _ref.apply(this, arguments);
                    };
                  }(), _promise.default.resolve({})));
                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },
      // Used for testing
      getRawStorage: function() {
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5() {
          var keys;
          return _regenerator.default.wrap(function(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _Storage.default.getAllKeysAsync();
                case 2:
                  keys = _context5.sent;
                  return _context5.abrupt("return", (0, _reduce.default)(keys).call(keys, function() {
                    var _ref2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(previousPromise, key2) {
                      var LDS, value;
                      return _regenerator.default.wrap(function(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.next = 2;
                              return previousPromise;
                            case 2:
                              LDS = _context4.sent;
                              _context4.next = 5;
                              return _Storage.default.getItemAsync(key2);
                            case 5:
                              value = _context4.sent;
                              LDS[key2] = value;
                              return _context4.abrupt("return", LDS);
                            case 8:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));
                    return function() {
                      return _ref2.apply(this, arguments);
                    };
                  }(), _promise.default.resolve({})));
                case 4:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },
      clear: function() {
        var _this = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6() {
          var keys, toRemove, _iterator, _step, key2, promises;
          return _regenerator.default.wrap(function(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _Storage.default.getAllKeysAsync();
                case 2:
                  keys = _context6.sent;
                  toRemove = [];
                  _iterator = _createForOfIteratorHelper(keys);
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      key2 = _step.value;
                      if ((0, _LocalDatastoreUtils.isLocalDatastoreKey)(key2)) {
                        toRemove.push(key2);
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  promises = (0, _map.default)(toRemove).call(toRemove, _this.unPinWithName);
                  return _context6.abrupt("return", _promise.default.all(promises));
                case 8:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }))();
      }
    };
    module.exports = LocalDatastoreController;
  }
});

// node_modules/moralis-v1/lib/browser/LocalDatastore.js
var require_LocalDatastore = __commonJS({
  "node_modules/moralis-v1/lib/browser/LocalDatastore.js"(exports, module) {
    "use strict";
    var _sliceInstanceProperty = require_slice4();
    var _Array$from2 = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray2 = require_is_array4();
    var _interopRequireDefault = require_interopRequireDefault();
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _promise = _interopRequireDefault(require_promise3());
    var _set = _interopRequireDefault(require_set3());
    var _concat = _interopRequireDefault(require_concat4());
    var _filter = _interopRequireDefault(require_filter4());
    var _includes = _interopRequireDefault(require_includes5());
    var _keys2 = _interopRequireDefault(require_keys3());
    var _startsWith = _interopRequireDefault(require_starts_with4());
    var _keys3 = _interopRequireDefault(require_keys7());
    var _isArray = _interopRequireDefault(require_is_array4());
    var _map = _interopRequireDefault(require_map10());
    var _from = _interopRequireDefault(require_from3());
    var _find = _interopRequireDefault(require_find4());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    var _LocalDatastoreUtils = require_LocalDatastoreUtils();
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray2(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context16;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty(_context16 = Object.prototype.toString.call(o2)).call(_context16, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from2(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var LocalDatastore = {
      isEnabled: false,
      isSyncing: false,
      fromPinWithName: function(name2) {
        var controller = _CoreManager.default.getLocalDatastoreController();
        return controller.fromPinWithName(name2);
      },
      pinWithName: function(name2, value) {
        var controller = _CoreManager.default.getLocalDatastoreController();
        return controller.pinWithName(name2, value);
      },
      unPinWithName: function(name2) {
        var controller = _CoreManager.default.getLocalDatastoreController();
        return controller.unPinWithName(name2);
      },
      _getAllContents: function() {
        var controller = _CoreManager.default.getLocalDatastoreController();
        return controller.getAllContents();
      },
      // Use for testing
      _getRawStorage: function() {
        var controller = _CoreManager.default.getLocalDatastoreController();
        return controller.getRawStorage();
      },
      _clear: function() {
        var controller = _CoreManager.default.getLocalDatastoreController();
        return controller.clear();
      },
      // Pin the object and children recursively
      // Saves the object and children key to Pin Name
      _handlePinAllWithName: function(name2, objects) {
        var _this = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
          var _context;
          var pinName, toPinPromises, objectKeys, _iterator, _step, parent, children, parentKey, json, objectKey, fromPinPromise, _yield$Promise$all, _yield$Promise$all2, pinned, toPin;
          return _regenerator.default.wrap(function(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  pinName = _this.getPinName(name2);
                  toPinPromises = [];
                  objectKeys = [];
                  _iterator = _createForOfIteratorHelper(objects);
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      parent = _step.value;
                      children = _this._getChildren(parent);
                      parentKey = _this.getKeyForObject(parent);
                      json = parent._toFullJSON(void 0, true);
                      if (parent._localId) {
                        json._localId = parent._localId;
                      }
                      children[parentKey] = json;
                      for (objectKey in children) {
                        objectKeys.push(objectKey);
                        toPinPromises.push(_this.pinWithName(objectKey, [children[objectKey]]));
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  fromPinPromise = _this.fromPinWithName(pinName);
                  _context2.next = 8;
                  return _promise.default.all([fromPinPromise, toPinPromises]);
                case 8:
                  _yield$Promise$all = _context2.sent;
                  _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 1);
                  pinned = _yield$Promise$all2[0];
                  toPin = (0, _toConsumableArray2.default)(new _set.default((0, _concat.default)(_context = []).call(_context, (0, _toConsumableArray2.default)(pinned || []), objectKeys)));
                  return _context2.abrupt("return", _this.pinWithName(pinName, toPin));
                case 13:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee);
        }))();
      },
      // Removes object and children keys from pin name
      // Keeps the object and children pinned
      _handleUnPinAllWithName: function(name2, objects) {
        var _this2 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
          var localDatastore, pinName, promises, objectKeys, _iterator2, _step2, _objectKeys, _context3, parent, children, parentKey, pinned, _iterator3, _step3, objectKey, hasReference, key2, pinnedObjects;
          return _regenerator.default.wrap(function(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return _this2._getAllContents();
                case 2:
                  localDatastore = _context4.sent;
                  pinName = _this2.getPinName(name2);
                  promises = [];
                  objectKeys = [];
                  _iterator2 = _createForOfIteratorHelper(objects);
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      parent = _step2.value;
                      children = _this2._getChildren(parent);
                      parentKey = _this2.getKeyForObject(parent);
                      (_objectKeys = objectKeys).push.apply(_objectKeys, (0, _concat.default)(_context3 = [parentKey]).call(_context3, (0, _toConsumableArray2.default)((0, _keys2.default)(children))));
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                  objectKeys = (0, _toConsumableArray2.default)(new _set.default(objectKeys));
                  pinned = localDatastore[pinName] || [];
                  pinned = (0, _filter.default)(pinned).call(pinned, function(item) {
                    return !(0, _includes.default)(objectKeys).call(objectKeys, item);
                  });
                  if (pinned.length === 0) {
                    promises.push(_this2.unPinWithName(pinName));
                    delete localDatastore[pinName];
                  } else {
                    promises.push(_this2.pinWithName(pinName, pinned));
                    localDatastore[pinName] = pinned;
                  }
                  _iterator3 = _createForOfIteratorHelper(objectKeys);
                  _context4.prev = 13;
                  _iterator3.s();
                case 15:
                  if ((_step3 = _iterator3.n()).done) {
                    _context4.next = 31;
                    break;
                  }
                  objectKey = _step3.value;
                  hasReference = false;
                  _context4.t0 = (0, _keys3.default)(_regenerator.default).call(_regenerator.default, localDatastore);
                case 19:
                  if ((_context4.t1 = _context4.t0()).done) {
                    _context4.next = 28;
                    break;
                  }
                  key2 = _context4.t1.value;
                  if (!(key2 === _LocalDatastoreUtils.DEFAULT_PIN || (0, _startsWith.default)(key2).call(key2, _LocalDatastoreUtils.PIN_PREFIX))) {
                    _context4.next = 26;
                    break;
                  }
                  pinnedObjects = localDatastore[key2] || [];
                  if (!(0, _includes.default)(pinnedObjects).call(pinnedObjects, objectKey)) {
                    _context4.next = 26;
                    break;
                  }
                  hasReference = true;
                  return _context4.abrupt("break", 28);
                case 26:
                  _context4.next = 19;
                  break;
                case 28:
                  if (!hasReference) {
                    promises.push(_this2.unPinWithName(objectKey));
                  }
                case 29:
                  _context4.next = 15;
                  break;
                case 31:
                  _context4.next = 36;
                  break;
                case 33:
                  _context4.prev = 33;
                  _context4.t2 = _context4["catch"](13);
                  _iterator3.e(_context4.t2);
                case 36:
                  _context4.prev = 36;
                  _iterator3.f();
                  return _context4.finish(36);
                case 39:
                  return _context4.abrupt("return", _promise.default.all(promises));
                case 40:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee2, null, [[13, 33, 36, 39]]);
        }))();
      },
      // Retrieve all pointer fields from object recursively
      _getChildren: function(object) {
        var encountered = {};
        var json = object._toFullJSON(void 0, true);
        for (var key2 in json) {
          if (json[key2] && json[key2].__type && json[key2].__type === "Object") {
            this._traverse(json[key2], encountered);
          }
        }
        return encountered;
      },
      _traverse: function(object, encountered) {
        if (!object.objectId) {
          return;
        }
        var objectKey = this.getKeyForObject(object);
        if (encountered[objectKey]) {
          return;
        }
        encountered[objectKey] = object;
        for (var key2 in object) {
          var json = object[key2];
          if (!object[key2]) {
            json = object;
          }
          if (json.__type && json.__type === "Object") {
            this._traverse(json, encountered);
          }
        }
      },
      // Transform keys in pin name to objects
      _serializeObjectsFromPinName: function(name2) {
        var _this3 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
          var _ref;
          var localDatastore, allObjects, key2, pinName, pinned, promises, objects;
          return _regenerator.default.wrap(function(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this3._getAllContents();
                case 2:
                  localDatastore = _context5.sent;
                  allObjects = [];
                  for (key2 in localDatastore) {
                    if ((0, _startsWith.default)(key2).call(key2, _LocalDatastoreUtils.OBJECT_PREFIX)) {
                      allObjects.push(localDatastore[key2][0]);
                    }
                  }
                  if (name2) {
                    _context5.next = 7;
                    break;
                  }
                  return _context5.abrupt("return", allObjects);
                case 7:
                  pinName = _this3.getPinName(name2);
                  pinned = localDatastore[pinName];
                  if ((0, _isArray.default)(pinned)) {
                    _context5.next = 11;
                    break;
                  }
                  return _context5.abrupt("return", []);
                case 11:
                  promises = (0, _map.default)(pinned).call(pinned, function(objectKey) {
                    return _this3.fromPinWithName(objectKey);
                  });
                  _context5.next = 14;
                  return _promise.default.all(promises);
                case 14:
                  objects = _context5.sent;
                  objects = (0, _concat.default)(_ref = []).apply(_ref, (0, _toConsumableArray2.default)(objects));
                  return _context5.abrupt("return", (0, _filter.default)(objects).call(objects, function(object) {
                    return object != null;
                  }));
                case 17:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee3);
        }))();
      },
      // Replaces object pointers with pinned pointers
      // The object pointers may contain old data
      // Uses Breadth First Search Algorithm
      _serializeObject: function(objectKey, localDatastore) {
        var _this4 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {
          var LDS, root, queue, meta, uniqueId, nodeId, subTreeRoot, field, value, key2, pointer;
          return _regenerator.default.wrap(function(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  LDS = localDatastore;
                  if (LDS) {
                    _context6.next = 5;
                    break;
                  }
                  _context6.next = 4;
                  return _this4._getAllContents();
                case 4:
                  LDS = _context6.sent;
                case 5:
                  if (!(!LDS[objectKey] || LDS[objectKey].length === 0)) {
                    _context6.next = 7;
                    break;
                  }
                  return _context6.abrupt("return", null);
                case 7:
                  root = LDS[objectKey][0];
                  queue = [];
                  meta = {};
                  uniqueId = 0;
                  meta[uniqueId] = root;
                  queue.push(uniqueId);
                  while (queue.length !== 0) {
                    nodeId = queue.shift();
                    subTreeRoot = meta[nodeId];
                    for (field in subTreeRoot) {
                      value = subTreeRoot[field];
                      if (value.__type && value.__type === "Object") {
                        key2 = _this4.getKeyForObject(value);
                        if (LDS[key2] && LDS[key2].length > 0) {
                          pointer = LDS[key2][0];
                          uniqueId++;
                          meta[uniqueId] = pointer;
                          subTreeRoot[field] = pointer;
                          queue.push(uniqueId);
                        }
                      }
                    }
                  }
                  return _context6.abrupt("return", root);
                case 15:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee4);
        }))();
      },
      // Called when an object is save / fetched
      // Update object pin value
      _updateObjectIfPinned: function(object) {
        var _this5 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5() {
          var objectKey, pinned;
          return _regenerator.default.wrap(function(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  if (_this5.isEnabled) {
                    _context7.next = 2;
                    break;
                  }
                  return _context7.abrupt("return");
                case 2:
                  objectKey = _this5.getKeyForObject(object);
                  _context7.next = 5;
                  return _this5.fromPinWithName(objectKey);
                case 5:
                  pinned = _context7.sent;
                  if (!(!pinned || pinned.length === 0)) {
                    _context7.next = 8;
                    break;
                  }
                  return _context7.abrupt("return");
                case 8:
                  return _context7.abrupt("return", _this5.pinWithName(objectKey, [object._toFullJSON()]));
                case 9:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee5);
        }))();
      },
      // Called when object is destroyed
      // Unpin object and remove all references from pin names
      // TODO: Destroy children?
      _destroyObjectIfPinned: function(object) {
        var _this6 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6() {
          var localDatastore, objectKey, pin, promises, key2, pinned;
          return _regenerator.default.wrap(function(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  if (_this6.isEnabled) {
                    _context8.next = 2;
                    break;
                  }
                  return _context8.abrupt("return");
                case 2:
                  _context8.next = 4;
                  return _this6._getAllContents();
                case 4:
                  localDatastore = _context8.sent;
                  objectKey = _this6.getKeyForObject(object);
                  pin = localDatastore[objectKey];
                  if (pin) {
                    _context8.next = 9;
                    break;
                  }
                  return _context8.abrupt("return");
                case 9:
                  promises = [_this6.unPinWithName(objectKey)];
                  delete localDatastore[objectKey];
                  for (key2 in localDatastore) {
                    if (key2 === _LocalDatastoreUtils.DEFAULT_PIN || (0, _startsWith.default)(key2).call(key2, _LocalDatastoreUtils.PIN_PREFIX)) {
                      pinned = localDatastore[key2] || [];
                      if ((0, _includes.default)(pinned).call(pinned, objectKey)) {
                        pinned = (0, _filter.default)(pinned).call(pinned, function(item) {
                          return item !== objectKey;
                        });
                        if (pinned.length === 0) {
                          promises.push(_this6.unPinWithName(key2));
                          delete localDatastore[key2];
                        } else {
                          promises.push(_this6.pinWithName(key2, pinned));
                          localDatastore[key2] = pinned;
                        }
                      }
                    }
                  }
                  return _context8.abrupt("return", _promise.default.all(promises));
                case 13:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee6);
        }))();
      },
      // Update pin and references of the unsaved object
      _updateLocalIdForObject: function(localId, object) {
        var _this7 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7() {
          var _context9, _context10;
          var localKey, objectKey, unsaved, promises, localDatastore, key2, pinned;
          return _regenerator.default.wrap(function(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  if (_this7.isEnabled) {
                    _context11.next = 2;
                    break;
                  }
                  return _context11.abrupt("return");
                case 2:
                  localKey = (0, _concat.default)(_context9 = (0, _concat.default)(_context10 = "".concat(_LocalDatastoreUtils.OBJECT_PREFIX)).call(_context10, object.className, "_")).call(_context9, localId);
                  objectKey = _this7.getKeyForObject(object);
                  _context11.next = 6;
                  return _this7.fromPinWithName(localKey);
                case 6:
                  unsaved = _context11.sent;
                  if (!(!unsaved || unsaved.length === 0)) {
                    _context11.next = 9;
                    break;
                  }
                  return _context11.abrupt("return");
                case 9:
                  promises = [_this7.unPinWithName(localKey), _this7.pinWithName(objectKey, unsaved)];
                  _context11.next = 12;
                  return _this7._getAllContents();
                case 12:
                  localDatastore = _context11.sent;
                  for (key2 in localDatastore) {
                    if (key2 === _LocalDatastoreUtils.DEFAULT_PIN || (0, _startsWith.default)(key2).call(key2, _LocalDatastoreUtils.PIN_PREFIX)) {
                      pinned = localDatastore[key2] || [];
                      if ((0, _includes.default)(pinned).call(pinned, localKey)) {
                        pinned = (0, _filter.default)(pinned).call(pinned, function(item) {
                          return item !== localKey;
                        });
                        pinned.push(objectKey);
                        promises.push(_this7.pinWithName(key2, pinned));
                        localDatastore[key2] = pinned;
                      }
                    }
                  }
                  return _context11.abrupt("return", _promise.default.all(promises));
                case 15:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee7);
        }))();
      },
      /**
       * Updates Local Datastore from Server
       *
       * <pre>
       * await Parse.LocalDatastore.updateFromServer();
       * </pre>
       *
       * @function updateFromServer
       * @name Parse.LocalDatastore.updateFromServer
       * @static
       */
      updateFromServer: function() {
        var _this8 = this;
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee8() {
          var _context12;
          var localDatastore, keys, key2, pointersHash, _i, _keys, _key, _key$split, _key$split2, className, objectId, queryPromises, responses, objects, pinPromises;
          return _regenerator.default.wrap(function(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  if (!(!_this8.checkIfEnabled() || _this8.isSyncing)) {
                    _context13.next = 2;
                    break;
                  }
                  return _context13.abrupt("return");
                case 2:
                  _context13.next = 4;
                  return _this8._getAllContents();
                case 4:
                  localDatastore = _context13.sent;
                  keys = [];
                  for (key2 in localDatastore) {
                    if ((0, _startsWith.default)(key2).call(key2, _LocalDatastoreUtils.OBJECT_PREFIX)) {
                      keys.push(key2);
                    }
                  }
                  if (!(keys.length === 0)) {
                    _context13.next = 9;
                    break;
                  }
                  return _context13.abrupt("return");
                case 9:
                  _this8.isSyncing = true;
                  pointersHash = {};
                  _i = 0, _keys = keys;
                case 12:
                  if (!(_i < _keys.length)) {
                    _context13.next = 23;
                    break;
                  }
                  _key = _keys[_i];
                  _key$split = _key.split("_"), _key$split2 = (0, _slicedToArray2.default)(_key$split, 4), className = _key$split2[2], objectId = _key$split2[3];
                  if (_key.split("_").length === 5 && _key.split("_")[3] === "User") {
                    className = "_User";
                    objectId = _key.split("_")[4];
                  }
                  if (!(0, _startsWith.default)(objectId).call(objectId, "local")) {
                    _context13.next = 18;
                    break;
                  }
                  return _context13.abrupt("continue", 20);
                case 18:
                  if (!(className in pointersHash)) {
                    pointersHash[className] = new _set.default();
                  }
                  pointersHash[className].add(objectId);
                case 20:
                  _i++;
                  _context13.next = 12;
                  break;
                case 23:
                  queryPromises = (0, _map.default)(_context12 = (0, _keys2.default)(pointersHash)).call(_context12, function(className2) {
                    var objectIds = (0, _from.default)(pointersHash[className2]);
                    var query = new _ParseQuery.default(className2);
                    query.limit(objectIds.length);
                    if (objectIds.length === 1) {
                      query.equalTo("objectId", objectIds[0]);
                    } else {
                      query.containedIn("objectId", objectIds);
                    }
                    return (0, _find.default)(query).call(query);
                  });
                  _context13.prev = 24;
                  _context13.next = 27;
                  return _promise.default.all(queryPromises);
                case 27:
                  responses = _context13.sent;
                  objects = (0, _concat.default)([]).apply([], responses);
                  pinPromises = (0, _map.default)(objects).call(objects, function(object) {
                    var objectKey = _this8.getKeyForObject(object);
                    return _this8.pinWithName(objectKey, object._toFullJSON());
                  });
                  _context13.next = 32;
                  return _promise.default.all(pinPromises);
                case 32:
                  _this8.isSyncing = false;
                  _context13.next = 39;
                  break;
                case 35:
                  _context13.prev = 35;
                  _context13.t0 = _context13["catch"](24);
                  console.error("Error syncing LocalDatastore: ", _context13.t0);
                  _this8.isSyncing = false;
                case 39:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee8, null, [[24, 35]]);
        }))();
      },
      getKeyForObject: function(object) {
        var _context14, _context15;
        var objectId = object.objectId || object._getId();
        return (0, _concat.default)(_context14 = (0, _concat.default)(_context15 = "".concat(_LocalDatastoreUtils.OBJECT_PREFIX)).call(_context15, object.className, "_")).call(_context14, objectId);
      },
      getPinName: function(pinName) {
        if (!pinName || pinName === _LocalDatastoreUtils.DEFAULT_PIN) {
          return _LocalDatastoreUtils.DEFAULT_PIN;
        }
        return _LocalDatastoreUtils.PIN_PREFIX + pinName;
      },
      checkIfEnabled: function() {
        if (!this.isEnabled) {
          console.error("Parse.enableLocalDatastore() must be called first");
        }
        return this.isEnabled;
      }
    };
    module.exports = LocalDatastore;
    _CoreManager.default.setLocalDatastoreController(require_LocalDatastoreController());
    _CoreManager.default.setLocalDatastore(LocalDatastore);
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/bind.js
var require_bind9 = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn2, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn2.apply(thisArg, args);
      };
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind9();
    var toString2 = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString2.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString2.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString2.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString2.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString2.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString2.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString2.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn2) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn2.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) {
            fn2.call(null, obj[key2], key2, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key2) {
        if (isPlainObject(result[key2]) && isPlainObject(val)) {
          result[key2] = merge(result[key2], val);
        } else if (isPlainObject(val)) {
          result[key2] = merge({}, val);
        } else if (isArray(val)) {
          result[key2] = val.slice();
        } else {
          result[key2] = val;
        }
      }
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        forEach(arguments[i2], assignValue);
      }
      return result;
    }
    function extend(a2, b2, thisArg) {
      forEach(b2, function assignValue(val, key2) {
        if (thisArg && typeof val === "function") {
          a2[key2] = bind(val, thisArg);
        } else {
          a2[key2] = val;
        }
      });
      return a2;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function encode4(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize3(val, key2) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key2 = key2 + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v2) {
            if (utils.isDate(v2)) {
              v2 = v2.toISOString();
            } else if (utils.isObject(v2)) {
              v2 = JSON.stringify(v2);
            }
            parts.push(encode4(key2) + "=" + encode4(v2));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn2) {
      utils.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn2(h2);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name2) {
        if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name2];
        }
      });
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name2, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name2 + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name2) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name2) {
            this.write(name2, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key2;
      var val;
      var i2;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i2 = line.indexOf(":");
        key2 = utils.trim(line.substr(0, i2)).toLowerCase();
        val = utils.trim(line.substr(i2 + 1));
        if (key2) {
          if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
            return;
          }
          if (key2 === "set-cookie") {
            parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
          } else {
            parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString2() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var transitionalDefaults = require_transitional();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key2) {
            if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
              delete requestHeaders[key2];
            } else {
              request.setRequestHeader(key2, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn2) {
        data = fn2.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.26.1"
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version28, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version28 ? " in " + version28 : "")));
        }
        if (version28 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version28 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i2 = keys.length;
      while (i2-- > 0) {
        var opt = keys[i2];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i2;
        var l2 = token._listeners.length;
        for (i2 = 0; i2 < l2; i2++) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/moralis-v1/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var bind = require_bind9();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/moralis-v1/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/moralis-v1/node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/moralis-v1/lib/browser/MoralisWeb3Api.js
var require_MoralisWeb3Api = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisWeb3Api.js"(exports) {
    "use strict";
    var _Object$keys2 = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty2 = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty2 = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _keys = _interopRequireDefault(require_keys3());
    var _filter = _interopRequireDefault(require_filter4());
    var _includes = _interopRequireDefault(require_includes5());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _every = _interopRequireDefault(require_every4());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys2(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty2(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context61, _context62;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty2(_context61 = ownKeys5(Object(source), true)).call(_context61, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty2(_context62 = ownKeys5(Object(source))).call(_context62, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    var axios = require_axios2();
    var Web3Api = function() {
      function Web3Api2() {
        (0, _classCallCheck2.default)(this, Web3Api2);
      }
      (0, _createClass2.default)(Web3Api2, null, [{
        key: "initialize",
        value: function(_ref) {
          var apiKey = _ref.apiKey, serverUrl = _ref.serverUrl, _ref$Moralis = _ref.Moralis, Moralis = _ref$Moralis === void 0 ? null : _ref$Moralis, _ref$headers = _ref.headers, headers = _ref$headers === void 0 ? {} : _ref$headers;
          if (!serverUrl && !apiKey) {
            throw new Error("Web3Api.initialize failed: initialize with apiKey or serverUrl");
          }
          if (apiKey)
            this.apiKey = apiKey;
          if (serverUrl)
            this.serverUrl = serverUrl;
          this.Moralis = Moralis;
          this.headers = headers;
        }
      }, {
        key: "getBody",
        value: function(params, bodyParams) {
          var _this = this;
          if (!params || !bodyParams || !bodyParams.length) {
            return void 0;
          }
          var body = {};
          (0, _forEach.default)(bodyParams).call(bodyParams, function(_ref2) {
            var key2 = _ref2.key, type = _ref2.type, required = _ref2.required;
            if (params[key2] === void 0) {
              if (required)
                throw new Error("param ".concat(key2, " is required!"));
            } else if (type === _this.BodyParamTypes.setBody) {
              body = params[key2];
            } else {
              body[key2] = params[key2];
            }
            delete params[key2];
          });
          return body;
        }
      }, {
        key: "getParameterizedUrl",
        value: function(url, params) {
          var _context;
          if (!(0, _keys.default)(params).length)
            return url;
          var requiredParams = (0, _filter.default)(_context = url.split("/")).call(_context, function(s2) {
            return s2 && (0, _includes.default)(s2).call(s2, ":");
          });
          if (!requiredParams.length)
            return url;
          var parameterizedUrl = url;
          (0, _forEach.default)(requiredParams).call(requiredParams, function(p2) {
            var key2 = p2.substr(1);
            var value = params[key2];
            if (!value) {
              throw new Error("required param ".concat(key2, " not provided"));
            }
            parameterizedUrl = parameterizedUrl.replace(p2, value);
            delete params[key2];
          });
          return parameterizedUrl;
        }
      }, {
        key: "getNextOptions",
        value: function(result, options) {
          var nextOptions = _objectSpread5({}, options);
          if (!result || !result.page_size || !result.total || result.page === void 0)
            return options;
          if (result.cursor) {
            if (result.cursor !== "")
              nextOptions.cursor = result.cursor;
          } else {
            if (result.total > result.page_size * (result.page + 1)) {
              nextOptions.offset = (result.page + 1) * (nextOptions.limit || 500);
            }
          }
          return nextOptions;
        }
      }, {
        key: "getApiRateLimitInfo",
        value: function(headers) {
          return {
            "x-rate-limit-limit": headers["x-rate-limit-limit"],
            "x-rate-limit-remaining-ttl": headers["x-rate-limit-remaining-ttl"],
            "x-rate-limit-used": headers["x-rate-limit-used"],
            "x-rate-limit-remaining-ip-ttl": headers["x-rate-limit-remaining-ip-ttl"],
            "x-rate-limit-ip-used": headers["x-rate-limit-ip-used"]
          };
        }
      }, {
        key: "getApiErrorMessage",
        value: function(error, url) {
          var _error$response, _error$response$data;
          return (error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()) || "Web3 API error while calling ".concat(url);
        }
      }, {
        key: "fetch",
        value: function() {
          var _fetch = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref3) {
            var endpoint, providedParams, params, _this$Moralis, User, account, user;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    endpoint = _ref3.endpoint, providedParams = _ref3.params;
                    params = _objectSpread5({}, providedParams);
                    if (this.Moralis) {
                      _this$Moralis = this.Moralis, User = _this$Moralis.User, account = _this$Moralis.account;
                      user = User.current();
                      if (!params.address) {
                        if (user) {
                          params.address = user.get("ethAddress");
                        } else if (account) {
                          params.address = account;
                        }
                      }
                    }
                    if (this.apiKey) {
                      _context2.next = 5;
                      break;
                    }
                    return _context2.abrupt("return", this.fetchFromServer(endpoint.name, params));
                  case 5:
                    return _context2.abrupt("return", this.fetchFromApi(endpoint, params));
                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _fetch.apply(this, arguments);
          };
        }()
      }, {
        key: "fetchFromApi",
        value: function() {
          var _fetchFromApi = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(endpoint, params) {
            var _this2 = this;
            var _endpoint$method, method, url, bodyParams, parameterizedUrl, data, response, result, nextOptions, _error$response2, status, headers, _data, msg;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _endpoint$method = endpoint.method, method = _endpoint$method === void 0 ? "GET" : _endpoint$method, url = endpoint.url, bodyParams = endpoint.bodyParams;
                    _context3.prev = 1;
                    parameterizedUrl = this.getParameterizedUrl(url, params);
                    data = this.getBody(params, bodyParams);
                    _context3.next = 6;
                    return axios(this.baseURL + parameterizedUrl, {
                      params,
                      method,
                      data,
                      headers: _objectSpread5({
                        Accept: "application/json",
                        "Content-Type": "application/json",
                        "x-api-key": this.apiKey
                      }, this.headers)
                    });
                  case 6:
                    response = _context3.sent;
                    result = response.data;
                    nextOptions = this.getNextOptions(result, params);
                    if (!this.checkObjEqual(nextOptions, params))
                      result.next = function() {
                        return _this2.fetchFromApi(endpoint, nextOptions);
                      };
                    return _context3.abrupt("return", result);
                  case 13:
                    _context3.prev = 13;
                    _context3.t0 = _context3["catch"](1);
                    _error$response2 = _context3.t0.response, status = _error$response2.status, headers = _error$response2.headers, _data = _error$response2.data;
                    if (status === 429) {
                      msg = "This Moralis Server is rate-limited because of the plan restrictions. See the details about the current rate and throttle limits: ".concat((0, _stringify.default)(this.getApiRateLimitInfo(headers)));
                    } else {
                      msg = this.getApiErrorMessage(_context3.t0, url);
                    }
                    throw new Error(msg);
                  case 18:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, this, [[1, 13]]);
          }));
          return function() {
            return _fetchFromApi.apply(this, arguments);
          };
        }()
      }, {
        key: "fetchFromServer",
        value: function() {
          var _fetchFromServer = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(name2, options) {
            var _this3 = this;
            var http, user, response, result, nextOptions, _error$response3, _error$response3$data;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this.serverUrl) {
                      _context4.next = 2;
                      break;
                    }
                    throw new Error("Web3Api not initialized, run Moralis.start() first");
                  case 2:
                    _context4.prev = 2;
                    http = axios.create({
                      baseURL: this.serverUrl
                    });
                    if (!options.chain)
                      options.chain = "eth";
                    user = this.Moralis.User.current();
                    if (user) {
                      options._SessionToken = user.attributes.sessionToken;
                    }
                    options._ApplicationId = this.Moralis.applicationId;
                    _context4.next = 10;
                    return http.post("/functions/".concat(name2), options, {
                      headers: _objectSpread5({
                        Accept: "application/json",
                        "Content-Type": "application/json"
                      }, this.headers)
                    });
                  case 10:
                    response = _context4.sent;
                    result = response.data.result;
                    nextOptions = this.getNextOptions(result, options);
                    if (!this.checkObjEqual(nextOptions, options))
                      result.next = function() {
                        return _this3.fetchFromServer(name2, nextOptions);
                      };
                    return _context4.abrupt("return", result);
                  case 17:
                    _context4.prev = 17;
                    _context4.t0 = _context4["catch"](2);
                    if (!((_error$response3 = _context4.t0.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && _error$response3$data.error)) {
                      _context4.next = 21;
                      break;
                    }
                    throw new Error(_context4.t0.response.data.error);
                  case 21:
                    throw _context4.t0;
                  case 22:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee3, this, [[2, 17]]);
          }));
          return function() {
            return _fetchFromServer.apply(this, arguments);
          };
        }()
      }]);
      return Web3Api2;
    }();
    (0, _defineProperty2.default)(Web3Api, "baseURL", "https://deep-index.moralis.io/api/v2");
    (0, _defineProperty2.default)(Web3Api, "BodyParamTypes", {
      setBody: "set body",
      property: "property"
    });
    (0, _defineProperty2.default)(Web3Api, "checkObjEqual", function() {
      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }
      return (0, _every.default)(objects).call(objects, function(obj) {
        return (0, _stringify.default)(obj) === (0, _stringify.default)(objects[0]);
      });
    });
    (0, _defineProperty2.default)(Web3Api, "native", {
      getBlock: function() {
        var _getBlock = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {
          var options, _args4 = arguments;
          return _regenerator.default.wrap(function(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  options = _args4.length > 0 && _args4[0] !== void 0 ? _args4[0] : {};
                  return _context5.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getBlock",
                      "url": "/block/:block_number_or_hash"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee4);
        }));
        return function() {
          return _getBlock.apply(this, arguments);
        };
      }(),
      getDateToBlock: function() {
        var _getDateToBlock = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5() {
          var options, _args5 = arguments;
          return _regenerator.default.wrap(function(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  options = _args5.length > 0 && _args5[0] !== void 0 ? _args5[0] : {};
                  return _context6.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getDateToBlock",
                      "url": "/dateToBlock"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee5);
        }));
        return function() {
          return _getDateToBlock.apply(this, arguments);
        };
      }(),
      getLogsByAddress: function() {
        var _getLogsByAddress = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6() {
          var options, _args6 = arguments;
          return _regenerator.default.wrap(function(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  options = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : {};
                  return _context7.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getLogsByAddress",
                      "url": "/:address/logs"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee6);
        }));
        return function() {
          return _getLogsByAddress.apply(this, arguments);
        };
      }(),
      getNFTTransfersByBlock: function() {
        var _getNFTTransfersByBlock = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7() {
          var options, _args7 = arguments;
          return _regenerator.default.wrap(function(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  options = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {};
                  return _context8.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getNFTTransfersByBlock",
                      "url": "/block/:block_number_or_hash/nft/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee7);
        }));
        return function() {
          return _getNFTTransfersByBlock.apply(this, arguments);
        };
      }(),
      getInternalTransactions: function() {
        var _getInternalTransactions = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee8() {
          var options, _args8 = arguments;
          return _regenerator.default.wrap(function(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  options = _args8.length > 0 && _args8[0] !== void 0 ? _args8[0] : {};
                  return _context9.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getInternalTransactions",
                      "url": "/transaction/:transaction_hash/internal-transactions"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee8);
        }));
        return function() {
          return _getInternalTransactions.apply(this, arguments);
        };
      }(),
      getTransaction: function() {
        var _getTransaction = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee9() {
          var options, _args9 = arguments;
          return _regenerator.default.wrap(function(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  options = _args9.length > 0 && _args9[0] !== void 0 ? _args9[0] : {};
                  return _context10.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getTransaction",
                      "url": "/transaction/:transaction_hash"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee9);
        }));
        return function() {
          return _getTransaction.apply(this, arguments);
        };
      }(),
      getTransactionVerbose: function() {
        var _getTransactionVerbose = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee10() {
          var options, _args10 = arguments;
          return _regenerator.default.wrap(function(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  options = _args10.length > 0 && _args10[0] !== void 0 ? _args10[0] : {};
                  return _context11.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "native",
                      "name": "getTransactionVerbose",
                      "url": "/transaction/:transaction_hash/verbose"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee10);
        }));
        return function() {
          return _getTransactionVerbose.apply(this, arguments);
        };
      }(),
      getContractEvents: function() {
        var _getContractEvents = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee11() {
          var options, _args11 = arguments;
          return _regenerator.default.wrap(function(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  options = _args11.length > 0 && _args11[0] !== void 0 ? _args11[0] : {};
                  return _context12.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "POST",
                      "group": "native",
                      "name": "getContractEvents",
                      "url": "/:address/events",
                      "bodyParams": [{
                        "key": "data",
                        "type": "set body",
                        "required": false
                      }]
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee11);
        }));
        return function() {
          return _getContractEvents.apply(this, arguments);
        };
      }(),
      runContractFunction: function() {
        var _runContractFunction = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee12() {
          var options, _args12 = arguments;
          return _regenerator.default.wrap(function(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  options = _args12.length > 0 && _args12[0] !== void 0 ? _args12[0] : {};
                  return _context13.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "POST",
                      "group": "native",
                      "name": "runContractFunction",
                      "url": "/:address/function",
                      "bodyParams": [{
                        "key": "abi",
                        "type": "property",
                        "required": true
                      }, {
                        "key": "params",
                        "type": "property",
                        "required": false
                      }]
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee12);
        }));
        return function() {
          return _runContractFunction.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "account", {
      getTransactions: function() {
        var _getTransactions = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee13() {
          var options, _args13 = arguments;
          return _regenerator.default.wrap(function(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  options = _args13.length > 0 && _args13[0] !== void 0 ? _args13[0] : {};
                  return _context14.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getTransactions",
                      "url": "/:address"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee13);
        }));
        return function() {
          return _getTransactions.apply(this, arguments);
        };
      }(),
      getTransactionsVerbose: function() {
        var _getTransactionsVerbose = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee14() {
          var options, _args14 = arguments;
          return _regenerator.default.wrap(function(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  options = _args14.length > 0 && _args14[0] !== void 0 ? _args14[0] : {};
                  return _context15.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getTransactionsVerbose",
                      "url": "/:address/verbose"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee14);
        }));
        return function() {
          return _getTransactionsVerbose.apply(this, arguments);
        };
      }(),
      getNativeBalance: function() {
        var _getNativeBalance = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee15() {
          var options, _args15 = arguments;
          return _regenerator.default.wrap(function(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  options = _args15.length > 0 && _args15[0] !== void 0 ? _args15[0] : {};
                  return _context16.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getNativeBalance",
                      "url": "/:address/balance"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee15);
        }));
        return function() {
          return _getNativeBalance.apply(this, arguments);
        };
      }(),
      getNativeBalancesForAddresses: function() {
        var _getNativeBalancesForAddresses = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee16() {
          var options, _args16 = arguments;
          return _regenerator.default.wrap(function(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  options = _args16.length > 0 && _args16[0] !== void 0 ? _args16[0] : {};
                  return _context17.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getNativeBalancesForAddresses",
                      "url": "/wallets/balances"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee16);
        }));
        return function() {
          return _getNativeBalancesForAddresses.apply(this, arguments);
        };
      }(),
      getTokenBalances: function() {
        var _getTokenBalances = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee17() {
          var options, _args17 = arguments;
          return _regenerator.default.wrap(function(_context18) {
            while (1) {
              switch (_context18.prev = _context18.next) {
                case 0:
                  options = _args17.length > 0 && _args17[0] !== void 0 ? _args17[0] : {};
                  return _context18.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getTokenBalances",
                      "url": "/:address/erc20"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context18.stop();
              }
            }
          }, _callee17);
        }));
        return function() {
          return _getTokenBalances.apply(this, arguments);
        };
      }(),
      getTokenTransfers: function() {
        var _getTokenTransfers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee18() {
          var options, _args18 = arguments;
          return _regenerator.default.wrap(function(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  options = _args18.length > 0 && _args18[0] !== void 0 ? _args18[0] : {};
                  return _context19.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getTokenTransfers",
                      "url": "/:address/erc20/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee18);
        }));
        return function() {
          return _getTokenTransfers.apply(this, arguments);
        };
      }(),
      getNFTs: function() {
        var _getNFTs = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee19() {
          var options, _args19 = arguments;
          return _regenerator.default.wrap(function(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  options = _args19.length > 0 && _args19[0] !== void 0 ? _args19[0] : {};
                  return _context20.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getNFTs",
                      "url": "/:address/nft"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee19);
        }));
        return function() {
          return _getNFTs.apply(this, arguments);
        };
      }(),
      getNFTTransfers: function() {
        var _getNFTTransfers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee20() {
          var options, _args20 = arguments;
          return _regenerator.default.wrap(function(_context21) {
            while (1) {
              switch (_context21.prev = _context21.next) {
                case 0:
                  options = _args20.length > 0 && _args20[0] !== void 0 ? _args20[0] : {};
                  return _context21.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getNFTTransfers",
                      "url": "/:address/nft/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context21.stop();
              }
            }
          }, _callee20);
        }));
        return function() {
          return _getNFTTransfers.apply(this, arguments);
        };
      }(),
      getWalletNFTCollections: function() {
        var _getWalletNFTCollections = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee21() {
          var options, _args21 = arguments;
          return _regenerator.default.wrap(function(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  options = _args21.length > 0 && _args21[0] !== void 0 ? _args21[0] : {};
                  return _context22.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getWalletNFTCollections",
                      "url": "/:address/nft/collections"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee21);
        }));
        return function() {
          return _getWalletNFTCollections.apply(this, arguments);
        };
      }(),
      getNFTsForContract: function() {
        var _getNFTsForContract = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee22() {
          var options, _args22 = arguments;
          return _regenerator.default.wrap(function(_context23) {
            while (1) {
              switch (_context23.prev = _context23.next) {
                case 0:
                  options = _args22.length > 0 && _args22[0] !== void 0 ? _args22[0] : {};
                  return _context23.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getNFTsForContract",
                      "url": "/:address/nft/:token_address"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context23.stop();
              }
            }
          }, _callee22);
        }));
        return function() {
          return _getNFTsForContract.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "token", {
      getTokenMetadata: function() {
        var _getTokenMetadata = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee23() {
          var options, _args23 = arguments;
          return _regenerator.default.wrap(function(_context24) {
            while (1) {
              switch (_context24.prev = _context24.next) {
                case 0:
                  options = _args23.length > 0 && _args23[0] !== void 0 ? _args23[0] : {};
                  return _context24.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenMetadata",
                      "url": "/erc20/metadata"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context24.stop();
              }
            }
          }, _callee23);
        }));
        return function() {
          return _getTokenMetadata.apply(this, arguments);
        };
      }(),
      getNFTTrades: function() {
        var _getNFTTrades = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee24() {
          var options, _args24 = arguments;
          return _regenerator.default.wrap(function(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  options = _args24.length > 0 && _args24[0] !== void 0 ? _args24[0] : {};
                  return _context25.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getNFTTrades",
                      "url": "/nft/:address/trades"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee24);
        }));
        return function() {
          return _getNFTTrades.apply(this, arguments);
        };
      }(),
      getNFTLowestPrice: function() {
        var _getNFTLowestPrice = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee25() {
          var options, _args25 = arguments;
          return _regenerator.default.wrap(function(_context26) {
            while (1) {
              switch (_context26.prev = _context26.next) {
                case 0:
                  options = _args25.length > 0 && _args25[0] !== void 0 ? _args25[0] : {};
                  return _context26.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getNFTLowestPrice",
                      "url": "/nft/:address/lowestprice"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context26.stop();
              }
            }
          }, _callee25);
        }));
        return function() {
          return _getNFTLowestPrice.apply(this, arguments);
        };
      }(),
      getTokenMetadataBySymbol: function() {
        var _getTokenMetadataBySymbol = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee26() {
          var options, _args26 = arguments;
          return _regenerator.default.wrap(function(_context27) {
            while (1) {
              switch (_context27.prev = _context27.next) {
                case 0:
                  options = _args26.length > 0 && _args26[0] !== void 0 ? _args26[0] : {};
                  return _context27.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenMetadataBySymbol",
                      "url": "/erc20/metadata/symbols"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context27.stop();
              }
            }
          }, _callee26);
        }));
        return function() {
          return _getTokenMetadataBySymbol.apply(this, arguments);
        };
      }(),
      getTokenPrice: function() {
        var _getTokenPrice = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee27() {
          var options, _args27 = arguments;
          return _regenerator.default.wrap(function(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  options = _args27.length > 0 && _args27[0] !== void 0 ? _args27[0] : {};
                  return _context28.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenPrice",
                      "url": "/erc20/:address/price"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee27);
        }));
        return function() {
          return _getTokenPrice.apply(this, arguments);
        };
      }(),
      getMultipleTokenPrices: function() {
        var _getMultipleTokenPrices = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee28() {
          var options, _args28 = arguments;
          return _regenerator.default.wrap(function(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  options = _args28.length > 0 && _args28[0] !== void 0 ? _args28[0] : {};
                  return _context29.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "POST",
                      "group": "token",
                      "name": "getMultipleTokenPrices",
                      "url": "/erc20/prices",
                      "bodyParams": [{
                        "key": "tokens",
                        "type": "property",
                        "required": true
                      }]
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context29.stop();
              }
            }
          }, _callee28);
        }));
        return function() {
          return _getMultipleTokenPrices.apply(this, arguments);
        };
      }(),
      getTokenAddressTransfers: function() {
        var _getTokenAddressTransfers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee29() {
          var options, _args29 = arguments;
          return _regenerator.default.wrap(function(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  options = _args29.length > 0 && _args29[0] !== void 0 ? _args29[0] : {};
                  return _context30.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenAddressTransfers",
                      "url": "/erc20/:address/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee29);
        }));
        return function() {
          return _getTokenAddressTransfers.apply(this, arguments);
        };
      }(),
      getTokenAllowance: function() {
        var _getTokenAllowance = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee30() {
          var options, _args30 = arguments;
          return _regenerator.default.wrap(function(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  options = _args30.length > 0 && _args30[0] !== void 0 ? _args30[0] : {};
                  return _context31.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenAllowance",
                      "url": "/erc20/:address/allowance"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee30);
        }));
        return function() {
          return _getTokenAllowance.apply(this, arguments);
        };
      }(),
      getErc20Transfers: function() {
        var _getErc20Transfers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee31() {
          var options, _args31 = arguments;
          return _regenerator.default.wrap(function(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  options = _args31.length > 0 && _args31[0] !== void 0 ? _args31[0] : {};
                  return _context32.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getErc20Transfers",
                      "url": "/erc20/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee31);
        }));
        return function() {
          return _getErc20Transfers.apply(this, arguments);
        };
      }(),
      getErc20Mints: function() {
        var _getErc20Mints = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee32() {
          var options, _args32 = arguments;
          return _regenerator.default.wrap(function(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  options = _args32.length > 0 && _args32[0] !== void 0 ? _args32[0] : {};
                  return _context33.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getErc20Mints",
                      "url": "/erc20/mints"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee32);
        }));
        return function() {
          return _getErc20Mints.apply(this, arguments);
        };
      }(),
      getErc20Burns: function() {
        var _getErc20Burns = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee33() {
          var options, _args33 = arguments;
          return _regenerator.default.wrap(function(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  options = _args33.length > 0 && _args33[0] !== void 0 ? _args33[0] : {};
                  return _context34.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getErc20Burns",
                      "url": "/erc20/burns"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee33);
        }));
        return function() {
          return _getErc20Burns.apply(this, arguments);
        };
      }(),
      getErc20Approvals: function() {
        var _getErc20Approvals = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee34() {
          var options, _args34 = arguments;
          return _regenerator.default.wrap(function(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  options = _args34.length > 0 && _args34[0] !== void 0 ? _args34[0] : {};
                  return _context35.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getErc20Approvals",
                      "url": "/erc20/approvals"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee34);
        }));
        return function() {
          return _getErc20Approvals.apply(this, arguments);
        };
      }(),
      searchNFTs: function() {
        var _searchNFTs = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee35() {
          var options, _args35 = arguments;
          return _regenerator.default.wrap(function(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  options = _args35.length > 0 && _args35[0] !== void 0 ? _args35[0] : {};
                  return _context36.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "searchNFTs",
                      "url": "/nft/search"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee35);
        }));
        return function() {
          return _searchNFTs.apply(this, arguments);
        };
      }(),
      getNFTTransfersFromToBlock: function() {
        var _getNFTTransfersFromToBlock = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee36() {
          var options, _args36 = arguments;
          return _regenerator.default.wrap(function(_context37) {
            while (1) {
              switch (_context37.prev = _context37.next) {
                case 0:
                  options = _args36.length > 0 && _args36[0] !== void 0 ? _args36[0] : {};
                  return _context37.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getNFTTransfersFromToBlock",
                      "url": "/nft/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context37.stop();
              }
            }
          }, _callee36);
        }));
        return function() {
          return _getNFTTransfersFromToBlock.apply(this, arguments);
        };
      }(),
      getAllTokenIds: function() {
        var _getAllTokenIds = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee37() {
          var options, _args37 = arguments;
          return _regenerator.default.wrap(function(_context38) {
            while (1) {
              switch (_context38.prev = _context38.next) {
                case 0:
                  options = _args37.length > 0 && _args37[0] !== void 0 ? _args37[0] : {};
                  return _context38.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getAllTokenIds",
                      "url": "/nft/:address"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context38.stop();
              }
            }
          }, _callee37);
        }));
        return function() {
          return _getAllTokenIds.apply(this, arguments);
        };
      }(),
      getMultipleNFTs: function() {
        var _getMultipleNFTs = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee38() {
          var options, _args38 = arguments;
          return _regenerator.default.wrap(function(_context39) {
            while (1) {
              switch (_context39.prev = _context39.next) {
                case 0:
                  options = _args38.length > 0 && _args38[0] !== void 0 ? _args38[0] : {};
                  return _context39.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "POST",
                      "group": "token",
                      "name": "getMultipleNFTs",
                      "url": "/nft/getMultipleNFTs",
                      "bodyParams": [{
                        "key": "tokens",
                        "type": "property",
                        "required": true
                      }, {
                        "key": "normalizeMetadata",
                        "type": "property",
                        "required": false
                      }, {
                        "key": "media_items",
                        "type": "property",
                        "required": false
                      }]
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context39.stop();
              }
            }
          }, _callee38);
        }));
        return function() {
          return _getMultipleNFTs.apply(this, arguments);
        };
      }(),
      getContractNFTTransfers: function() {
        var _getContractNFTTransfers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee39() {
          var options, _args39 = arguments;
          return _regenerator.default.wrap(function(_context40) {
            while (1) {
              switch (_context40.prev = _context40.next) {
                case 0:
                  options = _args39.length > 0 && _args39[0] !== void 0 ? _args39[0] : {};
                  return _context40.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getContractNFTTransfers",
                      "url": "/nft/:address/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context40.stop();
              }
            }
          }, _callee39);
        }));
        return function() {
          return _getContractNFTTransfers.apply(this, arguments);
        };
      }(),
      getNFTOwners: function() {
        var _getNFTOwners = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee40() {
          var options, _args40 = arguments;
          return _regenerator.default.wrap(function(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  options = _args40.length > 0 && _args40[0] !== void 0 ? _args40[0] : {};
                  return _context41.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getNFTOwners",
                      "url": "/nft/:address/owners"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee40);
        }));
        return function() {
          return _getNFTOwners.apply(this, arguments);
        };
      }(),
      getNFTMetadata: function() {
        var _getNFTMetadata = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee41() {
          var options, _args41 = arguments;
          return _regenerator.default.wrap(function(_context42) {
            while (1) {
              switch (_context42.prev = _context42.next) {
                case 0:
                  options = _args41.length > 0 && _args41[0] !== void 0 ? _args41[0] : {};
                  return _context42.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getNFTMetadata",
                      "url": "/nft/:address/metadata"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context42.stop();
              }
            }
          }, _callee41);
        }));
        return function() {
          return _getNFTMetadata.apply(this, arguments);
        };
      }(),
      reSyncMetadata: function() {
        var _reSyncMetadata = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee42() {
          var options, _args42 = arguments;
          return _regenerator.default.wrap(function(_context43) {
            while (1) {
              switch (_context43.prev = _context43.next) {
                case 0:
                  options = _args42.length > 0 && _args42[0] !== void 0 ? _args42[0] : {};
                  return _context43.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "reSyncMetadata",
                      "url": "/nft/:address/:token_id/metadata/resync"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context43.stop();
              }
            }
          }, _callee42);
        }));
        return function() {
          return _reSyncMetadata.apply(this, arguments);
        };
      }(),
      getTokenIdMetadata: function() {
        var _getTokenIdMetadata = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee43() {
          var options, _args43 = arguments;
          return _regenerator.default.wrap(function(_context44) {
            while (1) {
              switch (_context44.prev = _context44.next) {
                case 0:
                  options = _args43.length > 0 && _args43[0] !== void 0 ? _args43[0] : {};
                  return _context44.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenIdMetadata",
                      "url": "/nft/:address/:token_id"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context44.stop();
              }
            }
          }, _callee43);
        }));
        return function() {
          return _getTokenIdMetadata.apply(this, arguments);
        };
      }(),
      getTokenIdOwners: function() {
        var _getTokenIdOwners = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee44() {
          var options, _args44 = arguments;
          return _regenerator.default.wrap(function(_context45) {
            while (1) {
              switch (_context45.prev = _context45.next) {
                case 0:
                  options = _args44.length > 0 && _args44[0] !== void 0 ? _args44[0] : {};
                  return _context45.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenIdOwners",
                      "url": "/nft/:address/:token_id/owners"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context45.stop();
              }
            }
          }, _callee44);
        }));
        return function() {
          return _getTokenIdOwners.apply(this, arguments);
        };
      }(),
      getWalletTokenIdTransfers: function() {
        var _getWalletTokenIdTransfers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee45() {
          var options, _args45 = arguments;
          return _regenerator.default.wrap(function(_context46) {
            while (1) {
              switch (_context46.prev = _context46.next) {
                case 0:
                  options = _args45.length > 0 && _args45[0] !== void 0 ? _args45[0] : {};
                  return _context46.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getWalletTokenIdTransfers",
                      "url": "/nft/:address/:token_id/transfers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context46.stop();
              }
            }
          }, _callee45);
        }));
        return function() {
          return _getWalletTokenIdTransfers.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "contract", {
      syncNFTContract: function() {
        var _syncNFTContract = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee46() {
          var options, _args46 = arguments;
          return _regenerator.default.wrap(function(_context47) {
            while (1) {
              switch (_context47.prev = _context47.next) {
                case 0:
                  options = _args46.length > 0 && _args46[0] !== void 0 ? _args46[0] : {};
                  return _context47.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "PUT",
                      "group": "contract",
                      "name": "syncNFTContract",
                      "url": "/nft/:address/sync"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context47.stop();
              }
            }
          }, _callee46);
        }));
        return function() {
          return _syncNFTContract.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "resolve", {
      resolveDomain: function() {
        var _resolveDomain = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee47() {
          var options, _args47 = arguments;
          return _regenerator.default.wrap(function(_context48) {
            while (1) {
              switch (_context48.prev = _context48.next) {
                case 0:
                  options = _args47.length > 0 && _args47[0] !== void 0 ? _args47[0] : {};
                  return _context48.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "resolve",
                      "name": "resolveDomain",
                      "url": "/resolve/:domain"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context48.stop();
              }
            }
          }, _callee47);
        }));
        return function() {
          return _resolveDomain.apply(this, arguments);
        };
      }(),
      resolveENSDomain: function() {
        var _resolveENSDomain = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee48() {
          var options, _args48 = arguments;
          return _regenerator.default.wrap(function(_context49) {
            while (1) {
              switch (_context49.prev = _context49.next) {
                case 0:
                  options = _args48.length > 0 && _args48[0] !== void 0 ? _args48[0] : {};
                  return _context49.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "resolve",
                      "name": "resolveENSDomain",
                      "url": "/resolve/ens/:domain"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context49.stop();
              }
            }
          }, _callee48);
        }));
        return function() {
          return _resolveENSDomain.apply(this, arguments);
        };
      }(),
      resolveAddress: function() {
        var _resolveAddress = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee49() {
          var options, _args49 = arguments;
          return _regenerator.default.wrap(function(_context50) {
            while (1) {
              switch (_context50.prev = _context50.next) {
                case 0:
                  options = _args49.length > 0 && _args49[0] !== void 0 ? _args49[0] : {};
                  return _context50.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "resolve",
                      "name": "resolveAddress",
                      "url": "/resolve/:address/reverse"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context50.stop();
              }
            }
          }, _callee49);
        }));
        return function() {
          return _resolveAddress.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "defi", {
      getPairReserves: function() {
        var _getPairReserves = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee50() {
          var options, _args50 = arguments;
          return _regenerator.default.wrap(function(_context51) {
            while (1) {
              switch (_context51.prev = _context51.next) {
                case 0:
                  options = _args50.length > 0 && _args50[0] !== void 0 ? _args50[0] : {};
                  return _context51.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "defi",
                      "name": "getPairReserves",
                      "url": "/:pair_address/reserves"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context51.stop();
              }
            }
          }, _callee50);
        }));
        return function() {
          return _getPairReserves.apply(this, arguments);
        };
      }(),
      getPairAddress: function() {
        var _getPairAddress = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee51() {
          var options, _args51 = arguments;
          return _regenerator.default.wrap(function(_context52) {
            while (1) {
              switch (_context52.prev = _context52.next) {
                case 0:
                  options = _args51.length > 0 && _args51[0] !== void 0 ? _args51[0] : {};
                  return _context52.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "defi",
                      "name": "getPairAddress",
                      "url": "/:token0_address/:token1_address/pairAddress"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context52.stop();
              }
            }
          }, _callee51);
        }));
        return function() {
          return _getPairAddress.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "storage", {
      uploadFolder: function() {
        var _uploadFolder = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee52() {
          var options, _args52 = arguments;
          return _regenerator.default.wrap(function(_context53) {
            while (1) {
              switch (_context53.prev = _context53.next) {
                case 0:
                  options = _args52.length > 0 && _args52[0] !== void 0 ? _args52[0] : {};
                  return _context53.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "POST",
                      "group": "storage",
                      "name": "uploadFolder",
                      "url": "/ipfs/uploadFolder",
                      "bodyParams": [{
                        "key": "data",
                        "type": "set body",
                        "required": false
                      }]
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context53.stop();
              }
            }
          }, _callee52);
        }));
        return function() {
          return _uploadFolder.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "info", {
      web3ApiVersion: function() {
        var _web3ApiVersion = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee53() {
          var options, _args53 = arguments;
          return _regenerator.default.wrap(function(_context54) {
            while (1) {
              switch (_context54.prev = _context54.next) {
                case 0:
                  options = _args53.length > 0 && _args53[0] !== void 0 ? _args53[0] : {};
                  return _context54.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "info",
                      "name": "web3ApiVersion",
                      "url": "/web3/version"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context54.stop();
              }
            }
          }, _callee53);
        }));
        return function() {
          return _web3ApiVersion.apply(this, arguments);
        };
      }(),
      endpointWeights: function() {
        var _endpointWeights = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee54() {
          var options, _args54 = arguments;
          return _regenerator.default.wrap(function(_context55) {
            while (1) {
              switch (_context55.prev = _context55.next) {
                case 0:
                  options = _args54.length > 0 && _args54[0] !== void 0 ? _args54[0] : {};
                  return _context55.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "info",
                      "name": "endpointWeights",
                      "url": "/info/endpointWeights"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context55.stop();
              }
            }
          }, _callee54);
        }));
        return function() {
          return _endpointWeights.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "market_data", {
      getTopERC20TokensByMarketCap: function() {
        var _getTopERC20TokensByMarketCap = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee55() {
          var options, _args55 = arguments;
          return _regenerator.default.wrap(function(_context56) {
            while (1) {
              switch (_context56.prev = _context56.next) {
                case 0:
                  options = _args55.length > 0 && _args55[0] !== void 0 ? _args55[0] : {};
                  return _context56.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "market data",
                      "name": "getTopERC20TokensByMarketCap",
                      "url": "/market-data/erc20s/top-tokens"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context56.stop();
              }
            }
          }, _callee55);
        }));
        return function() {
          return _getTopERC20TokensByMarketCap.apply(this, arguments);
        };
      }(),
      getTopERC20TokensByPriceMovers: function() {
        var _getTopERC20TokensByPriceMovers = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee56() {
          var options, _args56 = arguments;
          return _regenerator.default.wrap(function(_context57) {
            while (1) {
              switch (_context57.prev = _context57.next) {
                case 0:
                  options = _args56.length > 0 && _args56[0] !== void 0 ? _args56[0] : {};
                  return _context57.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "market data",
                      "name": "getTopERC20TokensByPriceMovers",
                      "url": "/market-data/erc20s/top-movers"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context57.stop();
              }
            }
          }, _callee56);
        }));
        return function() {
          return _getTopERC20TokensByPriceMovers.apply(this, arguments);
        };
      }(),
      getTopNFTCollectionsByMarketCap: function() {
        var _getTopNFTCollectionsByMarketCap = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee57() {
          var options, _args57 = arguments;
          return _regenerator.default.wrap(function(_context58) {
            while (1) {
              switch (_context58.prev = _context58.next) {
                case 0:
                  options = _args57.length > 0 && _args57[0] !== void 0 ? _args57[0] : {};
                  return _context58.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "market data",
                      "name": "getTopNFTCollectionsByMarketCap",
                      "url": "/market-data/nfts/top-collections"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context58.stop();
              }
            }
          }, _callee57);
        }));
        return function() {
          return _getTopNFTCollectionsByMarketCap.apply(this, arguments);
        };
      }(),
      getHottestNFTCollectionsByTradingVolume: function() {
        var _getHottestNFTCollectionsByTradingVolume = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee58() {
          var options, _args58 = arguments;
          return _regenerator.default.wrap(function(_context59) {
            while (1) {
              switch (_context59.prev = _context59.next) {
                case 0:
                  options = _args58.length > 0 && _args58[0] !== void 0 ? _args58[0] : {};
                  return _context59.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "market data",
                      "name": "getHottestNFTCollectionsByTradingVolume",
                      "url": "/market-data/nfts/hottest-collections"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context59.stop();
              }
            }
          }, _callee58);
        }));
        return function() {
          return _getHottestNFTCollectionsByTradingVolume.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(Web3Api, "utils", {
      reviewContracts: function() {
        var _reviewContracts = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee59() {
          var options, _args59 = arguments;
          return _regenerator.default.wrap(function(_context60) {
            while (1) {
              switch (_context60.prev = _context60.next) {
                case 0:
                  options = _args59.length > 0 && _args59[0] !== void 0 ? _args59[0] : {};
                  return _context60.abrupt("return", Web3Api.fetch({
                    endpoint: {
                      "method": "POST",
                      "group": "utils",
                      "name": "reviewContracts",
                      "url": "/contracts-review",
                      "bodyParams": [{
                        "key": "contracts",
                        "type": "property",
                        "required": true
                      }]
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context60.stop();
              }
            }
          }, _callee59);
        }));
        return function() {
          return _reviewContracts.apply(this, arguments);
        };
      }()
    });
    var _default = Web3Api;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/MoralisSolanaApi.js
var require_MoralisSolanaApi = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisSolanaApi.js"(exports) {
    "use strict";
    var _Object$keys2 = require_keys3();
    var _Object$getOwnPropertySymbols = require_get_own_property_symbols3();
    var _filterInstanceProperty2 = require_filter4();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _forEachInstanceProperty2 = require_for_each4();
    var _Object$getOwnPropertyDescriptors = require_get_own_property_descriptors3();
    var _Object$defineProperties = require_define_properties3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _keys = _interopRequireDefault(require_keys3());
    var _filter = _interopRequireDefault(require_filter4());
    var _includes = _interopRequireDefault(require_includes5());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    function ownKeys5(object, enumerableOnly) {
      var keys = _Object$keys2(object);
      if (_Object$getOwnPropertySymbols) {
        var symbols = _Object$getOwnPropertySymbols(object);
        enumerableOnly && (symbols = _filterInstanceProperty2(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var _context11, _context12;
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? _forEachInstanceProperty2(_context11 = ownKeys5(Object(source), true)).call(_context11, function(key2) {
          (0, _defineProperty2.default)(target, key2, source[key2]);
        }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty2(_context12 = ownKeys5(Object(source))).call(_context12, function(key2) {
          _Object$defineProperty(target, key2, _Object$getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    var axios = require_axios2();
    var SolanaApi = function() {
      function SolanaApi2() {
        (0, _classCallCheck2.default)(this, SolanaApi2);
      }
      (0, _createClass2.default)(SolanaApi2, null, [{
        key: "initialize",
        value: (
          // URL will be changed when api is deployed
          function(_ref) {
            var apiKey = _ref.apiKey, serverUrl = _ref.serverUrl, _ref$Moralis = _ref.Moralis, Moralis = _ref$Moralis === void 0 ? null : _ref$Moralis, _ref$headers = _ref.headers, headers = _ref$headers === void 0 ? {} : _ref$headers;
            if (!serverUrl && !apiKey) {
              throw new Error("SolanaApi.initialize failed: initialize with apiKey or serverUrl");
            }
            if (apiKey)
              this.apiKey = apiKey;
            if (serverUrl)
              this.serverUrl = serverUrl;
            this.Moralis = Moralis;
            this.headers = headers;
          }
        )
      }, {
        key: "getBody",
        value: function(params, bodyParams) {
          var _this = this;
          if (!params || !bodyParams || !bodyParams.length) {
            return void 0;
          }
          var body = {};
          (0, _forEach.default)(bodyParams).call(bodyParams, function(_ref2) {
            var key2 = _ref2.key, type = _ref2.type, required = _ref2.required;
            if (params[key2] === void 0) {
              if (required)
                throw new Error("param ".concat(key2, " is required!"));
            } else if (type === _this.BodyParamTypes.setBody) {
              body = params[key2];
            } else {
              body[key2] = params[key2];
            }
            delete params[key2];
          });
          return body;
        }
      }, {
        key: "getParameterizedUrl",
        value: function(url, params) {
          var _context;
          if (!(0, _keys.default)(params).length)
            return url;
          var requiredParams = (0, _filter.default)(_context = url.split("/")).call(_context, function(s2) {
            return s2 && (0, _includes.default)(s2).call(s2, ":");
          });
          if (!requiredParams.length)
            return url;
          var parameterizedUrl = url;
          (0, _forEach.default)(requiredParams).call(requiredParams, function(p2) {
            var key2 = p2.substr(1);
            var value = params[key2];
            if (!value) {
              throw new Error("required param ".concat(key2, " not provided"));
            }
            parameterizedUrl = parameterizedUrl.replace(p2, value);
            delete params[key2];
          });
          return parameterizedUrl;
        }
      }, {
        key: "getApiRateLimitInfo",
        value: function(headers) {
          return {
            "x-rate-limit-limit": headers["x-rate-limit-limit"],
            "x-rate-limit-remaining-ttl": headers["x-rate-limit-remaining-ttl"],
            "x-rate-limit-used": headers["x-rate-limit-used"],
            "x-rate-limit-remaining-ip-ttl": headers["x-rate-limit-remaining-ip-ttl"],
            "x-rate-limit-ip-used": headers["x-rate-limit-ip-used"]
          };
        }
      }, {
        key: "getErrorMessage",
        value: function(error, url) {
          var _error$response, _error$response$data;
          return (error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()) || "Solana API error while calling ".concat(url);
        }
      }, {
        key: "fetch",
        value: function() {
          var _fetch = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref3) {
            var endpoint, providedParams, params, User, user;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    endpoint = _ref3.endpoint, providedParams = _ref3.params;
                    params = _objectSpread5({}, providedParams);
                    if (this.Moralis) {
                      User = this.Moralis.User;
                      user = User.current();
                      if (!params.address) {
                        if (user) {
                          params.address = user.get("solAddress");
                        }
                      }
                    }
                    if (!params.network)
                      params.network = "mainnet";
                    if (!params.responseType)
                      params.responseType = "native";
                    if (this.apiKey) {
                      _context2.next = 7;
                      break;
                    }
                    return _context2.abrupt("return", this.fetchFromServer(endpoint.name, params));
                  case 7:
                    return _context2.abrupt("return", this.fetchFromApi(endpoint, params));
                  case 8:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee, this);
          }));
          return function() {
            return _fetch.apply(this, arguments);
          };
        }()
      }, {
        key: "fetchFromApi",
        value: function() {
          var _fetchFromApi = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(endpoint, params) {
            var _endpoint$method, method, url, bodyParams, parameterizedUrl, data, response, _error$response2, status, headers, _data, msg;
            return _regenerator.default.wrap(function(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _endpoint$method = endpoint.method, method = _endpoint$method === void 0 ? "GET" : _endpoint$method, url = endpoint.url, bodyParams = endpoint.bodyParams;
                    _context3.prev = 1;
                    parameterizedUrl = this.getParameterizedUrl(url, params);
                    data = this.getBody(params, bodyParams);
                    _context3.next = 6;
                    return axios(this.baseURL + parameterizedUrl, {
                      params,
                      method,
                      data,
                      headers: _objectSpread5({
                        Accept: "application/json",
                        "Content-Type": "application/json",
                        "x-api-key": this.apiKey
                      }, this.headers)
                    });
                  case 6:
                    response = _context3.sent;
                    return _context3.abrupt("return", response.data);
                  case 10:
                    _context3.prev = 10;
                    _context3.t0 = _context3["catch"](1);
                    _error$response2 = _context3.t0.response, status = _error$response2.status, headers = _error$response2.headers, _data = _error$response2.data;
                    if (status === 429) {
                      msg = "This Moralis Server is rate-limited because of the plan restrictions. See the details about the current rate and throttle limits: ".concat((0, _stringify.default)(this.getApiRateLimitInfo(headers)));
                    } else {
                      msg = this.getApiErrorMessage(_context3.t0, url);
                    }
                    throw new Error(msg);
                  case 15:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, this, [[1, 10]]);
          }));
          return function() {
            return _fetchFromApi.apply(this, arguments);
          };
        }()
      }, {
        key: "fetchFromServer",
        value: function() {
          var _fetchFromServer = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(name2, options) {
            var http, user, response, _error$response3, _error$response3$data;
            return _regenerator.default.wrap(function(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this.serverUrl) {
                      _context4.next = 2;
                      break;
                    }
                    throw new Error("SolanaAPI not initialized, run Moralis.start() first");
                  case 2:
                    _context4.prev = 2;
                    http = axios.create({
                      baseURL: this.serverUrl
                    });
                    user = this.Moralis.User.current();
                    if (user) {
                      options._SessionToken = user.attributes.sessionToken;
                    }
                    options._ApplicationId = this.Moralis.applicationId;
                    _context4.next = 9;
                    return http.post("/functions/sol-".concat(name2), options, {
                      headers: _objectSpread5({
                        Accept: "application/json",
                        "Content-Type": "application/json"
                      }, this.headers)
                    });
                  case 9:
                    response = _context4.sent;
                    return _context4.abrupt("return", response.data.result);
                  case 13:
                    _context4.prev = 13;
                    _context4.t0 = _context4["catch"](2);
                    if (!((_error$response3 = _context4.t0.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && _error$response3$data.error)) {
                      _context4.next = 17;
                      break;
                    }
                    throw new Error(_context4.t0.response.data.error);
                  case 17:
                    throw _context4.t0;
                  case 18:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee3, this, [[2, 13]]);
          }));
          return function() {
            return _fetchFromServer.apply(this, arguments);
          };
        }()
      }]);
      return SolanaApi2;
    }();
    (0, _defineProperty2.default)(SolanaApi, "baseURL", "https://solana-gateway.moralis.io");
    (0, _defineProperty2.default)(SolanaApi, "BodyParamTypes", {
      setBody: "set body",
      property: "property"
    });
    (0, _defineProperty2.default)(SolanaApi, "account", {
      balance: function() {
        var _balance = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {
          var options, _args4 = arguments;
          return _regenerator.default.wrap(function(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  options = _args4.length > 0 && _args4[0] !== void 0 ? _args4[0] : {};
                  return _context5.abrupt("return", SolanaApi.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "balance",
                      "url": "/account/:network/:address/balance"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee4);
        }));
        return function() {
          return _balance.apply(this, arguments);
        };
      }(),
      getSPL: function() {
        var _getSPL = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5() {
          var options, _args5 = arguments;
          return _regenerator.default.wrap(function(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  options = _args5.length > 0 && _args5[0] !== void 0 ? _args5[0] : {};
                  return _context6.abrupt("return", SolanaApi.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getSPL",
                      "url": "/account/:network/:address/tokens"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee5);
        }));
        return function() {
          return _getSPL.apply(this, arguments);
        };
      }(),
      getNFTs: function() {
        var _getNFTs = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6() {
          var options, _args6 = arguments;
          return _regenerator.default.wrap(function(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  options = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : {};
                  return _context7.abrupt("return", SolanaApi.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getNFTs",
                      "url": "/account/:network/:address/nft"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee6);
        }));
        return function() {
          return _getNFTs.apply(this, arguments);
        };
      }(),
      getPortfolio: function() {
        var _getPortfolio = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7() {
          var options, _args7 = arguments;
          return _regenerator.default.wrap(function(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  options = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {};
                  return _context8.abrupt("return", SolanaApi.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "account",
                      "name": "getPortfolio",
                      "url": "/account/:network/:address/portfolio"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee7);
        }));
        return function() {
          return _getPortfolio.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(SolanaApi, "nft", {
      getNFTMetadata: function() {
        var _getNFTMetadata = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee8() {
          var options, _args8 = arguments;
          return _regenerator.default.wrap(function(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  options = _args8.length > 0 && _args8[0] !== void 0 ? _args8[0] : {};
                  return _context9.abrupt("return", SolanaApi.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "nft",
                      "name": "getNFTMetadata",
                      "url": "/nft/:network/:address/metadata"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee8);
        }));
        return function() {
          return _getNFTMetadata.apply(this, arguments);
        };
      }()
    });
    (0, _defineProperty2.default)(SolanaApi, "token", {
      getTokenPrice: function() {
        var _getTokenPrice = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee9() {
          var options, _args9 = arguments;
          return _regenerator.default.wrap(function(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  options = _args9.length > 0 && _args9[0] !== void 0 ? _args9[0] : {};
                  return _context10.abrupt("return", SolanaApi.fetch({
                    endpoint: {
                      "method": "GET",
                      "group": "token",
                      "name": "getTokenPrice",
                      "url": "/token/:network/:address/price"
                    },
                    params: options
                  }));
                case 2:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee9);
        }));
        return function() {
          return _getTokenPrice.apply(this, arguments);
        };
      }()
    });
    var _default = SolanaApi;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/Push.js
var require_Push = __commonJS({
  "node_modules/moralis-v1/lib/browser/Push.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.send = send;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _ParseQuery = _interopRequireDefault(require_ParseQuery());
    function send(data) {
      if (data.where && data.where instanceof _ParseQuery.default) {
        data.where = data.where.toJSON().where;
      }
      if (data.push_time && (0, _typeof2.default)(data.push_time) === "object") {
        data.push_time = data.push_time.toJSON();
      }
      if (data.expiration_time && (0, _typeof2.default)(data.expiration_time) === "object") {
        data.expiration_time = data.expiration_time.toJSON();
      }
      if (data.expiration_time && data.expiration_interval) {
        throw new Error("expiration_time and expiration_interval cannot both be set.");
      }
      return _CoreManager.default.getPushController().send(data);
    }
    var DefaultController = {
      send: function(data) {
        return _CoreManager.default.getRESTController().request("POST", "push", data, {
          useMasterKey: true
        });
      }
    };
    _CoreManager.default.setPushController(DefaultController);
  }
});

// node_modules/moralis-v1/lib/browser/ParseSchema.js
var require_ParseSchema = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseSchema.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _ParseCLP = _interopRequireDefault(require_ParseCLP());
    var FIELD_TYPES = ["String", "Number", "Boolean", "Date", "File", "GeoPoint", "Polygon", "Array", "Object", "Pointer", "Relation"];
    var ParseSchema = function() {
      function ParseSchema2(className) {
        (0, _classCallCheck2.default)(this, ParseSchema2);
        (0, _defineProperty2.default)(this, "className", void 0);
        (0, _defineProperty2.default)(this, "_fields", void 0);
        (0, _defineProperty2.default)(this, "_indexes", void 0);
        (0, _defineProperty2.default)(this, "_clp", void 0);
        if (typeof className === "string") {
          if (className === "User" && _CoreManager.default.get("PERFORM_USER_REWRITE")) {
            this.className = "_User";
          } else {
            this.className = className;
          }
        }
        this._fields = {};
        this._indexes = {};
      }
      (0, _createClass2.default)(ParseSchema2, [{
        key: "get",
        value: (
          /**
           * Get the Schema from Parse
           *
           * @returns {Promise} A promise that is resolved with the result when
           * the query completes.
           */
          function() {
            this.assertClassName();
            var controller = _CoreManager.default.getSchemaController();
            return controller.get(this.className).then(function(response) {
              if (!response) {
                throw new Error("Schema not found.");
              }
              return response;
            });
          }
        )
        /**
         * Create a new Schema on Parse
         *
         * @returns {Promise} A promise that is resolved with the result when
         * the query completes.
         */
      }, {
        key: "save",
        value: function() {
          this.assertClassName();
          var controller = _CoreManager.default.getSchemaController();
          var params = {
            className: this.className,
            fields: this._fields,
            indexes: this._indexes,
            classLevelPermissions: this._clp
          };
          return controller.create(this.className, params);
        }
        /**
         * Update a Schema on Parse
         *
         * @returns {Promise} A promise that is resolved with the result when
         * the query completes.
         */
      }, {
        key: "update",
        value: function() {
          this.assertClassName();
          var controller = _CoreManager.default.getSchemaController();
          var params = {
            className: this.className,
            fields: this._fields,
            indexes: this._indexes,
            classLevelPermissions: this._clp
          };
          this._fields = {};
          this._indexes = {};
          return controller.update(this.className, params);
        }
        /**
         * Removing a Schema from Parse
         * Can only be used on Schema without objects
         *
         * @returns {Promise} A promise that is resolved with the result when
         * the query completes.
         */
      }, {
        key: "delete",
        value: function() {
          this.assertClassName();
          var controller = _CoreManager.default.getSchemaController();
          return controller.delete(this.className);
        }
        /**
         * Removes all objects from a Schema (class) in Parse.
         * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed
         *
         * @returns {Promise} A promise that is resolved with the result when
         * the query completes.
         */
      }, {
        key: "purge",
        value: function() {
          this.assertClassName();
          var controller = _CoreManager.default.getSchemaController();
          return controller.purge(this.className);
        }
        /**
         * Assert if ClassName has been filled
         *
         * @private
         */
      }, {
        key: "assertClassName",
        value: function() {
          if (!this.className) {
            throw new Error("You must set a Class Name before making any request.");
          }
        }
        /**
         * Sets Class Level Permissions when creating / updating a Schema.
         * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed
         *
         * @param {object | Parse.CLP} clp Class Level Permissions
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "setCLP",
        value: function(clp) {
          if (clp instanceof _ParseCLP.default) {
            this._clp = clp.toJSON();
          } else {
            this._clp = clp;
          }
          return this;
        }
        /**
         * Adding a Field to Create / Update a Schema
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)
         * @param {object} options
         * Valid options are:<ul>
         *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)
         *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)
         * </ul>
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addField",
        value: function(name2, type) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          type = type || "String";
          if (!name2) {
            throw new Error("field name may not be null.");
          }
          if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {
            throw new Error("".concat(type, " is not a valid type."));
          }
          var fieldOptions = {
            type
          };
          if (typeof options.required === "boolean") {
            fieldOptions.required = options.required;
          }
          if (options.defaultValue !== void 0) {
            fieldOptions.defaultValue = options.defaultValue;
          }
          this._fields[name2] = fieldOptions;
          return this;
        }
        /**
         * Adding an Index to Create / Update a Schema
         *
         * @param {string} name Name of the index
         * @param {object} index { field: value }
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         *
         * <pre>
         * schema.addIndex('index_name', { 'field': 1 });
         * </pre>
         */
      }, {
        key: "addIndex",
        value: function(name2, index) {
          if (!name2) {
            throw new Error("index name may not be null.");
          }
          if (!index) {
            throw new Error("index may not be null.");
          }
          this._indexes[name2] = index;
          return this;
        }
        /**
         * Adding String Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addString",
        value: function(name2, options) {
          return this.addField(name2, "String", options);
        }
        /**
         * Adding Number Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addNumber",
        value: function(name2, options) {
          return this.addField(name2, "Number", options);
        }
        /**
         * Adding Boolean Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addBoolean",
        value: function(name2, options) {
          return this.addField(name2, "Boolean", options);
        }
        /**
         * Adding Date Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addDate",
        value: function(name2, options) {
          if (options && options.defaultValue) {
            options.defaultValue = {
              __type: "Date",
              iso: new Date(options.defaultValue)
            };
          }
          return this.addField(name2, "Date", options);
        }
        /**
         * Adding File Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addFile",
        value: function(name2, options) {
          return this.addField(name2, "File", options);
        }
        /**
         * Adding GeoPoint Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addGeoPoint",
        value: function(name2, options) {
          return this.addField(name2, "GeoPoint", options);
        }
        /**
         * Adding Polygon Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addPolygon",
        value: function(name2, options) {
          return this.addField(name2, "Polygon", options);
        }
        /**
         * Adding Array Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addArray",
        value: function(name2, options) {
          return this.addField(name2, "Array", options);
        }
        /**
         * Adding Object Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addObject",
        value: function(name2, options) {
          return this.addField(name2, "Object", options);
        }
        /**
         * Adding Pointer Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {string} targetClass Name of the target Pointer Class
         * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addPointer",
        value: function(name2, targetClass) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (!name2) {
            throw new Error("field name may not be null.");
          }
          if (!targetClass) {
            throw new Error("You need to set the targetClass of the Pointer.");
          }
          var fieldOptions = {
            type: "Pointer",
            targetClass
          };
          if (typeof options.required === "boolean") {
            fieldOptions.required = options.required;
          }
          if (options.defaultValue !== void 0) {
            fieldOptions.defaultValue = options.defaultValue;
            if (options.defaultValue instanceof _ParseObject.default) {
              fieldOptions.defaultValue = options.defaultValue.toPointer();
            }
          }
          this._fields[name2] = fieldOptions;
          return this;
        }
        /**
         * Adding Relation Field
         *
         * @param {string} name Name of the field that will be created on Parse
         * @param {string} targetClass Name of the target Pointer Class
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "addRelation",
        value: function(name2, targetClass) {
          if (!name2) {
            throw new Error("field name may not be null.");
          }
          if (!targetClass) {
            throw new Error("You need to set the targetClass of the Relation.");
          }
          this._fields[name2] = {
            type: "Relation",
            targetClass
          };
          return this;
        }
        /**
         * Deleting a Field to Update on a Schema
         *
         * @param {string} name Name of the field
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "deleteField",
        value: function(name2) {
          this._fields[name2] = {
            __op: "Delete"
          };
          return this;
        }
        /**
         * Deleting an Index to Update on a Schema
         *
         * @param {string} name Name of the field
         * @returns {Parse.Schema} Returns the schema, so you can chain this call.
         */
      }, {
        key: "deleteIndex",
        value: function(name2) {
          this._indexes[name2] = {
            __op: "Delete"
          };
          return this;
        }
      }], [{
        key: "all",
        value: function() {
          var controller = _CoreManager.default.getSchemaController();
          return controller.get("").then(function(response) {
            if (response.results.length === 0) {
              throw new Error("Schema not found.");
            }
            return response.results;
          });
        }
      }]);
      return ParseSchema2;
    }();
    var DefaultController = {
      send: function(className, method) {
        var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request(method, "schemas/".concat(className), params, {
          useMasterKey: true
        });
      },
      get: function(className) {
        return this.send(className, "GET");
      },
      create: function(className, params) {
        return this.send(className, "POST", params);
      },
      update: function(className, params) {
        return this.send(className, "PUT", params);
      },
      delete: function(className) {
        return this.send(className, "DELETE");
      },
      purge: function(className) {
        var RESTController = _CoreManager.default.getRESTController();
        return RESTController.request("DELETE", "purge/".concat(className), {}, {
          useMasterKey: true
        });
      }
    };
    _CoreManager.default.setSchemaController(DefaultController);
    var _default = ParseSchema;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/moralis-v1/lib/browser/EventEmitter.js"(exports, module) {
    "use strict";
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/core-js-pure/es/array/virtual/values.js
var require_values4 = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/values.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_object_to_string();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Array", "values");
  }
});

// node_modules/core-js-pure/stable/array/virtual/values.js
var require_values5 = __commonJS({
  "node_modules/core-js-pure/stable/array/virtual/values.js"(exports, module) {
    "use strict";
    var parent = require_values4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/stable/instance/values.js
var require_values6 = __commonJS({
  "node_modules/core-js-pure/stable/instance/values.js"(exports, module) {
    "use strict";
    require_web_dom_collections_iterator();
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_values5();
    var ArrayPrototype = Array.prototype;
    var DOMIterables = {
      DOMTokenList: true,
      NodeList: true
    };
    module.exports = function(it) {
      var own = it.values;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.values || hasOwn(DOMIterables, classof(it)) ? method : own;
    };
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/values.js
var require_values7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/values.js"(exports, module) {
    module.exports = require_values6();
  }
});

// node_modules/moralis-v1/lib/browser/LiveQuerySubscription.js
var require_LiveQuerySubscription = __commonJS({
  "node_modules/moralis-v1/lib/browser/LiveQuerySubscription.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _EventEmitter2 = _interopRequireDefault(require_EventEmitter());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _promiseUtils = require_promiseUtils();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Subscription = function(_EventEmitter) {
      (0, _inherits2.default)(Subscription2, _EventEmitter);
      var _super = _createSuper(Subscription2);
      function Subscription2(id2, query, sessionToken) {
        var _this;
        (0, _classCallCheck2.default)(this, Subscription2);
        _this = _super.call(this);
        _this.id = id2;
        _this.query = query;
        _this.sessionToken = sessionToken;
        _this.subscribePromise = (0, _promiseUtils.resolvingPromise)();
        _this.subscribed = false;
        _this.on("error", function() {
        });
        return _this;
      }
      (0, _createClass2.default)(Subscription2, [{
        key: "unsubscribe",
        value: function() {
          var _this2 = this;
          return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient().then(function(liveQueryClient) {
            liveQueryClient.unsubscribe(_this2);
            _this2.emit("close");
          });
        }
      }]);
      return Subscription2;
    }(_EventEmitter2.default);
    var _default = Subscription;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/LiveQueryClient.js
var require_LiveQueryClient = __commonJS({
  "node_modules/moralis-v1/lib/browser/LiveQueryClient.js"(exports) {
    "use strict";
    var _Reflect$construct = require_construct3();
    var _sliceInstanceProperty = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray = require_is_array4();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _map = _interopRequireDefault(require_map11());
    var _keys = _interopRequireDefault(require_keys7());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _values = _interopRequireDefault(require_values7());
    var _setTimeout2 = _interopRequireDefault(require_set_timeout2());
    var _bind = _interopRequireDefault(require_bind8());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _EventEmitter2 = _interopRequireDefault(require_EventEmitter());
    var _ParseObject = _interopRequireDefault(require_ParseObject());
    var _LiveQuerySubscription = _interopRequireDefault(require_LiveQuerySubscription());
    var _promiseUtils = require_promiseUtils();
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
      if (!it) {
        if (_Array$isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          var F2 = function() {
          };
          return {
            s: F2,
            n: function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function(_e) {
              throw _e;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function() {
          it = it.call(o2);
        },
        n: function() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      var _context6;
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = _sliceInstanceProperty(_context6 = Object.prototype.toString.call(o2)).call(_context6, 8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return _Array$from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var CLIENT_STATE = {
      INITIALIZED: "initialized",
      CONNECTING: "connecting",
      CONNECTED: "connected",
      CLOSED: "closed",
      RECONNECTING: "reconnecting",
      DISCONNECTED: "disconnected"
    };
    var OP_TYPES = {
      CONNECT: "connect",
      SUBSCRIBE: "subscribe",
      UNSUBSCRIBE: "unsubscribe",
      ERROR: "error"
    };
    var OP_EVENTS = {
      CONNECTED: "connected",
      SUBSCRIBED: "subscribed",
      UNSUBSCRIBED: "unsubscribed",
      ERROR: "error",
      CREATE: "create",
      UPDATE: "update",
      ENTER: "enter",
      LEAVE: "leave",
      DELETE: "delete"
    };
    var CLIENT_EMMITER_TYPES = {
      CLOSE: "close",
      ERROR: "error",
      OPEN: "open"
    };
    var SUBSCRIPTION_EMMITER_TYPES = {
      OPEN: "open",
      CLOSE: "close",
      ERROR: "error",
      CREATE: "create",
      UPDATE: "update",
      ENTER: "enter",
      LEAVE: "leave",
      DELETE: "delete"
    };
    var generateInterval = function(k2) {
      return Math.random() * Math.min(30, Math.pow(2, k2) - 1) * 1e3;
    };
    var LiveQueryClient = function(_EventEmitter) {
      (0, _inherits2.default)(LiveQueryClient2, _EventEmitter);
      var _super = _createSuper(LiveQueryClient2);
      function LiveQueryClient2(_ref) {
        var _this;
        var applicationId = _ref.applicationId, serverURL = _ref.serverURL, javascriptKey = _ref.javascriptKey, masterKey = _ref.masterKey, sessionToken = _ref.sessionToken, installationId = _ref.installationId;
        (0, _classCallCheck2.default)(this, LiveQueryClient2);
        _this = _super.call(this);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "attempts", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "id", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "requestId", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "applicationId", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "serverURL", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "javascriptKey", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "masterKey", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sessionToken", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "installationId", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "additionalProperties", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "connectPromise", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subscriptions", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "socket", void 0);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", void 0);
        if (!serverURL || (0, _indexOf.default)(serverURL).call(serverURL, "ws") !== 0) {
          throw new Error("You need to set a proper Parse LiveQuery server url before using LiveQueryClient");
        }
        _this.reconnectHandle = null;
        _this.attempts = 1;
        _this.id = 0;
        _this.requestId = 1;
        _this.serverURL = serverURL;
        _this.applicationId = applicationId;
        _this.javascriptKey = javascriptKey || void 0;
        _this.masterKey = masterKey || void 0;
        _this.sessionToken = sessionToken || void 0;
        _this.installationId = installationId || void 0;
        _this.additionalProperties = true;
        _this.connectPromise = (0, _promiseUtils.resolvingPromise)();
        _this.subscriptions = new _map.default();
        _this.state = CLIENT_STATE.INITIALIZED;
        _this.on("error", function() {
        });
        return _this;
      }
      (0, _createClass2.default)(LiveQueryClient2, [{
        key: "shouldOpen",
        value: function() {
          return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;
        }
        /**
         * Subscribes to a ParseQuery
         *
         * If you provide the sessionToken, when the LiveQuery server gets ParseObject's
         * updates from parse server, it'll try to check whether the sessionToken fulfills
         * the ParseObject's ACL. The LiveQuery server will only send updates to clients whose
         * sessionToken is fit for the ParseObject's ACL. You can check the LiveQuery protocol
         * <a href="https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification">here</a> for more details. The subscription you get is the same subscription you get
         * from our Standard API.
         *
         * @param {object} query - the ParseQuery you want to subscribe to
         * @param {string} sessionToken (optional)
         * @returns {LiveQuerySubscription} subscription
         */
      }, {
        key: "subscribe",
        value: function(query, sessionToken) {
          var _this2 = this;
          if (!query) {
            return;
          }
          var className = query.className;
          var queryJSON = query.toJSON();
          var where = queryJSON.where;
          var fields = (0, _keys.default)(queryJSON) ? (0, _keys.default)(queryJSON).split(",") : void 0;
          var subscribeRequest = {
            op: OP_TYPES.SUBSCRIBE,
            requestId: this.requestId,
            query: {
              className,
              where,
              fields
            }
          };
          if (sessionToken) {
            subscribeRequest.sessionToken = sessionToken;
          }
          var subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken);
          this.subscriptions.set(this.requestId, subscription);
          this.requestId += 1;
          this.connectPromise.then(function() {
            _this2.socket.send((0, _stringify.default)(subscribeRequest));
          });
          return subscription;
        }
        /**
         * After calling unsubscribe you'll stop receiving events from the subscription object.
         *
         * @param {object} subscription - subscription you would like to unsubscribe from.
         */
      }, {
        key: "unsubscribe",
        value: function(subscription) {
          var _this3 = this;
          if (!subscription) {
            return;
          }
          this.subscriptions.delete(subscription.id);
          var unsubscribeRequest = {
            op: OP_TYPES.UNSUBSCRIBE,
            requestId: subscription.id
          };
          this.connectPromise.then(function() {
            _this3.socket.send((0, _stringify.default)(unsubscribeRequest));
          });
        }
        /**
         * After open is called, the LiveQueryClient will try to send a connect request
         * to the LiveQuery server.
         *
         */
      }, {
        key: "open",
        value: function() {
          var _this4 = this;
          var WebSocketImplementation = _CoreManager.default.getWebSocketController();
          if (!WebSocketImplementation) {
            this.emit(CLIENT_EMMITER_TYPES.ERROR, "Can not find WebSocket implementation");
            return;
          }
          if (this.state !== CLIENT_STATE.RECONNECTING) {
            this.state = CLIENT_STATE.CONNECTING;
          }
          this.socket = new WebSocketImplementation(this.serverURL);
          this.socket.onopen = function() {
            _this4._handleWebSocketOpen();
          };
          this.socket.onmessage = function(event) {
            _this4._handleWebSocketMessage(event);
          };
          this.socket.onclose = function() {
            _this4._handleWebSocketClose();
          };
          this.socket.onerror = function(error) {
            _this4._handleWebSocketError(error);
          };
        }
      }, {
        key: "resubscribe",
        value: function() {
          var _context, _this5 = this;
          (0, _forEach.default)(_context = this.subscriptions).call(_context, function(subscription, requestId) {
            var query = subscription.query;
            var queryJSON = query.toJSON();
            var where = queryJSON.where;
            var fields = (0, _keys.default)(queryJSON) ? (0, _keys.default)(queryJSON).split(",") : void 0;
            var className = query.className;
            var sessionToken = subscription.sessionToken;
            var subscribeRequest = {
              op: OP_TYPES.SUBSCRIBE,
              requestId,
              query: {
                className,
                where,
                fields
              }
            };
            if (sessionToken) {
              subscribeRequest.sessionToken = sessionToken;
            }
            _this5.connectPromise.then(function() {
              _this5.socket.send((0, _stringify.default)(subscribeRequest));
            });
          });
        }
        /**
         * This method will close the WebSocket connection to this LiveQueryClient,
         * cancel the auto reconnect and unsubscribe all subscriptions based on it.
         *
         */
      }, {
        key: "close",
        value: function() {
          var _context2;
          if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {
            return;
          }
          this.state = CLIENT_STATE.DISCONNECTED;
          this.socket.close();
          var _iterator = _createForOfIteratorHelper((0, _values.default)(_context2 = this.subscriptions).call(_context2)), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var subscription = _step.value;
              subscription.subscribed = false;
              subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          this._handleReset();
          this.emit(CLIENT_EMMITER_TYPES.CLOSE);
        }
        // ensure we start with valid state if connect is called again after close
      }, {
        key: "_handleReset",
        value: function() {
          this.attempts = 1;
          this.id = 0;
          this.requestId = 1;
          this.connectPromise = (0, _promiseUtils.resolvingPromise)();
          this.subscriptions = new _map.default();
        }
      }, {
        key: "_handleWebSocketOpen",
        value: function() {
          this.attempts = 1;
          var connectRequest = {
            op: OP_TYPES.CONNECT,
            applicationId: this.applicationId,
            javascriptKey: this.javascriptKey,
            masterKey: this.masterKey,
            sessionToken: this.sessionToken
          };
          if (this.additionalProperties) {
            connectRequest.installationId = this.installationId;
          }
          this.socket.send((0, _stringify.default)(connectRequest));
        }
      }, {
        key: "_handleWebSocketMessage",
        value: function(event) {
          var data = event.data;
          if (typeof data === "string") {
            data = JSON.parse(data);
          }
          var subscription = null;
          if (data.requestId) {
            subscription = this.subscriptions.get(data.requestId);
          }
          var response = {
            clientId: data.clientId,
            installationId: data.installationId
          };
          switch (data.op) {
            case OP_EVENTS.CONNECTED:
              if (this.state === CLIENT_STATE.RECONNECTING) {
                this.resubscribe();
              }
              this.emit(CLIENT_EMMITER_TYPES.OPEN);
              this.id = data.clientId;
              this.connectPromise.resolve();
              this.state = CLIENT_STATE.CONNECTED;
              break;
            case OP_EVENTS.SUBSCRIBED:
              if (subscription) {
                subscription.subscribed = true;
                subscription.subscribePromise.resolve();
                (0, _setTimeout2.default)(function() {
                  return subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN, response);
                }, 200);
              }
              break;
            case OP_EVENTS.ERROR:
              if (data.requestId) {
                if (subscription) {
                  subscription.subscribePromise.resolve();
                  (0, _setTimeout2.default)(function() {
                    return subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data.error);
                  }, 200);
                }
              } else {
                this.emit(CLIENT_EMMITER_TYPES.ERROR, data.error);
              }
              if (data.error === "Additional properties not allowed") {
                this.additionalProperties = false;
              }
              if (data.reconnect) {
                this._handleReconnect();
              }
              break;
            case OP_EVENTS.UNSUBSCRIBED:
              break;
            default: {
              if (!subscription) {
                break;
              }
              var override = false;
              if (data.original) {
                override = true;
                delete data.original.__type;
                for (var field in data.original) {
                  if (!(field in data.object)) {
                    data.object[field] = void 0;
                  }
                }
                data.original = _ParseObject.default.fromJSON(data.original, false);
              }
              delete data.object.__type;
              var parseObject = _ParseObject.default.fromJSON(data.object, override);
              if (data.original) {
                subscription.emit(data.op, parseObject, data.original, response);
              } else {
                subscription.emit(data.op, parseObject, response);
              }
              var localDatastore = _CoreManager.default.getLocalDatastore();
              if (override && localDatastore.isEnabled) {
                localDatastore._updateObjectIfPinned(parseObject).then(function() {
                });
              }
            }
          }
        }
      }, {
        key: "_handleWebSocketClose",
        value: function() {
          var _context3;
          if (this.state === CLIENT_STATE.DISCONNECTED) {
            return;
          }
          this.state = CLIENT_STATE.CLOSED;
          this.emit(CLIENT_EMMITER_TYPES.CLOSE);
          var _iterator2 = _createForOfIteratorHelper((0, _values.default)(_context3 = this.subscriptions).call(_context3)), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var subscription = _step2.value;
              subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          this._handleReconnect();
        }
      }, {
        key: "_handleWebSocketError",
        value: function(error) {
          var _context4;
          this.emit(CLIENT_EMMITER_TYPES.ERROR, error);
          var _iterator3 = _createForOfIteratorHelper((0, _values.default)(_context4 = this.subscriptions).call(_context4)), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var subscription = _step3.value;
              subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          this._handleReconnect();
        }
      }, {
        key: "_handleReconnect",
        value: function() {
          var _context5, _this6 = this;
          if (this.state === CLIENT_STATE.DISCONNECTED) {
            return;
          }
          this.state = CLIENT_STATE.RECONNECTING;
          var time = generateInterval(this.attempts);
          if (this.reconnectHandle) {
            clearTimeout(this.reconnectHandle);
          }
          this.reconnectHandle = (0, _setTimeout2.default)((0, _bind.default)(_context5 = function() {
            _this6.attempts++;
            _this6.connectPromise = (0, _promiseUtils.resolvingPromise)();
            _this6.open();
          }).call(_context5, this), time);
        }
      }]);
      return LiveQueryClient2;
    }(_EventEmitter2.default);
    _CoreManager.default.setWebSocketController(typeof WebSocket === "function" || (typeof WebSocket === "undefined" ? "undefined" : (0, _typeof2.default)(WebSocket)) === "object" ? WebSocket : null);
    var _default = LiveQueryClient;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/ParseLiveQuery.js
var require_ParseLiveQuery = __commonJS({
  "node_modules/moralis-v1/lib/browser/ParseLiveQuery.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _promise = _interopRequireDefault(require_promise3());
    var _indexOf = _interopRequireDefault(require_index_of8());
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _EventEmitter = _interopRequireDefault(require_EventEmitter());
    var _LiveQueryClient = _interopRequireDefault(require_LiveQueryClient());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    function getLiveQueryClient() {
      return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();
    }
    var LiveQuery = new _EventEmitter.default();
    LiveQuery.open = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
      var liveQueryClient;
      return _regenerator.default.wrap(function(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getLiveQueryClient();
            case 2:
              liveQueryClient = _context.sent;
              liveQueryClient.open();
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    LiveQuery.close = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
      var liveQueryClient;
      return _regenerator.default.wrap(function(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getLiveQueryClient();
            case 2:
              liveQueryClient = _context2.sent;
              liveQueryClient.close();
            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    LiveQuery.on("error", function() {
    });
    var _default = LiveQuery;
    exports.default = _default;
    var defaultLiveQueryClient;
    var DefaultLiveQueryController = {
      setDefaultLiveQueryClient: function(liveQueryClient) {
        defaultLiveQueryClient = liveQueryClient;
      },
      getDefaultLiveQueryClient: function() {
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3() {
          var _yield$Promise$all, _yield$Promise$all2, currentUser, installationId, sessionToken, liveQueryServerURL, serverURL, protocol, host, applicationId, javascriptKey, masterKey;
          return _regenerator.default.wrap(function(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!defaultLiveQueryClient) {
                    _context3.next = 2;
                    break;
                  }
                  return _context3.abrupt("return", defaultLiveQueryClient);
                case 2:
                  _context3.next = 4;
                  return _promise.default.all([_CoreManager.default.getUserController().currentUserAsync(), _CoreManager.default.getInstallationController().currentInstallationId()]);
                case 4:
                  _yield$Promise$all = _context3.sent;
                  _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 2);
                  currentUser = _yield$Promise$all2[0];
                  installationId = _yield$Promise$all2[1];
                  sessionToken = currentUser ? currentUser.getSessionToken() : void 0;
                  liveQueryServerURL = _CoreManager.default.get("LIVEQUERY_SERVER_URL");
                  if (!(liveQueryServerURL && (0, _indexOf.default)(liveQueryServerURL).call(liveQueryServerURL, "ws") !== 0)) {
                    _context3.next = 12;
                    break;
                  }
                  throw new Error("You need to set a proper Parse LiveQuery server url before using LiveQueryClient");
                case 12:
                  if (!liveQueryServerURL) {
                    serverURL = _CoreManager.default.get("SERVER_URL");
                    protocol = (0, _indexOf.default)(serverURL).call(serverURL, "https") === 0 ? "wss://" : "ws://";
                    host = serverURL.replace(/^https?:\/\//, "");
                    liveQueryServerURL = protocol + host;
                    _CoreManager.default.set("LIVEQUERY_SERVER_URL", liveQueryServerURL);
                  }
                  applicationId = _CoreManager.default.get("APPLICATION_ID");
                  javascriptKey = _CoreManager.default.get("JAVASCRIPT_KEY");
                  masterKey = _CoreManager.default.get("MASTER_KEY");
                  defaultLiveQueryClient = new _LiveQueryClient.default({
                    applicationId,
                    serverURL: liveQueryServerURL,
                    javascriptKey,
                    masterKey,
                    sessionToken,
                    installationId
                  });
                  defaultLiveQueryClient.on("error", function(error) {
                    LiveQuery.emit("error", error);
                  });
                  defaultLiveQueryClient.on("open", function() {
                    LiveQuery.emit("open");
                  });
                  defaultLiveQueryClient.on("close", function() {
                    LiveQuery.emit("close");
                  });
                  return _context3.abrupt("return", defaultLiveQueryClient);
                case 21:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },
      _clearCachedDefaultClient: function() {
        defaultLiveQueryClient = null;
      }
    };
    _CoreManager.default.setLiveQueryController(DefaultLiveQueryController);
  }
});

// node_modules/moralis-v1/lib/browser/UnitConvert.js
var require_UnitConvert = __commonJS({
  "node_modules/moralis-v1/lib/browser/UnitConvert.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    var UnitConverter = function() {
      function UnitConverter2() {
        (0, _classCallCheck2.default)(this, UnitConverter2);
      }
      (0, _createClass2.default)(UnitConverter2, null, [{
        key: "ETH",
        value: function(value) {
          return _ethers.ethers.utils.parseEther("".concat(value)).toString();
        }
      }, {
        key: "Token",
        value: function(value) {
          var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 18;
          return _ethers.ethers.utils.parseUnits("".concat(value), +decimals).toString();
        }
      }, {
        key: "FromWei",
        value: function(value) {
          var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 18;
          var result = _ethers.ethers.utils.formatUnits(value, decimals);
          var splitResult = result.split(".");
          if (splitResult[1] === "0") {
            return splitResult[0];
          }
          return result;
        }
      }]);
      return UnitConverter2;
    }();
    module.exports = UnitConverter;
  }
});

// node_modules/moralis-v1/lib/browser/MoralisUI.js
var require_MoralisUI = __commonJS({
  "node_modules/moralis-v1/lib/browser/MoralisUI.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var MoralisUI = {
      openPrompt: function() {
        return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
          return _regenerator.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  console.warn("Moralis: No prompt supplied");
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    };
    var _default = MoralisUI;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/Chains.js
var require_Chains = __commonJS({
  "node_modules/moralis-v1/lib/browser/Chains.js"(exports) {
    "use strict";
    var _Object$defineProperty = require_define_property3();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Chains = {
      ETH_MAINNET: "0x1",
      ETH_ROPSTEN: "0x3",
      ETH_GOERLI: "0x5",
      ETH_KOVAN: "0x2a",
      ETH_RINKEBY: "0x4",
      ETH_LOCALDEVCHAIN: "0x539",
      POLYGON_MAINNET: "0x89",
      POLYGON_MUMBAI: "0x13881",
      BSC_MAINNET: "0x38",
      BSC_TESTNET: "0x61",
      AVAX_MAINNET: "0xa86a",
      AVAX_TESTNET: "0xa869",
      FANTOM_MAINNET: "0xfa",
      CRONOS_MAINNET: "0x19",
      CRONOS_TESTNET: "0x152"
    };
    var _default = Chains;
    exports.default = _default;
  }
});

// node_modules/moralis-v1/lib/browser/Parse.js
var require_Parse = __commonJS({
  "node_modules/moralis-v1/lib/browser/Parse.js"(exports, module) {
    "use strict";
    var _typeof = require_typeof();
    var _Reflect$construct = require_construct3();
    var _WeakMap = require_weak_map3();
    var _Object$defineProperty = require_define_property3();
    var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor3();
    var _interopRequireDefault = require_interopRequireDefault();
    var _promise = _interopRequireDefault(require_promise3());
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _decode2 = _interopRequireDefault(require_decode());
    var _encode3 = _interopRequireDefault(require_encode());
    var _CoreManager = _interopRequireDefault(require_CoreManager());
    var _CryptoController = _interopRequireDefault(require_CryptoController());
    var _InstallationController = _interopRequireDefault(require_InstallationController());
    var ParseOp = _interopRequireWildcard(require_ParseOp());
    var _RESTController2 = _interopRequireDefault(require_RESTController());
    var _MoralisWeb2 = _interopRequireDefault(require_MoralisWeb3());
    var _ethers = (init_lib31(), __toCommonJS(lib_exports5));
    var _filterConsole = require_filterConsole();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof _WeakMap !== "function")
        return null;
      var cacheBabelInterop = new _WeakMap();
      var cacheNodeInterop = new _WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      for (var key2 in obj) {
        if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
          var desc = _Object$defineProperty && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key2) : null;
          if (desc && (desc.get || desc.set)) {
            _Object$defineProperty(newObj, key2, desc);
          } else {
            newObj[key2] = obj[key2];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
          result = _Reflect$construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !_Reflect$construct)
        return false;
      if (_Reflect$construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var _require = require_utils();
    var checkForSdkUpdates = _require.checkForSdkUpdates;
    var trackEvent = _require.trackEvent;
    var TrackingEventName = _require.TrackingEventName;
    var getSubdomain = _require.getSubdomain;
    var Moralis = function(_MoralisWeb) {
      (0, _inherits2.default)(Moralis2, _MoralisWeb);
      var _super = _createSuper(Moralis2);
      function Moralis2() {
        (0, _classCallCheck2.default)(this, Moralis2);
        return _super.apply(this, arguments);
      }
      (0, _createClass2.default)(Moralis2, null, [{
        key: "start",
        value: (
          /**
           * Call this method to initialize all moralis instances (Moralis, Web3Api, plugins).
           *
           * @param {object} options Your Moralis Application ID and Server URL. Moralis.start({serverUrl,appId})
           * @static
           */
          function() {
            var _start = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(options) {
              var appId, serverUrl, plugins, javascriptKey, masterKey, moralisSecret, disableVersionCheck, apiKey, trackOptions, _yield$this$getApiKey, web3ApiKey, speedyNodeApiKey, apiHeaders;
              return _regenerator.default.wrap(function(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      appId = options.appId, serverUrl = options.serverUrl, plugins = options.plugins, javascriptKey = options.javascriptKey, masterKey = options.masterKey, moralisSecret = options.moralisSecret, disableVersionCheck = options.disableVersionCheck;
                      if (serverUrl) {
                        _context.next = 4;
                        break;
                      }
                      throw new Error("Moralis.start failed: serverUrl is required");
                    case 4:
                      if (appId) {
                        _context.next = 6;
                        break;
                      }
                      throw new Error("Moralis.start failed: appId is required");
                    case 6:
                      if (moralisSecret) {
                        console.warn("Moralis.start warning: Using moralisSecret on the browser enviroment reveals critical information.");
                      }
                      _context.next = 18;
                      break;
                    case 9:
                      if (!moralisSecret) {
                        _context.next = 18;
                        break;
                      }
                      this.moralisSecret = moralisSecret;
                      _context.next = 13;
                      return this.getApiKeys(moralisSecret);
                    case 13:
                      _yield$this$getApiKey = _context.sent;
                      web3ApiKey = _yield$this$getApiKey.web3ApiKey;
                      speedyNodeApiKey = _yield$this$getApiKey.speedyNodeApiKey;
                      apiKey = web3ApiKey;
                      this.speedyNodeApiKey = speedyNodeApiKey;
                    case 18:
                      this.initialize(appId, javascriptKey, masterKey);
                      this.serverURL = serverUrl;
                      apiHeaders = {
                        "x-moralis-platform": "JS SDK",
                        "x-moralis-platform-version": "1.12.0",
                        "x-moralis-build-target": "browser"
                      };
                      this.Web3API.initialize({
                        serverUrl,
                        apiKey,
                        Moralis: Moralis2,
                        headers: apiHeaders
                      });
                      this.SolanaAPI.initialize({
                        serverUrl,
                        apiKey,
                        Moralis: Moralis2,
                        headers: apiHeaders
                      });
                      if (!(appId && serverUrl)) {
                        _context.next = 29;
                        break;
                      }
                      trackOptions = {
                        subdomain: getSubdomain(serverUrl),
                        sdk_type: "javascript",
                        sdk_version: "1.12.0",
                        sdk_enviroment: "browser",
                        appId
                      };
                      _context.next = 27;
                      return this.initPlugins(plugins);
                    case 27:
                      _context.next = 30;
                      break;
                    case 29:
                      trackOptions = {
                        sdk_type: "javascript",
                        sdk_version: "1.12.0",
                        sdk_enviroment: "browser"
                      };
                    case 30:
                      checkForSdkUpdates();
                      trackEvent(TrackingEventName.START_FUNCTION, serverUrl ? getSubdomain(serverUrl) : null, trackOptions);
                    case 32:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));
            return function() {
              return _start.apply(this, arguments);
            };
          }()
        )
        /**
         * Call this method to get apiKeys using moralis secret.
         *
         * @param {string} moralisSecret Your MoralisSecret
         * @static
         */
      }, {
        key: "getApiKeys",
        value: function() {
          var _getApiKeys = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(moralisSecret) {
            var _RESTController, response;
            return _regenerator.default.wrap(function(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    _RESTController = _CoreManager.default.getRESTController();
                    _context2.next = 4;
                    return _RESTController.ajax("GET", "https://admin.moralis.io/api/publics/apiKeys", null, {
                      "moralis-secret": moralisSecret,
                      Accept: "application/json",
                      "Content-Type": "application/json"
                    });
                  case 4:
                    response = _context2.sent;
                    return _context2.abrupt("return", response.response.result);
                  case 8:
                    _context2.prev = 8;
                    _context2.t0 = _context2["catch"](0);
                    throw new Error("Could not fetch keys with moralisSecret");
                  case 11:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, null, [[0, 8]]);
          }));
          return function() {
            return _getApiKeys.apply(this, arguments);
          };
        }()
        /**
         * Call this method first to set up your authentication tokens for Moralis.
         *
         * @param {string} applicationId Your Moralis Application ID.
         * @param {string} [javaScriptKey] Your Moralis JavaScript Key (Not needed for moralis-server)
         * @param {string} [masterKey] Your Moralis Master Key. (Node.js only!)
         * @static
         */
      }, {
        key: "initialize",
        value: function(applicationId, javaScriptKey) {
          if (_CoreManager.default.get("IS_NODE") && !process.env.SERVER_RENDERING) {
            console.log("Moralis: It looks like you're using the browser version of the SDK in a node.js environment. You should require('moralis/node') instead.");
          }
          Moralis2._initialize(applicationId, javaScriptKey);
        }
      }, {
        key: "_initialize",
        value: function(applicationId, javaScriptKey, masterKey) {
          _CoreManager.default.set("APPLICATION_ID", applicationId);
          _CoreManager.default.set("JAVASCRIPT_KEY", javaScriptKey);
          _CoreManager.default.set("MASTER_KEY", masterKey);
          _CoreManager.default.set("USE_MASTER_KEY", false);
        }
        /**
         * Call this method to set your AsyncStorage engine
         * Starting Parse@1.11, the ParseSDK do not provide a React AsyncStorage as the ReactNative module
         * is not provided at a stable path and changes over versions.
         *
         * @param {AsyncStorage} storage a react native async storage.
         * @static
         */
      }, {
        key: "setAsyncStorage",
        value: function(storage) {
          _CoreManager.default.setAsyncStorage(storage);
        }
        /**
         * Call this method to set your LocalDatastoreStorage engine
         * If using React-Native use {@link Moralis.setAsyncStorage Moralis.setAsyncStorage()}
         *
         * @param {LocalDatastoreController} controller a data storage.
         * @static
         */
      }, {
        key: "setLocalDatastoreController",
        value: function(controller) {
          _CoreManager.default.setLocalDatastoreController(controller);
        }
        /**
         * @member {string} Moralis.applicationId
         * @static
         */
      }, {
        key: "applicationId",
        get: function() {
          return _CoreManager.default.get("APPLICATION_ID");
        },
        set: function(value) {
          _CoreManager.default.set("APPLICATION_ID", value);
        }
      }, {
        key: "javaScriptKey",
        get: function() {
          return _CoreManager.default.get("JAVASCRIPT_KEY");
        },
        set: function(value) {
          _CoreManager.default.set("JAVASCRIPT_KEY", value);
        }
      }, {
        key: "masterKey",
        get: function() {
          return _CoreManager.default.get("MASTER_KEY");
        },
        set: function(value) {
          _CoreManager.default.set("MASTER_KEY", value);
        }
      }, {
        key: "serverURL",
        get: function() {
          return _CoreManager.default.get("SERVER_URL");
        },
        set: function(value) {
          _CoreManager.default.set("SERVER_URL", value);
        }
      }, {
        key: "serverAuthToken",
        get: function() {
          return _CoreManager.default.get("SERVER_AUTH_TOKEN");
        },
        set: function(value) {
          _CoreManager.default.set("SERVER_AUTH_TOKEN", value);
        }
      }, {
        key: "serverAuthType",
        get: function() {
          return _CoreManager.default.get("SERVER_AUTH_TYPE");
        },
        set: function(value) {
          _CoreManager.default.set("SERVER_AUTH_TYPE", value);
        }
      }, {
        key: "liveQueryServerURL",
        get: function() {
          return _CoreManager.default.get("LIVEQUERY_SERVER_URL");
        },
        set: function(value) {
          _CoreManager.default.set("LIVEQUERY_SERVER_URL", value);
        }
      }, {
        key: "encryptedUser",
        get: function() {
          return _CoreManager.default.get("ENCRYPTED_USER");
        },
        set: function(value) {
          _CoreManager.default.set("ENCRYPTED_USER", value);
        }
      }, {
        key: "secret",
        get: function() {
          return _CoreManager.default.get("ENCRYPTED_KEY");
        },
        set: function(value) {
          _CoreManager.default.set("ENCRYPTED_KEY", value);
        }
      }, {
        key: "idempotency",
        get: function() {
          return _CoreManager.default.get("IDEMPOTENCY");
        },
        set: function(value) {
          _CoreManager.default.set("IDEMPOTENCY", value);
        }
      }]);
      return Moralis2;
    }(_MoralisWeb2.default);
    Moralis.ACL = require_ParseACL().default;
    Moralis.Analytics = require_Analytics();
    Moralis.AnonymousUtils = require_AnonymousUtils().default;
    Moralis.Cloud = require_Cloud();
    Moralis.CLP = require_ParseCLP().default;
    Moralis.CoreManager = require_CoreManager();
    Moralis.Config = require_ParseConfig().default;
    Moralis.Error = require_ParseError().default;
    Moralis.FacebookUtils = require_FacebookUtils().default;
    Moralis.File = require_ParseFile().default;
    Moralis.GeoPoint = require_ParseGeoPoint().default;
    Moralis.Polygon = require_ParsePolygon().default;
    Moralis.Installation = require_ParseInstallation().default;
    Moralis.LocalDatastore = require_LocalDatastore();
    Moralis.Object = require_ParseObject().default;
    Moralis.Op = {
      Set: ParseOp.SetOp,
      Unset: ParseOp.UnsetOp,
      Increment: ParseOp.IncrementOp,
      Add: ParseOp.AddOp,
      Remove: ParseOp.RemoveOp,
      AddUnique: ParseOp.AddUniqueOp,
      Relation: ParseOp.RelationOp
    };
    Moralis.Web3API = require_MoralisWeb3Api().default;
    Moralis.SolanaAPI = require_MoralisSolanaApi().default;
    Moralis.Push = require_Push();
    Moralis.Query = require_ParseQuery().default;
    Moralis.Relation = require_ParseRelation().default;
    Moralis.Role = require_ParseRole().default;
    Moralis.Schema = require_ParseSchema().default;
    Moralis.Session = require_ParseSession().default;
    Moralis.Storage = require_Storage();
    Moralis.User = require_ParseUser().default;
    Moralis.LiveQuery = require_ParseLiveQuery().default;
    Moralis.LiveQueryClient = require_LiveQueryClient().default;
    Moralis.Web3 = Moralis;
    Moralis.Units = require_UnitConvert();
    Moralis.Elrond = require_MoralisErd().default;
    Moralis.Erd = Moralis.Elrond;
    Moralis.Dot = require_MoralisDot().default;
    Moralis.UI = require_MoralisUI().default;
    Moralis.Chains = require_Chains().default;
    Moralis.AbstractWeb3Connector = require_AbstractWeb3Connector().default;
    (0, _filterConsole.filterConsole)();
    Moralis._request = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _CoreManager.default.getRESTController().request.apply(null, args);
    };
    Moralis._ajax = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _CoreManager.default.getRESTController().ajax.apply(null, args);
    };
    Moralis._decode = function(_2, value) {
      return (0, _decode2.default)(value);
    };
    Moralis._encode = function(value, _2, disallowObjects) {
      return (0, _encode3.default)(value, disallowObjects);
    };
    Moralis._getInstallationId = function() {
      return _CoreManager.default.getInstallationController().currentInstallationId();
    };
    Moralis.enableLocalDatastore = function() {
      Moralis.LocalDatastore.isEnabled = true;
    };
    Moralis.isLocalDatastoreEnabled = function() {
      return Moralis.LocalDatastore.isEnabled;
    };
    Moralis.dumpLocalDatastore = function() {
      if (!Moralis.LocalDatastore.isEnabled) {
        console.log("Moralis: Moralis.enableLocalDatastore() must be called first");
        return _promise.default.resolve({});
      }
      return Moralis.LocalDatastore._getAllContents();
    };
    Moralis.enableEncryptedUser = function() {
      Moralis.encryptedUser = true;
    };
    Moralis.isEncryptedUserEnabled = function() {
      return Moralis.encryptedUser;
    };
    _CoreManager.default.setCryptoController(_CryptoController.default);
    _CoreManager.default.setInstallationController(_InstallationController.default);
    _CoreManager.default.setRESTController(_RESTController2.default);
    Moralis.Moralis = Moralis;
    module.exports = Moralis;
  }
});

// node_modules/moralis-v1/index.js
var require_moralis_v1 = __commonJS({
  "node_modules/moralis-v1/index.js"(exports, module) {
    module.exports = require_Parse();
  }
});

// node_modules/react-moralis/lib/index.esm.js
var import_react2 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_moralis_v1 = __toESM(require_moralis_v1());
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __awaiter17(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f3 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var DEFAULT_API_CHAIN = "eth";
var Plugin;
(function(Plugin2) {
  Plugin2["ONE_INCH"] = "oneInch";
  Plugin2["OPEN_SEA"] = "opensea";
  Plugin2["FIAT"] = "fiat";
  Plugin2["RARIBLE"] = "rarible";
})(Plugin || (Plugin = {}));
var supportedChains = [
  "0x1",
  "0x3",
  "0x4",
  "0x5",
  "0x2a",
  "0x38",
  "0x61",
  "0x89",
  "0x13881",
  "0xfa",
  "0xa86a",
  "0xa869",
  "0x539",
  "0x19"
];
var blockExplorers = {
  "0x1": "https://etherscan.io/",
  "0x3": "https://ropsten.etherscan.io/",
  "0x4": "https://rinkeby.etherscan.io/",
  "0x2a": "https://kovan.etherscan.io/",
  "0x5": "https://goerli.etherscan.io/",
  "0x539": null,
  "0xa86a": "https://cchain.explorer.avax.network/",
  "0xa869": "https://explorer.avax-test.network/",
  "0x38": "https://bscscan.com/",
  "0x61": "https://testnet.bscscan.com",
  "0x89": "https://explorer-mainnet.maticvigil.com",
  "0x13881": "https://mumbai.polygonscan.com",
  "0xfa": "https://ftmscan.com/",
  "0x19": "https://cronoscan.com/"
};
var chains = [
  {
    name: "Ethereum Mainnet",
    chainId: 1,
    shortName: "eth",
    networkId: 1,
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpc: [
      "https://mainnet.infura.io/v3/${INFURA_API_KEY}",
      "wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}",
      "https://api.mycryptoapi.com/eth",
      "https://cloudflare-eth.com"
    ],
    faucets: [],
    infoURL: "https://ethereum.org"
  },
  {
    name: "Expanse Network",
    chainId: 2,
    shortName: "exp",
    networkId: 1,
    nativeCurrency: {
      name: "Expanse Network Ether",
      symbol: "EXP",
      decimals: 18
    },
    rpc: ["https://node.expanse.tech"],
    faucets: [],
    infoURL: "https://expanse.tech"
  },
  {
    name: "Ethereum Testnet Ropsten",
    chainId: 3,
    shortName: "rop",
    networkId: 3,
    nativeCurrency: { name: "Ropsten Ether", symbol: "ROP", decimals: 18 },
    rpc: [
      "https://ropsten.infura.io/v3/${INFURA_API_KEY}",
      "wss://ropsten.infura.io/ws/v3/${INFURA_API_KEY}"
    ],
    faucets: ["https://faucet.ropsten.be?${ADDRESS}"],
    infoURL: "https://github.com/ethereum/ropsten"
  },
  {
    name: "Ethereum Testnet Rinkeby",
    chainId: 4,
    shortName: "rin",
    networkId: 4,
    nativeCurrency: { name: "Rinkeby Ether", symbol: "RIN", decimals: 18 },
    rpc: [
      "https://rinkeby.infura.io/v3/${INFURA_API_KEY}",
      "wss://rinkeby.infura.io/ws/v3/${INFURA_API_KEY}"
    ],
    faucets: ["https://faucet.rinkeby.io"],
    infoURL: "https://www.rinkeby.io"
  },
  {
    name: "Ethereum Testnet Görli",
    chainId: 5,
    shortName: "gor",
    networkId: 5,
    nativeCurrency: { name: "Görli Ether", symbol: "GOR", decimals: 18 },
    rpc: [
      "https://rpc.goerli.mudit.blog/",
      "https://rpc.slock.it/goerli",
      "https://goerli.prylabs.net/"
    ],
    faucets: [
      "https://goerli-faucet.slock.it/?address=${ADDRESS}",
      "https://faucet.goerli.mudit.blog"
    ],
    infoURL: "https://goerli.net/#about"
  },
  {
    name: "Ethereum Classic Testnet Kotti",
    chainId: 6,
    shortName: "kot",
    networkId: 6,
    nativeCurrency: { name: "Kotti Ether", symbol: "KOT", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://explorer.jade.builders/?network=kotti"
  },
  {
    name: "ThaiChain",
    chainId: 7,
    shortName: "tch",
    networkId: 7,
    nativeCurrency: { name: "ThaiChain Ether", symbol: "TCH", decimals: 18 },
    rpc: ["https://rpc.dome.cloud"],
    faucets: [],
    infoURL: "https://thaichain.io"
  },
  {
    name: "Ubiq",
    chainId: 8,
    shortName: "ubq",
    networkId: 8,
    nativeCurrency: { name: "Ubiq Ether", symbol: "UBQ", decimals: 18 },
    rpc: ["https://rpc.octano.dev", "https://pyrus2.ubiqscan.io"],
    faucets: [],
    infoURL: "https://ubiqsmart.com"
  },
  {
    name: "Ubiq Network Testnet",
    chainId: 9,
    shortName: "tubq",
    networkId: 2,
    nativeCurrency: {
      name: "Ubiq Testnet Ether",
      symbol: "TUBQ",
      decimals: 18
    },
    rpc: [],
    faucets: [],
    infoURL: "https://ethersocial.org"
  },
  {
    name: "Optimistic Ethereum",
    chainId: 10,
    shortName: "oeth",
    networkId: 10,
    nativeCurrency: { name: "Ether", symbol: "OETH", decimals: 18 },
    rpc: ["https://mainnet.optimism.io/"],
    faucets: [],
    infoURL: "https://optimism.io"
  },
  {
    name: "Metadium Mainnet",
    chainId: 11,
    shortName: "meta",
    networkId: 11,
    nativeCurrency: {
      name: "Metadium Mainnet Ether",
      symbol: "META",
      decimals: 18
    },
    rpc: ["https://api.metadium.com/prod"],
    faucets: [],
    infoURL: "https://metadium.com"
  },
  {
    name: "Metadium Testnet",
    chainId: 12,
    shortName: "kal",
    networkId: 12,
    nativeCurrency: {
      name: "Metadium Testnet Ether",
      symbol: "KAL",
      decimals: 18
    },
    rpc: ["https://api.metadium.com/dev"],
    faucets: [],
    infoURL: "https://metadium.com"
  },
  {
    name: "Diode Testnet Staging",
    chainId: 13,
    shortName: "dstg",
    networkId: 13,
    nativeCurrency: { name: "Staging Diodes", symbol: "sDIODE", decimals: 18 },
    rpc: ["https://staging.diode.io:8443/", "wss://staging.diode.io:8443/ws"],
    faucets: [],
    infoURL: "https://diode.io/staging"
  },
  {
    name: "Flare Mainnet",
    chainId: 14,
    shortName: "flr",
    networkId: 14,
    nativeCurrency: { name: "Spark", symbol: "FLR", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://flare.xyz"
  },
  {
    name: "Diode Prenet",
    chainId: 15,
    shortName: "diode",
    networkId: 15,
    nativeCurrency: { name: "Diodes", symbol: "DIODE", decimals: 18 },
    rpc: ["https://prenet.diode.io:8443/", "wss://prenet.diode.io:8443/ws"],
    faucets: [],
    infoURL: "https://diode.io/prenet"
  },
  {
    name: "Flare Testnet Coston",
    chainId: 16,
    shortName: "cflr",
    networkId: 16,
    nativeCurrency: { name: "Coston Spark", symbol: "CFLR", decimals: 18 },
    rpc: [],
    faucets: ["https://faucet.towolabs.com"],
    infoURL: "https://github.com/flare-eng/coston"
  },
  {
    name: "ThaiChain 2.0 ThaiFi",
    chainId: 17,
    shortName: "tfi",
    networkId: 17,
    nativeCurrency: { name: "Thaifi Ether", symbol: "TFI", decimals: 18 },
    rpc: ["https://rpc.thaifi.com"],
    faucets: [],
    infoURL: "https://exp.thaifi.com"
  },
  {
    name: "ThunderCore Testnet",
    chainId: 18,
    shortName: "TST",
    networkId: 18,
    nativeCurrency: {
      name: "ThunderCore Testnet Ether",
      symbol: "TST",
      decimals: 18
    },
    rpc: ["https://testnet-rpc.thundercore.com"],
    faucets: ["https://faucet-testnet.thundercore.com"],
    infoURL: "https://thundercore.com"
  },
  {
    name: "Songbird Canary-Network",
    chainId: 19,
    shortName: "sgb",
    networkId: 19,
    nativeCurrency: { name: "Songbird", symbol: "SGB", decimals: 18 },
    rpc: ["https://songbird.towolabs.com/rpc"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://flare.xyz"
  },
  {
    name: "ELA-ETH-Sidechain Mainnet",
    chainId: 20,
    shortName: "elaeth",
    networkId: 20,
    nativeCurrency: { name: "Elastos", symbol: "ELA", decimals: 18 },
    rpc: ["https://mainrpc.elaeth.io"],
    faucets: [],
    infoURL: "https://www.elastos.org/"
  },
  {
    name: "ELA-ETH-Sidechain Testnet",
    chainId: 21,
    shortName: "elaetht",
    networkId: 21,
    nativeCurrency: { name: "Elastos", symbol: "tELA", decimals: 18 },
    rpc: ["https://rpc.elaeth.io"],
    faucets: ["https://faucet.elaeth.io/"],
    infoURL: "https://elaeth.io/"
  },
  {
    name: "ELA-DID-Sidechain Mainnet",
    chainId: 22,
    shortName: "eladid",
    networkId: 22,
    nativeCurrency: { name: "Elastos", symbol: "ELA", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://www.elastos.org/"
  },
  {
    name: "ELA-DID-Sidechain Testnet",
    chainId: 23,
    shortName: "eladidt",
    networkId: 23,
    nativeCurrency: { name: "Elastos", symbol: "tELA", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://elaeth.io/"
  },
  {
    name: "Cronos Mainnet Beta",
    chainId: 25,
    shortName: "cro",
    networkId: 25,
    nativeCurrency: { name: "Crypto.org Coin", symbol: "CRO", decimals: 18 },
    rpc: ["https://evm-cronos.crypto.org"],
    faucets: [],
    infoURL: "https://cronos.crypto.org"
  },
  {
    name: "ShibaChain",
    chainId: 27,
    shortName: "shib",
    networkId: 27,
    nativeCurrency: { name: "SHIBA INU COIN", symbol: "SHIB", decimals: 18 },
    rpc: ["https://rpc.shibachain.net"],
    faucets: [],
    infoURL: "https://www.shibachain.net"
  },
  {
    name: "Boba Network Rinkeby Testnet",
    chainId: 28,
    shortName: "Boba Rinkeby",
    networkId: 28,
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpc: ["https://rinkeby.boba.network/"],
    faucets: [],
    infoURL: "https://boba.network"
  },
  {
    name: "RSK Mainnet",
    chainId: 30,
    shortName: "rsk",
    networkId: 30,
    nativeCurrency: { name: "RSK Mainnet Ether", symbol: "RBTC", decimals: 18 },
    rpc: ["https://public-node.rsk.co", "https://mycrypto.rsk.co"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://rsk.co"
  },
  {
    name: "RSK Testnet",
    chainId: 31,
    shortName: "trsk",
    networkId: 31,
    nativeCurrency: {
      name: "RSK Testnet Ether",
      symbol: "tRBTC",
      decimals: 18
    },
    rpc: [
      "https://public-node.testnet.rsk.co",
      "https://mycrypto.testnet.rsk.co"
    ],
    faucets: ["https://faucet.testnet.rsk.co"],
    infoURL: "https://rsk.co"
  },
  {
    name: "GoodData Testnet",
    chainId: 32,
    shortName: "GooDT",
    networkId: 32,
    nativeCurrency: {
      name: "GoodData Testnet Ether",
      symbol: "GooD",
      decimals: 18
    },
    rpc: ["https://test2.goodata.io"],
    faucets: [],
    infoURL: "https://www.goodata.org"
  },
  {
    name: "GoodData Mainnet",
    chainId: 33,
    shortName: "GooD",
    networkId: 33,
    nativeCurrency: {
      name: "GoodData Mainnet Ether",
      symbol: "GooD",
      decimals: 18
    },
    rpc: ["https://rpc.goodata.io"],
    faucets: [],
    infoURL: "https://www.goodata.org"
  },
  {
    name: "TBWG Chain",
    chainId: 35,
    shortName: "tbwg",
    networkId: 35,
    nativeCurrency: { name: "TBWG Ether", symbol: "TBG", decimals: 18 },
    rpc: ["https://rpc.tbwg.io"],
    faucets: [],
    infoURL: "https://tbwg.io"
  },
  {
    name: "Valorbit",
    chainId: 38,
    shortName: "val",
    networkId: 38,
    nativeCurrency: { name: "Valorbit", symbol: "VAL", decimals: 18 },
    rpc: ["https://rpc.valorbit.com/v2"],
    faucets: [],
    infoURL: "https://valorbit.com"
  },
  {
    name: "Telos EVM Mainnet",
    chainId: 40,
    shortName: "Telos EVM",
    networkId: 40,
    nativeCurrency: { name: "Telos", symbol: "TLOS", decimals: 18 },
    rpc: ["https://mainnet.telos.net/evm"],
    faucets: [],
    infoURL: "https://telos.net"
  },
  {
    name: "Telos EVM Testnet",
    chainId: 41,
    shortName: "Telos EVM Testnet",
    networkId: 41,
    nativeCurrency: { name: "Telos", symbol: "TLOS", decimals: 18 },
    rpc: ["https://testnet.telos.net/evm"],
    faucets: ["https://app.telos.net/testnet/developers"],
    infoURL: "https://telos.net"
  },
  {
    name: "Ethereum Testnet Kovan",
    chainId: 42,
    shortName: "kov",
    networkId: 42,
    nativeCurrency: { name: "Kovan Ether", symbol: "KOV", decimals: 18 },
    rpc: [
      "https://kovan.poa.network",
      "http://kovan.poa.network:8545",
      "https://kovan.infura.io/v3/${INFURA_API_KEY}",
      "wss://kovan.infura.io/ws/v3/${INFURA_API_KEY}",
      "ws://kovan.poa.network:8546"
    ],
    faucets: [
      "https://faucet.kovan.network",
      "https://gitter.im/kovan-testnet/faucet"
    ],
    infoURL: "https://kovan-testnet.github.io/website"
  },
  {
    name: "Darwinia Pangolin Testnet",
    chainId: 43,
    shortName: "darwinia",
    networkId: 43,
    nativeCurrency: { name: "Pangolin RING", symbol: "PRING", decimals: 9 },
    rpc: [],
    faucets: [],
    infoURL: "https://darwinia.network/"
  },
  {
    name: "Darwinia Crab Network",
    chainId: 44,
    shortName: "crab",
    networkId: 44,
    nativeCurrency: { name: "Crab Token", symbol: "CRING", decimals: 9 },
    rpc: [],
    faucets: [],
    infoURL: "https://crab.network/"
  },
  {
    name: "XinFin Network Mainnet",
    chainId: 50,
    shortName: "xdc",
    networkId: 50,
    nativeCurrency: { name: "XinFin", symbol: "XDC", decimals: 18 },
    rpc: ["https://rpc.xinfin.network"],
    faucets: [],
    infoURL: "https://xinfin.org"
  },
  {
    name: "XinFin Apothem Testnet",
    chainId: 51,
    shortName: "TXDC",
    networkId: 51,
    nativeCurrency: { name: "XinFinTest", symbol: "TXDC", decimals: 18 },
    rpc: ["https://rpc.apothem.network"],
    faucets: [],
    infoURL: "https://xinfin.org"
  },
  {
    name: "CoinEx Smart Chain Mainnet",
    chainId: 52,
    shortName: "cet",
    networkId: 52,
    nativeCurrency: {
      name: "CoinEx Chain Native Token",
      symbol: "cet",
      decimals: 18
    },
    rpc: ["https://rpc-mainnet.coinex.net"],
    faucets: [],
    infoURL: "http://www.coinex.org/"
  },
  {
    name: "CoinEx Smart Chain Testnet",
    chainId: 53,
    shortName: "tcet",
    networkId: 53,
    nativeCurrency: {
      name: "CoinEx Chain Test Native Token",
      symbol: "cett",
      decimals: 18
    },
    rpc: ["https://rpc-testnet.coinex.net"],
    faucets: [],
    infoURL: "http://www.coinex.org/"
  },
  {
    name: "Zyx Mainnet",
    chainId: 55,
    shortName: "ZYX",
    networkId: 55,
    nativeCurrency: { name: "Zyx", symbol: "ZYX", decimals: 18 },
    rpc: [
      "https://rpc-1.zyx.network/",
      "https://rpc-2.zyx.network/",
      "https://rpc-3.zyx.network/",
      "https://rpc-4.zyx.network/",
      "https://rpc-5.zyx.network/",
      "https://rpc-6.zyx.network/"
    ],
    faucets: [],
    infoURL: "https://zyx.network/"
  },
  {
    name: "Binance Smart Chain Mainnet",
    chainId: 56,
    shortName: "bnb",
    networkId: 56,
    nativeCurrency: {
      name: "Binance Chain Native Token",
      symbol: "BNB",
      decimals: 18
    },
    rpc: [
      "https://bsc-dataseed1.binance.org",
      "https://bsc-dataseed2.binance.org",
      "https://bsc-dataseed3.binance.org",
      "https://bsc-dataseed4.binance.org",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed4.defibit.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io",
      "https://bsc-dataseed4.ninicoin.io",
      "wss://bsc-ws-node.nariox.org"
    ],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://www.binance.org"
  },
  {
    name: "Ontology Mainnet",
    chainId: 58,
    shortName: "Ontology Mainnet",
    networkId: 58,
    nativeCurrency: { name: "ONG", symbol: "ONG", decimals: 9 },
    rpc: [
      "https://dappnode1.ont.io:20339",
      "https://dappnode2.ont.io:20339",
      "https://dappnode3.ont.io:20339",
      "https://dappnode4.ont.io:20339"
    ],
    faucets: [],
    infoURL: "https://ont.io/"
  },
  {
    name: "EOS Mainnet",
    chainId: 59,
    shortName: "EOS Mainnet",
    networkId: 59,
    nativeCurrency: { name: "EOS", symbol: "EOS", decimals: 18 },
    rpc: ["https://api.eosargentina.io"],
    faucets: [],
    infoURL: "https://eoscommunity.org/"
  },
  {
    name: "GoChain",
    chainId: 60,
    shortName: "go",
    networkId: 60,
    nativeCurrency: { name: "GoChain Ether", symbol: "GO", decimals: 18 },
    rpc: ["https://rpc.gochain.io"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://gochain.io"
  },
  {
    name: "Ethereum Classic Mainnet",
    chainId: 61,
    shortName: "etc",
    networkId: 1,
    nativeCurrency: {
      name: "Ethereum Classic Ether",
      symbol: "ETC",
      decimals: 18
    },
    rpc: ["https://ethereumclassic.network"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/?"],
    infoURL: "https://ethereumclassic.org"
  },
  {
    name: "Ethereum Classic Testnet Morden",
    chainId: 62,
    shortName: "tetc",
    networkId: 2,
    nativeCurrency: {
      name: "Ethereum Classic Testnet Ether",
      symbol: "TETC",
      decimals: 18
    },
    rpc: [],
    faucets: [],
    infoURL: "https://ethereumclassic.org"
  },
  {
    name: "Ethereum Classic Testnet Mordor",
    chainId: 63,
    shortName: "metc",
    networkId: 7,
    nativeCurrency: {
      name: "Mordor Classic Testnet Ether",
      symbol: "METC",
      decimals: 18
    },
    rpc: [],
    faucets: [],
    infoURL: "https://github.com/eth-classic/mordor/"
  },
  {
    name: "Ellaism",
    chainId: 64,
    shortName: "ella",
    networkId: 64,
    nativeCurrency: { name: "Ellaism Ether", symbol: "ELLA", decimals: 18 },
    rpc: ["https://jsonrpc.ellaism.org"],
    faucets: [],
    infoURL: "https://ellaism.org"
  },
  {
    name: "OKExChain Testnet",
    chainId: 65,
    shortName: "tokt",
    networkId: 65,
    nativeCurrency: {
      name: "OKExChain Global Utility Token in testnet",
      symbol: "OKT",
      decimals: 18
    },
    rpc: ["https://exchaintestrpc.okex.org"],
    faucets: ["https://www.okex.com/drawdex"],
    infoURL: "https://www.okex.com/okexchain"
  },
  {
    name: "OKExChain Mainnet",
    chainId: 66,
    shortName: "okt",
    networkId: 66,
    nativeCurrency: {
      name: "OKExChain Global Utility Token",
      symbol: "OKT",
      decimals: 18
    },
    rpc: ["https://exchainrpc.okex.org"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/?"],
    infoURL: "https://www.okex.com/okexchain"
  },
  {
    name: "DBChain Testnet",
    chainId: 67,
    shortName: "dbm",
    networkId: 67,
    nativeCurrency: { name: "DBChain Testnet", symbol: "DBM", decimals: 18 },
    rpc: ["http://test-rpc.dbmbp.com"],
    faucets: [],
    infoURL: "http://test.dbmbp.com"
  },
  {
    name: "SoterOne Mainnet",
    chainId: 68,
    shortName: "SO1",
    networkId: 68,
    nativeCurrency: {
      name: "SoterOne Mainnet Ether",
      symbol: "SOTER",
      decimals: 18
    },
    rpc: ["https://rpc.soter.one"],
    faucets: [],
    infoURL: "https://www.soterone.com"
  },
  {
    name: "Optimistic Ethereum Testnet Kovan",
    chainId: 69,
    shortName: "okov",
    networkId: 69,
    nativeCurrency: { name: "Kovan Ether", symbol: "KOR", decimals: 18 },
    rpc: ["https://kovan.optimism.io/"],
    faucets: [],
    infoURL: "https://optimism.io"
  },
  {
    name: "Mix",
    chainId: 76,
    shortName: "mix",
    networkId: 76,
    nativeCurrency: { name: "Mix Ether", symbol: "MIX", decimals: 18 },
    rpc: ["https://rpc2.mix-blockchain.org:8647"],
    faucets: [],
    infoURL: "https://mix-blockchain.org"
  },
  {
    name: "POA Network Sokol",
    chainId: 77,
    shortName: "skl",
    networkId: 77,
    nativeCurrency: { name: "POA Sokol Ether", symbol: "SKL", decimals: 18 },
    rpc: [
      "https://sokol.poa.network",
      "wss://sokol.poa.network/wss",
      "ws://sokol.poa.network:8546"
    ],
    faucets: ["https://faucet-sokol.herokuapp.com"],
    infoURL: "https://poa.network"
  },
  {
    name: "PrimusChain mainnet",
    chainId: 78,
    shortName: "primuschain",
    networkId: 78,
    nativeCurrency: { name: "Primus Ether", symbol: "PETH", decimals: 18 },
    rpc: ["https://ethnode.primusmoney.com/mainnet"],
    faucets: [],
    infoURL: "https://primusmoney.com"
  },
  {
    name: "GeneChain",
    chainId: 80,
    shortName: "GeneChain",
    networkId: 80,
    nativeCurrency: { name: "RNA", symbol: "RNA", decimals: 18 },
    rpc: ["https://rpc.genechain.io"],
    faucets: [],
    infoURL: "https://scan.genechain.io/"
  },
  {
    name: "Meter Mainnet",
    chainId: 82,
    shortName: "Meter",
    networkId: 82,
    nativeCurrency: { name: "Meter", symbol: "MTR", decimals: 18 },
    rpc: ["https://rpc.meter.io"],
    faucets: ["https://faucet.meter.io"],
    infoURL: "https://www.meter.io"
  },
  {
    name: "Meter Testnet",
    chainId: 83,
    shortName: "MeterTest",
    networkId: 83,
    nativeCurrency: { name: "Meter", symbol: "MTR", decimals: 18 },
    rpc: ["https://rpctest.meter.io"],
    faucets: ["https://faucet-warringstakes.meter.io"],
    infoURL: "https://www.meter.io"
  },
  {
    name: "GateChain Testnet",
    chainId: 85,
    shortName: "gttest",
    networkId: 85,
    nativeCurrency: { name: "GateToken", symbol: "GT", decimals: 18 },
    rpc: ["https://testnet.gatenode.cc"],
    faucets: ["https://www.gatescan.org/testnet/faucet"],
    infoURL: "https://www.gatechain.io"
  },
  {
    name: "GateChain Mainnet",
    chainId: 86,
    shortName: "gt",
    networkId: 86,
    nativeCurrency: { name: "GateToken", symbol: "GT", decimals: 18 },
    rpc: ["https://evm.gatenode.cc"],
    faucets: ["https://www.gatescan.org/faucet"],
    infoURL: "https://www.gatechain.io"
  },
  {
    name: "TomoChain",
    chainId: 88,
    shortName: "tomo",
    networkId: 88,
    nativeCurrency: { name: "TomoChain Ether", symbol: "TOMO", decimals: 18 },
    rpc: ["https://rpc.tomochain.com"],
    faucets: [],
    infoURL: "https://tomocoin.io"
  },
  {
    name: "CryptoKylin Testnet",
    chainId: 95,
    shortName: "Kylin Testnet",
    networkId: 95,
    nativeCurrency: { name: "EOS", symbol: "EOS", decimals: 18 },
    rpc: ["https://kylin.eosargentina.io"],
    faucets: [],
    infoURL: "https://www.cryptokylin.io/"
  },
  {
    name: "NEXT Smart Chain",
    chainId: 96,
    shortName: "nsc",
    networkId: 96,
    nativeCurrency: { name: "NEXT", symbol: "NEXT", decimals: 18 },
    rpc: ["https://rpc.nextsmartchain.com"],
    faucets: ["https://faucet.nextsmartchain.com"],
    infoURL: "https://www.nextsmartchain.com/"
  },
  {
    name: "Binance Smart Chain Testnet",
    chainId: 97,
    shortName: "bnbt",
    networkId: 97,
    nativeCurrency: {
      name: "Binance Chain Native Token",
      symbol: "tBNB",
      decimals: 18
    },
    rpc: [
      "https://data-seed-prebsc-1-s1.binance.org:8545",
      "https://data-seed-prebsc-2-s1.binance.org:8545",
      "https://data-seed-prebsc-1-s2.binance.org:8545",
      "https://data-seed-prebsc-2-s2.binance.org:8545",
      "https://data-seed-prebsc-1-s3.binance.org:8545",
      "https://data-seed-prebsc-2-s3.binance.org:8545"
    ],
    faucets: ["https://testnet.binance.org/faucet-smart"],
    infoURL: "https://testnet.binance.org/"
  },
  {
    name: "POA Network Core",
    chainId: 99,
    shortName: "poa",
    networkId: 99,
    nativeCurrency: {
      name: "POA Network Core Ether",
      symbol: "POA",
      decimals: 18
    },
    rpc: [
      "https://core.poanetwork.dev",
      "http://core.poanetwork.dev:8545",
      "https://core.poa.network",
      "ws://core.poanetwork.dev:8546"
    ],
    faucets: [],
    infoURL: "https://poa.network"
  },
  {
    name: "xDAI Chain",
    chainId: 100,
    shortName: "xdai",
    networkId: 100,
    nativeCurrency: { name: "xDAI", symbol: "xDAI", decimals: 18 },
    rpc: [
      "https://rpc.xdaichain.com",
      "https://xdai.poanetwork.dev",
      "wss://rpc.xdaichain.com/wss",
      "wss://xdai.poanetwork.dev/wss",
      "http://xdai.poanetwork.dev",
      "https://dai.poa.network",
      "ws://xdai.poanetwork.dev:8546"
    ],
    faucets: [
      "https://free-online-app.com/faucet-for-eth-evm-chains/",
      "https://xdai-app.herokuapp.com/faucet"
    ],
    infoURL: "https://forum.poa.network/c/xdai-chain"
  },
  {
    name: "EtherInc",
    chainId: 101,
    shortName: "eti",
    networkId: 1,
    nativeCurrency: { name: "EtherInc Ether", symbol: "ETI", decimals: 18 },
    rpc: ["https://api.einc.io/jsonrpc/mainnet"],
    faucets: [],
    infoURL: "https://einc.io"
  },
  {
    name: "Web3Games Testnet",
    chainId: 102,
    shortName: "w3g",
    networkId: 102,
    nativeCurrency: { name: "Web3Games", symbol: "W3G", decimals: 18 },
    rpc: ["https://substrate.org.cn"],
    faucets: [],
    infoURL: "https://web3games.org/"
  },
  {
    name: "Velas EVM Mainnet",
    chainId: 106,
    shortName: "vlx",
    networkId: 106,
    nativeCurrency: { name: "Velas", symbol: "VLX", decimals: 18 },
    rpc: [
      "https://evmexplorer.velas.com/rpc",
      "https://explorer.velas.com/rpc"
    ],
    faucets: [],
    infoURL: "https://velas.com"
  },
  {
    name: "ThunderCore Mainnet",
    chainId: 108,
    shortName: "TT",
    networkId: 108,
    nativeCurrency: {
      name: "ThunderCore Mainnet Ether",
      symbol: "TT",
      decimals: 18
    },
    rpc: ["https://mainnet-rpc.thundercore.com"],
    faucets: ["https://faucet.thundercore.com"],
    infoURL: "https://thundercore.com"
  },
  {
    name: "Proton Testnet",
    chainId: 110,
    shortName: "xpr",
    networkId: 110,
    nativeCurrency: { name: "Proton", symbol: "XPR", decimals: 4 },
    rpc: ["https://protontestnet.greymass.com/"],
    faucets: [],
    infoURL: "https://protonchain.com"
  },
  {
    name: "EtherLite Chain",
    chainId: 111,
    shortName: "ETL",
    networkId: 111,
    nativeCurrency: { name: "EtherLite", symbol: "ETL", decimals: 18 },
    rpc: ["https://rpc.etherlite.org"],
    faucets: ["https://etherlite.org/faucets"],
    infoURL: "https://etherlite.org"
  },
  {
    name: "Fuse Mainnet",
    chainId: 122,
    shortName: "fuse",
    networkId: 122,
    nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
    rpc: ["https://rpc.fuse.io"],
    faucets: [],
    infoURL: "https://fuse.io/"
  },
  {
    name: "Fuse Sparknet",
    chainId: 123,
    shortName: "spark",
    networkId: 123,
    nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
    rpc: ["https://rpc.fusespark.io"],
    faucets: ["https://get.fusespark.io"],
    infoURL: "https://docs.fuse.io/general/fuse-network-blockchain/fuse-testnet"
  },
  {
    name: "Decentralized Web Mainnet",
    chainId: 124,
    shortName: "dwu",
    networkId: 124,
    nativeCurrency: {
      name: "Decentralized Web Utility",
      symbol: "DWU",
      decimals: 18
    },
    rpc: ["https://decentralized-web.tech/dw_rpc.php"],
    faucets: [],
    infoURL: "https://decentralized-web.tech/dw_chain.php"
  },
  {
    name: "Factory 127 Mainnet",
    chainId: 127,
    shortName: "feth",
    networkId: 127,
    nativeCurrency: { name: "Factory 127 Token", symbol: "FETH", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://www.factory127.com"
  },
  {
    name: "Huobi ECO Chain Mainnet",
    chainId: 128,
    shortName: "heco",
    networkId: 128,
    nativeCurrency: {
      name: "Huobi ECO Chain Native Token",
      symbol: "HT",
      decimals: 18
    },
    rpc: [
      "https://http-mainnet.hecochain.com",
      "wss://ws-mainnet.hecochain.com"
    ],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://www.hecochain.com"
  },
  {
    name: "Polygon Mainnet",
    chainId: 137,
    shortName: "MATIC",
    networkId: 137,
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpc: [
      "https://polygon-rpc.com/",
      "https://rpc-mainnet.matic.network",
      "https://matic-mainnet.chainstacklabs.com",
      "https://rpc-mainnet.maticvigil.com",
      "https://rpc-mainnet.matic.quiknode.pro",
      "https://matic-mainnet-full-rpc.bwarelabs.com"
    ],
    faucets: [],
    infoURL: "https://polygon.technology/"
  },
  {
    name: "DAX CHAIN",
    chainId: 142,
    shortName: "dax",
    networkId: 142,
    nativeCurrency: { name: "Prodax", symbol: "DAX", decimals: 18 },
    rpc: ["https://rpc.prodax.io"],
    faucets: [],
    infoURL: "https://prodax.io/"
  },
  {
    name: "Lightstreams Testnet",
    chainId: 162,
    shortName: "tpht",
    networkId: 162,
    nativeCurrency: { name: "Lightstreams PHT", symbol: "PHT", decimals: 18 },
    rpc: ["https://node.sirius.lightstreams.io"],
    faucets: ["https://discuss.lightstreams.network/t/request-test-tokens"],
    infoURL: "https://explorer.sirius.lightstreams.io"
  },
  {
    name: "Lightstreams Mainnet",
    chainId: 163,
    shortName: "pht",
    networkId: 163,
    nativeCurrency: { name: "Lightstreams PHT", symbol: "PHT", decimals: 18 },
    rpc: ["https://node.mainnet.lightstreams.io"],
    faucets: [],
    infoURL: "https://explorer.lightstreams.io"
  },
  {
    name: "HOO Smart Chain Testnet",
    chainId: 170,
    shortName: "hoosmartchain",
    networkId: 170,
    nativeCurrency: { name: "HOO", symbol: "HOO", decimals: 18 },
    rpc: ["https://http-testnet.hoosmartchain.com"],
    faucets: ["https://faucet-testnet.hscscan.com/"],
    infoURL: "https://www.hoosmartchain.com"
  },
  {
    name: "Latam-Blockchain Resil Testnet",
    chainId: 172,
    shortName: "resil",
    networkId: 172,
    nativeCurrency: {
      name: "Latam-Blockchain Resil Test Native Token",
      symbol: "usd",
      decimals: 18
    },
    rpc: ["https://rpc.latam-blockchain.com", "wss://ws.latam-blockchain.com"],
    faucets: ["https://faucet.latam-blockchain.com"],
    infoURL: "https://latam-blockchain.com"
  },
  {
    name: "Seele Mainnet",
    chainId: 186,
    shortName: "Seele",
    networkId: 186,
    nativeCurrency: { name: "Seele", symbol: "Seele", decimals: 18 },
    rpc: ["https://rpc.seelen.pro/"],
    faucets: [],
    infoURL: "https://seelen.pro/"
  },
  {
    name: "BitTorrent Chain Mainnet",
    chainId: 199,
    shortName: "BTT",
    networkId: 199,
    nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
    rpc: ["https://rpc.bittorrentchain.io/"],
    faucets: [],
    infoURL: "https://bittorrentchain.io/"
  },
  {
    name: "Arbitrum on xDai",
    chainId: 200,
    shortName: "aox",
    networkId: 200,
    nativeCurrency: { name: "xDAI", symbol: "xDAI", decimals: 18 },
    rpc: ["https://arbitrum.xdaichain.com/"],
    faucets: [],
    infoURL: "https://xdaichain.com"
  },
  {
    name: "Freight Trust Network",
    chainId: 211,
    shortName: "EDI",
    networkId: 0,
    nativeCurrency: {
      name: "Freight Trust Native",
      symbol: "0xF",
      decimals: 18
    },
    rpc: [
      "http://13.57.207.168:3435",
      "https://app.freighttrust.net/ftn/${API_KEY}"
    ],
    faucets: ["http://faucet.freight.sh"],
    infoURL: "https://freighttrust.com"
  },
  {
    name: "Permission",
    chainId: 222,
    shortName: "ASK",
    networkId: 2221,
    nativeCurrency: { name: "ASK", symbol: "ASK", decimals: 18 },
    rpc: ["https://blockchain-api-mainnet.permission.io/rpc"],
    faucets: [],
    infoURL: "https://permission.io/"
  },
  {
    name: "Energy Web Chain",
    chainId: 246,
    shortName: "ewt",
    networkId: 246,
    nativeCurrency: { name: "Energy Web Token", symbol: "EWT", decimals: 18 },
    rpc: ["https://rpc.energyweb.org", "wss://rpc.energyweb.org/ws"],
    faucets: [
      "https://faucet.carbonswap.exchange",
      "https://free-online-app.com/faucet-for-eth-evm-chains/"
    ],
    infoURL: "https://energyweb.org"
  },
  {
    name: "Fantom Opera",
    chainId: 250,
    shortName: "ftm",
    networkId: 250,
    nativeCurrency: { name: "Fantom", symbol: "FTM", decimals: 18 },
    rpc: ["https://rpc.ftm.tools"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://fantom.foundation"
  },
  {
    name: "Huobi ECO Chain Testnet",
    chainId: 256,
    shortName: "hecot",
    networkId: 256,
    nativeCurrency: {
      name: "Huobi ECO Chain Test Native Token",
      symbol: "htt",
      decimals: 18
    },
    rpc: [
      "https://http-testnet.hecochain.com",
      "wss://ws-testnet.hecochain.com"
    ],
    faucets: ["https://scan-testnet.hecochain.com/faucet"],
    infoURL: "https://testnet.hecoinfo.com"
  },
  {
    name: "SUR Blockchain Network",
    chainId: 262,
    shortName: "SUR",
    networkId: 1,
    nativeCurrency: { name: "Suren", symbol: "SRN", decimals: 18 },
    rpc: ["https://sur.nilin.org"],
    faucets: [],
    infoURL: "https://surnet.org"
  },
  {
    name: "High Performance Blockchain",
    chainId: 269,
    shortName: "hpb",
    networkId: 269,
    nativeCurrency: {
      name: "High Performance Blockchain Ether",
      symbol: "HPB",
      decimals: 18
    },
    rpc: ["https://hpbnode.com", "wss://ws.hpbnode.com"],
    faucets: ["https://myhpbwallet.com/"],
    infoURL: "https://hpb.io"
  },
  {
    name: "Boba Network",
    chainId: 288,
    shortName: "Boba",
    networkId: 288,
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpc: ["https://mainnet.boba.network/"],
    faucets: [],
    infoURL: "https://boba.network"
  },
  {
    name: "KCC Mainnet",
    chainId: 321,
    shortName: "kcs",
    networkId: 1,
    nativeCurrency: { name: "KuCoin Token", symbol: "KCS", decimals: 18 },
    rpc: [
      "https://rpc-mainnet.kcc.network",
      "wss://rpc-ws-mainnet.kcc.network"
    ],
    faucets: [],
    infoURL: "https://kcc.io"
  },
  {
    name: "KCC Testnet",
    chainId: 322,
    shortName: "kcst",
    networkId: 322,
    nativeCurrency: {
      name: "KuCoin Testnet Token",
      symbol: "tKCS",
      decimals: 18
    },
    rpc: [
      "https://rpc-testnet.kcc.network",
      "wss://rpc-ws-testnet.kcc.network"
    ],
    faucets: ["https://faucet-testnet.kcc.network"],
    infoURL: "https://scan-testnet.kcc.network"
  },
  {
    name: "Shiden",
    chainId: 336,
    shortName: "sdn",
    networkId: 336,
    nativeCurrency: { name: "Shiden", symbol: "SDN", decimals: 18 },
    rpc: [
      "https://rpc.shiden.astar.network:8545",
      "wss://shiden.api.onfinality.io/public-ws"
    ],
    faucets: [],
    infoURL: "https://shiden.astar.network/"
  },
  {
    name: "Cronos Testnet",
    chainId: 338,
    shortName: "tcro",
    networkId: 338,
    nativeCurrency: {
      name: "Crypto.org Test Coin",
      symbol: "TCRO",
      decimals: 18
    },
    rpc: [
      "https://cronos-testnet-3.crypto.org:8545",
      "wss://cronos-testnet-3.crypto.org:8546"
    ],
    faucets: ["https://cronos.crypto.org/faucet"],
    infoURL: "https://cronos.crypto.org"
  },
  {
    name: "Theta Mainnet",
    chainId: 361,
    shortName: "theta-mainnet",
    networkId: 361,
    nativeCurrency: { name: "Theta Fuel", symbol: "TFUEL", decimals: 18 },
    rpc: ["https://eth-rpc-api.thetatoken.org/rpc"],
    faucets: [],
    infoURL: "https://www.thetatoken.org/"
  },
  {
    name: "Theta Sapphire Testnet",
    chainId: 363,
    shortName: "theta-sapphire",
    networkId: 363,
    nativeCurrency: { name: "Theta Fuel", symbol: "TFUEL", decimals: 18 },
    rpc: ["https://eth-rpc-api-sapphire.thetatoken.org/rpc"],
    faucets: [],
    infoURL: "https://www.thetatoken.org/"
  },
  {
    name: "Theta Amber Testnet",
    chainId: 364,
    shortName: "theta-amber",
    networkId: 364,
    nativeCurrency: { name: "Theta Fuel", symbol: "TFUEL", decimals: 18 },
    rpc: ["https://eth-rpc-api-amber.thetatoken.org/rpc"],
    faucets: [],
    infoURL: "https://www.thetatoken.org/"
  },
  {
    name: "Theta Testnet",
    chainId: 365,
    shortName: "theta-testnet",
    networkId: 365,
    nativeCurrency: { name: "Theta Fuel", symbol: "TFUEL", decimals: 18 },
    rpc: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"],
    faucets: [],
    infoURL: "https://www.thetatoken.org/"
  },
  {
    name: "PulseChain Mainnet",
    chainId: 369,
    shortName: "pls",
    networkId: 369,
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    rpc: [
      "https://rpc.mainnet.pulsechain.com/v1/${PULSECHAIN_API_KEY}",
      "wss://rpc.mainnet.pulsechain.com/ws/v1/${PULSECHAIN_API_KEY}"
    ],
    faucets: [],
    infoURL: "https://pulsechain.com/"
  },
  {
    name: "Lisinski",
    chainId: 385,
    shortName: "lisinski",
    networkId: 385,
    nativeCurrency: {
      name: "Lisinski Ether",
      symbol: "LISINSKI",
      decimals: 18
    },
    rpc: ["https://rpc-bitfalls1.lisinski.online"],
    faucets: ["https://pipa.lisinski.online"],
    infoURL: "https://lisinski.online"
  },
  {
    name: "Optimistic Ethereum Testnet Goerli",
    chainId: 420,
    shortName: "ogor",
    networkId: 420,
    nativeCurrency: { name: "Görli Ether", symbol: "GOR", decimals: 18 },
    rpc: ["https://goerli.optimism.io/"],
    faucets: [],
    infoURL: "https://optimism.io"
  },
  {
    name: "Rupaya",
    chainId: 499,
    shortName: "rupx",
    networkId: 499,
    nativeCurrency: { name: "Rupaya", symbol: "RUPX", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://www.rupx.io"
  },
  {
    name: "Tao Network",
    chainId: 558,
    shortName: "tao",
    networkId: 558,
    nativeCurrency: { name: "Tao", symbol: "TAO", decimals: 18 },
    rpc: [
      "https://rpc.testnet.tao.network",
      "http://rpc.testnet.tao.network:8545",
      "https://rpc.tao.network",
      "wss://rpc.tao.network"
    ],
    faucets: [],
    infoURL: "https://tao.network"
  },
  {
    name: "Acala Mandala Testnet",
    chainId: 595,
    shortName: "maca",
    networkId: 595,
    nativeCurrency: {
      name: "Acala Mandala Token",
      symbol: "mACA",
      decimals: 18
    },
    rpc: [],
    faucets: [],
    infoURL: "https://acala.network"
  },
  {
    name: "Karura Network",
    chainId: 686,
    shortName: "kar",
    networkId: 686,
    nativeCurrency: { name: "Karura Token", symbol: "KAR", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://karura.network"
  },
  {
    name: "Factory 127 Testnet",
    chainId: 721,
    shortName: "tfeth",
    networkId: 721,
    nativeCurrency: { name: "Factory 127 Token", symbol: "FETH", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://www.factory127.com"
  },
  {
    name: "cheapETH",
    chainId: 777,
    shortName: "cth",
    networkId: 777,
    nativeCurrency: { name: "cTH", symbol: "cTH", decimals: 18 },
    rpc: ["https://node.cheapeth.org/rpc"],
    faucets: [],
    infoURL: "https://cheapeth.org/"
  },
  {
    name: "Acala Network",
    chainId: 787,
    shortName: "aca",
    networkId: 787,
    nativeCurrency: { name: "Acala Token", symbol: "ACA", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://acala.network"
  },
  {
    name: "Haic",
    chainId: 803,
    shortName: "haic",
    networkId: 803,
    nativeCurrency: { name: "Haicoin", symbol: "HAIC", decimals: 18 },
    rpc: ["https://orig.haichain.io/"],
    faucets: [],
    infoURL: "https://www.haichain.io/"
  },
  {
    name: "Callisto Mainnet",
    chainId: 820,
    shortName: "clo",
    networkId: 1,
    nativeCurrency: {
      name: "Callisto Mainnet Ether",
      symbol: "CLO",
      decimals: 18
    },
    rpc: ["https://clo-geth.0xinfra.com"],
    faucets: [],
    infoURL: "https://callisto.network"
  },
  {
    name: "Callisto Testnet",
    chainId: 821,
    shortName: "tclo",
    networkId: 2,
    nativeCurrency: {
      name: "Callisto Testnet Ether",
      symbol: "TCLO",
      decimals: 18
    },
    rpc: [],
    faucets: [],
    infoURL: "https://callisto.network"
  },
  {
    name: "Ambros Chain Mainnet",
    chainId: 880,
    shortName: "ambros",
    networkId: 880,
    nativeCurrency: { name: "AMBROS", symbol: "AMBR", decimals: 18 },
    rpc: ["https://mainnet.ambroschain.com"],
    faucets: [],
    infoURL: "https://bcmhunt.com/"
  },
  {
    name: "Wanchain",
    chainId: 888,
    shortName: "wan",
    networkId: 888,
    nativeCurrency: { name: "Wancoin", symbol: "WAN", decimals: 18 },
    rpc: ["https://gwan-ssl.wandevs.org:56891/"],
    faucets: [],
    infoURL: "https://www.wanscan.org"
  },
  {
    name: "PulseChain Testnet",
    chainId: 940,
    shortName: "tpls",
    networkId: 940,
    nativeCurrency: { name: "Test Pulse", symbol: "tPLS", decimals: 18 },
    rpc: [
      "https://rpc.testnet.pulsechain.com/v1/${PULSECHAIN_API_KEY}",
      "wss://rpc.testnet.pulsechain.com/ws/v1/${PULSECHAIN_API_KEY}"
    ],
    faucets: [],
    infoURL: "https://pulsechain.com/"
  },
  {
    name: "Nepal Blockchain Network",
    chainId: 977,
    shortName: "yeti",
    networkId: 977,
    nativeCurrency: {
      name: "Nepal Blockchain Network Ether",
      symbol: "YETI",
      decimals: 18
    },
    rpc: [
      "https://api.nepalblockchain.dev",
      "https://api.nepalblockchain.network"
    ],
    faucets: ["https://faucet.nepalblockchain.network"],
    infoURL: "https://nepalblockchain.network"
  },
  {
    name: "Lucky Network",
    chainId: 998,
    shortName: "ln",
    networkId: 998,
    nativeCurrency: { name: "Lucky", symbol: "L99", decimals: 18 },
    rpc: [
      "https://rpc.luckynetwork.org",
      "wss://ws.lnscan.org",
      "https://rpc.lnscan.org"
    ],
    faucets: [],
    infoURL: "https://luckynetwork.org"
  },
  {
    name: "Wanchain Testnet",
    chainId: 999,
    shortName: "twan",
    networkId: 999,
    nativeCurrency: { name: "Wancoin", symbol: "WAN", decimals: 18 },
    rpc: ["https://gwan-ssl.wandevs.org:46891/"],
    faucets: [],
    infoURL: "https://testnet.wanscan.org"
  },
  {
    name: "Klaytn Testnet Baobab",
    chainId: 1001,
    shortName: "Baobab",
    networkId: 1001,
    nativeCurrency: { name: "KLAY", symbol: "KLAY", decimals: 18 },
    rpc: ["https://node-api.klaytnapi.com/v1/klaytn"],
    faucets: ["https://baobab.wallet.klaytn.com/access?next=faucet"],
    infoURL: "https://www.klaytn.com/"
  },
  {
    name: "Newton Testnet",
    chainId: 1007,
    shortName: "tnew",
    networkId: 1007,
    nativeCurrency: { name: "Newton", symbol: "NEW", decimals: 18 },
    rpc: ["https://rpc1.newchain.newtonproject.org"],
    faucets: [],
    infoURL: "https://www.newtonproject.org/"
  },
  {
    name: "Evrice Network",
    chainId: 1010,
    shortName: "EVC",
    networkId: 1010,
    nativeCurrency: { name: "Evrice", symbol: "EVC", decimals: 18 },
    rpc: ["https://meta.evrice.com"],
    faucets: [],
    infoURL: "https://evrice.com"
  },
  {
    name: "Newton",
    chainId: 1012,
    shortName: "new",
    networkId: 1012,
    nativeCurrency: { name: "Newton", symbol: "NEW", decimals: 18 },
    rpc: ["https://global.rpc.mainnet.newtonproject.org"],
    faucets: [],
    infoURL: "https://www.newtonproject.org/"
  },
  {
    name: "Sakura",
    chainId: 1022,
    shortName: "sku",
    networkId: 1022,
    nativeCurrency: { name: "Sakura", symbol: "SKU", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://clover.finance/sakura"
  },
  {
    name: "Clover Testnet",
    chainId: 1023,
    shortName: "tclv",
    networkId: 1023,
    nativeCurrency: { name: "Clover", symbol: "CLV", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://clover.finance"
  },
  {
    name: "Clover Mainnet",
    chainId: 1024,
    shortName: "clv",
    networkId: 1024,
    nativeCurrency: { name: "Clover", symbol: "CLV", decimals: 18 },
    rpc: [
      "https://rpc-ivy.clover.finance",
      "https://rpc-ivy-2.clover.finance",
      "https://rpc-ivy-3.clover.finance"
    ],
    faucets: [],
    infoURL: "https://clover.finance"
  },
  {
    name: "BitTorrent Chain Testnet",
    chainId: 1028,
    shortName: "tbtt",
    networkId: 1028,
    nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
    rpc: ["https://testrpc.bittorrentchain.io/"],
    faucets: [],
    infoURL: "https://bittorrentchain.io/"
  },
  {
    name: "MathChain",
    chainId: 1139,
    shortName: "MATH",
    networkId: 1139,
    nativeCurrency: { name: "MathChain", symbol: "MATH", decimals: 18 },
    rpc: [
      "https://mathchain-asia.maiziqianbao.net/rpc",
      "https://mathchain-us.maiziqianbao.net/rpc"
    ],
    faucets: [],
    infoURL: "https://mathchain.org"
  },
  {
    name: "MathChain Testnet",
    chainId: 1140,
    shortName: "tMATH",
    networkId: 1140,
    nativeCurrency: { name: "MathChain", symbol: "MATH", decimals: 18 },
    rpc: ["https://galois-hk.maiziqianbao.net/rpc"],
    faucets: ["https://scan.boka.network/#/Galois/faucet"],
    infoURL: "https://mathchain.org"
  },
  {
    name: "Popcateum Mainnet",
    chainId: 1213,
    shortName: "popcat",
    networkId: 1213,
    nativeCurrency: { name: "Popcat", symbol: "POP", decimals: 18 },
    rpc: ["https://dataseed.popcateum.org"],
    faucets: [],
    infoURL: "https://popcateum.org"
  },
  {
    name: "HALO Mainnet",
    chainId: 1280,
    shortName: "HO",
    networkId: 1280,
    nativeCurrency: { name: "HALO", symbol: "HO", decimals: 18 },
    rpc: ["https://nodes.halo.land"],
    faucets: [],
    infoURL: "https://halo.land/#/"
  },
  {
    name: "Moonbeam",
    chainId: 1284,
    shortName: "mbeam",
    networkId: 1284,
    nativeCurrency: { name: "Glimmer", symbol: "GLMR", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://moonbeam.network/networks/moonbeam/"
  },
  {
    name: "Moonriver",
    chainId: 1285,
    shortName: "mriver",
    networkId: 1285,
    nativeCurrency: { name: "Moonriver", symbol: "MOVR", decimals: 18 },
    rpc: [
      "https://rpc.moonriver.moonbeam.network",
      "wss://wss.moonriver.moonbeam.network"
    ],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://moonbeam.network/networks/moonriver/"
  },
  {
    name: "Moonrock",
    chainId: 1286,
    shortName: "mrock",
    networkId: 1286,
    nativeCurrency: { name: "Rocs", symbol: "ROC", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: ""
  },
  {
    name: "Moonbase Alpha",
    chainId: 1287,
    shortName: "mbase",
    networkId: 1287,
    nativeCurrency: { name: "Dev", symbol: "DEV", decimals: 18 },
    rpc: [
      "https://rpc.testnet.moonbeam.network",
      "wss://wss.testnet.moonbeam.network"
    ],
    faucets: [],
    infoURL: "https://docs.moonbeam.network/networks/testnet/"
  },
  {
    name: "Moonshadow",
    chainId: 1288,
    shortName: "mshadow",
    networkId: 1288,
    nativeCurrency: { name: "Moonshadow", symbol: "MSHD", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://docs.moonbeam.network/networks/overview/"
  },
  {
    name: "Catecoin Chain Mainnet",
    chainId: 1618,
    shortName: "cate",
    networkId: 1618,
    nativeCurrency: { name: "Catecoin", symbol: "CATE", decimals: 18 },
    rpc: ["https://send.catechain.com"],
    faucets: [],
    infoURL: "https://catechain.com"
  },
  {
    name: "Atheios",
    chainId: 1620,
    shortName: "ath",
    networkId: 11235813,
    nativeCurrency: { name: "Atheios Ether", symbol: "ATH", decimals: 18 },
    rpc: ["https://wallet.atheios.com:8797"],
    faucets: [],
    infoURL: "https://atheios.com"
  },
  {
    name: "Btachain",
    chainId: 1657,
    shortName: "bta",
    networkId: 1657,
    nativeCurrency: { name: "Bitcoin Asset", symbol: "BTA", decimals: 18 },
    rpc: ["https://dataseed1.btachain.com/"],
    faucets: [],
    infoURL: "https://bitcoinasset.io/"
  },
  {
    name: "Teslafunds",
    chainId: 1856,
    shortName: "tsf",
    networkId: 1,
    nativeCurrency: { name: "Teslafunds Ether", symbol: "TSF", decimals: 18 },
    rpc: ["https://tsfapi.europool.me"],
    faucets: [],
    infoURL: "https://teslafunds.io"
  },
  {
    name: "EtherGem",
    chainId: 1987,
    shortName: "egem",
    networkId: 1987,
    nativeCurrency: { name: "EtherGem Ether", symbol: "EGEM", decimals: 18 },
    rpc: ["https://jsonrpc.egem.io/custom"],
    faucets: [],
    infoURL: "https://egem.io"
  },
  {
    name: "420coin",
    chainId: 2020,
    shortName: "420",
    networkId: 2020,
    nativeCurrency: { name: "Fourtwenty", symbol: "420", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://420integrated.com"
  },
  {
    name: "Edgeware Mainnet",
    chainId: 2021,
    shortName: "edg",
    networkId: 2021,
    nativeCurrency: { name: "Edge", symbol: "EDG", decimals: 18 },
    rpc: ["https://mainnet1.edgewa.re"],
    faucets: [],
    infoURL: "http://edgewa.re"
  },
  {
    name: "Beresheet Testnet",
    chainId: 2022,
    shortName: "edgt",
    networkId: 2022,
    nativeCurrency: { name: "Testnet Edge", symbol: "tEDG", decimals: 18 },
    rpc: ["https://beresheet1.edgewa.re"],
    faucets: [],
    infoURL: "http://edgewa.re"
  },
  {
    name: "Ecoball Mainnet",
    chainId: 2100,
    shortName: "eco",
    networkId: 2100,
    nativeCurrency: { name: "Ecoball Coin", symbol: "ECO", decimals: 18 },
    rpc: ["https://api.ecoball.org/ecoball/"],
    faucets: [],
    infoURL: "https://ecoball.org"
  },
  {
    name: "Ecoball Testnet Espuma",
    chainId: 2101,
    shortName: "esp",
    networkId: 2101,
    nativeCurrency: { name: "Espuma Coin", symbol: "ECO", decimals: 18 },
    rpc: ["https://api.ecoball.org/espuma/"],
    faucets: [],
    infoURL: "https://ecoball.org"
  },
  {
    name: "Kortho Mainnet",
    chainId: 2559,
    shortName: "ktoc",
    networkId: 2559,
    nativeCurrency: { name: "KorthoChain", symbol: "KTO", decimals: 11 },
    rpc: ["https://www.kortho-chain.com"],
    faucets: [],
    infoURL: "https://www.kortho.io/"
  },
  {
    name: "Fantom Testnet",
    chainId: 4002,
    shortName: "tftm",
    networkId: 4002,
    nativeCurrency: { name: "Fantom", symbol: "FTM", decimals: 18 },
    rpc: ["https://rpc.testnet.fantom.network"],
    faucets: ["https://faucet.fantom.network"],
    infoURL: "https://docs.fantom.foundation/quick-start/short-guide#fantom-testnet"
  },
  {
    name: "IoTeX Network Mainnet",
    chainId: 4689,
    shortName: "iotex-mainnet",
    networkId: 4689,
    nativeCurrency: { name: "IoTeX", symbol: "IOTX", decimals: 18 },
    rpc: ["https://babel-api.mainnet.iotex.io"],
    faucets: [],
    infoURL: "https://iotex.io"
  },
  {
    name: "IoTeX Network Testnet",
    chainId: 4690,
    shortName: "iotex-testnet",
    networkId: 4690,
    nativeCurrency: { name: "IoTeX", symbol: "IOTX", decimals: 18 },
    rpc: ["https://babel-api.testnet.iotex.io"],
    faucets: ["https://faucet.iotex.io/"],
    infoURL: "https://iotex.io"
  },
  {
    name: "EraSwap Mainnet",
    chainId: 5197,
    shortName: "es",
    networkId: 5197,
    nativeCurrency: { name: "EraSwap", symbol: "ES", decimals: 18 },
    rpc: [
      "https://mainnet.eraswap.network",
      "https://rpc-mumbai.mainnet.eraswap.network"
    ],
    faucets: [],
    infoURL: "https://eraswap.info/"
  },
  {
    name: "Syscoin Tanenbaum Testnet",
    chainId: 5700,
    shortName: "tsys",
    networkId: 5700,
    nativeCurrency: { name: "Testnet Syscoin", symbol: "tSYS", decimals: 18 },
    rpc: ["https://rpc.tanenbaum.io", "wss://rpc.tanenbaum.io/wss"],
    faucets: ["https://faucet.tanenbaum.io"],
    infoURL: "https://syscoin.org"
  },
  {
    name: "Ontology Testnet",
    chainId: 5851,
    shortName: "Ontology Testnet",
    networkId: 5851,
    nativeCurrency: { name: "ONG", symbol: "ONG", decimals: 9 },
    rpc: [
      "https://polaris1.ont.io:20339",
      "https://polaris2.ont.io:20339",
      "https://polaris3.ont.io:20339",
      "https://polaris4.ont.io:20339"
    ],
    faucets: ["https://developer.ont.io/"],
    infoURL: "https://ont.io/"
  },
  {
    name: "Wegochain Rubidium Mainnet",
    chainId: 5869,
    shortName: "rbd",
    networkId: 5869,
    nativeCurrency: { name: "Rubid", symbol: "RBD", decimals: 18 },
    rpc: ["https://proxy.wegochain.io", "http://wallet.wegochain.io:7764"],
    faucets: [],
    infoURL: "http://wegochain.io"
  },
  {
    name: "Hazlor Testnet",
    chainId: 7878,
    shortName: "hazlor-hatlas",
    networkId: 7878,
    nativeCurrency: { name: "Planet", symbol: "PLANET", decimals: 18 },
    rpc: ["http://hatlas.rpc.hazlor.com:8545/"],
    faucets: ["https://faucet.hazlor.com"],
    infoURL: "https://hazlor.com"
  },
  {
    name: "MDGL Testnet",
    chainId: 8029,
    shortName: "mdgl",
    networkId: 8029,
    nativeCurrency: { name: "MDGL Token", symbol: "MDGLT", decimals: 18 },
    rpc: ["https://testnet.mdgl.io"],
    faucets: [],
    infoURL: "https://mdgl.io"
  },
  {
    name: "GeneChain Adenine Testnet",
    chainId: 8080,
    shortName: "GeneChainAdn",
    networkId: 8080,
    nativeCurrency: { name: "Testnet RNA", symbol: "tRNA", decimals: 18 },
    rpc: ["https://rpc-testnet.genechain.io"],
    faucets: ["https://faucet.genechain.io"],
    infoURL: "https://scan-testnet.genechain.io/"
  },
  {
    name: "Klaytn Mainnet Cypress",
    chainId: 8217,
    shortName: "Cypress",
    networkId: 8217,
    nativeCurrency: { name: "KLAY", symbol: "KLAY", decimals: 18 },
    rpc: ["https://node-api.klaytnapi.com/v1/klaytn"],
    faucets: [],
    infoURL: "https://www.klaytn.com/"
  },
  {
    name: "KorthoTest",
    chainId: 8285,
    shortName: "Kortho",
    networkId: 8285,
    nativeCurrency: { name: "Kortho Test", symbol: "KTO", decimals: 11 },
    rpc: ["https://www.krotho-test.net"],
    faucets: [],
    infoURL: "https://www.kortho.io/"
  },
  {
    name: "TOOL Global Mainnet",
    chainId: 8723,
    shortName: "olo",
    networkId: 8723,
    nativeCurrency: { name: "TOOL Global", symbol: "OLO", decimals: 18 },
    rpc: ["https://mainnet-web3.wolot.io"],
    faucets: [],
    infoURL: "https://ibdt.io"
  },
  {
    name: "TOOL Global Testnet",
    chainId: 8724,
    shortName: "tolo",
    networkId: 8724,
    nativeCurrency: { name: "TOOL Global", symbol: "OLO", decimals: 18 },
    rpc: ["https://testnet-web3.wolot.io"],
    faucets: ["https://testnet-explorer.wolot.io"],
    infoURL: "https://testnet-explorer.wolot.io"
  },
  {
    name: "Ambros Chain Testnet",
    chainId: 8888,
    shortName: "ambrostestnet",
    networkId: 8888,
    nativeCurrency: { name: "AMBROS", symbol: "AMBR", decimals: 18 },
    rpc: ["https://testnet.ambroschain.com"],
    faucets: [],
    infoURL: "https://bcmhunt.com/"
  },
  {
    name: "bloxberg",
    chainId: 8995,
    shortName: "berg",
    networkId: 8995,
    nativeCurrency: { name: "BERG", symbol: "U+25B3", decimals: 18 },
    rpc: ["https://core.bloxberg.org"],
    faucets: ["https://faucet.bloxberg.org/"],
    infoURL: "https://bloxberg.org"
  },
  {
    name: "Evmos Testnet",
    chainId: 9e3,
    shortName: "evmos-mons",
    networkId: 9e3,
    nativeCurrency: { name: "Photon", symbol: "PHOTON", decimals: 18 },
    rpc: ["https://ethereum.rpc.evmos.dev"],
    faucets: ["https://faucet.evmos.org"],
    infoURL: "https://evmos.org"
  },
  {
    name: "Smart Bitcoin Cash",
    chainId: 1e4,
    shortName: "smartbch",
    networkId: 1e4,
    nativeCurrency: { name: "Bitcoin Cash", symbol: "BCH", decimals: 18 },
    rpc: [
      "https://smartbch.greyh.at",
      "https://rpc-mainnet.smartbch.org",
      "https://smartbch.fountainhead.cash/mainnet",
      "https://smartbch.devops.cash/mainnet"
    ],
    faucets: [],
    infoURL: "https://smartbch.org/"
  },
  {
    name: "Smart Bitcoin Cash Testnet",
    chainId: 10001,
    shortName: "smartbchtest",
    networkId: 10001,
    nativeCurrency: {
      name: "Bitcoin Cash Test Token",
      symbol: "BCHT",
      decimals: 18
    },
    rpc: [
      "https://rpc-testnet.smartbch.org",
      "https://smartbch.devops.cash/testnet"
    ],
    faucets: [],
    infoURL: "http://smartbch.org/"
  },
  {
    name: "Blockchain Genesis Mainnet",
    chainId: 10101,
    shortName: "GEN",
    networkId: 10101,
    nativeCurrency: { name: "GEN", symbol: "GEN", decimals: 18 },
    rpc: [
      "https://eu.mainnet.xixoio.com",
      "https://us.mainnet.xixoio.com",
      "https://asia.mainnet.xixoio.com"
    ],
    faucets: [],
    infoURL: "https://www.xixoio.com/"
  },
  {
    name: "Singularity ZERO Testnet",
    chainId: 12051,
    shortName: "tZERO",
    networkId: 12051,
    nativeCurrency: { name: "ZERO", symbol: "tZERO", decimals: 18 },
    rpc: ["https://betaenv.singularity.gold:18545"],
    faucets: ["https://nft.singularity.gold"],
    infoURL: "https://www.singularity.gold"
  },
  {
    name: "MetaDot Mainnet",
    chainId: 16e3,
    shortName: "mtt",
    networkId: 16e3,
    nativeCurrency: { name: "MetaDot Token", symbol: "MTT", decimals: 18 },
    rpc: ["https://mainnet.metadot.network"],
    faucets: [],
    infoURL: "https://metadot.network"
  },
  {
    name: "MetaDot Testnet",
    chainId: 16001,
    shortName: "mtttest",
    networkId: 16001,
    nativeCurrency: {
      name: "MetaDot Token TestNet",
      symbol: "MTT-test",
      decimals: 18
    },
    rpc: ["https://testnet.metadot.network"],
    faucets: ["https://faucet.metadot.network/"],
    infoURL: "https://metadot.network"
  },
  {
    name: "Webchain",
    chainId: 24484,
    shortName: "web",
    networkId: 37129,
    nativeCurrency: { name: "Webchain Ether", symbol: "WEB", decimals: 18 },
    rpc: ["https://node1.webchain.network"],
    faucets: [],
    infoURL: "https://webchain.network"
  },
  {
    name: "MintMe.com Coin",
    chainId: 24734,
    shortName: "mintme",
    networkId: 37480,
    nativeCurrency: { name: "MintMe.com Coin", symbol: "MINTME", decimals: 18 },
    rpc: ["https://node1.mintme.com"],
    faucets: [],
    infoURL: "https://www.mintme.com"
  },
  {
    name: "Ethersocial Network",
    chainId: 31102,
    shortName: "esn",
    networkId: 1,
    nativeCurrency: {
      name: "Ethersocial Network Ether",
      symbol: "ESN",
      decimals: 18
    },
    rpc: ["https://api.esn.gonspool.com"],
    faucets: [],
    infoURL: "https://ethersocial.org"
  },
  {
    name: "GoChain Testnet",
    chainId: 31337,
    shortName: "got",
    networkId: 31337,
    nativeCurrency: { name: "GoChain Coin", symbol: "GO", decimals: 18 },
    rpc: ["https://testnet-rpc.gochain.io"],
    faucets: [],
    infoURL: "https://gochain.io"
  },
  {
    name: "Fusion Mainnet",
    chainId: 32659,
    shortName: "fsn",
    networkId: 32659,
    nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
    rpc: ["https://mainnet.anyswap.exchange", "https://fsn.dev/api"],
    faucets: [],
    infoURL: "https://www.fusion.org/"
  },
  {
    name: "Energi Mainnet",
    chainId: 39797,
    shortName: "nrg",
    networkId: 39797,
    nativeCurrency: { name: "Energi", symbol: "NRG", decimals: 18 },
    rpc: ["https://nodeapi.energi.network"],
    faucets: [],
    infoURL: "https://www.energi.world/"
  },
  {
    name: "pegglecoin",
    chainId: 42069,
    shortName: "PC",
    networkId: 42069,
    nativeCurrency: { name: "pegglecoin", symbol: "peggle", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://teampeggle.com"
  },
  {
    name: "Arbitrum One",
    chainId: 42161,
    shortName: "arb1",
    networkId: 42161,
    nativeCurrency: { name: "Ether", symbol: "AETH", decimals: 18 },
    rpc: [
      "https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://arb1.arbitrum.io/rpc",
      "wss://arb1.arbitrum.io/ws"
    ],
    faucets: [],
    infoURL: "https://arbitrum.io"
  },
  {
    name: "Celo Mainnet",
    chainId: 42220,
    shortName: "CELO",
    networkId: 42220,
    nativeCurrency: { name: "CELO", symbol: "CELO", decimals: 18 },
    rpc: ["https://forno.celo.org", "wss://forno.celo.org/ws"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://docs.celo.org/"
  },
  {
    name: "Athereum",
    chainId: 43110,
    shortName: "avaeth",
    networkId: 43110,
    nativeCurrency: { name: "Athereum Ether", symbol: "ATH", decimals: 18 },
    rpc: ["https://ava.network:21015/ext/evm/rpc"],
    faucets: ["http://athfaucet.ava.network//?address=${ADDRESS}"],
    infoURL: "https://athereum.ava.network"
  },
  {
    name: "Avalanche Fuji Testnet",
    chainId: 43113,
    shortName: "Fuji",
    networkId: 1,
    nativeCurrency: { name: "Avalanche", symbol: "AVAX", decimals: 18 },
    rpc: ["https://api.avax-test.network/ext/bc/C/rpc"],
    faucets: ["https://faucet.avax-test.network/"],
    infoURL: "https://cchain.explorer.avax-test.network"
  },
  {
    name: "Avalanche Mainnet",
    chainId: 43114,
    shortName: "Avalanche",
    networkId: 43114,
    nativeCurrency: { name: "Avalanche", symbol: "AVAX", decimals: 18 },
    rpc: ["https://api.avax.network/ext/bc/C/rpc"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://www.avax.network/"
  },
  {
    name: "Celo Alfajores Testnet",
    chainId: 44787,
    shortName: "ALFA",
    networkId: 44787,
    nativeCurrency: { name: "CELO", symbol: "CELO", decimals: 18 },
    rpc: [
      "https://alfajores-forno.celo-testnet.org",
      "wss://alfajores-forno.celo-testnet.org/ws"
    ],
    faucets: [
      "https://celo.org/developers/faucet",
      "https://cauldron.pretoriaresearchlab.io/alfajores-faucet"
    ],
    infoURL: "https://docs.celo.org/"
  },
  {
    name: "Energi Testnet",
    chainId: 49797,
    shortName: "tnrg",
    networkId: 49797,
    nativeCurrency: { name: "Energi", symbol: "NRG", decimals: 18 },
    rpc: ["https://nodeapi.test.energi.network"],
    faucets: [],
    infoURL: "https://www.energi.world/"
  },
  {
    name: "Thinkium Testnet Chain 0",
    chainId: 6e4,
    shortName: "TKM-test0",
    networkId: 6e4,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://test.thinkiumrpc.net/"],
    faucets: ["https://www.thinkiumdev.net/faucet"],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Thinkium Testnet Chain 1",
    chainId: 60001,
    shortName: "TKM-test1",
    networkId: 60001,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://test1.thinkiumrpc.net/"],
    faucets: ["https://www.thinkiumdev.net/faucet"],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Thinkium Testnet Chain 2",
    chainId: 60002,
    shortName: "TKM-test2",
    networkId: 60002,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://test2.thinkiumrpc.net/"],
    faucets: ["https://www.thinkiumdev.net/faucet"],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Thinkium Testnet Chain 103",
    chainId: 60103,
    shortName: "TKM-test103",
    networkId: 60103,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://test103.thinkiumrpc.net/"],
    faucets: ["https://www.thinkiumdev.net/faucet"],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Celo Baklava Testnet",
    chainId: 62320,
    shortName: "BKLV",
    networkId: 62320,
    nativeCurrency: { name: "CELO", symbol: "CELO", decimals: 18 },
    rpc: ["https://baklava-forno.celo-testnet.org"],
    faucets: [
      "https://docs.google.com/forms/d/e/1FAIpQLSdfr1BwUTYepVmmvfVUDRCwALejZ-TUva2YujNpvrEmPAX2pg/viewform",
      "https://cauldron.pretoriaresearchlab.io/baklava-faucet"
    ],
    infoURL: "https://docs.celo.org/"
  },
  {
    name: "Thinkium Mainnet Chain 0",
    chainId: 7e4,
    shortName: "TKM0",
    networkId: 7e4,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://proxy.thinkiumrpc.net/"],
    faucets: [],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Thinkium Mainnet Chain 1",
    chainId: 70001,
    shortName: "TKM1",
    networkId: 70001,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://proxy1.thinkiumrpc.net/"],
    faucets: [],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Thinkium Mainnet Chain 2",
    chainId: 70002,
    shortName: "TKM2",
    networkId: 70002,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://proxy2.thinkiumrpc.net/"],
    faucets: [],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Thinkium Mainnet Chain 103",
    chainId: 70103,
    shortName: "TKM103",
    networkId: 70103,
    nativeCurrency: { name: "TKM", symbol: "TKM", decimals: 18 },
    rpc: ["https://proxy103.thinkiumrpc.net/"],
    faucets: [],
    infoURL: "https://thinkium.net/"
  },
  {
    name: "Polyjuice Testnet",
    chainId: 71393,
    shortName: "ckb",
    networkId: 1,
    nativeCurrency: { name: "CKB", symbol: "CKB", decimals: 8 },
    rpc: [
      "https://godwoken-testnet-web3-rpc.ckbapp.dev",
      "ws://godwoken-testnet-web3-rpc.ckbapp.dev/ws"
    ],
    faucets: ["https://faucet.nervos.org/"],
    infoURL: "https://github.com/nervosnetwork/godwoken"
  },
  {
    name: "Energy Web Volta Testnet",
    chainId: 73799,
    shortName: "vt",
    networkId: 73799,
    nativeCurrency: { name: "Volta Token", symbol: "VT", decimals: 18 },
    rpc: [
      "https://volta-rpc.energyweb.org",
      "wss://volta-rpc.energyweb.org/ws"
    ],
    faucets: ["https://voltafaucet.energyweb.org"],
    infoURL: "https://energyweb.org"
  },
  {
    name: "Firenze test network",
    chainId: 78110,
    shortName: "firenze",
    networkId: 78110,
    nativeCurrency: { name: "Firenze Ether", symbol: "FIN", decimals: 18 },
    rpc: ["https://ethnode.primusmoney.com/firenze"],
    faucets: [],
    infoURL: "https://primusmoney.com"
  },
  {
    name: "Polygon Testnet Mumbai",
    chainId: 80001,
    shortName: "maticmum",
    networkId: 80001,
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpc: [
      "https://matic-mumbai.chainstacklabs.com",
      "https://rpc-mumbai.maticvigil.com",
      "https://matic-testnet-archive-rpc.bwarelabs.com"
    ],
    faucets: ["https://faucet.polygon.technology/"],
    infoURL: "https://polygon.technology/"
  },
  {
    name: "QuarkChain Mainnet Root",
    chainId: 1e5,
    shortName: "qkc-r",
    networkId: 1e5,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://jrpc.mainnet.quarkchain.io:38391/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 0",
    chainId: 100001,
    shortName: "qkc-s0",
    networkId: 100001,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39000/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 1",
    chainId: 100002,
    shortName: "qkc-s1",
    networkId: 100002,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39001/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 2",
    chainId: 100003,
    shortName: "qkc-s2",
    networkId: 100003,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39002/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 3",
    chainId: 100004,
    shortName: "qkc-s3",
    networkId: 100004,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39003/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 4",
    chainId: 100005,
    shortName: "qkc-s4",
    networkId: 100005,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39004/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 5",
    chainId: 100006,
    shortName: "qkc-s5",
    networkId: 100006,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39005/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 6",
    chainId: 100007,
    shortName: "qkc-s6",
    networkId: 100007,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39006/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Mainnet Shard 7",
    chainId: 100008,
    shortName: "qkc-s7",
    networkId: 100008,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.mainnet.quarkchain.io:39007/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Root",
    chainId: 11e4,
    shortName: "qkc-d-r",
    networkId: 11e4,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://jrpc.devnet.quarkchain.io:38391/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 0",
    chainId: 110001,
    shortName: "qkc-d-s0",
    networkId: 110001,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39900/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 1",
    chainId: 110002,
    shortName: "qkc-d-s1",
    networkId: 110002,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39901/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 2",
    chainId: 110003,
    shortName: "qkc-d-s2",
    networkId: 110003,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39902/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 3",
    chainId: 110004,
    shortName: "qkc-d-s3",
    networkId: 110004,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39903/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 4",
    chainId: 110005,
    shortName: "qkc-d-s4",
    networkId: 110005,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39904/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 5",
    chainId: 110006,
    shortName: "qkc-d-s5",
    networkId: 110006,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39905/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 6",
    chainId: 110007,
    shortName: "qkc-d-s6",
    networkId: 110007,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39906/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "QuarkChain Devnet Shard 7",
    chainId: 110008,
    shortName: "qkc-d-s7",
    networkId: 110008,
    nativeCurrency: { name: "QKC", symbol: "QKC", decimals: 18 },
    rpc: ["http://eth-jrpc.devnet.quarkchain.io:39907/"],
    faucets: [],
    infoURL: "https://www.quarkchain.io/"
  },
  {
    name: "Akroma",
    chainId: 200625,
    shortName: "aka",
    networkId: 200625,
    nativeCurrency: { name: "Akroma Ether", symbol: "AKA", decimals: 18 },
    rpc: ["https://remote.akroma.io"],
    faucets: [],
    infoURL: "https://akroma.io"
  },
  {
    name: "Alaya Dev Testnet",
    chainId: 201030,
    shortName: "alaya",
    networkId: 1,
    nativeCurrency: { name: "ATP", symbol: "atp", decimals: 18 },
    rpc: [
      "https://devnetopenapi.alaya.network/rpc",
      "wss://devnetopenapi.alaya.network/ws"
    ],
    faucets: [
      "https://faucet.alaya.network/faucet/?id=f93426c0887f11eb83b900163e06151c"
    ],
    infoURL: "https://www.alaya.network/"
  },
  {
    name: "PlatON Dev Testnet",
    chainId: 210309,
    shortName: "PlatON",
    networkId: 1,
    nativeCurrency: { name: "LAT", symbol: "lat", decimals: 18 },
    rpc: [
      "https://devnetopenapi.platon.network/rpc",
      "wss://devnetopenapi.platon.network/ws"
    ],
    faucets: [
      "https://faucet.platon.network/faucet/?id=e5d32df10aee11ec911142010a667c03"
    ],
    infoURL: "https://www.platon.network"
  },
  {
    name: "ARTIS sigma1",
    chainId: 246529,
    shortName: "ats",
    networkId: 246529,
    nativeCurrency: { name: "ARTIS sigma1 Ether", symbol: "ATS", decimals: 18 },
    rpc: ["https://rpc.sigma1.artis.network"],
    faucets: [],
    infoURL: "https://artis.eco"
  },
  {
    name: "ARTIS Testnet tau1",
    chainId: 246785,
    shortName: "atstau",
    networkId: 246785,
    nativeCurrency: { name: "ARTIS tau1 Ether", symbol: "tATS", decimals: 18 },
    rpc: ["https://rpc.tau1.artis.network"],
    faucets: [],
    infoURL: "https://artis.network"
  },
  {
    name: "Polis Testnet",
    chainId: 333888,
    shortName: "sparta",
    networkId: 333888,
    nativeCurrency: { name: "tPolis", symbol: "tPOLIS", decimals: 18 },
    rpc: ["https://sparta-rpc.polis.tech"],
    faucets: ["https://faucet.polis.tech"],
    infoURL: "https://polis.tech"
  },
  {
    name: "Polis Mainnet",
    chainId: 333999,
    shortName: "olympus",
    networkId: 333999,
    nativeCurrency: { name: "Polis", symbol: "POLIS", decimals: 18 },
    rpc: ["https://rpc.polis.tech"],
    faucets: ["https://faucet.polis.tech"],
    infoURL: "https://polis.tech"
  },
  {
    name: "Arbitrum Testnet Rinkeby",
    chainId: 421611,
    shortName: "arb-rinkeby",
    networkId: 421611,
    nativeCurrency: {
      name: "Arbitrum Rinkeby Ether",
      symbol: "ARETH",
      decimals: 18
    },
    rpc: ["https://rinkeby.arbitrum.io/rpc", "wss://rinkeby.arbitrum.io/ws"],
    faucets: [],
    infoURL: "https://arbitrum.io"
  },
  {
    name: "Eluvio Content Fabric",
    chainId: 955305,
    shortName: "elv",
    networkId: 955305,
    nativeCurrency: { name: "ELV", symbol: "ELV", decimals: 18 },
    rpc: [
      "https://host-76-74-28-226.contentfabric.io/eth/",
      "https://host-76-74-28-232.contentfabric.io/eth/",
      "https://host-76-74-29-2.contentfabric.io/eth/",
      "https://host-76-74-29-8.contentfabric.io/eth/",
      "https://host-76-74-29-34.contentfabric.io/eth/",
      "https://host-76-74-29-35.contentfabric.io/eth/",
      "https://host-154-14-211-98.contentfabric.io/eth/",
      "https://host-154-14-192-66.contentfabric.io/eth/",
      "https://host-60-240-133-202.contentfabric.io/eth/",
      "https://host-64-235-250-98.contentfabric.io/eth/"
    ],
    faucets: [],
    infoURL: "https://eluv.io"
  },
  {
    name: "Etho Protocol",
    chainId: 1313114,
    shortName: "etho",
    networkId: 1313114,
    nativeCurrency: { name: "Etho Protocol", symbol: "ETHO", decimals: 18 },
    rpc: ["https://rpc.ether1.org"],
    faucets: [],
    infoURL: "https://ethoprotocol.com"
  },
  {
    name: "Xerom",
    chainId: 1313500,
    shortName: "xero",
    networkId: 1313500,
    nativeCurrency: { name: "Xerom Ether", symbol: "XERO", decimals: 18 },
    rpc: ["https://rpc.xerom.org"],
    faucets: [],
    infoURL: "https://xerom.org"
  },
  {
    name: "Musicoin",
    chainId: 7762959,
    shortName: "music",
    networkId: 7762959,
    nativeCurrency: { name: "Musicoin", symbol: "MUSIC", decimals: 18 },
    rpc: ["https://mewapi.musicoin.tw"],
    faucets: [],
    infoURL: "https://musicoin.tw"
  },
  {
    name: "PepChain Churchill",
    chainId: 13371337,
    shortName: "tpep",
    networkId: 13371337,
    nativeCurrency: {
      name: "PepChain Churchill Ether",
      symbol: "TPEP",
      decimals: 18
    },
    rpc: ["https://churchill-rpc.pepchain.io"],
    faucets: [],
    infoURL: "https://pepchain.io"
  },
  {
    name: "IOLite",
    chainId: 18289463,
    shortName: "ilt",
    networkId: 18289463,
    nativeCurrency: { name: "IOLite Ether", symbol: "ILT", decimals: 18 },
    rpc: ["https://net.iolite.io"],
    faucets: [],
    infoURL: "https://iolite.io"
  },
  {
    name: "quarkblockchain",
    chainId: 20181205,
    shortName: "qki",
    networkId: 20181205,
    nativeCurrency: {
      name: "quarkblockchain Native Token",
      symbol: "QKI",
      decimals: 18
    },
    rpc: ["https://hz.rpc.qkiscan.cn", "https://jp.rpc.qkiscan.io"],
    faucets: [],
    infoURL: "https://quarkblockchain.org/"
  },
  {
    name: "Auxilium Network Mainnet",
    chainId: 28945486,
    shortName: "auxi",
    networkId: 28945486,
    nativeCurrency: { name: "Auxilium coin", symbol: "AUX", decimals: 18 },
    rpc: ["https://rpc.auxilium.global"],
    faucets: [],
    infoURL: "https://auxilium.global"
  },
  {
    name: "Joys Digital Mainnet",
    chainId: 35855456,
    shortName: "JOYS",
    networkId: 35855456,
    nativeCurrency: { name: "JOYS", symbol: "JOYS", decimals: 18 },
    rpc: ["https://node.joys.digital"],
    faucets: [],
    infoURL: "https://joys.digital"
  },
  {
    name: "Aquachain",
    chainId: 61717561,
    shortName: "aqua",
    networkId: 61717561,
    nativeCurrency: { name: "Aquachain Ether", symbol: "AQUA", decimals: 18 },
    rpc: ["https://c.onical.org", "https://tx.aquacha.in/api"],
    faucets: ["https://aquacha.in/faucet"],
    infoURL: "https://aquachain.github.io"
  },
  {
    name: "Joys Digital TestNet",
    chainId: 99415706,
    shortName: "TOYS",
    networkId: 99415706,
    nativeCurrency: { name: "TOYS", symbol: "TOYS", decimals: 18 },
    rpc: ["https://toys.joys.cash/"],
    faucets: ["https://faucet.joys.digital/"],
    infoURL: "https://joys.digital"
  },
  {
    name: "Neon EVM DevNet",
    chainId: 245022926,
    shortName: "neonevm-devnet",
    networkId: 245022926,
    nativeCurrency: { name: "Neon", symbol: "NEON", decimals: 18 },
    rpc: ["https://proxy.devnet.neonlabs.org/solana"],
    faucets: ["https://neonswap.live/#/get-tokens"],
    infoURL: "https://neon-labs.org/"
  },
  {
    name: "Neon EVM MainNet",
    chainId: 245022934,
    shortName: "neonevm-mainnet",
    networkId: 245022934,
    nativeCurrency: { name: "Neon", symbol: "NEON", decimals: 18 },
    rpc: ["https://proxy.mainnet.neonlabs.org/solana"],
    faucets: [],
    infoURL: "https://neon-labs.org/"
  },
  {
    name: "Neon EVM TestNet",
    chainId: 245022940,
    shortName: "neonevm-testnet",
    networkId: 245022940,
    nativeCurrency: { name: "Neon", symbol: "NEON", decimals: 18 },
    rpc: ["https://proxy.testnet.neonlabs.org/solana"],
    faucets: [],
    infoURL: "https://neon-labs.org/"
  },
  {
    name: "OneLedger Mainnet",
    chainId: 311752642,
    shortName: "oneledger",
    networkId: 311752642,
    nativeCurrency: { name: "OLT", symbol: "OLT", decimals: 18 },
    rpc: ["https://mainnet-rpc.oneledger.network"],
    faucets: [],
    infoURL: "https://oneledger.io"
  },
  {
    name: "IPOS Network",
    chainId: 1122334455,
    shortName: "ipos",
    networkId: 1122334455,
    nativeCurrency: {
      name: "IPOS Network Ether",
      symbol: "IPOS",
      decimals: 18
    },
    rpc: ["https://rpc.iposlab.com", "https://rpc2.iposlab.com"],
    faucets: [],
    infoURL: "https://iposlab.com"
  },
  {
    name: "Aurora MainNet",
    chainId: 1313161554,
    shortName: "aurora",
    networkId: 1313161554,
    nativeCurrency: { name: "Ether", symbol: "aETH", decimals: 18 },
    rpc: ["https://mainnet.aurora.dev"],
    faucets: [],
    infoURL: "https://aurora.dev"
  },
  {
    name: "Aurora TestNet",
    chainId: 1313161555,
    shortName: "aurora-testnet",
    networkId: 1313161555,
    nativeCurrency: { name: "Ether", symbol: "aETH", decimals: 18 },
    rpc: ["https://testnet.aurora.dev/"],
    faucets: [],
    infoURL: "https://aurora.dev"
  },
  {
    name: "Aurora BetaNet",
    chainId: 1313161556,
    shortName: "aurora-betanet",
    networkId: 1313161556,
    nativeCurrency: { name: "Ether", symbol: "aETH", decimals: 18 },
    rpc: ["https://betanet.aurora.dev/"],
    faucets: [],
    infoURL: "https://aurora.dev"
  },
  {
    name: "Harmony Mainnet Shard 0",
    chainId: 16666e5,
    shortName: "hmy-s0",
    networkId: 16666e5,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://api.harmony.one"],
    faucets: ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Mainnet Shard 1",
    chainId: 1666600001,
    shortName: "hmy-s1",
    networkId: 1666600001,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://s1.api.harmony.one"],
    faucets: [],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Mainnet Shard 2",
    chainId: 1666600002,
    shortName: "hmy-s2",
    networkId: 1666600002,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://s2.api.harmony.one"],
    faucets: [],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Mainnet Shard 3",
    chainId: 1666600003,
    shortName: "hmy-s3",
    networkId: 1666600003,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://s3.api.harmony.one"],
    faucets: [],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Testnet Shard 0",
    chainId: 16667e5,
    shortName: "hmy-b-s0",
    networkId: 16667e5,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://api.s0.b.hmny.io"],
    faucets: ["https://faucet.pops.one"],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Testnet Shard 1",
    chainId: 1666700001,
    shortName: "hmy-b-s1",
    networkId: 1666700001,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://api.s1.b.hmny.io"],
    faucets: [],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Testnet Shard 2",
    chainId: 1666700002,
    shortName: "hmy-b-s2",
    networkId: 1666700002,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://api.s2.b.hmny.io"],
    faucets: [],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Harmony Testnet Shard 3",
    chainId: 1666700003,
    shortName: "hmy-b-s3",
    networkId: 1666700003,
    nativeCurrency: { name: "ONE", symbol: "ONE", decimals: 18 },
    rpc: ["https://api.s3.b.hmny.io"],
    faucets: [],
    infoURL: "https://www.harmony.one/"
  },
  {
    name: "Pirl",
    chainId: 3125659152,
    shortName: "pirl",
    networkId: 3125659152,
    nativeCurrency: { name: "Pirl Ether", symbol: "PIRL", decimals: 18 },
    rpc: ["https://wallrpc.pirl.io"],
    faucets: [],
    infoURL: "https://pirl.io"
  },
  {
    name: "OneLedger Testnet Frankenstein",
    chainId: 4216137055,
    shortName: "frankenstein",
    networkId: 4216137055,
    nativeCurrency: { name: "OLT", symbol: "OLT", decimals: 18 },
    rpc: ["https://frankenstein-rpc.oneledger.network"],
    faucets: ["https://frankenstein-faucet.oneledger.network"],
    infoURL: "https://oneledger.io"
  },
  {
    name: "Palm Testnet",
    chainId: 11297108099,
    shortName: "tpalm",
    networkId: 11297108099,
    nativeCurrency: { name: "PALM", symbol: "PALM", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://palm.io"
  },
  {
    name: "Palm Mainnet",
    chainId: 11297108109,
    shortName: "palm",
    networkId: 11297108109,
    nativeCurrency: { name: "PALM", symbol: "PALM", decimals: 18 },
    rpc: [],
    faucets: [],
    infoURL: "https://palm.io"
  }
];
var currencyFormatter = new Intl.NumberFormat("en-us", {
  style: "currency",
  currency: "USD",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
});
var decimalFormatter = new Intl.NumberFormat("en-us", {
  style: "decimal",
  minimumSignificantDigits: 1,
  maximumSignificantDigits: 4
});
var toUsd = function(value) {
  return currencyFormatter.format(value);
};
var limitDecimals = function(value) {
  return decimalFormatter.format(value);
};
var tokenValue = function(value, decimals) {
  return value / Math.pow(10, decimals);
};
var tokenValueTxt = function(value, decimals, symbol) {
  if (typeof value === "number") {
    return "".concat(limitDecimals(tokenValue(value, decimals)), " ").concat(symbol);
  }
  return "".concat(limitDecimals(tokenValue(Number(value), decimals)), " ").concat(symbol);
};
var decimalToHexString = function(decimal) {
  return "0x" + decimal.toString(16);
};
var getSupportedChains = function() {
  return chains.filter(function(chain) {
    return supportedChains.includes(decimalToHexString(chain.chainId));
  }).map(function(chainData) {
    return __assign(__assign({}, chainData), { chainId: decimalToHexString(chainData.chainId), blockExplorerUrl: blockExplorers[decimalToHexString(chainData.chainId)] });
  });
};
var getChain = function(chainId) {
  return getSupportedChains().find(function(chain) {
    return chain.chainId === chainId;
  });
};
var MoralisContext = (0, import_react2.createContext)(null);
var ReactMoralisError = (
  /** @class */
  function(_super) {
    __extends(ReactMoralisError2, _super);
    function ReactMoralisError2(message) {
      var _this = _super.call(this, "[react-moralis]: ".concat(message)) || this;
      _this.name = "ReactMoralisError";
      _this.message = message;
      return _this;
    }
    ReactMoralisError2.isReactMoraliserrpr = true;
    return ReactMoralisError2;
  }(Error)
);
var NoMoralisContextProviderError = (
  /** @class */
  function(_super) {
    __extends(NoMoralisContextProviderError2, _super);
    function NoMoralisContextProviderError2(message) {
      var _this = _super.call(this, message) || this;
      _this.name = "NoMoralisContextProviderError";
      return _this;
    }
    return NoMoralisContextProviderError2;
  }(ReactMoralisError)
);
var NotAuthenticatedError = (
  /** @class */
  function(_super) {
    __extends(NotAuthenticatedError2, _super);
    function NotAuthenticatedError2(message) {
      var _this = _super.call(this, message) || this;
      _this.name = "NotAuthenticatedError";
      return _this;
    }
    return NotAuthenticatedError2;
  }(ReactMoralisError)
);
var ValidationError = (
  /** @class */
  function(_super) {
    __extends(ValidationError2, _super);
    function ValidationError2(message) {
      var _this = _super.call(this, message) || this;
      _this.name = "ValidationError";
      return _this;
    }
    return ValidationError2;
  }(ReactMoralisError)
);
var useMoralis = function() {
  var moralisContext = (0, import_react2.useContext)(MoralisContext);
  if (!moralisContext) {
    throw new NoMoralisContextProviderError("Make sure to only call useMoralis within a  <MoralisProvider>");
  }
  return moralisContext;
};
var useChain = function() {
  var _a = useMoralis(), Moralis = _a.Moralis, chainId = _a.chainId, account = _a.account, network = _a.network, provider = _a.provider, connector = _a.connector, connectorType = _a.connectorType;
  var switchNetwork = function(providedChainId) {
    return __awaiter17(void 0, void 0, void 0, function() {
      var error_1, chainData, chainId_1, name_1, nativeCurrency, rpc, blockExplorerUrl;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 6]);
            return [4, Moralis.switchNetwork(providedChainId)];
          case 1:
            _a2.sent();
            return [3, 6];
          case 2:
            error_1 = _a2.sent();
            if (!(error_1.code === 4902))
              return [3, 4];
            chainData = getChain(providedChainId);
            if (!chainData) {
              throw new Error("Chain ".concat(providedChainId, " not supported or is not specified"));
            }
            chainId_1 = chainData.chainId, name_1 = chainData.name, nativeCurrency = chainData.nativeCurrency, rpc = chainData.rpc, blockExplorerUrl = chainData.blockExplorerUrl;
            return [4, Moralis.addNetwork(chainId_1, name_1, nativeCurrency.name, nativeCurrency.symbol, rpc[0], blockExplorerUrl !== null && blockExplorerUrl !== void 0 ? blockExplorerUrl : null)];
          case 3:
            _a2.sent();
            return [3, 5];
          case 4:
            throw error_1;
          case 5:
            return [3, 6];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  var chain = (0, import_react2.useMemo)(function() {
    if (!chainId) {
      return null;
    }
    return getChain(chainId);
  }, [chainId]);
  return {
    switchNetwork,
    chainId,
    chain,
    account,
    network,
    provider,
    connector,
    connectorType
  };
};
var react = function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length, i2, keys;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key2 = keys[i2];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!equal(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
function n(n2) {
  for (var t2 = arguments.length, r2 = Array(t2 > 1 ? t2 - 1 : 0), e = 1; e < t2; e++)
    r2[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? "function" == typeof i2 ? i2.apply(null, r2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (r2.length ? " " + r2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function t(n2) {
  return !!n2 && !!n2[Q];
}
function r(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var t2 = Object.getPrototypeOf(n3);
    if (null === t2)
      return true;
    var r2 = Object.hasOwnProperty.call(t2, "constructor") && t2.constructor;
    return r2 === Object || "function" == typeof r2 && Function.toString.call(r2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function i$1(n2, t2, r2) {
  void 0 === r2 && (r2 = false), 0 === o(n2) ? (r2 ? Object.keys : nn)(n2).forEach(function(e) {
    r2 && "symbol" == typeof e || t2(e, n2[e], n2);
  }) : n2.forEach(function(r3, e) {
    return t2(e, r3, n2);
  });
}
function o(n2) {
  var t2 = n2[Q];
  return t2 ? t2.i > 3 ? t2.i - 4 : t2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, t2) {
  return 2 === o(n2) ? n2.has(t2) : Object.prototype.hasOwnProperty.call(n2, t2);
}
function a(n2, t2) {
  return 2 === o(n2) ? n2.get(t2) : n2[t2];
}
function f2(n2, t2, r2) {
  var e = o(n2);
  2 === e ? n2.set(t2, r2) : 3 === e ? (n2.delete(t2), n2.add(r2)) : n2[t2] = r2;
}
function c(n2, t2) {
  return n2 === t2 ? 0 !== n2 || 1 / n2 == 1 / t2 : n2 != n2 && t2 != t2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var t2 = tn(n2);
  delete t2[Q];
  for (var r2 = nn(t2), e = 0; e < r2.length; e++) {
    var i2 = r2[e], o2 = t2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (t2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), t2);
}
function d(n2, e) {
  return void 0 === e && (e = false), y(n2) || t(n2) || !r(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i$1(n2, function(n3, t2) {
    return d(t2, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(t2) {
  var r2 = rn[t2];
  return r2 || n(18, t2), r2;
}
function _() {
  return U || n(0), U;
}
function j(n2, t2) {
  t2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = t2);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var t2 = n2[Q];
  0 === t2.i || 1 === t2.i ? t2.j() : t2.O = true;
}
function P(t2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = void 0 !== t2 && t2 !== i2;
  return e.h.g || b("ES5").S(e, t2, o2), o2 ? (i2[Q].P && (O(e), n(4)), r(t2) && (t2 = M(e, t2), e.l || x(e, t2)), e.u && b("Patches").M(i2[Q], t2, e.u, e.s)) : t2 = M(e, i2, []), O(e), e.u && e.v(e.u, e.s), t2 !== H ? t2 : void 0;
}
function M(n2, t2, r2) {
  if (y(t2))
    return t2;
  var e = t2[Q];
  if (!e)
    return i$1(t2, function(i2, o3) {
      return A(n2, e, t2, i2, o3, r2);
    }, true), t2;
  if (e.A !== n2)
    return t2;
  if (!e.P)
    return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o;
    i$1(3 === e.i ? new Set(o2) : o2, function(t3, i2) {
      return A(n2, e, o2, t3, i2, r2);
    }), x(n2, o2, false), r2 && n2.u && b("Patches").R(e, r2, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2) {
  if (c2 === o2 && n(5), t(c2)) {
    var v2 = M(e, c2, s2 && i2 && 3 !== i2.i && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f2(o2, a2, v2), !t(v2))
      return;
    e.m = false;
  }
  if (r(c2) && !y(c2)) {
    if (!e.h.F && e._ < 1)
      return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, t2, r2) {
  void 0 === r2 && (r2 = false), n2.h.F && n2.m && d(t2, r2);
}
function z(n2, t2) {
  var r2 = n2[Q];
  return (r2 ? p(r2) : n2)[t2];
}
function I(n2, t2) {
  if (t2 in n2)
    for (var r2 = Object.getPrototypeOf(n2); r2; ) {
      var e = Object.getOwnPropertyDescriptor(r2, t2);
      if (e)
        return e;
      r2 = Object.getPrototypeOf(r2);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, t2, r2) {
  var e = s(t2) ? b("MapSet").N(t2, r2) : v(t2) ? b("MapSet").T(t2, r2) : n2.g ? function(n3, t3) {
    var r3 = Array.isArray(n3), e2 = { i: r3 ? 1 : 0, A: t3 ? t3.A : _(), P: false, I: false, D: {}, l: t3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    r3 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f3 = u2.proxy;
    return e2.k = f3, e2.j = a2, f3;
  }(t2, r2) : b("ES5").J(t2, r2);
  return (r2 ? r2.A : _()).p.push(e), e;
}
function D(e) {
  return t(e) || n(22, e), function n2(t2) {
    if (!r(t2))
      return t2;
    var e2, u2 = t2[Q], c2 = o(t2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e2 = F(t2, c2), u2.I = false;
    } else
      e2 = F(t2, c2);
    return i$1(e2, function(t3, r2) {
      u2 && a(u2.t, t3) === r2 || f2(e2, t3, n2(r2));
    }), 3 === c2 ? new Set(e2) : e2;
  }(e);
}
function F(n2, t2) {
  switch (t2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var tn = Object.getOwnPropertyDescriptors || function(n2) {
  var t2 = {};
  return nn(n2).forEach(function(r2) {
    t2[r2] = Object.getOwnPropertyDescriptor(n2, r2);
  }), t2;
};
var rn = {};
var en = { get: function(n2, t2) {
  if (t2 === Q)
    return n2;
  var e = p(n2);
  if (!u(e, t2))
    return function(n3, t3, r2) {
      var e2, i3 = I(t3, r2);
      return i3 ? "value" in i3 ? i3.value : null === (e2 = i3.get) || void 0 === e2 ? void 0 : e2.call(n3.k) : void 0;
    }(n2, e, t2);
  var i2 = e[t2];
  return n2.I || !r(i2) ? i2 : i2 === z(n2.t, t2) ? (E(n2), n2.o[t2] = R(n2.A.h, i2, n2)) : i2;
}, has: function(n2, t2) {
  return t2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, t2, r2) {
  var e = I(p(n2), t2);
  if (null == e ? void 0 : e.set)
    return e.set.call(n2.k, r2), true;
  if (!n2.P) {
    var i2 = z(p(n2), t2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === r2)
      return n2.o[t2] = r2, n2.D[t2] = false, true;
    if (c(r2, i2) && (void 0 !== r2 || u(n2.t, t2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[t2] === r2 && "number" != typeof r2 && (void 0 !== r2 || t2 in n2.o) || (n2.o[t2] = r2, n2.D[t2] = true, true);
}, deleteProperty: function(n2, t2) {
  return void 0 !== z(n2.t, t2) || t2 in n2.t ? (n2.D[t2] = false, E(n2), k(n2)) : delete n2.D[t2], n2.o && delete n2.o[t2], true;
}, getOwnPropertyDescriptor: function(n2, t2) {
  var r2 = p(n2), e = Reflect.getOwnPropertyDescriptor(r2, t2);
  return e ? { writable: true, configurable: 1 !== n2.i || "length" !== t2, enumerable: e.enumerable, value: r2[t2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i$1(en, function(n2, t2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], t2.apply(this, arguments);
  };
}), on.deleteProperty = function(t2, r2) {
  return isNaN(parseInt(r2)) && n(13), en.deleteProperty.call(this, t2[0], r2);
}, on.set = function(t2, r2, e) {
  return "length" !== r2 && isNaN(parseInt(r2)) && n(14), en.set.call(this, t2[0], r2, e, t2[0]);
};
var un = function() {
  function e(t2) {
    var e2 = this;
    this.g = B, this.F = true, this.produce = function(t3, i3, o2) {
      if ("function" == typeof t3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = t3;
        var a2 = e2;
        return function(n2) {
          var t4 = this;
          void 0 === n2 && (n2 = u2);
          for (var r2 = arguments.length, e3 = Array(r2 > 1 ? r2 - 1 : 0), o3 = 1; o3 < r2; o3++)
            e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var r3;
            return (r3 = i3).call.apply(r3, [t4, n3].concat(e3));
          });
        };
      }
      var f3;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), r(t3)) {
        var c2 = w(e2), s2 = R(e2, t3, void 0), v2 = true;
        try {
          f3 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return "undefined" != typeof Promise && f3 instanceof Promise ? f3.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f3, c2));
      }
      if (!t3 || "object" != typeof t3) {
        if ((f3 = i3(t3)) === H)
          return;
        return void 0 === f3 && (f3 = t3), e2.F && d(f3, true), f3;
      }
      n(21, t3);
    }, this.produceWithPatches = function(n2, t3) {
      return "function" == typeof n2 ? function(t4) {
        for (var r3 = arguments.length, i4 = Array(r3 > 1 ? r3 - 1 : 0), o2 = 1; o2 < r3; o2++)
          i4[o2 - 1] = arguments[o2];
        return e2.produceWithPatches(t4, function(t5) {
          return n2.apply(void 0, [t5].concat(i4));
        });
      } : [e2.produce(n2, t3, function(n3, t4) {
        r2 = n3, i3 = t4;
      }), r2, i3];
      var r2, i3;
    }, "boolean" == typeof (null == t2 ? void 0 : t2.useProxies) && this.setUseProxies(t2.useProxies), "boolean" == typeof (null == t2 ? void 0 : t2.autoFreeze) && this.setAutoFreeze(t2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    r(e2) || n(8), t(e2) && (e2 = D(e2));
    var i3 = w(this), o2 = R(this, e2, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function(t2, r2) {
    var e2 = t2 && t2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, r2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(t2) {
    t2 && !B && n(20), this.g = t2;
  }, i2.applyPatches = function(n2, r2) {
    var e2;
    for (e2 = r2.length - 1; e2 >= 0; e2--) {
      var i3 = r2[e2];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (r2 = r2.slice(e2 + 1));
    var o2 = b("Patches").$;
    return t(n2) ? o2(n2, r2) : this.produce(n2, function(n3) {
      return o2(n3, r2);
    });
  }, e;
}();
var an = new un();
var fn = an.produce;
an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
var n$1 = fn;
function i(f3) {
  var u2 = (0, import_react2.useState)(function() {
    return d("function" == typeof f3 ? f3() : f3, true);
  }), i2 = u2[1];
  return [u2[0], (0, import_react2.useCallback)(function(t2) {
    i2("function" == typeof t2 ? n$1(t2) : d(t2));
  }, [])];
}
var _useResolveCall = function(call, initialData, params, options, defaultAutoFetch, validate6) {
  if (defaultAutoFetch === void 0) {
    defaultAutoFetch = true;
  }
  var isInitialized = useMoralis().isInitialized;
  var autoFetch = __assign({
    autoFetch: defaultAutoFetch
  }, options !== null && options !== void 0 ? options : {}).autoFetch;
  var _a = (0, import_react2.useState)(false), isFetching = _a[0], setIsFetching = _a[1];
  var _b = (0, import_react2.useState)(null), error = _b[0], setError = _b[1];
  var _c = i(initialData), data = _c[0], setData = _c[1];
  var paramsRef = (0, import_react2.useRef)(params);
  if (!react(paramsRef.current, params)) {
    paramsRef.current = params;
  }
  var fetch2 = (0, import_react2.useCallback)(function(_a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, throwOnError = _b2.throwOnError, onComplete = _b2.onComplete, onError = _b2.onError, onSuccess = _b2.onSuccess, fetchParams = _b2.params;
    return __awaiter17(void 0, void 0, void 0, function() {
      var combinedParams, error_2, results, error_1;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            combinedParams = __assign(__assign({}, params), fetchParams);
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, 4, 5]);
            if (validate6) {
              error_2 = validate6(combinedParams);
              if (error_2) {
                throw new Error(error_2);
              }
            }
            setIsFetching(true);
            setError(null);
            return [4, call(combinedParams)];
          case 2:
            results = _c2.sent();
            setData(results);
            if (onSuccess) {
              onSuccess(results);
            }
            return [2, results];
          case 3:
            error_1 = _c2.sent();
            setData(initialData);
            setError(error_1);
            if (throwOnError) {
              throw error_1;
            }
            if (onError) {
              onError(error_1);
            }
            return [3, 5];
          case 4:
            setIsFetching(false);
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [call, paramsRef.current, validate6]);
  var isEmpty = (0, import_react2.useMemo)(function() {
    if (data == null) {
      return true;
    }
    if (Array.isArray(data) && data.length === 0) {
      return true;
    }
    return false;
  }, [data]);
  var isLoading = (0, import_react2.useMemo)(function() {
    return isFetching && isEmpty;
  }, [isEmpty, isFetching]);
  (0, import_react2.useEffect)(function() {
    if (!isInitialized || !autoFetch) {
      return;
    }
    fetch2();
  }, [fetch2, isInitialized]);
  return {
    fetch: fetch2,
    isFetching,
    isLoading,
    error,
    data,
    setData
  };
};
var useMoralisCloudFunction = function(name2, params, options) {
  var Moralis = useMoralis().Moralis;
  var call = (0, import_react2.useCallback)(function(callParams) {
    return Moralis.Cloud.run(name2, callParams);
  }, [name2]);
  return _useResolveCall(call, null, params, options);
};
var useMoralisFile = function() {
  var Moralis = useMoralis().Moralis;
  var _a = (0, import_react2.useState)(null), error = _a[0], setError = _a[1];
  var _b = (0, import_react2.useState)(false), isUploading = _b[0], setIsUploading = _b[1];
  var _c = (0, import_react2.useState)(null), moralisFile = _c[0], setMoralisFile = _c[1];
  var saveFile = (0, import_react2.useCallback)(function(name2, file, _a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, type = _b2.type, metadata = _b2.metadata, tags = _b2.tags, saveIPFS = _b2.saveIPFS, throwOnError = _b2.throwOnError, onComplete = _b2.onComplete, onError = _b2.onError, onSuccess = _b2.onSuccess;
    return __awaiter17(void 0, void 0, void 0, function() {
      var moralisFile_1, error_1;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            _c2.trys.push([0, 5, 6, 7]);
            setIsUploading(true);
            setError(null);
            moralisFile_1 = new Moralis.File(
              name2,
              file,
              type,
              //@ts-ignore type is different than documentation (it should accept metadata and tags)
              metadata,
              tags
            );
            if (!saveIPFS)
              return [3, 2];
            return [4, moralisFile_1.saveIPFS()];
          case 1:
            _c2.sent();
            return [3, 4];
          case 2:
            return [4, moralisFile_1.save()];
          case 3:
            _c2.sent();
            _c2.label = 4;
          case 4:
            setMoralisFile(moralisFile_1);
            if (onSuccess) {
              onSuccess(moralisFile_1);
            }
            return [2, moralisFile_1];
          case 5:
            error_1 = _c2.sent();
            setError(error_1);
            if (throwOnError) {
              throw error_1;
            }
            if (onError) {
              onError(error_1);
            }
            return [3, 7];
          case 6:
            setIsUploading(false);
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  return {
    error,
    saveFile,
    isUploading,
    moralisFile
  };
};
var useNewMoralisObject = function(objectClassName) {
  var Moralis = useMoralis().Moralis;
  var _a = (0, import_react2.useState)(false), isSaving = _a[0], setIsSaving = _a[1];
  var _b = (0, import_react2.useState)(null), error = _b[0], setError = _b[1];
  var _c = (0, import_react2.useState)(null), object = _c[0], setObject = _c[1];
  var save = (0, import_react2.useCallback)(function(data, _a2) {
    if (data === void 0) {
      data = {};
    }
    var _b2 = _a2 === void 0 ? {} : _a2, cascadeSave = _b2.cascadeSave, throwOnError = _b2.throwOnError, context = _b2.context, onSuccess = _b2.onSuccess, onComplete = _b2.onComplete, onError = _b2.onError;
    return __awaiter17(void 0, void 0, void 0, function() {
      var Object_1, object_1, error_1;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            setIsSaving(true);
            setError(null);
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, 4, 5]);
            Object_1 = Moralis.Object.extend(objectClassName);
            object_1 = new Object_1();
            return [4, object_1.save(data, { cascadeSave, context })];
          case 2:
            _c2.sent();
            setObject(object_1);
            if (onSuccess) {
              onSuccess(object_1);
            }
            return [2, object_1];
          case 3:
            error_1 = _c2.sent();
            setError(error_1);
            if (throwOnError) {
              throw error_1;
            }
            if (onError) {
              onError(error_1);
            }
            return [3, 5];
          case 4:
            setIsSaving(false);
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [objectClassName]);
  return {
    isSaving,
    object,
    error,
    save
  };
};
var setMultipleDataToUser = function(data, user) {
  var password = data.password, email = data.email, username = data.username, restData = __rest(data, ["password", "email", "username"]);
  if (password !== void 0) {
    if (typeof password !== "string") {
      throw new ValidationError("password can only be a string type");
    }
    user.setPassword(password);
  }
  if (email !== void 0) {
    if (typeof email !== "string") {
      throw new ValidationError("email can only be a string type");
    }
    user.setEmail(email);
  }
  if (username !== void 0) {
    if (typeof username !== "string") {
      throw new ValidationError("username can only be a string type");
    }
    user.setUsername(username);
  }
  Object.entries(restData).filter(function(_a) {
    var value = _a[1];
    return value !== void 0;
  }).forEach(function(_a) {
    var key2 = _a[0], value = _a[1];
    user.set(key2, value);
  });
};
var AuthenticationState;
(function(AuthenticationState2) {
  AuthenticationState2["UNDEFINED"] = "undefined";
  AuthenticationState2["UNAUTHENTICATED"] = "unauthenticated";
  AuthenticationState2["AUTHENTICATED"] = "authenticated";
  AuthenticationState2["AUTHENTICATING"] = "authenticating";
  AuthenticationState2["LOGGING_OUT"] = "logging_out";
  AuthenticationState2["ERROR"] = "error";
})(AuthenticationState || (AuthenticationState = {}));
var initialAuth = {
  state: AuthenticationState.UNDEFINED,
  error: null
};
var defaultUseMoralisAuthOptions = function(moralis) {
  return {
    // We will override this right away, we just want to
    setUser: function() {
    },
    Moralis: moralis,
    environment: "browser"
  };
};
var _useMoralisAuth = function(options) {
  var _a = __assign(__assign({}, defaultUseMoralisAuthOptions(options.Moralis)), options), onAccountChanged = _a.onAccountChanged, Moralis = _a.Moralis, environment = _a.environment, _setIsWeb3Enabled = _a._setIsWeb3Enabled, _setIsWeb3EnableLoading = _a._setIsWeb3EnableLoading;
  var setUser = options.setUser;
  var _b = (0, import_react2.useState)(initialAuth), auth = _b[0], setAuth = _b[1];
  var _c = (0, import_react2.useState)(false), hasOnAccountChangeListener = _c[0], setHasOnAccountChangeListener = _c[1];
  var authenticate = (0, import_react2.useCallback)(function(_a2) {
    if (_a2 === void 0) {
      _a2 = {};
    }
    return __awaiter17(void 0, void 0, void 0, function() {
      var user, error_1;
      var onComplete = _a2.onComplete, onError = _a2.onError, onSuccess = _a2.onSuccess, throwOnError = _a2.throwOnError, rest = __rest(_a2, ["onComplete", "onError", "onSuccess", "throwOnError"]);
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            setAuth({
              state: AuthenticationState.AUTHENTICATING,
              error: null
            });
            if (_setIsWeb3EnableLoading) {
              _setIsWeb3EnableLoading(true);
            }
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, 3, 4, 5]);
            return [4, Moralis.authenticate(rest)];
          case 2:
            user = _b2.sent();
            setUser(user);
            if (_setIsWeb3Enabled) {
              _setIsWeb3Enabled(true);
            }
            setAuth({
              state: AuthenticationState.AUTHENTICATED,
              error: null
            });
            if (onSuccess) {
              onSuccess(user);
            }
            return [2, user];
          case 3:
            error_1 = _b2.sent();
            setAuth({ state: AuthenticationState.ERROR, error: error_1 });
            setUser(null);
            if (onError) {
              onError(error_1);
            }
            if (throwOnError) {
              throw error_1;
            }
            return [3, 5];
          case 4:
            if (_setIsWeb3EnableLoading) {
              _setIsWeb3EnableLoading(false);
            }
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [_setIsWeb3Enabled, _setIsWeb3EnableLoading]);
  var signup = (0, import_react2.useCallback)(function(username, password, email, otherFields, _a2) {
    if (otherFields === void 0) {
      otherFields = {};
    }
    var _b2 = _a2 === void 0 ? {} : _a2, throwOnError = _b2.throwOnError, onSuccess = _b2.onSuccess, onError = _b2.onError, onComplete = _b2.onComplete;
    return __awaiter17(void 0, void 0, void 0, function() {
      var newUser, user, error_2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            setAuth({
              state: AuthenticationState.AUTHENTICATING,
              error: null
            });
            newUser = new Moralis.User();
            setMultipleDataToUser(__assign({ username, password, email }, otherFields), newUser);
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, 4, 5]);
            return [4, newUser.signUp()];
          case 2:
            user = _c2.sent();
            setAuth({
              state: AuthenticationState.AUTHENTICATED,
              error: null
            });
            setUser(user);
            if (onSuccess) {
              onSuccess(user);
            }
            return [2, user];
          case 3:
            error_2 = _c2.sent();
            setAuth({ state: AuthenticationState.ERROR, error: error_2 });
            if (throwOnError) {
              throw error_2;
            }
            if (onError) {
              onError(error_2);
            }
            return [3, 5];
          case 4:
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  var login = (0, import_react2.useCallback)(function(username, password, _a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, usePost = _b2.usePost, throwOnError = _b2.throwOnError, onError = _b2.onError, onSuccess = _b2.onSuccess, onComplete = _b2.onComplete;
    return __awaiter17(void 0, void 0, void 0, function() {
      var user, error_3;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            setAuth({
              state: AuthenticationState.AUTHENTICATING,
              error: null
            });
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, 4, 5]);
            return [4, Moralis.User.logIn(username, password, {
              // @ts-ignore: missing types
              usePost
            })];
          case 2:
            user = _c2.sent();
            setAuth({
              state: AuthenticationState.AUTHENTICATED,
              error: null
            });
            setUser(user);
            if (onSuccess) {
              onSuccess(user);
            }
            return [2, user];
          case 3:
            error_3 = _c2.sent();
            setAuth({ state: AuthenticationState.ERROR, error: error_3 });
            if (throwOnError) {
              throw error_3;
            }
            if (onError) {
              onError(error_3);
            }
            return [3, 5];
          case 4:
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  var logout = (0, import_react2.useCallback)(function(_a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, throwOnError = _b2.throwOnError, onError = _b2.onError, onSuccess = _b2.onSuccess, onComplete = _b2.onComplete;
    return __awaiter17(void 0, void 0, void 0, function() {
      var error_4;
      var _c2;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            setAuth({
              state: AuthenticationState.AUTHENTICATING,
              error: null
            });
            _d.label = 1;
          case 1:
            _d.trys.push([1, 3, 4, 5]);
            return [4, Moralis.User.logOut()];
          case 2:
            _d.sent();
            setAuth({ state: AuthenticationState.UNAUTHENTICATED, error: null });
            setUser(null);
            if (onSuccess) {
              onSuccess();
            }
            return [3, 5];
          case 3:
            error_4 = _d.sent();
            setAuth({ state: AuthenticationState.ERROR, error: error_4 });
            setUser((_c2 = Moralis.User.current()) !== null && _c2 !== void 0 ? _c2 : null);
            if (throwOnError) {
              throw error_4;
            }
            if (onError) {
              onError(error_4);
            }
            return [3, 5];
          case 4:
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  (0, import_react2.useEffect)(function() {
    try {
      var currentUser = Moralis.User.current();
      if (currentUser) {
        setAuth({
          state: AuthenticationState.AUTHENTICATED,
          error: null
        });
        setUser(currentUser);
      } else {
        throw new Error("Let it catch");
      }
    } catch (error) {
      setAuth({
        state: AuthenticationState.UNAUTHENTICATED,
        error: null
      });
      setUser(null);
    }
  }, []);
  (0, import_react2.useEffect)(function() {
    if (hasOnAccountChangeListener) {
      return;
    }
    if (environment !== "browser") {
      return;
    }
    if (!window) {
      console.warn("No window object found");
      return;
    }
    try {
      var ethereum = window.ethereum;
      if (!ethereum) {
        console.warn("No window.ethereum found");
        return;
      }
      ethereum.on("accountsChanged", function(accounts) {
        return __awaiter17(void 0, void 0, void 0, function() {
          var account;
          return __generator(this, function(_a2) {
            account = accounts[0];
            if (onAccountChanged) {
              onAccountChanged(account);
            }
            return [
              2
              /*return*/
            ];
          });
        });
      });
    } catch (error) {
      console.warn(error.message);
    }
    setHasOnAccountChangeListener(true);
  }, [hasOnAccountChangeListener]);
  var isAuthenticated = auth.state === AuthenticationState.AUTHENTICATED;
  var isUnauthenticated = auth.state === AuthenticationState.UNAUTHENTICATED;
  var isAuthenticating = auth.state === AuthenticationState.AUTHENTICATING;
  var hasAuthError = auth.state === AuthenticationState.ERROR;
  var isLoggingOut = auth.state === AuthenticationState.LOGGING_OUT;
  var isAuthUndefined = auth.state === AuthenticationState.UNDEFINED;
  return {
    auth,
    authenticate,
    signup,
    login,
    logout,
    authError: auth.error,
    isAuthenticated,
    isUnauthenticated,
    isAuthenticating,
    hasAuthError,
    isLoggingOut,
    isAuthUndefined
  };
};
var _useMoralisInit = function(_a) {
  var appId = _a.appId, serverUrl = _a.serverUrl, jsKey = _a.jsKey, dangerouslyUseOfMasterKey = _a.dangerouslyUseOfMasterKey, plugins = _a.plugins, _b = _a.environment, environment = _b === void 0 ? "browser" : _b, _c = _a.getMoralis, getMoralis = _c === void 0 ? function() {
    return import_moralis_v1.default;
  } : _c, initializeOnMount = _a.initializeOnMount, setAppId = _a.setAppId, setServerUrl = _a.setServerUrl;
  var _d = (0, import_react2.useState)(false), isInitialized = _d[0], setIsInitialized = _d[1];
  var _e = (0, import_react2.useState)(false), isInitializing = _e[0], setIsInitializing = _e[1];
  var _f = (0, import_react2.useState)(false), shouldInitialize = _f[0], setShouldInitialize = _f[1];
  var Moralis = (0, import_react2.useRef)(getMoralis());
  var _initialize = (0, import_react2.useCallback)(function(_a2) {
    var serverUrl2 = _a2.serverUrl, appId2 = _a2.appId, javascriptKey = _a2.javascriptKey, masterKey = _a2.masterKey, plugins2 = _a2.plugins;
    return __awaiter17(void 0, void 0, void 0, function() {
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            if (isInitialized) {
              return [
                2
                /*return*/
              ];
            }
            if (!appId2) {
              throw new ReactMoralisError('Provide a "appId" provided to <MoralisProvider>');
            }
            if (!serverUrl2) {
              throw new ReactMoralisError('Provide a "serverUrl" provided to <MoralisProvider>');
            }
            setIsInitializing(true);
            return [4, Moralis.current.start({
              serverUrl: serverUrl2,
              appId: appId2,
              javascriptKey,
              masterKey,
              plugins: plugins2
            })];
          case 1:
            _b2.sent();
            setIsInitializing(false);
            setIsInitialized(true);
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  (0, import_react2.useEffect)(function() {
    if (isInitialized) {
      return;
    }
    if (!initializeOnMount && !shouldInitialize) {
      return;
    }
    _initialize({
      appId,
      serverUrl,
      masterKey: dangerouslyUseOfMasterKey,
      javascriptKey: jsKey,
      plugins
    });
    setIsInitialized(true);
  }, [
    appId,
    serverUrl,
    dangerouslyUseOfMasterKey,
    jsKey,
    plugins,
    isInitialized,
    initializeOnMount,
    shouldInitialize
  ]);
  var initialize = (0, import_react2.useCallback)(function(_a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, newAppId = _b2.appId, newServerUrl = _b2.serverUrl;
    if (newAppId) {
      setAppId(newAppId);
    }
    if (newServerUrl) {
      setServerUrl(newServerUrl);
    }
    if (!newAppId && !appId) {
      throw new Error("No appId is provided. Please provide an appId to the Moralis.Provider or as argument in initialize()");
    }
    if (!newServerUrl && !serverUrl) {
      throw new Error("No serverUrl is provided. Please provide an serverUrl to the Moralis.Provider or as argument in initialize()");
    }
    setShouldInitialize(true);
  }, [appId, serverUrl]);
  return {
    isInitialized,
    isInitializing,
    initialize,
    Moralis: Moralis.current,
    environment
  };
};
var _useMoralisUser = function(Moralis) {
  var _a = (0, import_react2.useState)(null), user = _a[0], setUser = _a[1];
  var _b = (0, import_react2.useState)(false), isUpdating = _b[0], setIsUpdating = _b[1];
  var _c = (0, import_react2.useState)(null), error = _c[0], setError = _c[1];
  var setUserData = (0, import_react2.useCallback)(function(data, _a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, throwOnError = _b2.throwOnError, onComplete = _b2.onComplete, onError = _b2.onError, onSuccess = _b2.onSuccess;
    return __awaiter17(void 0, void 0, void 0, function() {
      var userHasLocallyUpdated, currentUser, error_1;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            if (!user) {
              throw new NotAuthenticatedError("User needs to be authenticated before setting new data");
            }
            setIsUpdating(true);
            setError(null);
            userHasLocallyUpdated = false;
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, 4, 5]);
            setMultipleDataToUser(data, user);
            userHasLocallyUpdated = true;
            return [4, user.save()];
          case 2:
            _c2.sent();
            currentUser = Moralis.User.current();
            if (!currentUser) {
              throw new ReactMoralisError("No user data found after save");
            }
            setUser(currentUser);
            if (onSuccess) {
              onSuccess(user);
            }
            return [2, user];
          case 3:
            error_1 = _c2.sent();
            if (userHasLocallyUpdated) {
              user.revert();
            }
            setError(error_1);
            if (throwOnError) {
              throw error_1;
            }
            if (onError) {
              onError(error_1);
            }
            return [3, 5];
          case 4:
            setIsUpdating(false);
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [user]);
  var refetchUserData = (0, import_react2.useCallback)(function(_a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, throwOnError = _b2.throwOnError, onComplete = _b2.onComplete, onError = _b2.onError, onSuccess = _b2.onSuccess;
    return __awaiter17(void 0, void 0, void 0, function() {
      var newUserData, error_2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            if (!user) {
              throw new NotAuthenticatedError("User needs to be authenticated before refetching");
            }
            setIsUpdating(true);
            setError(null);
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, 4, 5]);
            return [4, user.fetch()];
          case 2:
            newUserData = _c2.sent();
            if (!newUserData) {
              throw new ReactMoralisError("No user data found after refetch");
            }
            setUser(newUserData);
            if (onSuccess) {
              onSuccess(newUserData);
            }
            return [2, newUserData];
          case 3:
            error_2 = _c2.sent();
            setError(error_2);
            if (throwOnError) {
              throw error_2;
            }
            if (onError) {
              onError(error_2);
            }
            return [3, 5];
          case 4:
            setIsUpdating(false);
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [user]);
  return {
    setUserData,
    setUser,
    refetchUserData,
    user,
    _setUser: setUser,
    isUserUpdating: isUpdating,
    userError: error
  };
};
var _useMoralisWeb3 = function(Moralis) {
  var _a = (0, import_react2.useState)(false), isWeb3Enabled = _a[0], _setIsWeb3Enabled = _a[1];
  var _b = (0, import_react2.useState)(null), web3EnableError = _b[0], setEnableWeb3Error = _b[1];
  var _c = (0, import_react2.useState)(false), isWeb3EnableLoading = _c[0], _setIsWeb3EnableLoading = _c[1];
  var _d = (0, import_react2.useState)(null), web3 = _d[0], setWeb3 = _d[1];
  var _e = (0, import_react2.useState)(null), chainId = _e[0], setChainId = _e[1];
  var _f = (0, import_react2.useState)(null), account = _f[0], setAccount = _f[1];
  var _g = (0, import_react2.useState)(null), connector = _g[0], setConnector = _g[1];
  var _h = (0, import_react2.useState)(null), provider = _h[0], setProvider = _h[1];
  (0, import_react2.useEffect)(function() {
    var handleConnect = function(_a2) {
      var web32 = _a2.web3, chainId2 = _a2.chainId, account2 = _a2.account, connector2 = _a2.connector, provider2 = _a2.provider;
      setWeb3(web32);
      setChainId(chainId2);
      setAccount(account2);
      setConnector(connector2);
      setProvider(provider2);
    };
    var handleDisconnect = function() {
      setWeb3(null);
      _setIsWeb3Enabled(false);
      setChainId(null);
      setAccount(null);
      setConnector(null);
      setProvider(null);
    };
    var handleChainChanged = function(chainId2) {
      setChainId(chainId2);
      setWeb3(Moralis.web3);
    };
    var unsubChainChanged = Moralis.onChainChanged(handleChainChanged);
    var unsubAccountChanged = Moralis.onAccountChanged(setAccount);
    var unsubEnable = Moralis.onWeb3Enabled(handleConnect);
    var unsubDeactivate = Moralis.onWeb3Deactivated(handleDisconnect);
    var unsubDisconnect = Moralis.onDisconnect(handleDisconnect);
    return function() {
      unsubChainChanged();
      unsubAccountChanged();
      unsubEnable();
      unsubDeactivate();
      unsubDisconnect();
    };
  }, [Moralis]);
  var enableWeb3 = (0, import_react2.useCallback)(function(_a2) {
    if (_a2 === void 0) {
      _a2 = {};
    }
    return __awaiter17(void 0, void 0, void 0, function() {
      var currentWeb3, error_1;
      var throwOnError = _a2.throwOnError, onComplete = _a2.onComplete, onError = _a2.onError, onSuccess = _a2.onSuccess, rest = __rest(_a2, ["throwOnError", "onComplete", "onError", "onSuccess"]);
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _setIsWeb3EnableLoading(true);
            setEnableWeb3Error(null);
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, 3, 4, 5]);
            return [4, Moralis.enableWeb3(rest)];
          case 2:
            currentWeb3 = _b2.sent();
            _setIsWeb3Enabled(true);
            if (onSuccess) {
              onSuccess(currentWeb3);
            }
            return [2, currentWeb3];
          case 3:
            error_1 = _b2.sent();
            setEnableWeb3Error(error_1);
            if (throwOnError) {
              throw error_1;
            }
            if (onError) {
              onError(error_1);
            }
            return [3, 5];
          case 4:
            _setIsWeb3EnableLoading(false);
            if (onComplete) {
              onComplete();
            }
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  var deactivateWeb3 = (0, import_react2.useCallback)(function() {
    return __awaiter17(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, Moralis.deactivateWeb3()];
          case 1:
            _a2.sent();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, []);
  var network = (0, import_react2.useMemo)(function() {
    var _a2;
    return (_a2 = connector === null || connector === void 0 ? void 0 : connector.network) !== null && _a2 !== void 0 ? _a2 : null;
  }, [connector]);
  var connectorType = (0, import_react2.useMemo)(function() {
    var _a2;
    return (_a2 = connector === null || connector === void 0 ? void 0 : connector.type) !== null && _a2 !== void 0 ? _a2 : null;
  }, [connector]);
  return {
    enableWeb3,
    web3,
    isWeb3Enabled,
    web3EnableError,
    isWeb3EnableLoading,
    _setIsWeb3Enabled,
    _setIsWeb3EnableLoading,
    chainId,
    account,
    network,
    connector,
    connectorType,
    deactivateWeb3,
    provider
  };
};
var MoralisProvider = function(_a) {
  var children = _a.children, _appId = _a.appId, _serverUrl = _a.serverUrl, jsKey = _a.jsKey, dangerouslyUseOfMasterKey = _a.dangerouslyUseOfMasterKey, plugins = _a.plugins, environment = _a.environment, getMoralis = _a.getMoralis, _b = _a.options, _c = _b === void 0 ? {} : _b, onAccountChanged = _c.onAccountChanged, _d = _a.initializeOnMount, initializeOnMount = _d === void 0 ? true : _d;
  var _e = (0, import_react2.useState)(_appId !== null && _appId !== void 0 ? _appId : null), appId = _e[0], setAppId = _e[1];
  var _f = (0, import_react2.useState)(_serverUrl !== null && _serverUrl !== void 0 ? _serverUrl : null), serverUrl = _f[0], setServerUrl = _f[1];
  var moralisInit = _useMoralisInit({
    appId,
    serverUrl,
    jsKey,
    dangerouslyUseOfMasterKey,
    plugins,
    environment,
    getMoralis,
    initializeOnMount,
    setAppId,
    setServerUrl
  });
  var _g = _useMoralisWeb3(moralisInit.Moralis), _setIsWeb3Enabled = _g._setIsWeb3Enabled, _setIsWeb3EnableLoading = _g._setIsWeb3EnableLoading, moralisWeb3 = __rest(_g, ["_setIsWeb3Enabled", "_setIsWeb3EnableLoading"]);
  var _h = _useMoralisUser(moralisInit.Moralis), setUser = _h.setUser, moralisUser = __rest(_h, ["setUser"]);
  var moralisAuth = _useMoralisAuth({
    onAccountChanged,
    setUser,
    Moralis: moralisInit.Moralis,
    environment: moralisInit.environment,
    _setIsWeb3Enabled,
    _setIsWeb3EnableLoading
  });
  return (0, import_jsx_runtime2.jsx)(MoralisContext.Provider, __assign({ value: __assign(__assign(__assign(__assign(__assign({}, moralisInit), moralisAuth), moralisUser), moralisWeb3), { appId, serverUrl }) }, { children }), void 0);
};
var _useSafeUpdatedQuery = function(nameOrObject, queryMap, dependencies, isInitialized) {
  if (queryMap === void 0) {
    queryMap = function(q2) {
      return q2;
    };
  }
  if (dependencies === void 0) {
    dependencies = [];
  }
  var Moralis = useMoralis().Moralis;
  var currentQueryMap = (0, import_react2.useMemo)(function() {
    return queryMap;
  }, dependencies);
  var currentNameOrObject = (0, import_react2.useMemo)(function() {
    return nameOrObject;
  }, dependencies);
  var query = (0, import_react2.useMemo)(function() {
    var q2 = new Moralis.Query(
      // Explicit cast to any to prevent ts-error, because Moralis.Query should accept a Moralis.object
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      currentNameOrObject
    );
    return currentQueryMap(q2);
  }, [isInitialized, currentNameOrObject, currentQueryMap]);
  return query;
};
var _useSubscriptionListener = function(_a) {
  var name2 = _a.name, handler = _a.handler, enable = _a.enable, subscription = _a.subscription;
  var isInitialized = useMoralis().isInitialized;
  (0, import_react2.useEffect)(function() {
    if (!enable || !isInitialized || !subscription || !handler) {
      return;
    }
    subscription.on(name2, handler);
    return function() {
      if (subscription) {
        subscription.off(name2, handler);
      }
    };
  }, [isInitialized, handler, enable, name2]);
};
var defaultUseSubscriptionQueryOptions = {
  enabled: true
};
var useMoralisSubscription = function(nameOrObject, queryMap, dependencies, options) {
  var _a, _b, _c, _d, _e, _f;
  if (queryMap === void 0) {
    queryMap = function(q2) {
      return q2;
    };
  }
  if (dependencies === void 0) {
    dependencies = [];
  }
  if (options === void 0) {
    options = {};
  }
  var _g = __assign(__assign({}, defaultUseSubscriptionQueryOptions), options), enabled = _g.enabled, onCreate = _g.onCreate, onDelete = _g.onDelete, onEnter = _g.onEnter, onLeave = _g.onLeave, onUpdate = _g.onUpdate;
  var moralisContext = (0, import_react2.useContext)(MoralisContext);
  var isInitialized = (_a = moralisContext === null || moralisContext === void 0 ? void 0 : moralisContext.isInitialized) !== null && _a !== void 0 ? _a : false;
  var subscriptionRef = (0, import_react2.useRef)();
  var _h = (0, import_react2.useState)(false), isReady = _h[0], setIsReady = _h[1];
  var query = _useSafeUpdatedQuery(nameOrObject, queryMap, dependencies, isInitialized);
  (0, import_react2.useEffect)(function() {
    setIsReady(false);
    if (!enabled || !isInitialized) {
      return;
    }
    query.subscribe().then(function(sub) {
      subscriptionRef.current = sub;
      setIsReady(true);
    });
    return function() {
      if (subscriptionRef.current) {
        subscriptionRef.current.unsubscribe();
      }
    };
  }, [enabled, isInitialized, query]);
  _useSubscriptionListener({
    name: "create",
    handler: onCreate,
    subscription: subscriptionRef.current,
    enable: (_b = enabled && isReady) !== null && _b !== void 0 ? _b : false
  });
  _useSubscriptionListener({
    name: "update",
    handler: onUpdate,
    subscription: subscriptionRef.current,
    enable: (_c = enabled && isReady) !== null && _c !== void 0 ? _c : false
  });
  _useSubscriptionListener({
    name: "enter",
    handler: onEnter,
    subscription: subscriptionRef.current,
    enable: (_d = enabled && isReady) !== null && _d !== void 0 ? _d : false
  });
  _useSubscriptionListener({
    name: "leave",
    handler: onLeave,
    subscription: subscriptionRef.current,
    enable: (_e = enabled && isReady) !== null && _e !== void 0 ? _e : false
  });
  _useSubscriptionListener({
    name: "delete",
    handler: onDelete,
    subscription: subscriptionRef.current,
    enable: (_f = enabled && isReady) !== null && _f !== void 0 ? _f : false
  });
};
var defaultUseMoralisQueryOptions = {
  autoFetch: true,
  live: false,
  onLiveEnter: function(entity, all) {
    return __spreadArray(__spreadArray([], all, true), [entity], false);
  },
  onLiveCreate: function(entity, all) {
    return __spreadArray(__spreadArray([], all, true), [entity], false);
  },
  onLiveDelete: function(entity, all) {
    return all.filter(function(e) {
      return e.id !== entity.id;
    });
  },
  onLiveLeave: function(entity, all) {
    return all.filter(function(e) {
      return e.id !== entity.id;
    });
  },
  onLiveUpdate: function(entity, all) {
    return all.map(function(e) {
      return e.id === entity.id ? entity : e;
    });
  }
};
var useMoralisQuery = function(nameOrObject, queryMap, dependencies, options) {
  if (queryMap === void 0) {
    queryMap = function(q2) {
      return q2;
    };
  }
  if (dependencies === void 0) {
    dependencies = [];
  }
  if (options === void 0) {
    options = {};
  }
  var isInitialized = useMoralis().isInitialized;
  var _a = __assign(__assign({}, defaultUseMoralisQueryOptions), options), live = _a.live, onLiveCreate = _a.onLiveCreate, onLiveDelete = _a.onLiveDelete, onLiveEnter = _a.onLiveEnter, onLiveLeave = _a.onLiveLeave, onLiveUpdate = _a.onLiveUpdate;
  var query = _useSafeUpdatedQuery(nameOrObject, queryMap, dependencies, isInitialized);
  var call = (0, import_react2.useCallback)(function() {
    return query.find();
  }, [query]);
  var _b = _useResolveCall(call, [], void 0, options), data = _b.data, error = _b.error, fetch2 = _b.fetch, isFetching = _b.isFetching, isLoading = _b.isLoading, setData = _b.setData;
  var handleOnCreate = (0, import_react2.useCallback)(function(entity) {
    if (onLiveCreate) {
      setData(function(data2) {
        return onLiveCreate(entity, data2);
      });
    }
  }, [onLiveCreate]);
  var handleOnEnter = (0, import_react2.useCallback)(function(entity) {
    if (onLiveEnter) {
      setData(function(data2) {
        return onLiveEnter(entity, data2);
      });
    }
  }, [onLiveEnter]);
  var handleOnUpdate = (0, import_react2.useCallback)(function(entity) {
    if (onLiveUpdate) {
      setData(function(data2) {
        return onLiveUpdate(entity, data2);
      });
    }
  }, [onLiveUpdate]);
  var handleOnDelete = (0, import_react2.useCallback)(function(entity) {
    if (onLiveDelete) {
      setData(function(data2) {
        return onLiveDelete(entity, data2);
      });
    }
  }, [onLiveDelete]);
  var handleOnLeave = (0, import_react2.useCallback)(function(entity) {
    if (onLiveLeave) {
      setData(function(data2) {
        return onLiveLeave(entity, data2);
      });
    }
  }, [onLiveLeave]);
  useMoralisSubscription(nameOrObject, queryMap, dependencies, {
    enabled: live,
    onCreate: handleOnCreate,
    onEnter: handleOnEnter,
    onUpdate: handleOnUpdate,
    onDelete: handleOnDelete,
    onLeave: handleOnLeave
  });
  return { fetch: fetch2, isFetching, isLoading, error, data };
};
var useMoralisWeb3ApiCall = function(call, params, options) {
  var result = _useResolveCall(call, null, params, options, false);
  return result;
};
var useMoralisWeb3Api = function() {
  var Moralis = useMoralis().Moralis;
  return __assign({ Web3API: Moralis.Web3API }, Moralis.Web3API);
};
var useMoralisSolanaCall = function(call, params, options) {
  var result = _useResolveCall(call, null, params, options, false);
  return result;
};
var useMoralisSolanaApi = function() {
  var Moralis = useMoralis().Moralis;
  return __assign({ SolanaAPI: Moralis.SolanaAPI }, Moralis.SolanaAPI);
};
var useWeb3ExecuteFunction = function(params, options) {
  var Moralis = useMoralis().Moralis;
  var call = (0, import_react2.useCallback)(function(callParams) {
    return __awaiter17(void 0, void 0, void 0, function() {
      var allParams;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            allParams = __assign(__assign({}, params), callParams);
            return [4, Moralis.executeFunction(allParams)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  }, []);
  return _useResolveCall(call, null, params, options, false);
};
var useWeb3Contract = function(params) {
  var _a = useWeb3ExecuteFunction(params), data = _a.data, error = _a.error, runContractFunction = _a.fetch, isFetching = _a.isFetching, isLoading = _a.isLoading;
  return { runContractFunction, data, error, isFetching, isLoading };
};
var useWeb3Transfer = function(params, options) {
  var Moralis = useMoralis().Moralis;
  var call = (0, import_react2.useCallback)(function(callParams) {
    return __awaiter17(void 0, void 0, void 0, function() {
      var allParams;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            allParams = __assign(__assign({}, params), callParams);
            return [4, Moralis.transfer(allParams)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  }, []);
  return _useResolveCall(call, null, params, options, false);
};
var _useResolvePluginCall = function(plugin, call, initialData, params, options, defaultAutoFetch, providedValidate) {
  if (defaultAutoFetch === void 0) {
    defaultAutoFetch = true;
  }
  var _a = useMoralis(), Moralis = _a.Moralis, isInitialized = _a.isInitialized, isInitializing = _a.isInitializing;
  var validate6 = (0, import_react2.useCallback)(function(params2) {
    if (!isInitialized && isInitializing) {
      return "Plugins are not finished initializing";
    }
    if (!isInitialized) {
      return "Moralis has not been initialized, run Moralis.start first";
    }
    if (!(Moralis === null || Moralis === void 0 ? void 0 : Moralis.Plugins) || !(Moralis === null || Moralis === void 0 ? void 0 : Moralis.Plugins[plugin])) {
      return "".concat(plugin, " plugin has not been installed or initialized");
    }
    if (providedValidate) {
      return providedValidate(params2);
    }
  }, [plugin, isInitialized, isInitializing, providedValidate]);
  return _useResolveCall(call, initialData, params, options, defaultAutoFetch, validate6);
};
var useOneInchTokens = function(_a, options) {
  var _b, _c;
  var _d = _a === void 0 ? {} : _a, chain = _d.chain;
  if (options === void 0) {
    options = {};
  }
  var _e = useMoralis(), Moralis = _e.Moralis, isInitialized = _e.isInitialized;
  var _f = _useResolvePluginCall(Plugin.ONE_INCH, (_c = (_b = Moralis.Plugins) === null || _b === void 0 ? void 0 : _b.oneInch) === null || _c === void 0 ? void 0 : _c.getSupportedTokens, [], { chain: chain !== null && chain !== void 0 ? chain : DEFAULT_API_CHAIN }, options, isInitialized), fetch2 = _f.fetch, data = _f.data, isFetching = _f.isFetching, isLoading = _f.isLoading, error = _f.error;
  return { getSupportedTokens: fetch2, data, isFetching, isLoading, error };
};
var useOneInchQuote = function(params, options) {
  var _a, _b, _c, _d;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _e = _useResolvePluginCall(Plugin.ONE_INCH, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.oneInch) === null || _b === void 0 ? void 0 : _b.quote, null, ((_c = Object.keys(params)) === null || _c === void 0 ? void 0 : _c.length) ? {
    chain: (_d = params.chain) !== null && _d !== void 0 ? _d : DEFAULT_API_CHAIN,
    // The token you want to swap
    fromTokenAddress: params.fromToken.address,
    // The token you want to receive
    toTokenAddress: params.toToken.address,
    amount: Moralis.Units.Token(params.fromAmount, params.fromToken.decimals).toString()
  } : void 0, options, false), fetch2 = _e.fetch, data = _e.data, isFetching = _e.isFetching, isLoading = _e.isLoading, error = _e.error;
  return { getQuote: fetch2, data, isFetching, isLoading, error };
};
var useOneInchSwap = function(params, options) {
  var _a, _b;
  if (options === void 0) {
    options = {};
  }
  var _c = useMoralis(), Moralis = _c.Moralis, account = _c.account;
  var doApproveAndSwap = (0, import_react2.useCallback)(function(params2) {
    return __awaiter17(void 0, void 0, void 0, function() {
      var hasAllowance;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, Moralis.Plugins.oneInch.hasAllowance({
              chain: params2.chain,
              fromTokenAddress: params2.fromTokenAddress,
              fromAddress: params2.fromAddress,
              amount: params2.amount
            })];
          case 1:
            hasAllowance = _a2.sent();
            if (!!hasAllowance)
              return [3, 3];
            return [4, Moralis.Plugins.oneInch.approve({
              chain: params2.chain,
              tokenAddress: params2.fromTokenAddress,
              fromAddress: params2.fromAddress
            })];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            return [2, Moralis.Plugins.oneInch.swap(params2)];
        }
      });
    });
  }, []);
  var _d = _useResolvePluginCall(Plugin.ONE_INCH, doApproveAndSwap, null, {
    chain: (_a = params.chain) !== null && _a !== void 0 ? _a : DEFAULT_API_CHAIN,
    fromTokenAddress: params.fromToken.address,
    toTokenAddress: params.toToken.address,
    amount: params.fromAmount,
    fromAddress: account,
    slippage: (_b = params.slippage) !== null && _b !== void 0 ? _b : 1
  }, options, false, function() {
    return !account ? "No web3 account found, run enableWeb3() first" : null;
  }), fetch2 = _d.fetch, data = _d.data, isFetching = _d.isFetching, isLoading = _d.isLoading, error = _d.error;
  return { swap: fetch2, data, isFetching, isLoading, error };
};
var DEFAULT_OPEN_SEA_NETWORK = "mainnet";
var useOpenSeaAsset = function(params, options) {
  var _a, _b, _c;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _d = _useResolvePluginCall(Plugin.OPEN_SEA, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.opensea) === null || _b === void 0 ? void 0 : _b.getAsset, null, {
    network: (_c = params.network) !== null && _c !== void 0 ? _c : DEFAULT_OPEN_SEA_NETWORK,
    tokenAddress: params.tokenAddress,
    tokenId: params.tokenId
  }, options, false), fetch2 = _d.fetch, data = _d.data, isFetching = _d.isFetching, isLoading = _d.isLoading, error = _d.error;
  return { getAsset: fetch2, data, isFetching, isLoading, error };
};
var useOpenSeaOrders = function(params, options) {
  var _a, _b, _c, _d;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _e = _useResolvePluginCall(Plugin.OPEN_SEA, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.opensea) === null || _b === void 0 ? void 0 : _b.getOrders, null, {
    network: (_c = params.network) !== null && _c !== void 0 ? _c : DEFAULT_OPEN_SEA_NETWORK,
    tokenAddress: params.tokenAddress,
    tokenId: params.tokenId,
    orderSide: params.orderSide,
    page: (_d = params.page) !== null && _d !== void 0 ? _d : 1
  }, options, false), fetch2 = _e.fetch, data = _e.data, isFetching = _e.isFetching, isLoading = _e.isLoading, error = _e.error;
  return { getOrders: fetch2, data, isFetching, isLoading, error };
};
var useOpenSeaSellOrder = function(params, options) {
  var _a, _b, _c;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _d = _useResolvePluginCall(Plugin.OPEN_SEA, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.opensea) === null || _b === void 0 ? void 0 : _b.createSellOrder, null, {
    network: (_c = params.network) !== null && _c !== void 0 ? _c : DEFAULT_OPEN_SEA_NETWORK,
    tokenAddress: params.tokenAddress,
    tokenId: params.tokenId,
    tokenType: params.tokenType,
    userAddress: params.userAddress,
    startAmount: params.startAmount,
    endAmount: params.endAmount,
    expirationTime: params.expirationTime
  }, options, false), fetch2 = _d.fetch, data = _d.data, isFetching = _d.isFetching, isLoading = _d.isLoading, error = _d.error;
  return { createSellOrder: fetch2, data, isFetching, isLoading, error };
};
var useOpenSeaBuyOrder = function(params, options) {
  var _a, _b, _c;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _d = _useResolvePluginCall(Plugin.OPEN_SEA, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.opensea) === null || _b === void 0 ? void 0 : _b.createBuyOrder, null, {
    network: (_c = params.network) !== null && _c !== void 0 ? _c : DEFAULT_OPEN_SEA_NETWORK,
    tokenAddress: params.tokenAddress,
    tokenId: params.tokenId,
    tokenType: params.tokenType,
    amount: params.amount,
    userAddress: params.userAddress,
    paymentTokenAddress: params.paymentTokenAddress
  }, options, false), fetch2 = _d.fetch, data = _d.data, isFetching = _d.isFetching, isLoading = _d.isLoading, error = _d.error;
  return { createBuyOrder: fetch2, data, isFetching, isLoading, error };
};
var useFiatBuy = function(params, _a) {
  if (params === void 0) {
    params = {};
  }
  if (_a === void 0) {
    _a = {};
  }
  var disableTriggers = _a.disableTriggers, options = __rest(_a, ["disableTriggers"]);
  var Moralis = useMoralis().Moralis;
  var doBuyCall = (0, import_react2.useCallback)(function(params2) {
    var _a2, _b2;
    return (_b2 = (_a2 = Moralis.Plugins) === null || _a2 === void 0 ? void 0 : _a2.fiat) === null || _b2 === void 0 ? void 0 : _b2.buy(params2, { disableTriggers });
  }, [disableTriggers]);
  var _b = _useResolvePluginCall(Plugin.FIAT, doBuyCall, null, {
    coin: params.coin,
    receiver: params.receiver
  }, options, false), fetch2 = _b.fetch, data = _b.data, isFetching = _b.isFetching, isLoading = _b.isLoading, error = _b.error;
  return { buy: fetch2, data, isFetching, isLoading, error };
};
var DEFAULT_RARIBLE_NETWORK = "eth";
var useRaribleLazyMint = function(params, options) {
  var _a, _b, _c;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _d = _useResolvePluginCall(Plugin.RARIBLE, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.rarible) === null || _b === void 0 ? void 0 : _b.lazyMint, null, {
    chain: (_c = params.chain) !== null && _c !== void 0 ? _c : DEFAULT_RARIBLE_NETWORK,
    userAddress: params.userAddress,
    tokenType: params.tokenType,
    tokenUri: params.tokenUri,
    supply: params.supply,
    royaltiesAmount: params.royaltiesAmount
  }, options, false), fetch2 = _d.fetch, data = _d.data, isFetching = _d.isFetching, isLoading = _d.isLoading, error = _d.error;
  return { lazyMint: fetch2, data, isFetching, isLoading, error };
};
var useRaribleSellOrder = function(params, options) {
  var _a, _b, _c;
  if (options === void 0) {
    options = {};
  }
  var Moralis = useMoralis().Moralis;
  var _d = _useResolvePluginCall(Plugin.RARIBLE, (_b = (_a = Moralis.Plugins) === null || _a === void 0 ? void 0 : _a.rarible) === null || _b === void 0 ? void 0 : _b.createSellOrder, null, {
    chain: (_c = params.chain) !== null && _c !== void 0 ? _c : DEFAULT_RARIBLE_NETWORK,
    userAddress: params.userAddress,
    makeTokenId: params.makeTokenId,
    makeTokenAddress: params.makeTokenAddress,
    makeAssetClass: params.makeAssetClass,
    makeValue: params.makeValue,
    takeAssetClass: params.takeAssetClass,
    takeValue: params.takeValue
  }, options, false), fetch2 = _d.fetch, data = _d.data, isFetching = _d.isFetching, isLoading = _d.isLoading, error = _d.error;
  return { createSellOrder: fetch2, data, isFetching, isLoading, error };
};
var useApiContract = function(_a, options) {
  var _b;
  var functionName = _a.functionName, address = _a.address, abi = _a.abi, chain = _a.chain, params = _a.params;
  if (options === void 0) {
    options = {};
  }
  var native = useMoralisWeb3Api().native;
  var payload = {
    abi,
    chain,
    function_name: functionName,
    address,
    params
  };
  var _c = useMoralisWeb3ApiCall(native.runContractFunction, payload, __assign({ autoFetch: (_b = options.autoFetch) !== null && _b !== void 0 ? _b : false }, options)), runContractFunction = _c.fetch, data = _c.data, error = _c.error, isFetching = _c.isFetching, isLoading = _c.isLoading;
  return { runContractFunction, data, error, isLoading, isFetching };
};
var isValidApiChain = function(chain) {
  if (!chain) {
    return null;
  }
  return chain;
};
var useERC20Balances = function(params, options) {
  var _a, _b, _c, _d, _e;
  var getTokenBalances = useMoralisWeb3Api().account.getTokenBalances;
  var _f = useMoralis(), account = _f.account, chainId = _f.chainId;
  var _g = useMoralisWeb3ApiCall(getTokenBalances, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN, address: (_d = (_c = params === null || params === void 0 ? void 0 : params.address) !== null && _c !== void 0 ? _c : account) !== null && _d !== void 0 ? _d : "" }, params), __assign({ autoFetch: (_e = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _e !== void 0 ? _e : !!account }, options)), fetch2 = _g.fetch, data = _g.data, isLoading = _g.isLoading, isFetching = _g.isFetching, error = _g.error;
  return {
    fetchERC20Balances: fetch2,
    data,
    isLoading,
    isFetching,
    error
  };
};
var useERC20Transfers = function(params, options) {
  var _a, _b, _c, _d, _e;
  var getTokenTransfers = useMoralisWeb3Api().account.getTokenTransfers;
  var _f = useMoralis(), account = _f.account, chainId = _f.chainId;
  var _g = useMoralisWeb3ApiCall(getTokenTransfers, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN, address: (_d = (_c = params === null || params === void 0 ? void 0 : params.address) !== null && _c !== void 0 ? _c : account) !== null && _d !== void 0 ? _d : "" }, params), __assign({ autoFetch: (_e = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _e !== void 0 ? _e : !!account }, options)), fetch2 = _g.fetch, data = _g.data, isLoading = _g.isLoading, isFetching = _g.isFetching, error = _g.error;
  return {
    fetchERC20Transfers: fetch2,
    data,
    error,
    isLoading,
    isFetching
  };
};
var IPFS_ROOT = "https://gateway.ipfs.io/ipfs/";
var resolveIPFS = function(url) {
  if (!url) {
    return url;
  }
  if (!url.includes("ipfs://") || !url) {
    return url;
  }
  return url.replace("ipfs://", IPFS_ROOT);
};
var useNFTBalances = function(params, options) {
  var _a, _b, _c, _d, _e;
  var getNFTs = useMoralisWeb3Api().account.getNFTs;
  var _f = useMoralis(), chainId = _f.chainId, account = _f.account;
  var _g = useMoralisWeb3ApiCall(getNFTs, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN, address: (_d = (_c = params === null || params === void 0 ? void 0 : params.address) !== null && _c !== void 0 ? _c : account) !== null && _d !== void 0 ? _d : "" }, params), __assign({ autoFetch: (_e = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _e !== void 0 ? _e : !!account }, options)), getNFTBalances = _g.fetch, data = _g.data, error = _g.error, isLoading = _g.isLoading, isFetching = _g.isFetching;
  var balances = (0, import_react2.useMemo)(function() {
    if (!(data === null || data === void 0 ? void 0 : data.result) || !(data === null || data === void 0 ? void 0 : data.result.length)) {
      return data;
    }
    var formattedResult = data.result.map(function(nft) {
      try {
        if (nft.metadata) {
          var metadata = JSON.parse(nft.metadata);
          var image = resolveIPFS(metadata === null || metadata === void 0 ? void 0 : metadata.image);
          return __assign(__assign({}, nft), { image, metadata });
        }
      } catch (error2) {
        return nft;
      }
      return nft;
    });
    return __assign(__assign({}, data), { result: formattedResult });
  }, [data]);
  return { getNFTBalances, data: balances, error, isLoading, isFetching };
};
var useNFTTransfers = function(params, options) {
  var _a, _b, _c, _d, _e;
  var getNFTTransfers = useMoralisWeb3Api().account.getNFTTransfers;
  var _f = useMoralis(), chainId = _f.chainId, account = _f.account;
  var _g = useMoralisWeb3ApiCall(getNFTTransfers, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN, address: (_d = (_c = params === null || params === void 0 ? void 0 : params.address) !== null && _c !== void 0 ? _c : account) !== null && _d !== void 0 ? _d : "" }, params), __assign({ autoFetch: (_e = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _e !== void 0 ? _e : !!account }, options)), fetch2 = _g.fetch, data = _g.data, error = _g.error, isLoading = _g.isLoading, isFetching = _g.isFetching;
  return { getNFTTransfers: fetch2, data, error, isLoading, isFetching };
};
var useNativeBalance = function(params, options) {
  var _a, _b, _c, _d, _e;
  var getNativeBalance = useMoralisWeb3Api().account.getNativeBalance;
  var _f = useMoralis(), chainId = _f.chainId, account = _f.account;
  var nativeToken = (0, import_react2.useMemo)(function() {
    var _a2, _b2;
    var chainData = getChain((_b2 = (_a2 = params === null || params === void 0 ? void 0 : params.chain) !== null && _a2 !== void 0 ? _a2 : isValidApiChain(chainId)) !== null && _b2 !== void 0 ? _b2 : DEFAULT_API_CHAIN);
    if (!chainData) {
      return null;
    }
    return chainData.nativeCurrency;
  }, [params, chainId]);
  var _g = useMoralisWeb3ApiCall(getNativeBalance, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN, address: (_d = (_c = params === null || params === void 0 ? void 0 : params.address) !== null && _c !== void 0 ? _c : account) !== null && _d !== void 0 ? _d : "" }, params), __assign({ autoFetch: (_e = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _e !== void 0 ? _e : !!account }, options)), fetch2 = _g.fetch, data = _g.data, error = _g.error, isLoading = _g.isLoading, isFetching = _g.isFetching;
  var formatted = (0, import_react2.useMemo)(function() {
    if (!nativeToken || !data) {
      return null;
    }
    return tokenValueTxt(data.balance, nativeToken.decimals, nativeToken.symbol);
  }, [data, nativeToken]);
  return {
    getBalances: fetch2,
    data: {
      balance: data === null || data === void 0 ? void 0 : data.balance,
      formatted
    },
    nativeToken,
    error,
    isLoading,
    isFetching
  };
};
var useNativeTransactions = function(params, options) {
  var _a, _b, _c, _d, _e;
  var getTransactions = useMoralisWeb3Api().account.getTransactions;
  var _f = useMoralis(), chainId = _f.chainId, account = _f.account;
  var _g = useMoralisWeb3ApiCall(getTransactions, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN, address: (_d = (_c = params === null || params === void 0 ? void 0 : params.address) !== null && _c !== void 0 ? _c : account) !== null && _d !== void 0 ? _d : "" }, params), __assign({ autoFetch: (_e = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _e !== void 0 ? _e : !!account }, options)), getNativeTransations = _g.fetch, data = _g.data, error = _g.error, isLoading = _g.isLoading, isFetching = _g.isFetching;
  return {
    getNativeTransations,
    data,
    chainId,
    error,
    isLoading,
    isFetching
  };
};
var useTokenPrice = function(params, options) {
  var _a, _b, _c;
  var getTokenPrice = useMoralisWeb3Api().token.getTokenPrice;
  var chainId = useMoralis().chainId;
  var _d = useMoralisWeb3ApiCall(getTokenPrice, __assign({ chain: (_b = (_a = params === null || params === void 0 ? void 0 : params.chain) !== null && _a !== void 0 ? _a : isValidApiChain(chainId)) !== null && _b !== void 0 ? _b : DEFAULT_API_CHAIN }, params), __assign({ autoFetch: (_c = options === null || options === void 0 ? void 0 : options.autoFetch) !== null && _c !== void 0 ? _c : true }, options)), fetch2 = _d.fetch, data = _d.data, error = _d.error, isFetching = _d.isFetching, isLoading = _d.isLoading;
  var formattedData = (0, import_react2.useMemo)(function() {
    var _a2;
    if (!data) {
      return null;
    }
    var _b2 = (_a2 = data.nativePrice) !== null && _a2 !== void 0 ? _a2 : {}, value = _b2.value, decimals = _b2.decimals, symbol = _b2.symbol;
    var formatted = __assign(__assign({}, data), { formattedUsd: toUsd(data.usdPrice), formattedNative: value ? tokenValueTxt(value, decimals !== null && decimals !== void 0 ? decimals : 0, symbol !== null && symbol !== void 0 ? symbol : "") : null });
    return formatted;
  }, [data]);
  return {
    fetchTokenPrice: fetch2,
    data: formattedData,
    error,
    isLoading,
    isFetching
  };
};
var useEnsAddress = function(ensAddress) {
  var web3 = useMoralis().web3;
  var _a = (0, import_react2.useState)(null), resolved = _a[0], setResolved = _a[1];
  var _b = (0, import_react2.useState)(false), isLoading = _b[0], setIsLoading = _b[1];
  var _c = (0, import_react2.useState)(null), error = _c[0], setError = _c[1];
  (0, import_react2.useEffect)(function() {
    if (web3) {
      setIsLoading(true);
      setError(null);
      web3.lookupAddress(ensAddress).then(function(result) {
        setResolved(result);
      }).catch(setError).finally(function() {
        setIsLoading(false);
      });
    }
  }, [ensAddress, web3]);
  return { name: resolved, isLoading, error };
};
var useEnsName = function(ensName) {
  var web3 = useMoralis().web3;
  var _a = (0, import_react2.useState)(null), address = _a[0], setAddress = _a[1];
  var _b = (0, import_react2.useState)(null), avatar = _b[0], setAvatar = _b[1];
  var _c = (0, import_react2.useState)(null), url = _c[0], setUrl = _c[1];
  var _d = (0, import_react2.useState)(null), email = _d[0], setEmail = _d[1];
  var _e = (0, import_react2.useState)(false), isLoading = _e[0], setIsLoading = _e[1];
  var _f = (0, import_react2.useState)(null), error = _f[0], setError = _f[1];
  (0, import_react2.useEffect)(function() {
    if (web3) {
      setIsLoading(true);
      setError(null);
      web3.getResolver(ensName).then(function(resolver) {
        if (!resolver) {
          return;
        }
        Promise.all([
          resolver.getAddress().catch(function() {
            return null;
          }),
          resolver.getAvatar().catch(function() {
            return null;
          }),
          resolver.getText("email").catch(function() {
            return null;
          }),
          resolver.getText("url").catch(function() {
            return null;
          })
        ]).then(function(_a2) {
          var _b2;
          var resolvedAddress = _a2[0], resolvedAvatar = _a2[1], resolvedEmail = _a2[2], resolvedUrl = _a2[3];
          setAddress(resolvedAddress);
          setAvatar((_b2 = resolvedAvatar === null || resolvedAvatar === void 0 ? void 0 : resolvedAvatar.url) !== null && _b2 !== void 0 ? _b2 : null);
          setEmail(resolvedEmail);
          setUrl(resolvedUrl);
        });
      }).catch(setError).finally(function() {
        setIsLoading(false);
      });
    }
  }, [ensName, web3]);
  return { address, avatar, email, url, isLoading, error };
};
var white = "#fff";
var brand = "#b7e803";
var PoweredByColour = function(_a) {
  var style = _a.style;
  return (0, import_jsx_runtime2.jsxs)("svg", __assign({ style, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 192 45" }, { children: [(0, import_jsx_runtime2.jsx)("path", { style: { fill: brand }, d: "M0 22.5A21.51 21.51 0 0121.5 1h149a21.5 21.5 0 010 43h-149A21.51 21.51 0 010 22.5z" }, void 0), (0, import_jsx_runtime2.jsx)("circle", { cx: "25.5", cy: "22.5", r: "17.5" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: white }, d: "M36.6 30.9l-.12.16s.08-.06.12-.16zM40 20.94A8.23 8.23 0 0031.7 13a8.38 8.38 0 00-5.7 2.25A8.3 8.3 0 0012 21v.06a17.82 17.82 0 002.41 8.48A23.4 23.4 0 0016 32.09c.22.3.41.54.55.71l.17.21.05.06a2.67 2.67 0 003.75.25 2.62 2.62 0 00.25-3.71l-.1-.11c-.08-.12-.22-.29-.39-.52A17.51 17.51 0 0119.07 27a12.74 12.74 0 01-1.76-5.9 3 3 0 016 0 2.72 2.72 0 00.3 1.14 2.66 2.66 0 005.13-.91V21a3 3 0 016 0 11.6 11.6 0 01-1.2 4.74c-.32.65-.62 1.18-.85 1.55-.11.19-.2.32-.26.41l-.06.08a2.66 2.66 0 012.08-1A2.63 2.63 0 0137 29.49a2.55 2.55 0 01-.43 1.41.1.1 0 000-.05l.12-.17c.1-.14.23-.35.39-.6A21.81 21.81 0 0038.31 28 16.56 16.56 0 0040 21v-.06z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: brand }, d: "M34.36 26.89a2.71 2.71 0 00-2.08 1 2.56 2.56 0 00-.57 1.62 2.63 2.63 0 002.65 2.6 2.69 2.69 0 002.11-1l.12-.16a2.6 2.6 0 00-2.23-4z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { d: "M55.61 21.43a2.4 2.4 0 01-.89 2 4 4 0 01-2.54.7h-1v3.37h-1v-8.57h2.22c2.14 0 3.21.84 3.21 2.5zm-4.44 1.84h.9a3.41 3.41 0 001.93-.42 1.6 1.6 0 00.59-1.37 1.49 1.49 0 00-.59-1.27 2.88 2.88 0 00-1.73-.42h-1.1zm11.64 1a3.55 3.55 0 01-.8 2.46 2.79 2.79 0 01-2.18.88 2.87 2.87 0 01-1.53-.41 2.59 2.59 0 01-1-1.16 4.05 4.05 0 01-.37-1.77 3.54 3.54 0 01.79-2.44 2.75 2.75 0 012.15-.83 2.71 2.71 0 012.14.9 3.51 3.51 0 01.8 2.38zm-4.9 0a3.12 3.12 0 00.49 1.88 2 2 0 002.9 0 3 3 0 00.5-1.88 3 3 0 00-.5-1.85 2 2 0 00-2.9 0 3 3 0 00-.49 1.86zm11.85 3.23l-1.18-3.77c-.07-.23-.21-.75-.41-1.57-.16.69-.29 1.21-.41 1.58L66.5 27.5h-1.13l-1.75-6.42h1c.41 1.61.73 2.84.94 3.68a15 15 0 01.44 1.71c0-.22.11-.51.21-.86s.18-.64.25-.85l1.18-3.68h1l1.15 3.68a12.91 12.91 0 01.45 1.7c0-.14.06-.36.13-.65s.48-1.87 1.22-4.73h1l-1.68 6.42zm6.81.12a3 3 0 01-2.25-.87 3.35 3.35 0 01-.82-2.41 3.69 3.69 0 01.76-2.46 2.55 2.55 0 012.06-.88 2.43 2.43 0 011.91.8 3.07 3.07 0 01.7 2.09v.61h-4.42a2.55 2.55 0 00.56 1.72 2 2 0 001.53.59 5.15 5.15 0 002.05-.44v.87a4.77 4.77 0 01-1 .32 5.85 5.85 0 01-1.08.06zm-.26-5.85a1.59 1.59 0 00-1.24.51 2.28 2.28 0 00-.54 1.39h3.36a2.13 2.13 0 00-.41-1.4 1.45 1.45 0 00-1.17-.5zm7.21-.77a3.61 3.61 0 01.77.07l-.13.9a4 4 0 00-.71-.08 1.71 1.71 0 00-1.33.63 2.3 2.3 0 00-.55 1.57v3.41h-1v-6.42h.81l.11 1.19a2.72 2.72 0 01.86-1 1.88 1.88 0 011.17-.27zm4.69 6.66a3 3 0 01-2.21-.91 3.35 3.35 0 01-.82-2.41 3.69 3.69 0 01.76-2.46A2.53 2.53 0 0188 21a2.4 2.4 0 011.91.8 3 3 0 01.71 2.09v.61h-4.48a2.55 2.55 0 00.57 1.72 2 2 0 001.53.59 5.15 5.15 0 002.05-.44v.87a4.65 4.65 0 01-1 .32 5.66 5.66 0 01-1.08.06zm-.27-5.85a1.57 1.57 0 00-1.23.51 2.28 2.28 0 00-.54 1.39h3.35a2.07 2.07 0 00-.41-1.4 1.43 1.43 0 00-1.17-.54zm8.66 4.87a2.29 2.29 0 01-2 1 2.4 2.4 0 01-2-.86 3.78 3.78 0 01-.7-2.45 3.86 3.86 0 01.71-2.47 2.6 2.6 0 014 .07h.07V18.38h1v9.12h-.79zm-1.94.16a1.77 1.77 0 001.44-.54 2.72 2.72 0 00.45-1.75v-.2a3.18 3.18 0 00-.46-1.95 1.7 1.7 0 00-1.44-.59 1.52 1.52 0 00-1.32.67 3.33 3.33 0 00-.45 1.88 3.19 3.19 0 00.45 1.86 1.54 1.54 0 001.33.58zm11-5.83a2.38 2.38 0 012 .87 3.75 3.75 0 01.7 2.44 3.81 3.81 0 01-.71 2.46 2.35 2.35 0 01-2 .88 2.88 2.88 0 01-1.15-.23 2.17 2.17 0 01-.87-.72h-.07l-.21.83h-.69v-9.16h1v2.22c0 .49 0 .94-.05 1.33h.05a2.3 2.3 0 012.04-.93zm-.15.82a1.69 1.69 0 00-1.43.57 3.23 3.23 0 00-.44 1.92 3.22 3.22 0 00.45 1.94 1.71 1.71 0 001.45.58 1.47 1.47 0 001.33-.65 3.31 3.31 0 00.44-1.88 3.19 3.19 0 00-.44-1.87 1.54 1.54 0 00-1.32-.65zm3.5-.71h1l1.41 3.66a14.72 14.72 0 01.57 1.81h.05c0-.2.15-.54.31-1s.7-2 1.6-4.45h1l-2.76 7.31a3.64 3.64 0 01-1 1.54 2 2 0 01-1.34.45 3.71 3.71 0 01-.88-.1v-.84a3.14 3.14 0 00.72.07 1.48 1.48 0 001.43-1.12l.36-.91zm13.89 6.38l-2.06-6.72c.07 1.37.11 2.28.11 2.74v4h-1.62v-8.59h2.47l2 6.55 2.2-6.55h2.48v8.57h-1.7v-4.05-.67c0-.25 0-.91.08-2l-2.21 6.71zm9-3.29a2.76 2.76 0 00.32 1.47 1.33 1.33 0 002.07 0 2.79 2.79 0 00.31-1.48 2.73 2.73 0 00-.31-1.46 1.17 1.17 0 00-1-.48 1.14 1.14 0 00-1 .48 2.7 2.7 0 00-.41 1.47zm4.53 0a3.52 3.52 0 01-.84 2.5 3.05 3.05 0 01-2.35.91 3.36 3.36 0 01-1.67-.41 2.75 2.75 0 01-1.1-1.19 4 4 0 01-.39-1.81 3.47 3.47 0 01.84-2.49 3 3 0 012.35-.89 3.26 3.26 0 011.67.41 2.65 2.65 0 011.1 1.17 3.94 3.94 0 01.37 1.8zm5.13-3.38a2.62 2.62 0 01.61.05l-.17 1.67a2.58 2.58 0 00-.53-.05 1.86 1.86 0 00-1.33.44 1.58 1.58 0 00-.48 1.23v3.33h-1.78V21h1.35l.26 1.1h.09a2.39 2.39 0 01.82-.88 2 2 0 011.14-.39zm6 6.67l-.35-.89h-.05a2.65 2.65 0 01-.93.79 3.09 3.09 0 01-1.24.22 2 2 0 01-1.49-.54 2.08 2.08 0 01-.54-1.54 1.73 1.73 0 01.73-1.53 4.19 4.19 0 012.2-.55h1.14v-.29a.89.89 0 00-1-1 4.79 4.79 0 00-1.85.47l-.59-1.2a5.29 5.29 0 012.51-.6 3.14 3.14 0 012 .58 2.1 2.1 0 01.7 1.74v4.34zm-.53-3h-.69a2.17 2.17 0 00-1.16.28.86.86 0 00-.38.78c0 .51.28.76.86.76a1.34 1.34 0 001-.36A1.25 1.25 0 00147 25zm5.41 3h-1.79v-9.12h1.79zm1.8-8.24c0-.59.33-.88 1-.88s1 .29 1 .88a.89.89 0 01-.25.65 1 1 0 01-.73.22c-.75 0-1.08-.29-1.08-.87zM156 27.5h-1.78V21H156zm6.46-1.95a1.8 1.8 0 01-.71 1.54 3.44 3.44 0 01-2.09.53 7.06 7.06 0 01-1.22-.1 4.66 4.66 0 01-.94-.28v-1.48a5.44 5.44 0 001.12.39 4.35 4.35 0 001.1.16c.65 0 1-.19 1-.56a.44.44 0 00-.13-.34 1.63 1.63 0 00-.44-.3c-.21-.11-.49-.24-.85-.39a5.42 5.42 0 01-1.11-.59 1.62 1.62 0 01-.51-.61 2.08 2.08 0 01-.16-.87 1.53 1.53 0 01.67-1.34 3.28 3.28 0 011.92-.48 5.54 5.54 0 012.31.51l-.54 1.29c-.33-.14-.64-.25-.92-.34a2.94 2.94 0 00-.88-.14c-.52 0-.79.14-.79.43a.5.5 0 00.25.41 7.16 7.16 0 001.12.53 4.79 4.79 0 011.13.58 1.65 1.65 0 01.53.62 1.92 1.92 0 01.18.83zm1.14 1.11a1 1 0 01.26-.74 1.07 1.07 0 01.77-.25 1 1 0 01.75.25 1 1 0 01.27.74 1 1 0 01-.27.74 1.23 1.23 0 01-1.51 0 1 1 0 01-.23-.74zm3.6-7.4c0-.59.32-.88 1-.88s1 .29 1 .88a.88.88 0 01-.24.65 1.06 1.06 0 01-.73.22c-.67 0-.99-.29-.99-.87zm1.86 8.24h-1.79V21h1.79zm3.3-3.29a2.76 2.76 0 00.32 1.47 1.13 1.13 0 001 .5 1.12 1.12 0 001-.49 2.79 2.79 0 00.31-1.48 2.73 2.73 0 00-.31-1.46 1.15 1.15 0 00-1-.48 1.14 1.14 0 00-1 .48 2.7 2.7 0 00-.28 1.46zm4.53 0a3.52 3.52 0 01-.84 2.5 3 3 0 01-2.35.91 3.32 3.32 0 01-1.66-.41A2.84 2.84 0 01171 26a4 4 0 01-.39-1.81 3.47 3.47 0 01.84-2.49 3 3 0 012.35-.89 3.26 3.26 0 011.67.41 2.73 2.73 0 011.11 1.17 4.08 4.08 0 01.35 1.82z" }, void 0)] }), void 0);
};
var PoweredByLight = function(_a) {
  var style = _a.style;
  return (0, import_jsx_runtime2.jsxs)("svg", __assign({ style, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 192 45" }, { children: [(0, import_jsx_runtime2.jsx)("path", { style: { fill: white }, d: "M1,22.5A21.51,21.51,0,0,1,22.5,1h147a21.5,21.5,0,0,1,0,43H22.5A21.51,21.51,0,0,1,1,22.5Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { d: "M37.6,30.9h0l-.12.16S37.56,31,37.6,30.9Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { d: "M41,20.94A8.23,8.23,0,0,0,32.7,13,8.38,8.38,0,0,0,27,15.25,8.3,8.3,0,0,0,13,21v.06a17.79,17.79,0,0,0,2.41,8.48A22.43,22.43,0,0,0,17,32.09c.22.3.41.54.55.71l.17.21.05.06,0,0h0a2.67,2.67,0,0,0,3.75.25,2.62,2.62,0,0,0,.25-3.71h0l0,0-.1-.11L21.31,29A17.51,17.51,0,0,1,20.07,27a12.74,12.74,0,0,1-1.76-5.9,3,3,0,0,1,6,0,2.72,2.72,0,0,0,.3,1.14,2.66,2.66,0,0,0,5.13-.91V21a3,3,0,0,1,6,0,11.6,11.6,0,0,1-1.2,4.74c-.32.65-.62,1.18-.85,1.55-.11.19-.2.32-.26.41l-.06.08h0l0,0a2.66,2.66,0,0,1,2.08-1A2.63,2.63,0,0,1,38,29.49a2.55,2.55,0,0,1-.43,1.41h0s0,0,0,0a.1.1,0,0,0,0-.05l.12-.17c.1-.14.23-.35.39-.6A21.81,21.81,0,0,0,39.31,28,16.56,16.56,0,0,0,41,21v-.06Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: brand }, d: "M35.36,26.89a2.71,2.71,0,0,0-2.08,1,2.56,2.56,0,0,0-.57,1.62,2.63,2.63,0,0,0,2.65,2.6,2.69,2.69,0,0,0,2.11-1l.12-.16a2.6,2.6,0,0,0-2.23-4Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { d: "M54.61,21.43a2.4,2.4,0,0,1-.89,2,4,4,0,0,1-2.54.7h-1V27.5h-1V18.93H51.4C53.54,18.93,54.61,19.77,54.61,21.43Zm-4.44,1.85h.9A3.4,3.4,0,0,0,53,22.85a1.59,1.59,0,0,0,.59-1.37A1.49,1.49,0,0,0,53,20.21a2.88,2.88,0,0,0-1.73-.42H50.17Zm11.64,1a3.55,3.55,0,0,1-.8,2.46,2.79,2.79,0,0,1-2.18.88,2.87,2.87,0,0,1-1.53-.41,2.59,2.59,0,0,1-1-1.16,4.05,4.05,0,0,1-.37-1.77,3.54,3.54,0,0,1,.79-2.44A2.75,2.75,0,0,1,58.87,21a2.71,2.71,0,0,1,2.14.9A3.51,3.51,0,0,1,61.81,24.28Zm-4.9,0a3.12,3.12,0,0,0,.49,1.88,2,2,0,0,0,2.9,0,3,3,0,0,0,.5-1.88,3,3,0,0,0-.5-1.85,2,2,0,0,0-2.9,0A3,3,0,0,0,56.91,24.28ZM68.76,27.5l-1.18-3.77c-.07-.23-.21-.75-.41-1.57h0c-.16.69-.29,1.21-.41,1.58L65.5,27.5H64.37l-1.75-6.42h1c.41,1.61.73,2.84.94,3.68A15,15,0,0,1,65,26.47h0c0-.22.11-.51.21-.86s.18-.64.25-.85l1.18-3.68h1l1.15,3.68a12.91,12.91,0,0,1,.45,1.7h0c0-.14.06-.36.13-.65s.48-1.87,1.22-4.73h1L69.91,27.5Zm6.81.12a3,3,0,0,1-2.25-.87,3.35,3.35,0,0,1-.82-2.41,3.69,3.69,0,0,1,.76-2.46A2.55,2.55,0,0,1,75.32,21a2.43,2.43,0,0,1,1.91.8,3.07,3.07,0,0,1,.7,2.09v.61H73.51a2.55,2.55,0,0,0,.56,1.72,2,2,0,0,0,1.53.59,5.15,5.15,0,0,0,2.05-.44v.87a4.77,4.77,0,0,1-1,.32A5.85,5.85,0,0,1,75.57,27.62Zm-.26-5.84a1.58,1.58,0,0,0-1.24.5,2.28,2.28,0,0,0-.54,1.39h3.36a2.13,2.13,0,0,0-.41-1.4A1.45,1.45,0,0,0,75.31,21.78ZM82.52,21a3.61,3.61,0,0,1,.77.07l-.13.9a4,4,0,0,0-.71-.08,1.71,1.71,0,0,0-1.33.63,2.3,2.3,0,0,0-.55,1.57V27.5h-1V21.08h.81l.11,1.19h0a2.72,2.72,0,0,1,.86-1A1.88,1.88,0,0,1,82.52,21Zm4.69,6.66A3,3,0,0,1,85,26.75a3.35,3.35,0,0,1-.82-2.41,3.69,3.69,0,0,1,.76-2.46A2.53,2.53,0,0,1,87,21a2.4,2.4,0,0,1,1.91.8,3,3,0,0,1,.71,2.09v.61H85.14a2.55,2.55,0,0,0,.57,1.72,2,2,0,0,0,1.53.59,5.15,5.15,0,0,0,2.05-.44v.87a4.65,4.65,0,0,1-1,.32A5.66,5.66,0,0,1,87.21,27.62Zm-.27-5.84a1.56,1.56,0,0,0-1.23.5,2.28,2.28,0,0,0-.54,1.39h3.35a2.07,2.07,0,0,0-.41-1.4A1.42,1.42,0,0,0,86.94,21.78Zm8.66,4.86h0a2.29,2.29,0,0,1-2,1,2.4,2.4,0,0,1-2-.86,3.78,3.78,0,0,1-.7-2.45,3.86,3.86,0,0,1,.71-2.47,2.6,2.6,0,0,1,4,.07h.07l0-.46,0-.45V18.38h1V27.5h-.79Zm-1.94.16a1.77,1.77,0,0,0,1.44-.54,2.72,2.72,0,0,0,.45-1.75v-.2a3.18,3.18,0,0,0-.46-1.95,1.7,1.7,0,0,0-1.44-.58,1.51,1.51,0,0,0-1.32.66,3.33,3.33,0,0,0-.45,1.88,3.19,3.19,0,0,0,.45,1.86A1.54,1.54,0,0,0,93.66,26.8Zm11-5.83a2.38,2.38,0,0,1,2,.87,3.75,3.75,0,0,1,.7,2.44,3.81,3.81,0,0,1-.71,2.46,2.35,2.35,0,0,1-2,.88,2.88,2.88,0,0,1-1.15-.23,2.17,2.17,0,0,1-.87-.72h-.07l-.21.83h-.69V18.38h1V20.6c0,.49,0,.94-.05,1.33h.05A2.3,2.3,0,0,1,104.7,21Zm-.15.82a1.69,1.69,0,0,0-1.43.57,3.23,3.23,0,0,0-.44,1.92,3.22,3.22,0,0,0,.45,1.94,1.71,1.71,0,0,0,1.45.58,1.47,1.47,0,0,0,1.33-.65,3.31,3.31,0,0,0,.44-1.88,3.19,3.19,0,0,0-.44-1.87A1.54,1.54,0,0,0,104.55,21.79Zm3.5-.71h1l1.41,3.66a14.72,14.72,0,0,1,.57,1.81h.05c0-.2.15-.54.31-1s.7-2,1.6-4.45h1l-2.76,7.31a3.64,3.64,0,0,1-1,1.54,2,2,0,0,1-1.34.45,3.71,3.71,0,0,1-.88-.1V29.5a3.14,3.14,0,0,0,.72.07,1.48,1.48,0,0,0,1.43-1.12l.36-.91ZM121.9,27.5l-2.06-6.72h0c.07,1.37.11,2.28.11,2.74v4h-1.62V18.93h2.47l2,6.55h0L125,18.93h2.48V27.5h-1.7V23.45c0-.2,0-.42,0-.67s0-.91.08-2h0l-2.21,6.71Zm9-3.29a2.76,2.76,0,0,0,.32,1.47,1.33,1.33,0,0,0,2.07,0,2.79,2.79,0,0,0,.31-1.48,2.73,2.73,0,0,0-.31-1.46,1.17,1.17,0,0,0-1-.48,1.14,1.14,0,0,0-1,.48A2.7,2.7,0,0,0,130.88,24.21Zm4.53,0a3.52,3.52,0,0,1-.84,2.5,3.05,3.05,0,0,1-2.35.91,3.36,3.36,0,0,1-1.67-.41,2.75,2.75,0,0,1-1.1-1.19,4,4,0,0,1-.39-1.81,3.47,3.47,0,0,1,.84-2.49,3,3,0,0,1,2.35-.89,3.26,3.26,0,0,1,1.67.41,2.65,2.65,0,0,1,1.1,1.17A4,4,0,0,1,135.41,24.21Zm5.13-3.38a2.62,2.62,0,0,1,.61.05L141,22.55a2.58,2.58,0,0,0-.53-.05,1.86,1.86,0,0,0-1.33.44,1.58,1.58,0,0,0-.48,1.23V27.5h-1.78V21h1.35l.26,1.1h.09a2.39,2.39,0,0,1,.82-.88A2,2,0,0,1,140.54,20.83Zm6,6.67-.35-.89h-.05a2.65,2.65,0,0,1-.93.79,3.09,3.09,0,0,1-1.24.22,2,2,0,0,1-1.49-.54,2.08,2.08,0,0,1-.54-1.54,1.73,1.73,0,0,1,.73-1.53,4.19,4.19,0,0,1,2.2-.55l1.14,0v-.29a.89.89,0,0,0-1-1,4.79,4.79,0,0,0-1.85.47l-.59-1.2a5.29,5.29,0,0,1,2.51-.6,3.14,3.14,0,0,1,2,.58,2.1,2.1,0,0,1,.7,1.74V27.5Zm-.53-3-.69,0a2.17,2.17,0,0,0-1.16.28.86.86,0,0,0-.38.78c0,.51.28.76.86.76a1.34,1.34,0,0,0,1-.36A1.25,1.25,0,0,0,146,25Zm5.41,3h-1.79V18.38h1.79Zm1.8-8.24c0-.59.33-.88,1-.88s1,.29,1,.88a.89.89,0,0,1-.25.65,1,1,0,0,1-.73.22C153.51,20.13,153.18,19.84,153.18,19.26ZM155,27.5h-1.78V21H155Zm6.46-1.95a1.8,1.8,0,0,1-.71,1.54,3.44,3.44,0,0,1-2.09.53,7.06,7.06,0,0,1-1.22-.1,4.66,4.66,0,0,1-.94-.28V25.76a5.44,5.44,0,0,0,1.12.39,4.35,4.35,0,0,0,1.1.16c.65,0,1-.19,1-.56a.44.44,0,0,0-.13-.34,1.63,1.63,0,0,0-.44-.3c-.21-.11-.49-.24-.85-.39a5.42,5.42,0,0,1-1.11-.59,1.62,1.62,0,0,1-.51-.61,2.08,2.08,0,0,1-.16-.87,1.53,1.53,0,0,1,.67-1.34,3.28,3.28,0,0,1,1.92-.48,5.54,5.54,0,0,1,2.31.51l-.54,1.29c-.33-.14-.64-.25-.92-.34a2.94,2.94,0,0,0-.88-.14c-.52,0-.79.14-.79.43a.5.5,0,0,0,.25.41,7.16,7.16,0,0,0,1.12.53,4.79,4.79,0,0,1,1.13.58,1.73,1.73,0,0,1,.53.62A1.92,1.92,0,0,1,161.5,25.55Zm1.14,1.11a1,1,0,0,1,.26-.74,1.07,1.07,0,0,1,.77-.25,1,1,0,0,1,.75.25,1.14,1.14,0,0,1,0,1.47,1,1,0,0,1-.75.27,1.06,1.06,0,0,1-.76-.26A1,1,0,0,1,162.64,26.66Zm3.6-7.4c0-.59.32-.88,1-.88s1,.29,1,.88a.88.88,0,0,1-.24.65,1.06,1.06,0,0,1-.73.22C166.56,20.13,166.24,19.84,166.24,19.26Zm1.86,8.24h-1.79V21h1.79Zm3.3-3.29a2.76,2.76,0,0,0,.32,1.47,1.13,1.13,0,0,0,1,.5,1.12,1.12,0,0,0,1-.49,2.79,2.79,0,0,0,.31-1.48,2.73,2.73,0,0,0-.31-1.46,1.15,1.15,0,0,0-1-.48,1.14,1.14,0,0,0-1,.48A2.7,2.7,0,0,0,171.4,24.21Zm4.53,0a3.52,3.52,0,0,1-.84,2.5,3,3,0,0,1-2.35.91,3.32,3.32,0,0,1-1.66-.41A2.84,2.84,0,0,1,170,26a4,4,0,0,1-.39-1.81,3.47,3.47,0,0,1,.84-2.49,3,3,0,0,1,2.35-.89,3.26,3.26,0,0,1,1.67.41,2.73,2.73,0,0,1,1.11,1.17A4.11,4.11,0,0,1,175.93,24.21Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { d: "M22.5,2h147V0H22.5Zm147,41H22.5v2h147Zm-147,0A20.5,20.5,0,0,1,2,22.5H0A22.5,22.5,0,0,0,22.5,45ZM190,22.5A20.5,20.5,0,0,1,169.5,43v2A22.5,22.5,0,0,0,192,22.5ZM169.5,2A20.5,20.5,0,0,1,190,22.5h2A22.5,22.5,0,0,0,169.5,0ZM22.5,0A22.5,22.5,0,0,0,0,22.5H2A20.5,20.5,0,0,1,22.5,2Z" }, void 0)] }), void 0);
};
var PoweredByDark = function(_a) {
  var style = _a.style;
  return (0, import_jsx_runtime2.jsxs)("svg", __assign({ style, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 192 45" }, { children: [(0, import_jsx_runtime2.jsx)("path", { d: "M1,22.5A21.51,21.51,0,0,1,22.5,1h147a21.5,21.5,0,0,1,0,43H22.5A21.51,21.51,0,0,1,1,22.5Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: white }, d: "M37.6,30.9h0l-.12.16S37.56,31,37.6,30.9Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: white }, d: "M41,20.94A8.23,8.23,0,0,0,32.7,13,8.38,8.38,0,0,0,27,15.25,8.3,8.3,0,0,0,13,21v.06a17.82,17.82,0,0,0,2.41,8.48A22.43,22.43,0,0,0,17,32.09c.22.3.41.54.55.71l.17.21.05.06,0,0h0a2.67,2.67,0,0,0,3.75.25,2.62,2.62,0,0,0,.25-3.71h0l0,0-.1-.11L21.31,29A17.51,17.51,0,0,1,20.07,27a12.74,12.74,0,0,1-1.76-5.9,3,3,0,0,1,6,0,2.72,2.72,0,0,0,.3,1.14,2.66,2.66,0,0,0,5.13-.91V21a3,3,0,0,1,6,0,11.6,11.6,0,0,1-1.2,4.74c-.32.65-.62,1.18-.85,1.55-.11.19-.2.32-.26.41l-.06.08a0,0,0,0,0,0,0l0,0a2.66,2.66,0,0,1,2.08-1A2.63,2.63,0,0,1,38,29.49a2.55,2.55,0,0,1-.43,1.41h0s0,0,0,0a.1.1,0,0,0,0-.05l.12-.17c.1-.14.23-.35.39-.6A21.81,21.81,0,0,0,39.31,28,16.56,16.56,0,0,0,41,21v-.06Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: brand }, d: "M35.36,26.89a2.71,2.71,0,0,0-2.08,1,2.56,2.56,0,0,0-.57,1.62,2.63,2.63,0,0,0,2.65,2.6,2.69,2.69,0,0,0,2.11-1l.12-.16a2.6,2.6,0,0,0-2.23-4Z" }, void 0), (0, import_jsx_runtime2.jsx)("path", { style: { fill: white }, d: "M54.61,21.43a2.4,2.4,0,0,1-.89,2,4,4,0,0,1-2.54.7h-1V27.5h-1V18.93H51.4C53.54,18.93,54.61,19.77,54.61,21.43Zm-4.44,1.84h.9A3.41,3.41,0,0,0,53,22.85a1.6,1.6,0,0,0,.59-1.37A1.49,1.49,0,0,0,53,20.21a2.88,2.88,0,0,0-1.73-.42H50.17Zm11.64,1a3.55,3.55,0,0,1-.8,2.46,2.79,2.79,0,0,1-2.18.88,2.87,2.87,0,0,1-1.53-.41,2.59,2.59,0,0,1-1-1.16,4.05,4.05,0,0,1-.37-1.77,3.54,3.54,0,0,1,.79-2.44A2.75,2.75,0,0,1,58.87,21a2.71,2.71,0,0,1,2.14.9A3.51,3.51,0,0,1,61.81,24.28Zm-4.9,0a3.12,3.12,0,0,0,.49,1.88,2,2,0,0,0,2.9,0,3,3,0,0,0,.5-1.88,3,3,0,0,0-.5-1.85,2,2,0,0,0-2.9,0A3,3,0,0,0,56.91,24.28ZM68.76,27.5l-1.18-3.77c-.07-.23-.21-.75-.41-1.57h0c-.16.69-.29,1.21-.41,1.58L65.5,27.5H64.37l-1.75-6.42h1c.41,1.61.73,2.84.94,3.68A15,15,0,0,1,65,26.47h0c0-.22.11-.51.21-.86s.18-.64.25-.85l1.18-3.68h1l1.15,3.68a12.91,12.91,0,0,1,.45,1.7h0c0-.14.06-.36.13-.65s.48-1.87,1.22-4.73h1L69.91,27.5Zm6.81.12a3,3,0,0,1-2.25-.87,3.35,3.35,0,0,1-.82-2.41,3.69,3.69,0,0,1,.76-2.46A2.55,2.55,0,0,1,75.32,21a2.43,2.43,0,0,1,1.91.8,3.07,3.07,0,0,1,.7,2.09v.61H73.51a2.55,2.55,0,0,0,.56,1.72,2,2,0,0,0,1.53.59,5.15,5.15,0,0,0,2.05-.44v.87a4.77,4.77,0,0,1-1,.32A5.85,5.85,0,0,1,75.57,27.62Zm-.26-5.85a1.59,1.59,0,0,0-1.24.51,2.28,2.28,0,0,0-.54,1.39h3.36a2.13,2.13,0,0,0-.41-1.4A1.45,1.45,0,0,0,75.31,21.77ZM82.52,21a3.61,3.61,0,0,1,.77.07l-.13.9a4,4,0,0,0-.71-.08,1.71,1.71,0,0,0-1.33.63,2.3,2.3,0,0,0-.55,1.57V27.5h-1V21.08h.81l.11,1.19h0a2.72,2.72,0,0,1,.86-1A1.88,1.88,0,0,1,82.52,21Zm4.69,6.66A3,3,0,0,1,85,26.75a3.35,3.35,0,0,1-.82-2.41,3.69,3.69,0,0,1,.76-2.46A2.53,2.53,0,0,1,87,21a2.4,2.4,0,0,1,1.91.8,3,3,0,0,1,.71,2.09v.61H85.14a2.55,2.55,0,0,0,.57,1.72,2,2,0,0,0,1.53.59,5.15,5.15,0,0,0,2.05-.44v.87a4.65,4.65,0,0,1-1,.32A5.66,5.66,0,0,1,87.21,27.62Zm-.27-5.85a1.57,1.57,0,0,0-1.23.51,2.28,2.28,0,0,0-.54,1.39h3.35a2.07,2.07,0,0,0-.41-1.4A1.43,1.43,0,0,0,86.94,21.77Zm8.66,4.87h0a2.29,2.29,0,0,1-2,1,2.4,2.4,0,0,1-2-.86,3.78,3.78,0,0,1-.7-2.45,3.86,3.86,0,0,1,.71-2.47,2.6,2.6,0,0,1,4,.07h.07l0-.46,0-.45V18.38h1V27.5h-.79Zm-1.94.16a1.77,1.77,0,0,0,1.44-.54,2.72,2.72,0,0,0,.45-1.75v-.2a3.18,3.18,0,0,0-.46-1.95,1.7,1.7,0,0,0-1.44-.59,1.52,1.52,0,0,0-1.32.67,3.33,3.33,0,0,0-.45,1.88,3.19,3.19,0,0,0,.45,1.86A1.54,1.54,0,0,0,93.66,26.8Zm11-5.83a2.38,2.38,0,0,1,2,.87,3.75,3.75,0,0,1,.7,2.44,3.81,3.81,0,0,1-.71,2.46,2.35,2.35,0,0,1-2,.88,2.88,2.88,0,0,1-1.15-.23,2.17,2.17,0,0,1-.87-.72h-.07l-.21.83h-.69V18.38h1V20.6c0,.49,0,.94-.05,1.33h.05A2.3,2.3,0,0,1,104.7,21Zm-.15.82a1.69,1.69,0,0,0-1.43.57,3.23,3.23,0,0,0-.44,1.92,3.22,3.22,0,0,0,.45,1.94,1.71,1.71,0,0,0,1.45.58,1.47,1.47,0,0,0,1.33-.65,3.31,3.31,0,0,0,.44-1.88,3.19,3.19,0,0,0-.44-1.87A1.54,1.54,0,0,0,104.55,21.79Zm3.5-.71h1l1.41,3.66a14.72,14.72,0,0,1,.57,1.81h.05c0-.2.15-.54.31-1s.7-2,1.6-4.45h1l-2.76,7.31a3.64,3.64,0,0,1-1,1.54,2,2,0,0,1-1.34.45,3.71,3.71,0,0,1-.88-.1V29.5a3.14,3.14,0,0,0,.72.07,1.48,1.48,0,0,0,1.43-1.12l.36-.91ZM121.9,27.5l-2.06-6.72h0c.07,1.37.11,2.28.11,2.74v4h-1.62V18.93h2.47l2,6.55h0L125,18.93h2.48V27.5h-1.7V23.45c0-.2,0-.42,0-.67s0-.91.08-2h0l-2.21,6.71Zm9-3.29a2.76,2.76,0,0,0,.32,1.47,1.33,1.33,0,0,0,2.07,0,2.79,2.79,0,0,0,.31-1.48,2.73,2.73,0,0,0-.31-1.46,1.17,1.17,0,0,0-1-.48,1.14,1.14,0,0,0-1,.48A2.7,2.7,0,0,0,130.88,24.21Zm4.53,0a3.52,3.52,0,0,1-.84,2.5,3.05,3.05,0,0,1-2.35.91,3.36,3.36,0,0,1-1.67-.41,2.75,2.75,0,0,1-1.1-1.19,4,4,0,0,1-.39-1.81,3.47,3.47,0,0,1,.84-2.49,3,3,0,0,1,2.35-.89,3.26,3.26,0,0,1,1.67.41,2.65,2.65,0,0,1,1.1,1.17A3.94,3.94,0,0,1,135.41,24.21Zm5.13-3.38a2.62,2.62,0,0,1,.61.05L141,22.55a2.58,2.58,0,0,0-.53-.05,1.86,1.86,0,0,0-1.33.44,1.58,1.58,0,0,0-.48,1.23V27.5h-1.78V21h1.35l.26,1.1h.09a2.39,2.39,0,0,1,.82-.88A2,2,0,0,1,140.54,20.83Zm6,6.67-.35-.89h-.05a2.65,2.65,0,0,1-.93.79,3.09,3.09,0,0,1-1.24.22,2,2,0,0,1-1.49-.54,2.08,2.08,0,0,1-.54-1.54,1.73,1.73,0,0,1,.73-1.53,4.19,4.19,0,0,1,2.2-.55l1.14,0v-.29a.89.89,0,0,0-1-1,4.79,4.79,0,0,0-1.85.47l-.59-1.2a5.29,5.29,0,0,1,2.51-.6,3.14,3.14,0,0,1,2,.58,2.1,2.1,0,0,1,.7,1.74V27.5Zm-.53-3-.69,0a2.17,2.17,0,0,0-1.16.28.86.86,0,0,0-.38.78c0,.51.28.76.86.76a1.34,1.34,0,0,0,1-.36A1.25,1.25,0,0,0,146,25Zm5.41,3h-1.79V18.38h1.79Zm1.8-8.24c0-.59.33-.88,1-.88s1,.29,1,.88a.89.89,0,0,1-.25.65,1,1,0,0,1-.73.22C153.51,20.13,153.18,19.84,153.18,19.26ZM155,27.5h-1.78V21H155Zm6.46-1.95a1.8,1.8,0,0,1-.71,1.54,3.44,3.44,0,0,1-2.09.53,7.06,7.06,0,0,1-1.22-.1,4.66,4.66,0,0,1-.94-.28V25.76a5.44,5.44,0,0,0,1.12.39,4.35,4.35,0,0,0,1.1.16c.65,0,1-.19,1-.56a.44.44,0,0,0-.13-.34,1.63,1.63,0,0,0-.44-.3c-.21-.11-.49-.24-.85-.39a5.42,5.42,0,0,1-1.11-.59,1.62,1.62,0,0,1-.51-.61,2.08,2.08,0,0,1-.16-.87,1.53,1.53,0,0,1,.67-1.34,3.28,3.28,0,0,1,1.92-.48,5.54,5.54,0,0,1,2.31.51l-.54,1.29c-.33-.14-.64-.25-.92-.34a2.94,2.94,0,0,0-.88-.14c-.52,0-.79.14-.79.43a.5.5,0,0,0,.25.41,7.16,7.16,0,0,0,1.12.53,4.79,4.79,0,0,1,1.13.58,1.65,1.65,0,0,1,.53.62A1.92,1.92,0,0,1,161.5,25.55Zm1.14,1.11a1,1,0,0,1,.26-.74,1.07,1.07,0,0,1,.77-.25,1,1,0,0,1,.75.25,1,1,0,0,1,.27.74,1,1,0,0,1-.27.74,1.23,1.23,0,0,1-1.51,0A1,1,0,0,1,162.64,26.66Zm3.6-7.4c0-.59.32-.88,1-.88s1,.29,1,.88a.88.88,0,0,1-.24.65,1.06,1.06,0,0,1-.73.22C166.56,20.13,166.24,19.84,166.24,19.26Zm1.86,8.24h-1.79V21h1.79Zm3.3-3.29a2.76,2.76,0,0,0,.32,1.47,1.13,1.13,0,0,0,1,.5,1.12,1.12,0,0,0,1-.49,2.79,2.79,0,0,0,.31-1.48,2.73,2.73,0,0,0-.31-1.46,1.15,1.15,0,0,0-1-.48,1.14,1.14,0,0,0-1,.48A2.7,2.7,0,0,0,171.4,24.21Zm4.53,0a3.52,3.52,0,0,1-.84,2.5,3,3,0,0,1-2.35.91,3.32,3.32,0,0,1-1.66-.41A2.84,2.84,0,0,1,170,26a4,4,0,0,1-.39-1.81,3.47,3.47,0,0,1,.84-2.49,3,3,0,0,1,2.35-.89,3.26,3.26,0,0,1,1.67.41,2.73,2.73,0,0,1,1.11,1.17A4.08,4.08,0,0,1,175.93,24.21Z" }, void 0)] }), void 0);
};
var ByMoralis = function(_a) {
  var _b = _a.variant, variant = _b === void 0 ? "colour" : _b, _c = _a.width, width = _c === void 0 ? 250 : _c, style = _a.style;
  if (variant === "light") {
    return (0, import_jsx_runtime2.jsx)(PoweredByLight, { style: __assign({ width }, style) }, void 0);
  }
  if (variant === "dark") {
    return (0, import_jsx_runtime2.jsx)(PoweredByDark, { style: __assign({ width }, style) }, void 0);
  }
  return (0, import_jsx_runtime2.jsx)(PoweredByColour, { style: __assign({ width }, style) }, void 0);
};
export {
  ByMoralis,
  MoralisContext,
  MoralisProvider,
  NoMoralisContextProviderError,
  NotAuthenticatedError,
  ReactMoralisError,
  ValidationError,
  getChain,
  getSupportedChains,
  resolveIPFS,
  useApiContract,
  useChain,
  useERC20Balances,
  useERC20Transfers,
  useEnsAddress,
  useEnsName,
  useFiatBuy,
  useMoralis,
  useMoralisCloudFunction,
  useMoralisFile,
  useMoralisQuery,
  useMoralisSolanaApi,
  useMoralisSolanaCall,
  useMoralisSubscription,
  useMoralisWeb3Api,
  useMoralisWeb3ApiCall,
  useNFTBalances,
  useNFTTransfers,
  useNativeBalance,
  useNativeTransactions,
  useNewMoralisObject,
  useOneInchQuote,
  useOneInchSwap,
  useOneInchTokens,
  useOpenSeaAsset,
  useOpenSeaBuyOrder,
  useOpenSeaOrders,
  useOpenSeaSellOrder,
  useRaribleLazyMint,
  useRaribleSellOrder,
  useTokenPrice,
  useWeb3Contract,
  useWeb3ExecuteFunction,
  useWeb3Transfer
};
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-moralis/lib/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=react-moralis.js.map
