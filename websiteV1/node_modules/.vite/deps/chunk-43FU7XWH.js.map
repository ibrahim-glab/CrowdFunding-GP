{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/dist/drop-claim-conditions-171f45b9.browser.esm.js"],
  "sourcesContent": ["import { utils, BigNumber, constants } from 'ethers';\r\nimport deepEqual from 'fast-deep-equal';\r\nimport { aL as resolveAddress, cv as AmountSchema, B as includesErrorMessage, d4 as isNode, cq as ContractWrapper } from './index-e7118e8b.browser.esm.js';\r\nimport { y as transformResultToClaimCondition, z as legacyContractModelToAbstract, A as newContractModelToAbstract, C as ClaimEligibility, D as convertQuantityToBigNumber, f as fetchSnapshotEntryForAddress, E as prepareClaim, F as SnapshotFormatVersion, H as processClaimConditionInputs, I as abstractContractModelToLegacy, J as abstractContractModelToNew, K as updateExistingClaimConditions } from './signature-61410b74.browser.esm.js';\r\nimport { i as isNativeToken, C as ContractEncoder } from './fetchCurrencyValue-27d660ae.browser.esm.js';\r\nimport { d as detectContractFeature, h as hasFunction } from './contract-appuri-3d68505c.browser.esm.js';\r\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-de84ba20.browser.esm.js';\r\n\r\n/**\r\n * Manages claim conditions for NFT Drop contracts\r\n * @erc721\r\n * @public\r\n */\r\nclass DropClaimConditions {\r\n  constructor(contractWrapper, metadata, storage) {\r\n    this.storage = storage;\r\n    this.contractWrapper = contractWrapper;\r\n    this.metadata = metadata;\r\n  }\r\n\r\n  /** ***************************************\r\n   * READ FUNCTIONS\r\n   *****************************************/\r\n\r\n  /**\r\n   * Get the currently active claim condition\r\n   *\r\n   * @returns The claim condition metadata\r\n   */\r\n  async getActive(options) {\r\n    const [cc, metadata, tokenDecimals] = await Promise.all([this.get(), this.metadata.get(), this.getTokenDecimals()]);\r\n    return await transformResultToClaimCondition(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\r\n  }\r\n  async get(conditionId) {\r\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\r\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\r\n      return legacyContractModelToAbstract(contractModel);\r\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\r\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\r\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\r\n      return legacyContractModelToAbstract(contractModel);\r\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\r\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\r\n      return newContractModelToAbstract(contractModel);\r\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\r\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\r\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\r\n      return newContractModelToAbstract(contractModel);\r\n    } else {\r\n      throw new Error(\"Contract does not support claim conditions\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all the claim conditions\r\n   *\r\n   * @returns The claim conditions metadata\r\n   */\r\n  async getAll(options) {\r\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\r\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\r\n      const startId = currentStartId.toNumber();\r\n      const count = countBn.toNumber();\r\n      const conditions = [];\r\n      for (let i = startId; i < startId + count; i++) {\r\n        conditions.push(this.get(i));\r\n      }\r\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\r\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\r\n    } else {\r\n      return [await this.getActive(options)];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Can Claim\r\n   *\r\n   * @remarks Check if the drop can currently be claimed.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Quantity of tokens to check claimability of\r\n   * const quantity = 1;\r\n   * const canClaim = await contract.canClaim(quantity);\r\n   * ```\r\n   */\r\n  async canClaim(quantity, addressToCheck) {\r\n    // TODO switch to use verifyClaim\r\n    if (addressToCheck) {\r\n      addressToCheck = await resolveAddress(addressToCheck);\r\n    }\r\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\r\n  }\r\n\r\n  /**\r\n   * For any claim conditions that a particular wallet is violating,\r\n   * this function returns human readable information about the\r\n   * breaks in the condition that can be used to inform the user.\r\n   *\r\n   * @param quantity - The desired quantity that would be claimed.\r\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\r\n   *\r\n   */\r\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\r\n    const reasons = [];\r\n    let activeConditionIndex;\r\n    let claimCondition;\r\n    if (addressToCheck === undefined) {\r\n      try {\r\n        addressToCheck = await this.contractWrapper.getSignerAddress();\r\n      } catch (err) {\r\n        console.warn(\"failed to get signer address\", err);\r\n      }\r\n    }\r\n\r\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\r\n    if (!addressToCheck) {\r\n      return [ClaimEligibility.NoWallet];\r\n    }\r\n    const [resolvedAddress, decimals] = await Promise.all([resolveAddress(addressToCheck), this.getTokenDecimals()]);\r\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\r\n    try {\r\n      claimCondition = await this.getActive();\r\n    } catch (err) {\r\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\r\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\r\n        return reasons;\r\n      }\r\n      console.warn(\"failed to get active claim condition\", err);\r\n      reasons.push(ClaimEligibility.Unknown);\r\n      return reasons;\r\n    }\r\n    if (claimCondition.availableSupply !== \"unlimited\") {\r\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\r\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\r\n        reasons.push(ClaimEligibility.NotEnoughSupply);\r\n        return reasons;\r\n      }\r\n    }\r\n\r\n    // check for merkle root inclusion\r\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\r\n    const hasAllowList = merkleRootArray.length > 0;\r\n    let allowListEntry = null;\r\n    if (hasAllowList) {\r\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\r\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\r\n        // exclusive allowlist behavior\r\n        reasons.push(ClaimEligibility.AddressNotAllowed);\r\n        return reasons;\r\n      }\r\n      if (allowListEntry) {\r\n        try {\r\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\r\n          let validMerkleProof;\r\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\r\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\r\n            // legacy verifyClaimerMerkleProofs function\r\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\r\n            if (!validMerkleProof) {\r\n              reasons.push(ClaimEligibility.AddressNotAllowed);\r\n              return reasons;\r\n            }\r\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\r\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\r\n              proof: claimVerification.proofs,\r\n              maxQuantityInAllowlist: claimVerification.maxClaimable\r\n            }]);\r\n            if (!validMerkleProof) {\r\n              reasons.push(ClaimEligibility.AddressNotAllowed);\r\n              return reasons;\r\n            }\r\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\r\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\r\n              proof: claimVerification.proofs,\r\n              quantityLimitPerWallet: claimVerification.maxClaimable,\r\n              currency: claimVerification.currencyAddressInProof,\r\n              pricePerToken: claimVerification.priceInProof\r\n            }]);\r\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\r\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\r\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\r\n              proof: claimVerification.proofs,\r\n              quantityLimitPerWallet: claimVerification.maxClaimable,\r\n              currency: claimVerification.currencyAddressInProof,\r\n              pricePerToken: claimVerification.priceInProof\r\n            }]);\r\n          }\r\n        } catch (e) {\r\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\r\n          const reason = e.reason;\r\n          switch (reason) {\r\n            case \"!Qty\":\r\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\r\n              break;\r\n            case \"!PriceOrCurrency\":\r\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\r\n              break;\r\n            case \"!MaxSupply\":\r\n              reasons.push(ClaimEligibility.NotEnoughSupply);\r\n              break;\r\n            case \"cant claim yet\":\r\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\r\n              break;\r\n            default:\r\n              {\r\n                reasons.push(ClaimEligibility.AddressNotAllowed);\r\n                break;\r\n              }\r\n          }\r\n          return reasons;\r\n        }\r\n      }\r\n    }\r\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\r\n      let claimedSupply = BigNumber.from(0);\r\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\r\n      try {\r\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\r\n      } catch (e) {\r\n        // no-op\r\n      }\r\n      if (allowListEntry) {\r\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\r\n      }\r\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\r\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\r\n        return reasons;\r\n      }\r\n\r\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\r\n      // if maxClaimable is 0, we consider it as the address is not allowed\r\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\r\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\r\n          reasons.push(ClaimEligibility.AddressNotAllowed);\r\n          return reasons;\r\n        }\r\n      }\r\n    }\r\n\r\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\r\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\r\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\r\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\r\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\r\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\r\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\r\n        // check for claim timestamp between claims\r\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\r\n      }\r\n      const now = BigNumber.from(Date.now()).div(1000);\r\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\r\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\r\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\r\n          reasons.push(ClaimEligibility.AlreadyClaimed);\r\n        } else {\r\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\r\n        }\r\n        return reasons;\r\n      }\r\n    }\r\n\r\n    // if not within a browser context, check for wallet balance.\r\n    // In browser context, let the wallet do that job\r\n    if (claimCondition.price.gt(0) && isNode()) {\r\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\r\n      const provider = this.contractWrapper.getProvider();\r\n      if (isNativeToken(claimCondition.currencyAddress)) {\r\n        const balance = await provider.getBalance(resolvedAddress);\r\n        if (balance.lt(totalPrice)) {\r\n          reasons.push(ClaimEligibility.NotEnoughTokens);\r\n        }\r\n      } else {\r\n        const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\r\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\r\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\r\n        if (balance.lt(totalPrice)) {\r\n          reasons.push(ClaimEligibility.NotEnoughTokens);\r\n        }\r\n      }\r\n    }\r\n    return reasons;\r\n  }\r\n\r\n  /**\r\n   * Returns allow list information and merkle proofs for the given address.\r\n   * @param claimerAddress - the claimer address\r\n   * @param claimConditionId - optional the claim condition id to get the proofs for\r\n   */\r\n  async getClaimerProofs(claimerAddress, claimConditionId) {\r\n    const claimCondition = await this.get(claimConditionId);\r\n    const merkleRoot = claimCondition.merkleRoot;\r\n    const merkleRootArray = utils.stripZeros(merkleRoot);\r\n    if (merkleRootArray.length > 0) {\r\n      const [metadata, resolvedAddress] = await Promise.all([this.metadata.get(), resolveAddress(claimerAddress)]);\r\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the total supply claimed by a specific wallet\r\n   * @param walletAddress - the wallet address to check\r\n   * @returns The total supply claimed\r\n   */\r\n  async getSupplyClaimedByWallet(walletAddress) {\r\n    const resolvedAddress = await resolveAddress(walletAddress);\r\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\r\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\r\n    }\r\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\r\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\r\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\r\n    }\r\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\r\n  }\r\n\r\n  /** ***************************************\r\n   * WRITE FUNCTIONS\r\n   *****************************************/\r\n\r\n  /**\r\n   * Set public mint conditions\r\n   *\r\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * const presaleStartTime = new Date();\r\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\r\n   *\r\n   * // Optionally specify addresses that can claim\r\n   * const snapshots = ['0x...', '0x...']\r\n   *\r\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\r\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\r\n   *\r\n   * const claimConditions = [\r\n   *   {\r\n   *     startTime: presaleStartTime, // start the presale now\r\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\r\n   *     price: 0.01, // presale price\r\n   *     snapshot: snapshots, // limit minting to only certain addresses\r\n   *   },\r\n   *   {\r\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\r\n   *     price: 0.08, // public sale price\r\n   *   }\r\n   * ]);\r\n   *\r\n   * await dropContract.claimConditions.set(claimConditions);\r\n   * ```\r\n   *\r\n   * @param claimConditionInputs - The claim conditions\r\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\r\n   */\r\n  set = /* @__PURE__ */buildTransactionFunction((() => {\r\n    var _this = this;\r\n    return async function (claimConditionInputs) {\r\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      let claimConditionsProcessed = claimConditionInputs;\r\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\r\n        resetClaimEligibilityForAll = true;\r\n        if (claimConditionInputs.length === 0) {\r\n          claimConditionsProcessed = [{\r\n            startTime: new Date(0),\r\n            currencyAddress: constants.AddressZero,\r\n            price: 0,\r\n            maxClaimableSupply: 0,\r\n            maxClaimablePerWallet: 0,\r\n            waitInSeconds: 0,\r\n            merkleRootHash: utils.hexZeroPad([0], 32),\r\n            snapshot: []\r\n          }];\r\n        } else if (claimConditionInputs.length > 1) {\r\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\r\n        }\r\n      }\r\n\r\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\r\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\r\n        claimConditionsProcessed.forEach(cc => {\r\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\r\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\r\n          }\r\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\r\n            if (typeof s === \"string\") {\r\n              return 0;\r\n            } else {\r\n              return Number(s.maxClaimable?.toString() || 0);\r\n            }\r\n          }).reduce((acc, current) => {\r\n            return acc + current;\r\n          }, 0) === 0) {\r\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\r\n          }\r\n        });\r\n      }\r\n\r\n      // process inputs\r\n      const {\r\n        snapshotInfos,\r\n        sortedConditions\r\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\r\n      const merkleInfo = {};\r\n      snapshotInfos.forEach(s => {\r\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\r\n      });\r\n      const metadata = await _this.metadata.get();\r\n      const encoded = [];\r\n\r\n      // upload new merkle roots to snapshot URIs if updated\r\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\r\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\r\n          ...metadata,\r\n          merkle: merkleInfo\r\n        });\r\n        // using internal method to just upload, avoids one contract call\r\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\r\n\r\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\r\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\r\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\r\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\r\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\r\n        } else {\r\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\r\n        }\r\n      }\r\n      const cw = _this.contractWrapper;\r\n      const baseContractEncoder = new ContractEncoder(cw);\r\n      if (_this.isLegacySinglePhaseDrop(cw)) {\r\n        const contractEncoderLegacy = new ContractEncoder(cw);\r\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\r\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\r\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\r\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\r\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\r\n      } else if (_this.isNewMultiphaseDrop(cw)) {\r\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\r\n      } else {\r\n        throw new Error(\"Contract does not support claim conditions\");\r\n      }\r\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\r\n        return Transaction.fromContractWrapper({\r\n          contractWrapper: _this.contractWrapper,\r\n          method: \"multicall\",\r\n          args: [encoded]\r\n        });\r\n      }\r\n      throw new Error(\"Contract does not support multicall\");\r\n    };\r\n  })());\r\n\r\n  /**\r\n   * Update a single claim condition with new data.\r\n   *\r\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\r\n   * @param claimConditionInput - the new data to update, previous data will be retained\r\n   */\r\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\r\n    const existingConditions = await this.getAll();\r\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\r\n    return await this.set.prepare(newConditionInputs);\r\n  });\r\n\r\n  /** ***************************************\r\n   * PRIVATE FUNCTIONS\r\n   *****************************************/\r\n\r\n  async getTokenDecimals() {\r\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\r\n      return this.contractWrapper.read(\"decimals\", []);\r\n    } else {\r\n      return Promise.resolve(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns proofs and the overrides required for the transaction.\r\n   *\r\n   * @returns  `overrides` and `proofs` as an object.\r\n   * @internal\r\n   */\r\n  async prepareClaim(quantity, checkERC20Allowance) {\r\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\r\n    let address = arguments.length > 3 ? arguments[3] : undefined;\r\n    const [addressToClaim, activeClaimConditions] = await Promise.all([address ? address : this.contractWrapper.getSignerAddress(), this.getActive()]);\r\n    return prepareClaim(addressToClaim, quantity, activeClaimConditions, async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\r\n  }\r\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\r\n    const resolvedAddress = await resolveAddress(destinationAddress);\r\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\r\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\r\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\r\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\r\n        proof: claimVerification.proofs,\r\n        maxQuantityInAllowlist: claimVerification.maxClaimable\r\n      }, utils.toUtf8Bytes(\"\")];\r\n    }\r\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\r\n      proof: claimVerification.proofs,\r\n      quantityLimitPerWallet: claimVerification.maxClaimable,\r\n      pricePerToken: claimVerification.priceInProof,\r\n      currency: claimVerification.currencyAddressInProof\r\n    }, utils.toUtf8Bytes(\"\")];\r\n  }\r\n\r\n  /**\r\n   * Construct a claim transaction without executing it.\r\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\r\n   * @param destinationAddress - The address to claim to\r\n   * @param quantity - The quantity to claim\r\n   * @param options - Options to override the claim transaction\r\n   *\r\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\r\n   */\r\n  async getClaimTransaction(destinationAddress, quantity, options) {\r\n    // TODO: Transaction Sequence Pattern\r\n    if (options?.pricePerToken) {\r\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\r\n    }\r\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\r\n    return Transaction.fromContractWrapper({\r\n      contractWrapper: this.contractWrapper,\r\n      method: \"claim\",\r\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\r\n      overrides: claimVerification.overrides\r\n    });\r\n  }\r\n  isNewSinglePhaseDrop(contractWrapper) {\r\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\r\n  }\r\n  isNewMultiphaseDrop(contractWrapper) {\r\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\r\n  }\r\n  isLegacySinglePhaseDrop(contractWrapper) {\r\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\r\n  }\r\n  isLegacyMultiPhaseDrop(contractWrapper) {\r\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\r\n  }\r\n  getSnapshotFormatVersion() {\r\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\r\n  }\r\n}\r\n\r\nexport { DropClaimConditions as D };\r\n"],
  "mappings": "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",
  "names": ["_a", "deepEqual"]
}
