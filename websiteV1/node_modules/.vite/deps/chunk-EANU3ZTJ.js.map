{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/dist/contract-owner-1f113a23.browser.esm.js"],
  "sourcesContent": ["import { h as hasFunction } from './contract-appuri-3d68505c.browser.esm.js';\r\nimport { d as buildTransactionFunction, T as Transaction } from './transactions-de84ba20.browser.esm.js';\r\nimport { d1 as FEATURE_ROYALTY, bD as CommonRoyaltySchema, aV as NATIVE_TOKEN_ADDRESS, d2 as FEATURE_OWNER, aL as resolveAddress } from './index-e7118e8b.browser.esm.js';\r\nimport { C as ContractEncoder } from './fetchCurrencyValue-27d660ae.browser.esm.js';\r\nimport { utils, BigNumber, Contract } from 'ethers';\r\nimport { a as CommonNFTInput } from './setErc20Allowance-0fd3045e.browser.esm.js';\r\nimport { c as fetchTokenMetadataForContract, g as getBaseUriFromBatch } from './QueryParams-c67b6cd4.browser.esm.js';\r\nimport { a as approveErc20Allowance } from './signature-61410b74.browser.esm.js';\r\nimport { n as normalizePriceValue } from './normalizePriceValue-ee13e65c.browser.esm.js';\r\n\r\n/**\r\n * Handle contract royalties\r\n * @remarks Configure royalties for an entire contract or a particular token.\r\n * @example\r\n * ```javascript\r\n * const contract = await sdk.getContract(\"{{contract_address}}\");\r\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\r\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\r\n *   seller_fee_basis_points: 100, // 1% royalty fee\r\n *   fee_recipient: \"0x...\", // the fee recipient\r\n * });\r\n * ```\r\n * @public\r\n */\r\nclass ContractRoyalty {\r\n  featureName = FEATURE_ROYALTY.name;\r\n  constructor(contractWrapper, metadata) {\r\n    this.contractWrapper = contractWrapper;\r\n    this.metadata = metadata;\r\n  }\r\n\r\n  /**\r\n   * Get the royalty recipient and fee\r\n   * @returns  The royalty recipient and BPS\r\n   * @example\r\n   * ```javascript\r\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\r\n   * console.log(royaltyInfo.fee_recipient);\r\n   * console.log(royaltyInfo.seller_fee_basis_points);\r\n   * ```\r\n   * @public\r\n   * @twfeature Royalty\r\n   */\r\n  async getDefaultRoyaltyInfo() {\r\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\r\n    // parse it on the way out to make sure we default things if they are not set\r\n    return CommonRoyaltySchema.parseAsync({\r\n      fee_recipient: royaltyRecipient,\r\n      seller_fee_basis_points: royaltyBps\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the royalty recipient and fee of a particular token\r\n   * @returns  The royalty recipient and BPS\r\n   * @example\r\n   * ```javascript\r\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\r\n   * console.log(royaltyInfo.fee_recipient);\r\n   * console.log(royaltyInfo.seller_fee_basis_points);\r\n   * ```\r\n   * @public\r\n   * @twfeature Royalty\r\n   */\r\n  async getTokenRoyaltyInfo(tokenId) {\r\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\r\n    return CommonRoyaltySchema.parseAsync({\r\n      fee_recipient: royaltyRecipient,\r\n      seller_fee_basis_points: royaltyBps\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the royalty recipient and fee\r\n   * @param royaltyData - the royalty recipient and fee\r\n   *  @example\r\n   * ```javascript\r\n   * await contract.roles.setDefaultRoyaltyInfo({\r\n   *   seller_fee_basis_points: 100, // 1% royalty fee\r\n   *   fee_recipient: \"0x...\", // the fee recipient\r\n   * });\r\n   * ```\r\n   * @public\r\n   * @twfeature Royalty\r\n   */\r\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\r\n    // read the metadata from the contract\r\n    const oldMetadata = await this.metadata.get();\r\n\r\n    // update the metadata with the new royalty data\r\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\r\n    const mergedMetadata = await this.metadata.parseInputMetadata({\r\n      ...oldMetadata,\r\n      ...royaltyData\r\n    });\r\n\r\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\r\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\r\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\r\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\r\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\r\n      // encode both the functions we want to send\r\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\r\n      // actually send the transaction and return the receipt + a way to get the new royalty info\r\n\r\n      return Transaction.fromContractWrapper({\r\n        contractWrapper: this.contractWrapper,\r\n        method: \"multicall\",\r\n        args: [encoded],\r\n        parse: receipt => ({\r\n          receipt,\r\n          data: () => this.getDefaultRoyaltyInfo()\r\n        })\r\n      });\r\n    } else {\r\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Set the royalty recipient and fee for a particular token\r\n   * @param tokenId - the token id\r\n   * @param royaltyData - the royalty recipient and fee\r\n   * @example\r\n   * ```javascript\r\n   * const tokenId = 0;\r\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\r\n   *   seller_fee_basis_points: 100, // 1% royalty fee\r\n   *   fee_recipient: \"0x...\", // the fee recipient\r\n   * });\r\n   * ```\r\n   * @public\r\n   * @twfeature Royalty\r\n   */\r\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\r\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\r\n    return Transaction.fromContractWrapper({\r\n      contractWrapper: this.contractWrapper,\r\n      method: \"setRoyaltyInfoForToken\",\r\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\r\n      parse: receipt => ({\r\n        receipt,\r\n        data: () => this.getDefaultRoyaltyInfo()\r\n      })\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Handles delayed reveal logic\r\n * @public\r\n */\r\nclass DelayedReveal {\r\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\r\n    this.featureName = featureName;\r\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\r\n    this.contractWrapper = contractWrapper;\r\n    this.storage = storage;\r\n  }\r\n\r\n  /**\r\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\r\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\r\n   * @example\r\n   * ```javascript\r\n   * // the real NFTs, these will be encrypted until your reveal them!\r\n   * const realNFTs = [{\r\n   *   name: \"Common NFT #1\",\r\n   *   description: \"Common NFT, one of many.\",\r\n   *   image: fs.readFileSync(\"path/to/image.png\"),\r\n   * }, {\r\n   *   name: \"Super Rare NFT #2\",\r\n   *   description: \"You got a Super Rare NFT!\",\r\n   *   image: fs.readFileSync(\"path/to/image.png\"),\r\n   * }];\r\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\r\n   * const placeholderNFT = {\r\n   *   name: \"Hidden NFT\",\r\n   *   description: \"Will be revealed next week!\"\r\n   * };\r\n   * // Create and encrypt the NFTs\r\n   * await contract.revealer.createDelayedRevealBatch(\r\n   *   placeholderNFT,\r\n   *   realNFTs,\r\n   *   \"my secret password\",\r\n   * );\r\n   * ```\r\n   * @public\r\n   * @param placeholder - the placeholder NFT to show before the reveal\r\n   * @param metadatas - the final NFTs that will be hidden\r\n   * @param password - the password that will be used to reveal these NFTs\r\n   * @param options - additional options like upload progress\r\n   */\r\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\r\n    if (!password) {\r\n      throw new Error(\"Password is required\");\r\n    }\r\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\r\n      rewriteFileNames: {\r\n        fileStartNumber: 0\r\n      }\r\n    });\r\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\r\n    const startFileNumber = await this.nextTokenIdToMintFn();\r\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\r\n      onProgress: options?.onProgress,\r\n      rewriteFileNames: {\r\n        fileStartNumber: startFileNumber.toNumber()\r\n      }\r\n    });\r\n    const baseUri = getBaseUriFromBatch(uris);\r\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\r\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\r\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\r\n    let data;\r\n    const legacyContract = await this.isLegacyContract();\r\n    if (legacyContract) {\r\n      data = encryptedBaseUri;\r\n    } else {\r\n      const chainId = await this.contractWrapper.getChainID();\r\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\r\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\r\n    }\r\n    return Transaction.fromContractWrapper({\r\n      contractWrapper: this.contractWrapper,\r\n      method: \"lazyMint\",\r\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\r\n      parse: receipt => {\r\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\r\n        const startingIndex = events[0].args.startTokenId;\r\n        const endingIndex = events[0].args.endTokenId;\r\n        const results = [];\r\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\r\n          results.push({\r\n            id,\r\n            receipt\r\n          });\r\n        }\r\n        return results;\r\n      }\r\n    });\r\n  });\r\n\r\n  /**\r\n   * Reveal a batch of hidden NFTs\r\n   * @remarks Reveal the NFTs of a batch using the password.\r\n   * @example\r\n   * ```javascript\r\n   * // the batch to reveal\r\n   * const batchId = 0;\r\n   * // reveal the batch\r\n   * await contract.revealer.reveal(batchId, \"my secret password\");\r\n   * ```\r\n   * @public\r\n   * @param batchId - the id of the batch to reveal\r\n   * @param password - the password\r\n   */\r\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\r\n    if (!password) {\r\n      throw new Error(\"Password is required\");\r\n    }\r\n    const key = await this.hashDelayRevealPassword(batchId, password);\r\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\r\n    try {\r\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\r\n      // basic sanity check for making sure decryptedUri is valid\r\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\r\n      // ethers would throw when trying to decode it\r\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\r\n        throw new Error(\"invalid password\");\r\n      }\r\n    } catch (e) {\r\n      throw new Error(\"invalid password\");\r\n    }\r\n    return Transaction.fromContractWrapper({\r\n      contractWrapper: this.contractWrapper,\r\n      method: \"reveal\",\r\n      args: [batchId, key]\r\n    });\r\n  });\r\n\r\n  /**\r\n   * Gets the list of unrevealed NFT batches.\r\n   * @remarks Gets the list of unrevealed NFT batches.\r\n   * @example\r\n   * ```javascript\r\n   * const batches = await contract.revealer.getBatchesToReveal();\r\n   * ```\r\n   * @public\r\n   */\r\n  async getBatchesToReveal() {\r\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\r\n    if (count.isZero()) {\r\n      return [];\r\n    }\r\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\r\n    // map over to get the base uri indices, which should be the end token id of every batch\r\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\r\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\r\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\r\n      }\r\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\r\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\r\n      }\r\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\r\n    }));\r\n\r\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\r\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\r\n\r\n    // returns the token uri for each batches. first batch always starts from token id 0.\r\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\r\n\r\n    // index is the uri indices, which is end token id. different from uris\r\n    const legacyContract = await this.isLegacyContract();\r\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\r\n    const encryptedBaseUris = encryptedUriData.map(data => {\r\n      if (utils.hexDataLength(data) > 0) {\r\n        if (legacyContract) {\r\n          return data;\r\n        }\r\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\r\n        return result[0];\r\n      } else {\r\n        return data;\r\n      }\r\n    });\r\n    return tokenMetadatas.map((meta, index) => ({\r\n      batchId: BigNumber.from(index),\r\n      batchUri: meta.uri,\r\n      placeholderMetadata: meta\r\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\r\n  }\r\n\r\n  /**\r\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\r\n   *\r\n   * @internal\r\n   */\r\n  async hashDelayRevealPassword(batchTokenIndex, password) {\r\n    const chainId = await this.contractWrapper.getChainID();\r\n    const contractAddress = this.contractWrapper.address;\r\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\r\n  }\r\n  async getNftMetadata(tokenId) {\r\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\r\n  }\r\n  async isLegacyContract() {\r\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\r\n      try {\r\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\r\n        return version <= 2;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  async getLegacyEncryptedData(index) {\r\n    const DeprecatedAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json')).default;\r\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\r\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\r\n    if (result.length > 0) {\r\n      return result[0];\r\n    } else {\r\n      return \"0x\";\r\n    }\r\n  }\r\n}\r\n\r\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\r\n  let overrides = {};\r\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\r\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\r\n  const totalCost = normalizedPrice.mul(quantity);\r\n  if (totalCost.gt(0)) {\r\n    if (currency === NATIVE_TOKEN_ADDRESS) {\r\n      overrides = {\r\n        value: totalCost\r\n      };\r\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\r\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\r\n    }\r\n  }\r\n  return overrides;\r\n}\r\n\r\n/**\r\n * Encodes and decodes Contract functions\r\n * @public\r\n */\r\nclass ContractOwner {\r\n  featureName = FEATURE_OWNER.name;\r\n  constructor(contractWrapper) {\r\n    this.contractWrapper = contractWrapper;\r\n  }\r\n\r\n  /**\r\n   * Get the current owner of the contract\r\n   * @example\r\n   * ```javascript\r\n   * await contract.owner.get();\r\n   * console.log(\"Owner address: \", ownerAddress);\r\n   * ```\r\n   * @returns The owner address\r\n   * @twfeature Ownable\r\n   */\r\n  async get() {\r\n    return this.contractWrapper.read(\"owner\", []);\r\n  }\r\n\r\n  /**\r\n   * Set the new owner of the contract\r\n   * @remarks Can only be called by the current owner.\r\n   *\r\n   * @param address - the address of the new owner\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * const newOwnerAddress = \"{{wallet_address}}\";\r\n   * await contract.owner.set(newOwnerAddress);\r\n   * ```\r\n   * @twfeature Ownable\r\n   */\r\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\r\n    const resolvedAddress = await resolveAddress(address);\r\n    return Transaction.fromContractWrapper({\r\n      contractWrapper: this.contractWrapper,\r\n      method: \"setOwner\",\r\n      args: [resolvedAddress]\r\n    });\r\n  });\r\n}\r\n\r\nexport { ContractRoyalty as C, DelayedReveal as D, ContractOwner as a, calculateClaimCost as c };\r\n"],
  "mappings": "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",
  "names": []
}
