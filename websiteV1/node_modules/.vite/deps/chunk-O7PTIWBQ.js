import {
  resolveOrGenerateId
} from "./chunk-EG3CND37.js";
import {
  EndDateSchema,
  StartDateSchema,
  assertEnabled
} from "./chunk-3M6RMWCZ.js";
import {
  ContractEvents,
  detectContractFeature
} from "./chunk-EWRZHZCC.js";
import {
  AbiSchema,
  AddressOrEnsSchema,
  AddressZero,
  AmountSchema,
  CommonContractSchema,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  FEATURE_ACCOUNT,
  FEATURE_ACCOUNT_FACTORY,
  FEATURE_ACCOUNT_PERMISSIONS,
  FEATURE_AIRDROP_ERC1155,
  FEATURE_AIRDROP_ERC20,
  FEATURE_AIRDROP_ERC721,
  FEATURE_DYNAMIC_CONTRACT,
  GAS_LIMIT_FOR_DEPLOYER,
  THIRDWEB_DEPLOYER,
  Transaction,
  buildTransactionFunction,
  caches,
  computeDeploymentInfo,
  extractCommentFromMetadata,
  extractFunctionsFromAbi,
  fetchAndCacheDeployMetadata,
  fetchContractMetadataFromAddress,
  fetchPublishedContractFromPolygon,
  fetchSourceFilesFromMetadata,
  getCreate2FactoryAddress,
  invariant,
  isContractDeployed,
  joinABIs,
  resolveAddress,
  z
} from "./chunk-DH5ORYRE.js";
import {
  ContractFactory,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4CCDGKES.js";
import {
  BigNumber
} from "./chunk-RN5BNASC.js";
import {
  __publicField
} from "./chunk-HY2WJTHE.js";

// node_modules/@thirdweb-dev/sdk/dist/deployContractDeterministic-df492605.browser.esm.js
init_lib();
function getFunctionSignature(fnInputs) {
  return "(" + fnInputs.map((i) => {
    return i.type === "tuple" ? getFunctionSignature(i.components) : i.type === "tuple[]" ? getFunctionSignature(i.components) + `[]` : i.type;
  }).join(",") + ")";
}
function generatePluginFunctions(pluginAddress, pluginAbi) {
  const pluginInterface = new utils_exports.Interface(pluginAbi);
  const pluginFunctions = [];
  for (const fnFragment of Object.values(pluginInterface.functions)) {
    const fn = pluginInterface.getFunction(pluginInterface.getSighash(fnFragment));
    if (fn.name.includes("_")) {
      continue;
    }
    pluginFunctions.push({
      functionSelector: pluginInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs),
      pluginAddress
    });
  }
  return pluginFunctions;
}
function generateExtensionFunctions(extensionAbi) {
  const extensionInterface = new utils_exports.Interface(extensionAbi);
  const extensionFunctions = [];
  for (const fnFragment of Object.values(extensionInterface.functions)) {
    const fn = extensionInterface.getFunction(extensionInterface.getSighash(fnFragment));
    if (fn.name.startsWith("_")) {
      continue;
    }
    extensionFunctions.push({
      functionSelector: extensionInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs)
    });
  }
  return extensionFunctions;
}
async function getDeploymentInfo(metadataUri, storage, provider, create2Factory, clientId, secretKey) {
  caches.deploymentPresets = {};
  const [create2FactoryAddress, {
    compilerMetadata,
    extendedMetadata
  }] = await Promise.all([create2Factory ? create2Factory : getCreate2FactoryAddress(provider), fetchAndCacheDeployMetadata(metadataUri, storage)]);
  const customParams = {};
  const finalDeploymentInfo = [];
  const defaultExtensions = extendedMetadata == null ? void 0 : extendedMetadata.defaultExtensions;
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" && defaultExtensions) {
    invariant(clientId || secretKey, "Require Client Id / Secret Key");
    const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);
    }));
    const pluginMetadata = (await Promise.all(publishedExtensions.map((c) => fetchAndCacheDeployMetadata(c.metadataUri, storage)))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map((metadata) => computeDeploymentInfo("plugin", provider, storage, create2FactoryAddress, {
      metadata
    }, clientId, secretKey)));
    const mapInput = [];
    pluginMetadata.forEach((metadata, index) => {
      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);
      mapInput.push(...input);
    });
    const pluginMapTransaction = await computeDeploymentInfo("plugin", provider, storage, create2FactoryAddress, {
      contractName: "PluginMap",
      constructorParams: {
        _pluginsToAdd: {
          value: mapInput
        }
      }
    }, clientId, secretKey);
    customParams["_pluginMap"] = {
      value: pluginMapTransaction.transaction.predictedAddress
    };
    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);
  } else if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic" && defaultExtensions) {
    invariant(clientId || secretKey, "Require Client Id / Secret Key");
    const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);
    }));
    const extensionMetadata = (await Promise.all(publishedExtensions.map(async (c) => {
      return fetchAndCacheDeployMetadata(c.metadataUri, storage);
    }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
    const extensionDeploymentInfo = await Promise.all(extensionMetadata.map((metadata) => computeDeploymentInfo("extension", provider, storage, create2FactoryAddress, {
      metadata
    }, clientId, secretKey)));
    const routerInput = [];
    extensionMetadata.forEach((metadata, index) => {
      const extensionFunctions = generateExtensionFunctions(metadata.abi);
      routerInput.push({
        metadata: {
          name: metadata.name,
          metadataURI: "",
          implementation: extensionDeploymentInfo[index].transaction.predictedAddress
        },
        functions: extensionFunctions
      });
    });
    customParams["_extensions"] = {
      value: routerInput
    };
    finalDeploymentInfo.push(...extensionDeploymentInfo);
  }
  const [implementationDeployInfo, factoryInfo] = await Promise.all([
    computeDeploymentInfo("implementation", provider, storage, create2FactoryAddress, {
      metadata: compilerMetadata,
      constructorParams: customParams
    }, clientId, secretKey),
    // get clone factory
    computeDeploymentInfo("infra", provider, storage, create2FactoryAddress, {
      contractName: "TWCloneFactory"
    }, clientId, secretKey)
  ]);
  finalDeploymentInfo.push(factoryInfo);
  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));
  finalDeploymentInfo.push(implementationDeployInfo);
  return finalDeploymentInfo;
}
function estimateGasForDeploy(initCode) {
  let gasLimit = utils_exports.arrayify(initCode).map((x) => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32e3 + 21e3;
  gasLimit = Math.floor(gasLimit * 64 / 63);
  return gasLimit;
}
function createTransactionBatches(transactions) {
  let upperGasLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;
  transactions = transactions.filter((tx) => {
    return tx.data.length > 0;
  });
  if (transactions.length === 0) {
    return [];
  }
  const transactionBatches = [];
  let sum = 0;
  let batch = [];
  transactions.forEach((tx) => {
    const gas = estimateGasForDeploy(tx.data);
    if (sum + gas > upperGasLimit) {
      if (batch.length === 0) {
        transactionBatches.push([tx]);
      } else {
        transactionBatches.push(batch);
        sum = gas;
        batch = [tx];
      }
    } else {
      sum += gas;
      batch.push(tx);
    }
  });
  if (batch.length > 0) {
    transactionBatches.push(batch);
  }
  return transactionBatches;
}
async function deployWithThrowawayDeployer(signer, transactions, options) {
  var _a, _b;
  const transactionBatches = createTransactionBatches(transactions);
  if (transactionBatches.length === 0) {
    return;
  }
  (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "infra");
  const deployTxns = await Promise.all(transactionBatches.map((txBatch) => {
    const deployer = new ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);
    return deployer;
  }));
  await Promise.all(deployTxns.map((tx) => {
    return tx.deployed();
  }));
  (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "infra");
}
async function deployContractDeterministic(signer, transaction, options) {
  var _a, _b;
  let gasLimit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);
    const tx = {
      to: transaction.to,
      data: transaction.data
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "preset");
    await (await signer.sendTransaction(tx)).wait();
    (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "preset");
  }
}

// node_modules/@thirdweb-dev/sdk/dist/airdrop-erc1155-1a0a4b59.browser.esm.js
init_lib();
var AdminFlag = function(AdminFlag2) {
  AdminFlag2[AdminFlag2["None"] = 0] = "None";
  AdminFlag2[AdminFlag2["AddAdmin"] = 1] = "AddAdmin";
  AdminFlag2[AdminFlag2["RemoveAdmin"] = 2] = "RemoveAdmin";
  return AdminFlag2;
}({});
var DEFAULT_PERMISSIONS = {
  // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
  startDate: BigNumber.from(0),
  // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
  expirationDate: BigNumber.from(0),
  approvedCallTargets: [],
  nativeTokenLimitPerTransaction: "0"
};
var SignerPermissionsSchema = (() => z.object({
  startDate: StartDateSchema,
  expirationDate: EndDateSchema,
  nativeTokenLimitPerTransaction: AmountSchema.default(0),
  approvedCallTargets: z.union([z.array(AddressOrEnsSchema), z.literal("*")])
}))();
var PermissionSnapshotSchema = (() => z.array(z.object({
  signer: AddressOrEnsSchema,
  makeAdmin: z.boolean(),
  permissions: SignerPermissionsSchema
})))();
var SignerPermissionRequestV1 = [{
  name: "signer",
  type: "address"
}, {
  name: "approvedTargets",
  type: "address[]"
}, {
  name: "nativeTokenLimitPerTransaction",
  type: "uint256"
}, {
  name: "permissionStartTimestamp",
  type: "uint128"
}, {
  name: "permissionEndTimestamp",
  type: "uint128"
}, {
  name: "reqValidityStartTimestamp",
  type: "uint128"
}, {
  name: "reqValidityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var SignerPermissionRequest = [{
  name: "signer",
  type: "address"
}, {
  name: "isAdmin",
  type: "uint8"
}, {
  name: "approvedTargets",
  type: "address[]"
}, {
  name: "nativeTokenLimitPerTransaction",
  type: "uint256"
}, {
  name: "permissionStartTimestamp",
  type: "uint128"
}, {
  name: "permissionEndTimestamp",
  type: "uint128"
}, {
  name: "reqValidityStartTimestamp",
  type: "uint128"
}, {
  name: "reqValidityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var AccountPermissions = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT_PERMISSIONS.name);
    /*********************************
     * WRITE FUNCTIONS
     ********************************/
    /**
     * Grant an address admin access to the account.
     *
     * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.
     *
     * @param signer - The address to be granted admin access to the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, DEFAULT_PERMISSIONS, AdminFlag.AddAdmin);
    }));
    /**
     * Revoke an address' admin access to the account.
     *
     * @remarks Revokes an address' admin access to the account.
     *
     * @param signer - The address of an admin of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, DEFAULT_PERMISSIONS, AdminFlag.RemoveAdmin);
    }));
    /**
     * Grant a signer permissions to use the account.
     *
     * @remarks Grants a signer permissions to use the account.
     *
     * @param signer - The signer to be granted permissions to use the account.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantPermissions(signer, permissions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantPermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot grant permissions to an existing admin.");
      }
      if (await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions, AdminFlag.None);
    }));
    /**
     * Update the permissions of a signer for using the account.
     *
     * @remarks Updates the permissions of a signer for using the account.
     *
     * @param signer - The signer whose permissions to use the account are to be updated.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.updatePermissions(signer, permissions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "updatePermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot update permissions of an existing admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions, AdminFlag.None);
    }));
    /**
     * Revoke a scoped access address to the account
     *
     * @remarks Revokes an address' access to the account.
     *
     * @param signer - The address whose access to the account is to be revoked.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAccess", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot revoke permissions of an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(0),
        expirationDate: BigNumber.from(0),
        approvedCallTargets: [],
        nativeTokenLimitPerTransaction: "0"
      }, AdminFlag.None);
    }));
    /**
     * Approve an address as a call target for a given signer on the account
     *
     * @remarks Approves an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to approve as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.approveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "approveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedTarget = await resolveAddress(target);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      const permissions = await this.contractWrapper.read("getPermissionsForSigner", [resolvedSignerAddress]);
      if (permissions.approvedTargets.includes(target)) {
        throw new Error("Target is already approved");
      }
      const newTargets = [...permissions.approvedTargets, resolvedTarget];
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(permissions.startTimestamp),
        expirationDate: BigNumber.from(permissions.endTimestamp),
        approvedCallTargets: newTargets,
        nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
      }, AdminFlag.None);
    }));
    /**
     * Disapprove an address as a call target for a given signer on the account
     *
     * @remarks Disapprove an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to disapprove as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.disapproveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "disapproveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedTarget = await resolveAddress(target);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      const permissions = await this.contractWrapper.read("getPermissionsForSigner", [resolvedSignerAddress]);
      if (!permissions.approvedTargets.includes(resolvedTarget)) {
        throw new Error("Target is currently not approved");
      }
      const newTargets = permissions.approvedTargets.filter((approvedTarget) => utils_exports.getAddress(approvedTarget) !== utils_exports.getAddress(resolvedTarget));
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(permissions.startTimestamp),
        expirationDate: BigNumber.from(permissions.endTimestamp),
        approvedCallTargets: newTargets,
        nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
      }, AdminFlag.None);
    }));
    /**
     * Set the account's entire snapshot of permissions.
     *
     * @remarks Sets the account's entire snapshot of permissions.
     *
     * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.setAccess(permissionSnapshot);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "resetAllPermissions", buildTransactionFunction(async (permissionSnapshot) => {
      const resolvedSnapshot = await PermissionSnapshotSchema.parseAsync(permissionSnapshot);
      if (this.hasDuplicateSigners(resolvedSnapshot)) {
        throw new Error("Duplicate signers found in input.");
      }
      const removeAdminData = [];
      const addOrUpdateSignerData = [];
      const removeSignerData = [];
      const allAdmins = await this.getAllAdmins();
      const allToMakeAdmin = resolvedSnapshot.filter((item) => item.makeAdmin).map((item) => item.signer);
      allAdmins.forEach(async (admin) => {
        if (!allToMakeAdmin.includes(admin)) {
          const data2 = (await this.sendSignerPermissionRequest(admin, DEFAULT_PERMISSIONS, AdminFlag.RemoveAdmin)).encode();
          removeAdminData.push(data2);
        }
      });
      const allSigners = await this.getAllSigners();
      const allToMakeSigners = resolvedSnapshot.filter((item) => {
        return !item.makeAdmin;
      }).map((item) => item.signer);
      await Promise.all(allSigners.map(async (item) => {
        if (!allToMakeSigners.includes(item.signer)) {
          const data2 = (await this.sendSignerPermissionRequest(item.signer, DEFAULT_PERMISSIONS, AdminFlag.None)).encode();
          removeSignerData.push(data2);
        }
      }));
      for (const member of resolvedSnapshot) {
        if (member.makeAdmin) {
          (await this.sendSignerPermissionRequest(member.signer, DEFAULT_PERMISSIONS, AdminFlag.AddAdmin)).encode();
        } else {
          const data2 = (await this.sendSignerPermissionRequest(member.signer, member.permissions, AdminFlag.None)).encode();
          addOrUpdateSignerData.push(data2);
        }
      }
      const data = [];
      removeAdminData.forEach((item) => {
        data.push(item);
      });
      removeSignerData.forEach((item) => {
        data.push(item);
      });
      addOrUpdateSignerData.forEach((item) => {
        data.push(item);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /*********************************
   * HELPER FUNCTIONS
   ********************************/
  hasDuplicateSigners(snapshot) {
    const checkedSigner = {};
    const signers = snapshot.map((item) => item.signer);
    for (const signer of signers) {
      if (!checkedSigner[signer]) {
        checkedSigner[signer] = true;
      } else {
        return true;
      }
    }
    return false;
  }
  /**
   * Format the access restrictions for a given role
   *
   * @param restrictions - The access restrictions for a given role
   * @returns formatted role restrictions
   *
   */
  parseSignerPermissionsStruct(permissions) {
    return {
      startDate: new Date(parseInt(permissions.startTimestamp.toString()) * 1e3),
      expirationDate: new Date(parseInt(permissions.endTimestamp.toString()) * 1e3),
      nativeTokenLimitPerTransaction: BigNumber.from(permissions.nativeTokenLimitPerTransaction),
      approvedCallTargets: permissions.approvedTargets
    };
  }
  async sendSignerPermissionRequest(signerAddress, permissions, adminFlag) {
    if (detectContractFeature(this.contractWrapper, "AccountPermissionsV1")) {
      if (adminFlag === AdminFlag.AddAdmin || adminFlag === AdminFlag.RemoveAdmin) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAdmin",
          args: [signerAddress, adminFlag === AdminFlag.AddAdmin]
        });
      } else {
        const {
          payload: payload2,
          signature: signature2
        } = await this.generateLegacyPayload(signerAddress, permissions);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setPermissionsForSigner",
          args: [payload2, signature2]
        });
      }
    }
    const {
      payload,
      signature
    } = await this.generatePayload(signerAddress, permissions, adminFlag);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "setPermissionsForSigner",
      args: [payload, signature]
    });
  }
  /**
   * Generate and sign a payload to grant or revoke a signer's access to the account.
   *
   * @param signer - The address of the signer
   * @param roleAction - The address of the signer
   * @returns The generated payload and signature produced on signing that payload.
   *
   */
  async generatePayload(signerAddress, permissions, isAdmin) {
    const payload = {
      signer: signerAddress,
      isAdmin: isAdmin.valueOf(),
      approvedTargets: permissions.approvedCallTargets === "*" ? [AddressZero] : permissions.approvedCallTargets,
      nativeTokenLimitPerTransaction: utils_exports.parseEther(permissions.nativeTokenLimitPerTransaction),
      permissionStartTimestamp: permissions.startDate,
      permissionEndTimestamp: permissions.expirationDate,
      reqValidityStartTimestamp: 0,
      // Req validity ends 10 years from now.
      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10).getTime() / 1e3)),
      uid: resolveOrGenerateId(void 0)
    };
    const chainId = await this.contractWrapper.getChainID();
    const connectedSigner = this.contractWrapper.getSigner();
    invariant(connectedSigner, "No signer available");
    const signature = await this.contractWrapper.signTypedData(connectedSigner, {
      name: "Account",
      version: "1",
      chainId,
      verifyingContract: this.getAddress()
    }, {
      SignerPermissionRequest
    }, payload);
    return {
      payload,
      signature
    };
  }
  async generateLegacyPayload(signerAddress, permissions) {
    if (permissions.approvedCallTargets === "*") {
      throw new Error("Wildcard call targets are not supported on legacy account permissions contract, please deploy an updated contract factory.");
    }
    const payload = {
      signer: signerAddress,
      approvedTargets: permissions.approvedCallTargets,
      nativeTokenLimitPerTransaction: utils_exports.parseEther(permissions.nativeTokenLimitPerTransaction),
      permissionStartTimestamp: permissions.startDate,
      permissionEndTimestamp: permissions.expirationDate,
      reqValidityStartTimestamp: 0,
      // Req validity ends 10 years from now.
      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10).getTime() / 1e3)),
      uid: resolveOrGenerateId(void 0)
    };
    const chainId = await this.contractWrapper.getChainID();
    const connectedSigner = this.contractWrapper.getSigner();
    invariant(connectedSigner, "No signer available");
    const signature = await this.contractWrapper.signTypedData(connectedSigner, {
      name: "Account",
      version: "1",
      chainId,
      verifyingContract: this.getAddress()
    }, {
      SignerPermissionRequest: SignerPermissionRequestV1
    }, payload);
    return {
      payload,
      signature
    };
  }
  /*********************************
   * READ FUNCTIONS
   ********************************/
  /**
   * Get whether a signer is an admin on the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isAdmin(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer is an admin on the account.
   *
   * @twfeature AccountPermissions
   */
  async isAdmin(signerAddress) {
    const resolvedSignerAddress = await resolveAddress(signerAddress);
    return await this.contractWrapper.read("isAdmin", [resolvedSignerAddress]);
  }
  /**
   * Get whether a signer has permissions to use the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isSigner(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer has permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async isSigner(signerAddress) {
    const resolvedSignerAddress = await resolveAddress(signerAddress);
    return await this.contractWrapper.read("isActiveSigner", [resolvedSignerAddress]);
  }
  /**
   * Get all admins of the account.
   *
   * @example
   * ```javascript
   * const allAdmins = await contract.account.getAllAdmins();
   * ```
   *
   * @returns All admins of the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdmins() {
    return await this.contractWrapper.read("getAllAdmins", []);
  }
  /**
   * Get all (non-admin) signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allSigners = await contract.account.getAllSigners();
   * ```
   *
   * @returns All (non-admin) signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllSigners() {
    const activeSignersWithPerms = await this.contractWrapper.read("getAllActiveSigners", []);
    return await Promise.all(activeSignersWithPerms.map(async (signerWithPermissions) => {
      const signer = signerWithPermissions.signer;
      const permissions = this.parseSignerPermissionsStruct(signerWithPermissions);
      return {
        signer,
        permissions
      };
    }));
  }
  /**
   * Get all admins and non-admin signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();
   * ```
   *
   * @returns All admins and non-admin signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdminsAndSigners() {
    const allAdmins = await this.getAllAdmins();
    const transformedAdmins = allAdmins.map((admin) => {
      return {
        isAdmin: true,
        signer: admin,
        permissions: {
          startDate: /* @__PURE__ */ new Date(0),
          expirationDate: /* @__PURE__ */ new Date(0),
          nativeTokenLimitPerTransaction: BigNumber.from(0),
          approvedCallTargets: []
        }
      };
    });
    const allSigners = await this.getAllSigners();
    return [...transformedAdmins, ...allSigners];
  }
};
var Account = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT.name);
    /*********************************
     * WRITE FUNCTIONS
     ********************************/
    /**
     * Grant an address admin access to the account.
     *
     * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.
     *
     * @param signer - The address to be granted admin access to the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantAdminPermissions.prepare(signerAddress);
    }));
    /**
     * Revoke an address' admin access to the account.
     *
     * @remarks Revokes an address' admin access to the account.
     *
     * @param signer - The address of an admin of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAdminPermissions.prepare(signerAddress);
    }));
    /**
     * Grant a signer permissions to use the account.
     *
     * @remarks Grants a signer permissions to use the account.
     *
     * @param signer - The signer to be granted permissions to use the account.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantPermissions(signer, permissions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantPermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantPermissions.prepare(signerAddress, permissions);
    }));
    /**
     * Update the permissions of a signer for using the account.
     *
     * @remarks Updates the permissions of a signer for using the account.
     *
     * @param signer - The signer whose permissions to use the account are to be updated.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.updateAccess(signer, restrictions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "updatePermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).updatePermissions.prepare(signerAddress, permissions);
    }));
    /**
     * Revoke a scoped access address to the account
     *
     * @remarks Revokes an address' access to the account.
     *
     * @param signer - The address whose access to the account is to be revoked.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAccess", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAccess.prepare(signerAddress);
    }));
    /**
     * Approve an address as a call target for a given signer on the account
     *
     * @remarks Approves an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to approve as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.approveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "approveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).approveTargetForSigner.prepare(signerAddress, target);
    }));
    /**
     * Disapprove an address as a call target for a given signer on the account
     *
     * @remarks Disapprove an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to disapprove as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.disapproveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "disapproveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).disapproveTargetForSigner.prepare(signerAddress, target);
    }));
    /**
     * Set the account's entire snapshot of permissions.
     *
     * @remarks Sets the account's entire snapshot of permissions.
     *
     * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.setAccess(permissionSnapshot);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "resetAllPermissions", buildTransactionFunction(async (permissionSnapshot) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).resetAllPermissions.prepare(permissionSnapshot);
    }));
    this.contractWrapper = contractWrapper;
    this.accountPermissions = this.detectAccountPermissions();
  }
  detectAccountPermissions() {
    if (detectContractFeature(this.contractWrapper, "AccountPermissions") || detectContractFeature(this.contractWrapper, "AccountPermissionsV1")) {
      return new AccountPermissions(this.contractWrapper);
    }
    return void 0;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /*********************************
   * READ FUNCTIONS
   ********************************/
  /**
   * Get whether a signer is an admin on the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isAdmin(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer is an admin on the account.
   *
   * @twfeature AccountPermissions
   */
  async isAdmin(signerAddress) {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isAdmin(signerAddress);
  }
  /**
   * Get whether a signer has permissions to use the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isSigner(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer has permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async isSigner(signerAddress) {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isSigner(signerAddress);
  }
  /**
   * Get all admins of the account.
   *
   * @example
   * ```javascript
   * const allAdmins = await contract.account.getAllAdmins();
   * ```
   *
   * @returns All admins of the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdmins() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdmins();
  }
  /**
   * Get all (non-admin) signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allSigners = await contract.account.getAllSigners();
   * ```
   *
   * @returns All (non-admin) signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllSigners() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllSigners();
  }
  /**
   * Get all admins and non-admin signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();
   * ```
   *
   * @returns All admins and non-admin signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdminsAndSigners() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdminsAndSigners();
  }
};
var AccountFactory = class {
  // utilities
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT_FACTORY.name);
    /*********************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Create a account
     *
     * @remarks Create a account for an admin. The admin will have complete authority over the account.
     *
     * @param admin - The admin of the account.
     * @param extraData - (Optional) Extra data to be passed to the account on creation.
     *
     * @example
     * ```javascript
     * const tx = await contract.accountFactory.createAccount(admin, extraData);
     * const receipt = tx.receipt();
     * const accountAddress = tx.address;
     * ```
     *
     * @twfeature AccountFactory
     */
    __publicField(this, "createAccount", buildTransactionFunction(async (accountAdmin, extraData) => {
      if (await this.isAccountDeployed(accountAdmin, extraData)) {
        throw new Error(`Account already deployed for admin: ${accountAdmin}`);
      }
      let data = utils_exports.toUtf8Bytes("");
      if (extraData) {
        data = extraData;
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAccount",
        args: [accountAdmin, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("AccountCreated", receipt == null ? void 0 : receipt.logs);
          return {
            address: event[0].args.account,
            receipt
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
    this.events = new ContractEvents(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /*********************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the deterministic address of the account that will be created
   *
   * @example
   * ```javascript
   * const accountAddress = await contract.accountFactory.predictAccountAddress(admin);
   * ```
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   * @returns The deterministic address of the account that will be created for the given admin.
   *
   * @twfeature AccountFactory
   */
  async predictAccountAddress(admin, extraData) {
    let data = utils_exports.toUtf8Bytes("");
    if (extraData) {
      data = extraData;
    }
    return this.contractWrapper.read("getAddress", [admin, data]);
  }
  /**
   * Get all accounts on which the given signer has authority
   *
   * @example
   * ```javascript
   * const allAccounts = await contract.accountFactory.getAssociatedAccounts(admin);
   * ```
   * @param signer - The account address.
   * @returns All accounts on which the given signer has authority.
   *
   * @twfeature AccountFactory
   */
  async getAssociatedAccounts(signer) {
    return this.contractWrapper.read("getAccountsOfSigner", [signer]);
  }
  /**
   * Get all accounts
   *
   * @example
   * ```javascript
   * const allAccounts = await contract.accountFactory.getAllAccounts();
   * ```
   *
   * @returns All accounts created via the account factory.
   *
   * @twfeature AccountFactory
   */
  async getAllAccounts() {
    return await this.contractWrapper.read("getAllAccounts", []);
  }
  /**
   * Check if a account has been deployed for the given admin
   *
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   * @returns whether the account has been deployed for the given admin.
   */
  async isAccountDeployed(admin, extraData) {
    const addr = await this.predictAccountAddress(admin, extraData);
    return isContractDeployed(addr, this.contractWrapper.getProvider());
  }
};
function extractEventsFromAbi(abi, metadata) {
  const parsedAbi = AbiSchema.parse(abi || []);
  const events = parsedAbi.filter((el) => el.type === "event");
  const parsed = [];
  for (const e of events) {
    const doc = extractCommentFromMetadata(e.name, metadata, "events");
    parsed.push({
      inputs: e.inputs || [],
      outputs: e.outputs || [],
      name: e.name || "unknown",
      comment: doc
    });
  }
  return parsed;
}
var ContractPublishedMetadata = class {
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Get the published metadata for this contract
   * @public
   */
  async get() {
    if (this._cachedMetadata) {
      return this._cachedMetadata;
    }
    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
    return this._cachedMetadata;
  }
  /**
   * @public
   */
  async extractSources() {
    const publishedMetadata = await this.get();
    return fetchSourceFilesFromMetadata(publishedMetadata, this.storage);
  }
  /**
   * @public
   */
  async extractFunctions() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
  /**
   * @public
   */
  async extractEvents() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
};
var ExtensionManager = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_DYNAMIC_CONTRACT.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Adds an extension to the contract
     */
    __publicField(this, "add", buildTransactionFunction(async (inputArgs) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "addExtension",
        args: [inputArgs.extension],
        parse: async (receipt) => {
          const events = this.contractWrapper.parseLogs("ExtensionAdded", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ExtensionAdded event found");
          }
          const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
          const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);
          const updatedAbi = joinABIs([AbiSchema.parse(this.contractWrapper.abi), abiToAdd]);
          this.contractWrapper.updateAbi(updatedAbi);
          return receipt;
        }
      });
    }));
    /**
     * Adds a deployed extension to the contract
     */
    __publicField(this, "addDeployed", buildTransactionFunction(async (inputArgs) => {
      let extensionAbi = inputArgs.extensionAbi;
      if (!extensionAbi) {
        const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
        extensionAbi = metadata.abi;
      }
      invariant(extensionAbi, "Require extension ABI");
      let extensionMetadataUri = "";
      if (inputArgs.extensionMetadata) {
        if (typeof inputArgs.extensionMetadata === "string") {
          extensionMetadataUri = inputArgs.extensionMetadata;
        } else {
          const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);
          extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);
        }
      }
      const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));
      const extension = {
        metadata: {
          name: inputArgs.extensionName,
          metadataURI: extensionMetadataUri,
          implementation: inputArgs.extensionAddress
        },
        functions: extensionFunctions
      };
      return this.add.prepare({
        extension,
        extensionAbi
      });
    }));
    /**
     * Adds a published extension to the contract, and deploys it deterministically if necessary
     */
    __publicField(this, "addPublished", buildTransactionFunction(async (inputArgs) => {
      const version = inputArgs.version || "latest";
      const {
        deployedExtensionAddress,
        extensionMetadata
      } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);
      return this.addDeployed.prepare({
        extensionName: inputArgs.extensionName,
        extensionAddress: deployedExtensionAddress,
        extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata
      });
    }));
    __publicField(this, "replace", buildTransactionFunction(async (inputArgs) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "replaceExtension",
        args: [inputArgs.extension],
        parse: async (receipt) => {
          const events = this.contractWrapper.parseLogs("ExtensionReplaced", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ExtensionReplaced event found");
          }
          const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
          const contractAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);
          const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);
          const updatedAbi = joinABIs([contractAbi, abiToAdd]);
          this.contractWrapper.updateAbi(updatedAbi);
          return receipt;
        }
      });
    }));
    __publicField(this, "replaceDeployed", buildTransactionFunction(async (inputArgs) => {
      let extensionAbi = inputArgs.extensionAbi;
      if (!extensionAbi) {
        const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
        extensionAbi = metadata.abi;
      }
      invariant(extensionAbi, "Require extension ABI");
      let extensionMetadataUri = "";
      if (inputArgs.extensionMetadata) {
        if (typeof inputArgs.extensionMetadata === "string") {
          extensionMetadataUri = inputArgs.extensionMetadata;
        } else {
          const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);
          extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);
        }
      }
      const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));
      const extension = {
        metadata: {
          name: inputArgs.extensionName,
          metadataURI: extensionMetadataUri,
          implementation: inputArgs.extensionAddress
        },
        functions: extensionFunctions
      };
      return this.replace.prepare({
        extension,
        extensionAbi
      });
    }));
    __publicField(this, "replacePublished", buildTransactionFunction(async (inputArgs) => {
      const version = inputArgs.version || "latest";
      const {
        deployedExtensionAddress,
        extensionMetadata
      } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);
      return this.replaceDeployed.prepare({
        extensionName: inputArgs.extensionName,
        extensionAddress: deployedExtensionAddress,
        extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata
      });
    }));
    __publicField(this, "remove", buildTransactionFunction(async (inputArgs) => {
      const extensionAddress = await this.getExtensionAddress(inputArgs.extensionName);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "removeExtension",
        args: [inputArgs.extensionName],
        parse: async (receipt) => {
          const events = this.contractWrapper.parseLogs("ExtensionRemoved", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ExtensionRemoved event found");
          }
          const extensionAbi = (await fetchContractMetadataFromAddress(extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
          const updatedAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);
          this.contractWrapper.updateAbi(updatedAbi);
          return receipt;
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  async getAll() {
    const extensions = await this.contractWrapper.readContract.getAllExtensions();
    return extensions;
  }
  async get(extensionName) {
    const extension = await this.contractWrapper.readContract.getExtension(extensionName);
    return extension;
  }
  async getExtensionAddress(extensionName) {
    const extension = await this.get(extensionName);
    return extension.metadata.implementation;
  }
  async getAllFunctions(extensionName) {
    const extension = await this.get(extensionName);
    return extension.functions;
  }
  async getExtensionForFunction(functionInput) {
    let selector = functionInput.functionSelector;
    if (!selector) {
      invariant(functionInput.functionSignature, "Atleast one of function selector and signature must be provided");
      selector = utils_exports.id(functionInput.functionSignature).substring(0, 10);
    }
    const extensionMetadata = await this.contractWrapper.readContract.getMetadataForFunction(selector);
    return extensionMetadata;
  }
  async getExtensionAddressForFunction(functionInput) {
    const extensionMetadata = await this.getExtensionForFunction(functionInput);
    return extensionMetadata.implementation;
  }
  /** ******************************
   * Internal / private
   *******************************/
  filterAbiForAdd(extensionAbi, extension) {
    const extensionAbiInterface = new utils_exports.Interface(extensionAbi);
    const extensionFunctionSelectors = extension.functions.map((fn) => fn.functionSelector);
    const filtered = extensionAbi.filter((item) => {
      const fnFragment = Object.values(new utils_exports.Interface([item]).functions);
      if (fnFragment.length === 0) {
        return false;
      }
      const fnSigHash = extensionAbiInterface.getSighash(fnFragment[0]);
      return extensionFunctionSelectors.includes(fnSigHash);
    });
    return filtered;
  }
  filterAbiForRemove(fullAbi, abiToRemove) {
    const fullAbiInterface = new utils_exports.Interface(fullAbi);
    const interfaceToRemove = new utils_exports.Interface(abiToRemove);
    const functionsToRemove = Object.values(interfaceToRemove.functions).map((fn) => interfaceToRemove.getSighash(fn));
    const filtered = fullAbi.filter((item) => {
      const fnFragment = Object.values(new utils_exports.Interface([item]).functions);
      if (fnFragment.length === 0) {
        return false;
      }
      const fnSigHash = fullAbiInterface.getSighash(fnFragment[0]);
      return !functionsToRemove.includes(fnSigHash);
    });
    return filtered;
  }
  async deployExtension(extensionName, publisherAddress) {
    var _a;
    let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const published = await fetchPublishedContractFromPolygon(publisherAddress, extensionName, version, this.contractWrapper.storage, this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);
    const deploymentInfo = await getDeploymentInfo(published.metadataUri, this.contractWrapper.storage, this.contractWrapper.getProvider(), "", this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);
    const implementationAddress = (_a = deploymentInfo.find((i) => i.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
    const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
    const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
      return i.type !== "infra";
    }).map((i) => i.transaction);
    const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
      return i.type === "infra";
    }).map((i) => i.transaction);
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "Signer is required");
    await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, {});
    for (const tx of transactionsforDirectDeploy) {
      try {
        await deployContractDeterministic(signer, tx);
      } catch (e) {
        console.debug(`Error deploying contract at ${tx.predictedAddress}`, e == null ? void 0 : e.message);
      }
    }
    return {
      deployedExtensionAddress: implementationAddress,
      extensionMetadata: published.metadataUri
    };
  }
};
var Airdrop20 = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_AIRDROP_ERC20.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Perform airdrop of ERC20 tokens
     *
     * @example
     * ```javascript
     * // Airdrop content array, with recipients and token amounts
     * const contents = [
     *      {
     *        recipient: "0xabc...", // first recipient address
     *        amount: "10" // number of tokens in wei units
     *      },
     *      {
     *        recipient: "0x123...", // second recipient address
     *        amount: "20" // number of tokens in wei units
     *      }
     *   ]
     *
     * const tokenAddress = "0x..." // Address of the ERC20 token being airdropped
     * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
     *
     * const output = await contract.airdrop20.drop(tokenAddress, tokenOwner, contents);
     *
     * // the `output` return value above contains:
     * //     - count of successful and failed drops
     * //     - array containing failed drops, if any
     *
     * ```
     * @param tokenAddress - Address of the ERC20 token being airdropped
     * @param tokenOwner - Address of the owner of the tokens being airdropped
     * @param contents - Array of airdrop contents
     *
     * @returns An array of recipients for who the airdrop failed (empty means all transfers were successful)
     * @twfeature AirdropERC20
     */
    __publicField(this, "drop", buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "airdropERC20",
        args: [tokenAddress, tokenOwner, contents],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
          const failedDrops = events.map((e) => {
            return {
              recipient: e.args.recipient,
              amount: e.args.amount.toString()
            };
          });
          return {
            successfulDropCount: contents.length - failedDrops.length,
            failedDropCount: failedDrops.length,
            failedDrops
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
};
var Airdrop721 = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_AIRDROP_ERC721.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Perform airdrop of ERC721 tokens
     *
     * @example
     * ```javascript
     * // Airdrop content array, with recipients and tokenIds
     * const contents = [
     *      {
     *        recipient: "0xabc...", // first recipient address
     *        tokenId: 0
     *      },
     *      {
     *        recipient: "0x123...", // second recipient address
     *        tokenId: 2
     *      }
     *   ]
     *
     * const tokenAddress = "0x..." // Address of the ERC721 token being airdropped
     * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
     *
     * const output = await contract.airdrop721.drop(tokenAddress, tokenOwner, contents);
     *
     * // the `output` return value above contains:
     * //     - count of successful and failed drops
     * //     - array containing failed drops, if any
     *
     * ```
     * @param tokenAddress - Address of the ERC721 token being airdropped
     * @param tokenOwner - Address of the owner of the tokens being airdropped
     * @param contents - Array of recipients and tokenIds to airdrop
     *
     * @returns An array of recipients for who the airdrop failed (empty means all transfers were successful)
     * @twfeature AirdropERC721
     */
    __publicField(this, "drop", buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "airdropERC721",
        args: [tokenAddress, tokenOwner, contents],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
          const failedDrops = events.map((e) => {
            return {
              recipient: e.args.recipient,
              tokenId: e.args.tokenId.toNumber()
            };
          });
          return {
            successfulDropCount: contents.length - failedDrops.length,
            failedDropCount: failedDrops.length,
            failedDrops
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
};
var Airdrop1155 = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_AIRDROP_ERC1155.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Perform airdrop of ERC1155 tokens
     *
     * @example
     * ```javascript
     * // Airdrop content array, with recipients and tokenIds
     * const contents = [
     *      {
     *        recipient: "0xabc...", // first recipient address
     *        tokenId: 0,
     *        amount: "10" // number of tokens
     *      },
     *      {
     *        recipient: "0x123...", // second recipient address
     *        tokenId: 0
     *        amount: "20" // number of tokens
     *      }
     *   ]
     *
     * const tokenAddress = "0x..." // Address of the ERC1155 token being airdropped
     * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
     *
     * const output = await contract.airdrop1155.drop(tokenAddress, tokenOwner, contents);
     *
     * // the `output` return value above contains:
     * //     - count of successful and failed drops
     * //     - array containing failed drops, if any
     *
     * ```
     * @param tokenAddress - Address of the ERC1155 token being airdropped
     * @param tokenOwner - Address of the owner of the tokens being airdropped
     * @param contents - Array of recipients and tokenIds to airdrop
     *
     * @returns An array of recipients for who the airdrop failed (empty means all transfers were successful)
     * @twfeature AirdropERC1155
     */
    __publicField(this, "drop", buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "airdropERC1155",
        args: [tokenAddress, tokenOwner, contents],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
          const failedDrops = events.map((e) => {
            return {
              recipient: e.args.recipient,
              tokenId: e.args.tokenId.toNumber(),
              amount: e.args.amount.toString()
            };
          });
          return {
            successfulDropCount: contents.length - failedDrops.length,
            failedDropCount: failedDrops.length,
            failedDrops
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
};

export {
  getDeploymentInfo,
  estimateGasForDeploy,
  createTransactionBatches,
  deployWithThrowawayDeployer,
  deployContractDeterministic,
  AdminFlag,
  DEFAULT_PERMISSIONS,
  SignerPermissionsSchema,
  PermissionSnapshotSchema,
  SignerPermissionRequestV1,
  SignerPermissionRequest,
  Account,
  AccountFactory,
  extractEventsFromAbi,
  ContractPublishedMetadata,
  ExtensionManager,
  Airdrop20,
  Airdrop721,
  Airdrop1155
};
//# sourceMappingURL=chunk-O7PTIWBQ.js.map
