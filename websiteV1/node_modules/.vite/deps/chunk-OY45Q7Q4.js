import {
  require_nacl_fast
} from "./chunk-3KSX3NCT.js";
import {
  BaseProvider,
  createFetchMiddleware,
  init_baseControllers_esm,
  init_baseProvider_esm,
  providerFromEngine
} from "./chunk-ZUOCL6F5.js";
import {
  Connection,
  Keypair,
  PublicKey,
  init_index_browser_esm
} from "./chunk-XQ5L4VJL.js";
import {
  CHAIN_NAMESPACES,
  JRPCEngine,
  WalletInitializationError,
  _defineProperty,
  createAsyncMiddleware,
  init_base_esm,
  init_defineProperty,
  init_openloginJrpc_esm,
  isHexStrict,
  mergeMiddleware
} from "./chunk-FJCF2OTK.js";
import {
  require_fast_safe_stringify
} from "./chunk-E54CA2HM.js";
import {
  require_safe_buffer
} from "./chunk-FBVATULW.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@web3auth/solana-provider/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/@web3auth/solana-provider/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/@web3auth/solana-provider/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@web3auth/solana-provider/dist/solanaProvider.esm.js
function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "solana_chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "solana_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createConfigMiddleware(providerConfig) {
  const {
    chainId
  } = providerConfig;
  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);
}
function createJsonRpcClient(providerConfig) {
  const {
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = createFetchMiddleware({
    rpcTarget
  });
  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
function createGetAccountsMiddleware(_ref) {
  let {
    getAccounts
  } = _ref;
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "getAccounts")
      return next();
    if (!getAccounts)
      throw new Error("WalletMiddleware - opts.getAccounts not provided");
    const accounts = await getAccounts(request);
    response.result = accounts;
    return void 0;
  });
}
function createRequestAccountsMiddleware(_ref2) {
  let {
    requestAccounts
  } = _ref2;
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "requestAccounts")
      return next();
    if (!requestAccounts)
      throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return void 0;
  });
}
function createGenericJRPCMiddleware(targetMethod, handler) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== targetMethod)
      return next();
    if (!handler)
      throw new Error("WalletMiddleware - ".concat(targetMethod, " not provided"));
    const result = await handler(request);
    response.result = result;
    return void 0;
  });
}
function createSolanaMiddleware(providerHandlers) {
  const {
    getAccounts,
    requestAccounts,
    signTransaction,
    signAndSendTransaction,
    signAllTransactions,
    signMessage,
    getPrivateKey,
    getSecretKey
  } = providerHandlers;
  return mergeMiddleware([createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), createGenericJRPCMiddleware("signTransaction", signTransaction), createGenericJRPCMiddleware("signAndSendTransaction", signAndSendTransaction), createGenericJRPCMiddleware("signAllTransactions", signAllTransactions), createGenericJRPCMiddleware("signMessage", signMessage), createGenericJRPCMiddleware("solanaPrivateKey", getPrivateKey), createGenericJRPCMiddleware("solanaSecretKey", getSecretKey)]);
}
function createChainSwitchMiddleware(_ref3) {
  let {
    addNewChainConfig,
    switchSolanaChain
  } = _ref3;
  return mergeMiddleware([createGenericJRPCMiddleware("addSolanaChain", addNewChainConfig), createGenericJRPCMiddleware("switchSolanaChain", switchSolanaChain)]);
}
function createAccountMiddleware(_ref4) {
  let {
    updatePrivatekey
  } = _ref4;
  return mergeMiddleware([createGenericJRPCMiddleware("updateAccount", updatePrivatekey)]);
}
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function createInjectedProviderProxyMiddleware(provider) {
  return createAsyncMiddleware(async (req, res, _next) => {
    const result = await provider.request(_objectSpread$2({}, req));
    res.result = result;
  });
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
async function getProviderHandlers(_ref) {
  let {
    privKey,
    getProviderEngineProxy
  } = _ref;
  const keyPairGenerator = () => {
    return Keypair.fromSecretKey(Buffer.from(privKey, "hex"));
  };
  if (typeof privKey !== "string")
    throw WalletInitializationError.invalidParams("privKey must be a string");
  const keyPair = keyPairGenerator();
  const providerHandlers = {
    requestAccounts: async () => {
      return [keyPair.publicKey.toBase58()];
    },
    getAccounts: async () => [keyPair.publicKey.toBase58()],
    getPrivateKey: async () => privKey,
    getSecretKey: async () => import_bs58.default.encode(keyPair.secretKey),
    signTransaction: async (req) => {
      var _req$params;
      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {
        throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
      }
      const transaction = req.params.message;
      transaction.partialSign(keyPair);
      return transaction;
    },
    signMessage: async (req) => {
      var _req$params2;
      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {
        throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
      }
      const signedMsg = import_tweetnacl_js.default.sign.detached(req.params.message, keyPair.secretKey);
      return signedMsg;
    },
    signAndSendTransaction: async (req) => {
      var _req$params3;
      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
        throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
      }
      const _providerEngineProxy = getProviderEngineProxy();
      if (!_providerEngineProxy)
        throw import_eth_rpc_errors.ethErrors.provider.custom({
          message: "Provider is not initialized",
          code: 4902
        });
      const transaction = req.params.message;
      transaction.sign(keyPair);
      const sig = await _providerEngineProxy.request({
        method: "sendTransaction",
        params: [import_bs58.default.encode(transaction.serialize())]
      });
      return {
        signature: sig
      };
    },
    signAllTransactions: async (req) => {
      var _req$params4, _req$params5, _req$params6;
      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {
        throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
      }
      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;
      for (const tx of txns || []) {
        const transaction = tx;
        transaction.partialSign(keyPair);
      }
      return txns;
    }
  };
  return providerHandlers;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_bs58, import_eth_rpc_errors, import_tweetnacl_js, BaseInjectedProvider, getBaseProviderHandlers, PhantomInjectedProvider, getSlopeHandlers, SlopeInjectedProxyProvider, getSolflareHandlers, SolflareInjectedProvider, getSolletHandlers, SolletInjectedProvider, getTorusHandlers, TorusInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet;
var init_solanaProvider_esm = __esm({
  "node_modules/@web3auth/solana-provider/dist/solanaProvider.esm.js"() {
    init_defineProperty();
    init_baseControllers_esm();
    init_openloginJrpc_esm();
    init_base_esm();
    init_baseProvider_esm();
    import_bs58 = __toESM(require_bs58());
    import_eth_rpc_errors = __toESM(require_dist());
    init_index_browser_esm();
    import_tweetnacl_js = __toESM(require_nacl_fast());
    BaseInjectedProvider = class extends BaseProvider {
      constructor(_ref) {
        let {
          config,
          state
        } = _ref;
        super({
          config: {
            chainConfig: _objectSpread$3(_objectSpread$3({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.SOLANA
            })
          },
          state
        });
      }
      async switchChain(_) {
        return Promise.resolve();
      }
      async setupProvider(injectedProvider) {
        const engine = new JRPCEngine();
        const providerHandlers = this.getProviderHandlers(injectedProvider);
        const solanaMiddleware = createSolanaMiddleware(providerHandlers);
        engine.push(solanaMiddleware);
        const configMiddleware = createConfigMiddleware(this.config.chainConfig);
        engine.push(configMiddleware);
        const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);
        if (injectedProviderProxy) {
          engine.push(injectedProviderProxy);
        }
        const provider = providerFromEngine(engine);
        this.updateProviderEngineProxy(provider);
        await this.lookupNetwork();
      }
      async lookupNetwork() {
        const {
          chainConfig
        } = this.config;
        this.update({
          chainId: chainConfig.chainId
        });
        return chainConfig.chainId || "";
      }
      getInjectedProviderProxy(_) {
        return void 0;
      }
    };
    getBaseProviderHandlers = (injectedProvider) => {
      const providerHandlers = {
        requestAccounts: async () => {
          return injectedProvider.publicKey ? [import_bs58.default.encode(injectedProvider.publicKey.toBytes())] : [];
        },
        getAccounts: async () => injectedProvider.publicKey ? [import_bs58.default.encode(injectedProvider.publicKey.toBytes())] : [],
        getPrivateKey: async () => {
          throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
        },
        getSecretKey: async () => {
          throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
        },
        signTransaction: async (req) => {
          const transaction = await injectedProvider.signTransaction(req.params.message);
          return transaction;
        },
        signMessage: async (req) => {
          const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);
          return sigData.signature;
        },
        signAllTransactions: async (req) => {
          var _req$params, _req$params2;
          if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {
            throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
          }
          const transaction = await injectedProvider.signAllTransactions(req.params.message);
          return transaction;
        },
        signAndSendTransaction: async (req) => {
          const txRes = await injectedProvider.signAndSendTransaction(req.params.message);
          return {
            signature: txRes.signature
          };
        }
      };
      return providerHandlers;
    };
    PhantomInjectedProvider = class extends BaseInjectedProvider {
      getProviderHandlers(injectedProvider) {
        return getBaseProviderHandlers(injectedProvider);
      }
      getInjectedProviderProxy(injectedProvider) {
        return createInjectedProviderProxyMiddleware(injectedProvider);
      }
    };
    getSlopeHandlers = (injectedProvider, getProviderEngineProxy) => {
      const providerHandlers = {
        requestAccounts: async () => {
          const {
            data
          } = await injectedProvider.connect();
          return [data.publicKey];
        },
        getAccounts: async () => {
          const {
            data
          } = await injectedProvider.connect();
          return [data.publicKey];
        },
        getPrivateKey: async () => {
          throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
        },
        getSecretKey: async () => {
          throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
        },
        signTransaction: async (req) => {
          const txMessage = req.params.message;
          if (!txMessage)
            throw import_eth_rpc_errors.ethErrors.rpc.invalidRequest({
              message: "Invalid transaction message"
            });
          const {
            data
          } = await injectedProvider.signTransaction(import_bs58.default.encode(txMessage.serializeMessage()));
          if (!data.publicKey || !data.signature)
            throw new Error("Invalid signature from slope wallet");
          const publicKey = new PublicKey(data.publicKey);
          const signature = import_bs58.default.decode(data.signature);
          txMessage.addSignature(publicKey, signature);
          return txMessage;
        },
        signMessage: async (req) => {
          const response = await injectedProvider.signMessage(req.params.message);
          return import_bs58.default.decode(response.data.signature);
        },
        signAndSendTransaction: async (req) => {
          const provider = getProviderEngineProxy();
          if (!provider)
            throw import_eth_rpc_errors.ethErrors.provider.custom({
              message: "Provider is not initialized",
              code: 4902
            });
          const txMessage = req.params.message;
          if (!txMessage)
            throw import_eth_rpc_errors.ethErrors.rpc.invalidRequest({
              message: "Invalid transaction message"
            });
          const {
            data
          } = await injectedProvider.signTransaction(import_bs58.default.encode(txMessage.serializeMessage()));
          if (!data.publicKey || !data.signature)
            throw new Error("Invalid signature from slope wallet");
          const publicKey = new PublicKey(data.publicKey);
          const signature = import_bs58.default.decode(data.signature);
          txMessage.addSignature(publicKey, signature);
          const chainConfig = await provider.request({
            method: "solana_provider_config",
            params: []
          });
          const conn = new Connection(chainConfig.rpcTarget);
          const res = await conn.sendRawTransaction(txMessage.serialize());
          return {
            signature: res
          };
        },
        signAllTransactions: async (req) => {
          var _req$params, _req$params2, _data$signatures;
          if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {
            throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
          }
          const allTxns = req.params.message;
          const {
            length
          } = allTxns;
          const unsignedTx = [];
          for (let i = 0; i < length; i++) {
            unsignedTx.push(import_bs58.default.encode(req.params.message[i].serializeMessage()));
          }
          const {
            msg,
            data
          } = await injectedProvider.signAllTransactions(unsignedTx);
          if (!data.publicKey || ((_data$signatures = data.signatures) === null || _data$signatures === void 0 ? void 0 : _data$signatures.length) !== length)
            throw new Error(msg);
          const publicKey = new PublicKey(data.publicKey);
          for (let i = 0; i < length; i++) {
            const signature = import_bs58.default.decode(data.signatures[i]);
            allTxns[i].addSignature(publicKey, signature);
          }
          return allTxns;
        }
      };
      return providerHandlers;
    };
    SlopeInjectedProxyProvider = class extends BaseInjectedProvider {
      getProviderHandlers(injectedProvider) {
        return getSlopeHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));
      }
    };
    getSolflareHandlers = (injectedProvider, getProviderEngineProxy) => {
      const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider);
      solflareProviderHandlers.signAndSendTransaction = async (req) => {
        const provider = getProviderEngineProxy();
        if (!provider)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Provider is not initialized",
            code: 4902
          });
        const transaction = await injectedProvider.signTransaction(req.params.message);
        const chainConfig = await provider.request({
          method: "solana_provider_config",
          params: []
        });
        const conn = new Connection(chainConfig.rpcTarget);
        const res = await conn.sendRawTransaction(transaction.serialize());
        return {
          signature: res
        };
      };
      return solflareProviderHandlers;
    };
    SolflareInjectedProvider = class extends BaseInjectedProvider {
      getProviderHandlers(injectedProvider) {
        return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));
      }
    };
    getSolletHandlers = (injectedProvider, getProviderEngineProxy) => {
      const providerHandlers = getBaseProviderHandlers(injectedProvider);
      providerHandlers.signMessage = async (req) => {
        const {
          signature
        } = await injectedProvider.sign(req.params.message, "utf8");
        return signature;
      };
      providerHandlers.signAndSendTransaction = async (req) => {
        const provider = getProviderEngineProxy();
        if (!provider)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Provider is not initialized",
            code: 4902
          });
        const transaction = await injectedProvider.signTransaction(req.params.message);
        const chainConfig = await provider.request({
          method: "solana_provider_config",
          params: []
        });
        const conn = new Connection(chainConfig.rpcTarget);
        const res = await conn.sendRawTransaction(transaction.serialize());
        return {
          signature: res
        };
      };
      return providerHandlers;
    };
    SolletInjectedProvider = class extends BaseInjectedProvider {
      getProviderHandlers(injectedProvider) {
        return getSolletHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));
      }
    };
    getTorusHandlers = (injectedProvider) => {
      const providerHandlers = {
        requestAccounts: async () => {
          const accounts = await injectedProvider.request({
            method: "solana_requestAccounts",
            params: {}
          });
          return accounts;
        },
        getAccounts: async () => {
          const accounts = await injectedProvider.request({
            method: "solana_requestAccounts",
            params: {}
          });
          return accounts;
        },
        getPrivateKey: async () => {
          throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
        },
        getSecretKey: async () => {
          throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
        },
        signMessage: async (req) => {
          var _req$params;
          if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {
            throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
          }
          const message = await injectedProvider.signMessage(req.params.message);
          return message;
        },
        signTransaction: async (req) => {
          var _req$params2;
          if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {
            throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
          }
          const txMessage = req.params.message;
          const response = await injectedProvider.signTransaction(txMessage);
          return response;
        },
        signAndSendTransaction: async (req) => {
          var _req$params3;
          if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
            throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
          }
          const txMessage = req.params.message;
          const response = await injectedProvider.sendTransaction(txMessage);
          return {
            signature: response
          };
        },
        signAllTransactions: async (req) => {
          var _req$params4, _req$params5;
          if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {
            throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("message");
          }
          const transactions = req.params.message;
          const response = await injectedProvider.signAllTransactions(transactions);
          return response;
        }
      };
      return providerHandlers;
    };
    TorusInjectedProvider = class extends BaseProvider {
      constructor(_ref) {
        let {
          config,
          state
        } = _ref;
        super({
          config: {
            chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.SOLANA
            })
          },
          state
        });
      }
      async switchChain(_) {
        return Promise.resolve();
      }
      async setupProvider(injectedProvider) {
        this.handleInjectedProviderUpdate(injectedProvider);
        await this.setupEngine(injectedProvider);
      }
      async lookupNetwork() {
        if (!this.provider)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Torus solana provider is not initialized",
            code: 4902
          });
        const {
          chainId
        } = this.config.chainConfig;
        const connectedChainId = await this.provider.request({
          method: "solana_chainId"
        });
        const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : "0x".concat(parseInt(connectedChainId, 10).toString(16));
        if (chainId !== connectedHexChainId)
          throw WalletInitializationError.rpcConnectionError("Invalid network, net_version is: ".concat(connectedHexChainId, ", expected: ").concat(chainId));
        this.update({
          chainId: connectedHexChainId
        });
        this.provider.emit("connect", {
          chainId: this.state.chainId
        });
        this.provider.emit("chainChanged", this.state.chainId);
        return this.state.chainId;
      }
      async setupEngine(injectedProvider) {
        const providerHandlers = getTorusHandlers(injectedProvider);
        const solanaMiddleware = createSolanaMiddleware(providerHandlers);
        const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);
        const engine = new JRPCEngine();
        engine.push(solanaMiddleware);
        engine.push(injectedProviderProxy);
        const provider = providerFromEngine(engine);
        this.updateProviderEngineProxy(provider);
        await this.lookupNetwork();
      }
      async handleInjectedProviderUpdate(injectedProvider) {
        injectedProvider.on("accountsChanged", async (accounts) => {
          this.provider.emit("accountsChanged", accounts);
        });
        injectedProvider.on("chainChanged", async (chainId) => {
          const connectedHexChainId = isHexStrict(chainId) ? chainId : "0x".concat(parseInt(chainId, 10).toString(16));
          this.configure({
            chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {
              chainId: connectedHexChainId
            })
          });
          await this.setupProvider(injectedProvider);
        });
      }
    };
    SolanaPrivateKeyProvider = class extends BaseProvider {
      constructor(_ref) {
        let {
          config,
          state
        } = _ref;
        super({
          config: {
            chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.SOLANA
            })
          },
          state
        });
      }
      async enable() {
        if (!this.state.privateKey)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Private key is not found in state, plz pass it in constructor state param",
            code: 4902
          });
        await this.setupProvider(this.state.privateKey);
        return this._providerEngineProxy.request({
          method: "eth_accounts"
        });
      }
      async setupProvider(privKey) {
        const providerHandlers = await getProviderHandlers({
          privKey,
          getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
        });
        const solanaMiddleware = createSolanaMiddleware(providerHandlers);
        const engine = new JRPCEngine();
        const {
          networkMiddleware
        } = createJsonRpcClient(this.config.chainConfig);
        engine.push(this.getChainSwitchMiddleware());
        engine.push(this.getAccountMiddleware());
        engine.push(solanaMiddleware);
        engine.push(networkMiddleware);
        const provider = providerFromEngine(engine);
        this.updateProviderEngineProxy(provider);
        await this.lookupNetwork();
      }
      async updateAccount(params) {
        if (!this._providerEngineProxy)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Provider is not initialized",
            code: 4902
          });
        const existingKey = await this._providerEngineProxy.request({
          method: "solanaPrivateKey"
        });
        if (existingKey !== params.privateKey) {
          await this.setupProvider(params.privateKey);
          this._providerEngineProxy.emit("accountsChanged", {
            accounts: await this._providerEngineProxy.request({
              method: "requestAccounts"
            })
          });
        }
      }
      async switchChain(params) {
        if (!this._providerEngineProxy)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Provider is not initialized",
            code: 4902
          });
        const chainConfig = this.getChainConfig(params.chainId);
        this.update({
          chainId: "loading"
        });
        this.configure({
          chainConfig
        });
        const privKey = await this._providerEngineProxy.request({
          method: "solanaPrivateKey"
        });
        await this.setupProvider(privKey);
      }
      async lookupNetwork() {
        if (!this._providerEngineProxy)
          throw import_eth_rpc_errors.ethErrors.provider.custom({
            message: "Provider is not initialized",
            code: 4902
          });
        const health = await this._providerEngineProxy.request({
          method: "getHealth",
          params: []
        });
        const {
          chainConfig
        } = this.config;
        if (health !== "ok")
          throw WalletInitializationError.rpcConnectionError("Failed to lookup network for following rpc target: ".concat(chainConfig.rpcTarget));
        this.update({
          chainId: chainConfig.chainId
        });
        if (this.state.chainId !== chainConfig.chainId) {
          this.provider.emit("chainChanged", this.state.chainId);
          this.provider.emit("connect", {
            chainId: this.state.chainId
          });
        }
        return this.state.chainId;
      }
      getChainSwitchMiddleware() {
        const chainSwitchHandlers = {
          addNewChainConfig: async (req) => {
            if (!req.params)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing request params");
            const {
              chainId,
              chainName,
              rpcUrls,
              blockExplorerUrls,
              nativeCurrency
            } = req.params;
            if (!chainId)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chainId in chainParams");
            if (!rpcUrls || rpcUrls.length === 0)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");
            if (!nativeCurrency)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");
            this.addChain({
              chainNamespace: CHAIN_NAMESPACES.SOLANA,
              chainId,
              ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "SOL",
              tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Solana",
              displayName: chainName,
              rpcTarget: rpcUrls[0],
              blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || ""
            });
          },
          switchSolanaChain: async (req) => {
            if (!req.params)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing request params");
            if (!req.params.chainId)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chainId");
            await this.switchChain(req.params);
          }
        };
        const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
        return chainSwitchMiddleware;
      }
      getAccountMiddleware() {
        const accountHandlers = {
          updatePrivatekey: async (req) => {
            if (!req.params)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing request params");
            if (!req.params.privateKey)
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing privateKey");
            const {
              privateKey
            } = req.params;
            await this.updateAccount({
              privateKey
            });
          }
        };
        return createAccountMiddleware(accountHandlers);
      }
    };
    _defineProperty(SolanaPrivateKeyProvider, "getProviderInstance", async (params) => {
      const providerFactory = new SolanaPrivateKeyProvider({
        config: {
          chainConfig: params.chainConfig
        }
      });
      await providerFactory.setupProvider(params.privKey);
      return providerFactory;
    });
    SolanaWallet = class {
      constructor(provider) {
        _defineProperty(this, "provider", void 0);
        this.provider = provider;
      }
      async requestAccounts() {
        const accounts = await this.provider.request({
          method: "requestAccounts",
          params: {}
        });
        return accounts;
      }
      async signAndSendTransaction(transaction) {
        const {
          signature
        } = await this.provider.request({
          method: "signAndSendTransaction",
          params: {
            message: transaction
          }
        });
        return {
          signature
        };
      }
      async signTransaction(transaction) {
        const signedTransaction = await this.provider.request({
          method: "signTransaction",
          params: {
            message: transaction
          }
        });
        return signedTransaction;
      }
      async signAllTransactions(transactions) {
        const signedTransactions = await this.provider.request({
          method: "signAllTransactions",
          params: {
            message: transactions
          }
        });
        return signedTransactions;
      }
      async signMessage(data) {
        const response = await this.provider.request({
          method: "signMessage",
          params: {
            message: data
          }
        });
        return response;
      }
      async request(args) {
        const result = await this.provider.request(args);
        return result;
      }
    };
  }
});

export {
  PhantomInjectedProvider,
  SlopeInjectedProxyProvider,
  SolflareInjectedProvider,
  SolletInjectedProvider,
  TorusInjectedProvider,
  SolanaPrivateKeyProvider,
  SolanaWallet,
  init_solanaProvider_esm
};
//# sourceMappingURL=chunk-OY45Q7Q4.js.map
