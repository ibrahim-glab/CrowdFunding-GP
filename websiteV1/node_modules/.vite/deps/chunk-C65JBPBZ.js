import {
  ADAPTER_STATUS,
  BaseAdapter,
  WalletLoginError,
  checkIfTokenIsExpired,
  clearToken,
  getSavedToken,
  init_base_esm,
  saveToken,
  signChallenge,
  verifySignedChallenge
} from "./chunk-W7XRB5CX.js";
import {
  require_bs58
} from "./chunk-AFD3C642.js";
import {
  __esm,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@web3auth/base-solana-adapter/dist/baseSolanaAdapter.esm.js
var import_bs58, BaseSolanaAdapter;
var init_baseSolanaAdapter_esm = __esm({
  "node_modules/@web3auth/base-solana-adapter/dist/baseSolanaAdapter.esm.js"() {
    init_base_esm();
    import_bs58 = __toESM(require_bs58());
    BaseSolanaAdapter = class extends BaseAdapter {
      async authenticateUser() {
        var _this$chainConfig;
        if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId))
          throw WalletLoginError.notConnectedError();
        const {
          chainNamespace,
          chainId
        } = this.chainConfig;
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
        const accounts = await this.provider.request({
          method: "getAccounts"
        });
        if (accounts && accounts.length > 0) {
          const existingToken = getSavedToken(accounts[0], this.name);
          if (existingToken) {
            const isExpired = checkIfTokenIsExpired(existingToken);
            if (!isExpired) {
              return {
                idToken: existingToken
              };
            }
          }
          const payload = {
            domain: window.location.origin,
            uri: window.location.href,
            address: accounts[0],
            chainId: parseInt(chainId, 16),
            version: "1",
            nonce: Math.random().toString(36).slice(2),
            issuedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const challenge = await signChallenge(payload, chainNamespace);
          const encodedMessage = new TextEncoder().encode(challenge);
          const signedMessage = await this.provider.request({
            method: "signMessage",
            params: {
              message: encodedMessage,
              display: "utf8"
            }
          });
          const idToken = await verifySignedChallenge(chainNamespace, import_bs58.default.encode(signedMessage), challenge, this.name, this.sessionTime);
          saveToken(accounts[0], this.name, idToken);
          return {
            idToken
          };
        }
        throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
      }
      async disconnect() {
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.disconnectionError("Not connected with wallet");
        const accounts = await this.provider.request({
          method: "getAccounts"
        });
        if (accounts && accounts.length > 0) {
          clearToken(accounts[0], this.name);
        }
      }
    };
  }
});

export {
  BaseSolanaAdapter,
  init_baseSolanaAdapter_esm
};
//# sourceMappingURL=chunk-C65JBPBZ.js.map
