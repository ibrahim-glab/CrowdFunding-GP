{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/dist/QueryParams-c67b6cd4.browser.esm.js"],
  "sourcesContent": ["import { C as CommonNFTOutput, a as CommonNFTInput } from './setErc20Allowance-0fd3045e.browser.esm.js';\r\nimport { utils, BigNumber, Contract } from 'ethers';\r\nimport 'zod';\r\n\r\n/**\r\n * @internal\r\n */\r\n\r\n/**\r\n * @internal\r\n */\r\nconst InterfaceId_IERC721 = /* @__PURE__ */(() => utils.arrayify(\"0x80ac58cd\"))();\r\n\r\n/**\r\n * @internal\r\n */\r\nconst InterfaceId_IERC1155 = /* @__PURE__ */(() => utils.arrayify(\"0xd9b67a26\"))();\r\n\r\nconst FALLBACK_METADATA = {\r\n  name: \"Failed to load NFT metadata\"\r\n};\r\n\r\n/**\r\n * fetches the token metadata\r\n * @param tokenId - the id (to get it back in the output)\r\n * @param tokenUri - the uri to fetch\r\n * @param storage - which storage to fetch from\r\n *\r\n * @internal\r\n */\r\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\r\n  // check for base64 encoded JSON\r\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\r\n    const base64 = tokenUri.split(\",\")[1];\r\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\r\n    return CommonNFTOutput.parse({\r\n      ...jsonMetadata,\r\n      id: BigNumber.from(tokenId).toString(),\r\n      uri: tokenUri\r\n    });\r\n  }\r\n  // handle dynamic id URIs (2 possible formats)\r\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\r\n  let jsonMetadata;\r\n  try {\r\n    jsonMetadata = await storage.downloadJSON(parsedUri);\r\n  } catch (err) {\r\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\r\n    try {\r\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\r\n    } catch (e) {\r\n      console.warn(`failed to get token metadata: ${JSON.stringify({\r\n        tokenId: tokenId.toString(),\r\n        tokenUri\r\n      })} -- falling back to default metadata`);\r\n      jsonMetadata = FALLBACK_METADATA;\r\n    }\r\n  }\r\n  return CommonNFTOutput.parse({\r\n    ...jsonMetadata,\r\n    id: BigNumber.from(tokenId).toString(),\r\n    uri: tokenUri\r\n  });\r\n}\r\n\r\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\r\n/**\r\n * @internal\r\n * @param contractAddress - the contract address\r\n * @param provider - the provider to use\r\n * @param tokenId - the token id\r\n * @param storage - the storage to use\r\n */\r\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\r\n  let uri;\r\n  const ERC165MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\r\n  const erc165 = new Contract(contractAddress, ERC165MetadataAbi, provider);\r\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\r\n  if (isERC721) {\r\n    const ERC721MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json')).default;\r\n    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider);\r\n    uri = await erc721.tokenURI(tokenId);\r\n  } else if (isERC1155) {\r\n    const ERC1155MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json')).default;\r\n    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider);\r\n    uri = await erc1155.uri(tokenId);\r\n  } else {\r\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\r\n  }\r\n  if (!uri) {\r\n    // no uri found, return fallback metadata\r\n    return CommonNFTOutput.parse({\r\n      ...FALLBACK_METADATA,\r\n      id: BigNumber.from(tokenId).toString(),\r\n      uri: \"\"\r\n    });\r\n  }\r\n  return fetchTokenMetadata(tokenId, uri, storage);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param metadata - the metadata to upload\r\n * @param storage - the storage to use\r\n */\r\nasync function uploadOrExtractURI(metadata, storage) {\r\n  if (typeof metadata === \"string\") {\r\n    return metadata;\r\n  } else {\r\n    return await storage.upload(CommonNFTInput.parse(metadata));\r\n  }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param metadatas - the metadata to upload\r\n * @param storage - the storage to use\r\n * @param startNumber - the number to start the file names at\r\n * @param contractAddress - the contract address\r\n * @param signerAddress - the signer address\r\n * @param options - options\r\n */\r\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\r\n  if (isUriList(metadatas)) {\r\n    return metadatas;\r\n  } else if (isMetadataList(metadatas)) {\r\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\r\n      rewriteFileNames: {\r\n        fileStartNumber: startNumber || 0\r\n      },\r\n      onProgress: options?.onProgress\r\n    });\r\n    return uris;\r\n  } else {\r\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\r\n  }\r\n}\r\nfunction getBaseUriFromBatch(uris) {\r\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\r\n  for (let i = 0; i < uris.length; i++) {\r\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\r\n    if (baseUri !== uri) {\r\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\r\n    }\r\n  }\r\n\r\n  // Ensure that baseUri ends with trailing slash\r\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\r\n}\r\nfunction isUriList(metadatas) {\r\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\r\n}\r\nfunction isMetadataList(metadatas) {\r\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst DEFAULT_QUERY_ALL_COUNT = 100;\r\n\r\n/**\r\n * Pagination Parameters\r\n * @public\r\n */\r\n\r\nexport { DEFAULT_QUERY_ALL_COUNT as D, FALLBACK_METADATA as F, InterfaceId_IERC721 as I, InterfaceId_IERC1155 as a, uploadOrExtractURI as b, fetchTokenMetadataForContract as c, fetchTokenMetadata as f, getBaseUriFromBatch as g, uploadOrExtractURIs as u };\r\n"],
  "mappings": "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",
  "names": ["jsonMetadata"]
}
