import {
  BaseEvmAdapter,
  init_baseEvmAdapter_esm
} from "./chunk-X463XUBI.js";
import {
  require_dist
} from "./chunk-QMXEXLRZ.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  CHAIN_NAMESPACES,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  _defineProperty,
  getChainConfig,
  init_base_esm,
  init_defineProperty,
  log
} from "./chunk-W7XRB5CX.js";
import "./chunk-PUGUP7MZ.js";
import "./chunk-BU2HI77A.js";
import "./chunk-3FPBSCFP.js";
import "./chunk-AQ6RT5SW.js";
import "./chunk-P3UYPI43.js";
import "./chunk-OP3MHZRI.js";
import "./chunk-GPX5XOM5.js";
import "./chunk-UFR7PFM3.js";
import {
  __esm,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@web3auth/metamask-adapter/dist/metamaskAdapter.esm.js
var import_detect_provider, MetamaskAdapter;
var init_metamaskAdapter_esm = __esm({
  "node_modules/@web3auth/metamask-adapter/dist/metamaskAdapter.esm.js"() {
    init_defineProperty();
    import_detect_provider = __toESM(require_dist());
    init_base_esm();
    init_baseEvmAdapter_esm();
    MetamaskAdapter = class extends BaseEvmAdapter {
      constructor() {
        let adapterOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        super();
        _defineProperty(this, "adapterNamespace", ADAPTER_NAMESPACES.EIP155);
        _defineProperty(this, "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
        _defineProperty(this, "type", ADAPTER_CATEGORY.EXTERNAL);
        _defineProperty(this, "name", WALLET_ADAPTERS.METAMASK);
        _defineProperty(this, "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(this, "rehydrated", false);
        _defineProperty(this, "metamaskProvider", null);
        this.chainConfig = adapterOptions.chainConfig || null;
        this.sessionTime = adapterOptions.sessionTime || 86400;
      }
      get provider() {
        if (this.status === ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {
          return this.metamaskProvider;
        }
        return null;
      }
      set provider(_) {
        throw new Error("Not implemented");
      }
      async init(options) {
        super.checkInitializationRequirements();
        this.metamaskProvider = await (0, import_detect_provider.default)({
          mustBeMetaMask: true
        });
        if (!this.metamaskProvider)
          throw WalletInitializationError.notInstalled("Metamask extension is not installed");
        this.status = ADAPTER_STATUS.READY;
        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.METAMASK);
        try {
          log.debug("initializing metamask adapter");
          if (options.autoConnect) {
            this.rehydrated = true;
            await this.connect();
          }
        } catch (error) {
          this.emit(ADAPTER_EVENTS.ERRORED, error);
        }
      }
      setAdapterSettings(options) {
        if (this.status === ADAPTER_STATUS.READY)
          return;
        if (options !== null && options !== void 0 && options.sessionTime) {
          this.sessionTime = options.sessionTime;
        }
      }
      async connect() {
        super.checkConnectionRequirements();
        if (!this.chainConfig)
          this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);
        this.status = ADAPTER_STATUS.CONNECTING;
        this.emit(ADAPTER_EVENTS.CONNECTING, {
          adapter: WALLET_ADAPTERS.METAMASK
        });
        if (!this.metamaskProvider)
          throw WalletLoginError.notConnectedError("Not able to connect with metamask");
        try {
          await this.metamaskProvider.request({
            method: "eth_requestAccounts"
          });
          const {
            chainId
          } = this.metamaskProvider;
          if (chainId !== this.chainConfig.chainId) {
            await this.switchChain(this.chainConfig);
          }
          this.status = ADAPTER_STATUS.CONNECTED;
          if (!this.provider)
            throw WalletLoginError.notConnectedError("Failed to connect with provider");
          this.provider.once("disconnect", () => {
            this.disconnect();
          });
          this.emit(ADAPTER_EVENTS.CONNECTED, {
            adapter: WALLET_ADAPTERS.METAMASK,
            reconnected: this.rehydrated
          });
          return this.provider;
        } catch (error) {
          this.status = ADAPTER_STATUS.READY;
          this.rehydrated = false;
          this.emit(ADAPTER_EVENTS.ERRORED, error);
          throw WalletLoginError.connectionError("Failed to login with metamask wallet");
        }
      }
      async disconnect() {
        var _this$provider;
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          cleanup: false
        };
        await super.disconnect();
        (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.removeAllListeners();
        if (options.cleanup) {
          this.status = ADAPTER_STATUS.NOT_READY;
          this.metamaskProvider = null;
        } else {
          this.status = ADAPTER_STATUS.READY;
        }
        this.rehydrated = false;
        this.emit(ADAPTER_EVENTS.DISCONNECTED);
      }
      async getUserInfo() {
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
        return {};
      }
      async switchChain(chainConfig) {
        if (!this.metamaskProvider)
          throw WalletLoginError.notConnectedError("Not connected with wallet");
        try {
          await this.metamaskProvider.request({
            method: "wallet_switchEthereumChain",
            params: [{
              chainId: chainConfig.chainId
            }]
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            await this.metamaskProvider.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: chainConfig.chainId,
                chainName: chainConfig.displayName,
                rpcUrls: [chainConfig.rpcTarget]
              }]
            });
          } else {
            throw switchError;
          }
        }
      }
    };
  }
});
init_metamaskAdapter_esm();
export {
  MetamaskAdapter
};
//# sourceMappingURL=metamaskAdapter.esm-MOJFORVR.js.map
