{
  "version": 3,
  "sources": ["../../@web3auth/metamask-adapter/src/metamaskAdapter.ts"],
  "sourcesContent": ["import detectEthereumProvider from \"@metamask/detect-provider\";\nimport {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  getChainConfig,\n  log,\n  SafeEventEmitterProvider,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n} from \"@web3auth/base\";\nimport { BaseEvmAdapter } from \"@web3auth/base-evm-adapter\";\n\ninterface EthereumProvider extends SafeEventEmitterProvider {\n  isMetaMask?: boolean;\n  isConnected: () => boolean;\n  chainId: string;\n}\nexport interface MetamaskAdapterOptions {\n  chainConfig?: CustomChainConfig;\n  sessionTime?: number;\n}\n\nclass MetamaskAdapter extends BaseEvmAdapter<void> {\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.EIP155;\n\n  readonly currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.EIP155;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.EXTERNAL;\n\n  readonly name: string = WALLET_ADAPTERS.METAMASK;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  private rehydrated = false;\n\n  private metamaskProvider: EthereumProvider | null = null;\n\n  constructor(adapterOptions: MetamaskAdapterOptions = {}) {\n    super();\n    this.chainConfig = adapterOptions.chainConfig || null;\n    this.sessionTime = adapterOptions.sessionTime || 86400;\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {\n      return this.metamaskProvider as SafeEventEmitterProvider;\n    }\n    return null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions): Promise<void> {\n    super.checkInitializationRequirements();\n    this.metamaskProvider = (await detectEthereumProvider({ mustBeMetaMask: true })) as EthereumProvider;\n    if (!this.metamaskProvider) throw WalletInitializationError.notInstalled(\"Metamask extension is not installed\");\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.METAMASK);\n    try {\n      log.debug(\"initializing metamask adapter\");\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n\n  setAdapterSettings(options: { sessionTime?: number }): void {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    if (options?.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n  }\n\n  async connect(): Promise<SafeEventEmitterProvider | null> {\n    super.checkConnectionRequirements();\n    // set default to mainnet\n    if (!this.chainConfig) this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, { adapter: WALLET_ADAPTERS.METAMASK });\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not able to connect with metamask\");\n    try {\n      await this.metamaskProvider.request({ method: \"eth_requestAccounts\" });\n      const { chainId } = this.metamaskProvider;\n      if (chainId !== (this.chainConfig as CustomChainConfig).chainId) {\n        await this.switchChain(this.chainConfig as CustomChainConfig);\n      }\n      this.status = ADAPTER_STATUS.CONNECTED;\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Failed to connect with provider\");\n      this.provider.once(\"disconnect\", () => {\n        // ready to be connected again\n        this.disconnect();\n      });\n      this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.METAMASK, reconnected: this.rehydrated } as CONNECTED_EVENT_DATA);\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw WalletLoginError.connectionError(\"Failed to login with metamask wallet\");\n    }\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    await super.disconnect();\n    this.provider?.removeAllListeners();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.metamaskProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  private async switchChain(chainConfig: CustomChainConfig): Promise<void> {\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    try {\n      await this.metamaskProvider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{ chainId: chainConfig.chainId }],\n      });\n    } catch (switchError: unknown) {\n      // This error code indicates that the chain has not been added to MetaMask.\n      if ((switchError as { code: number }).code === 4902) {\n        await this.metamaskProvider.request({\n          method: \"wallet_addEthereumChain\",\n          params: [{ chainId: chainConfig.chainId, chainName: chainConfig.displayName, rpcUrls: [chainConfig.rpcTarget] }],\n        });\n      } else {\n        throw switchError;\n      }\n    }\n  }\n}\n\nexport { MetamaskAdapter };\n"],
  "mappings": "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",
  "names": ["MetamaskAdapter", "BaseEvmAdapter", "constructor", "adapterOptions", "ADAPTER_NAMESPACES", "EIP155", "CHAIN_NAMESPACES", "ADAPTER_CATEGORY", "EXTERNAL", "WALLET_ADAPTERS", "METAMASK", "ADAPTER_STATUS", "NOT_READY", "chainConfig", "sessionTime", "provider", "status", "CONNECTED", "metamaskProvider", "_", "Error", "init", "options", "checkInitializationRequirements", "detectEthereumProvider", "mustBeMetaMask", "WalletInitializationError", "notInstalled", "READY", "emit", "ADAPTER_EVENTS", "log", "debug", "autoConnect", "rehydrated", "connect", "error", "ERRORED", "setAdapterSettings", "checkConnectionRequirements", "getChainConfig", "CONNECTING", "adapter", "WalletLoginError", "notConnectedError", "request", "method", "chainId", "switchChain", "once", "disconnect", "reconnected", "connectionError", "cleanup", "removeAllListeners", "DISCONNECTED", "getUserInfo", "params", "switchError", "code", "chainName", "displayName", "rpcUrls", "rpcTarget"]
}
