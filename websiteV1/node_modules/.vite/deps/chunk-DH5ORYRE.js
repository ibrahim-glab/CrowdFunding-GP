import {
  require_bs58
} from "./chunk-ALZVY6XD.js";
import {
  require_utils
} from "./chunk-GGTUGTMY.js";
import {
  init_sha256,
  sha256
} from "./chunk-IPWV37YA.js";
import {
  eventemitter3_default
} from "./chunk-ULMQ5M2J.js";
import {
  Contract,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4CCDGKES.js";
import {
  BigNumber,
  lib_exports19 as lib_exports2,
  lib_exports8 as lib_exports
} from "./chunk-RN5BNASC.js";
import {
  require_bn
} from "./chunk-FQ3VPZMN.js";
import {
  IERC1155Metadata_default
} from "./chunk-4FGL2VA3.js";
import {
  basics_exports,
  concat_exports,
  equals_exports,
  from_string_exports,
  init_basics,
  init_concat,
  init_equals,
  init_from_string,
  init_to_string,
  to_string_exports
} from "./chunk-JPRHTH4L.js";
import {
  IERC20_default
} from "./chunk-T6FU7KQN.js";
import {
  IERC20Metadata_default
} from "./chunk-IFLWFOT6.js";
import {
  IERC721_default
} from "./chunk-KWLF5MZH.js";
import {
  IERC721Metadata_default
} from "./chunk-SHK4Q3CR.js";
import {
  IERC1155_default
} from "./chunk-G5HFVUVZ.js";
import {
  c1220,
  c137,
  c220,
  c80001,
  defaultChains,
  getValidChainRPCs
} from "./chunk-DLXTD4FJ.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@thirdweb-dev/crypto/node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@thirdweb-dev/crypto/node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR2 = "input is invalid type";
      var FINALIZE_ERROR2 = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      } : Array.isArray;
      var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      } : ArrayBuffer.isView;
      var formatMessage2 = function(message) {
        var type = typeof message;
        if (type === "string") {
          return [message, true];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR2);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray(message) && !isView(message)) {
          throw new Error(INPUT_ERROR2);
        }
        return [message, false];
      };
      var empty = function(message) {
        return formatMessage2(message)[0].length === 0;
      };
      var cloneArray = function(array) {
        var newArray = [];
        for (var i2 = 0; i2 < array.length; ++i2) {
          newArray[i2] = array[i2];
        }
        return newArray;
      };
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (empty(n) && empty(s)) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR2);
        }
        var result = formatMessage2(message);
        message = result[0];
        var isString = result[1];
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (isString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var result = formatMessage2(str);
        str = result[0];
        var isString = result[1];
        var bytes = 0, length = str.length;
        if (isString) {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        } else {
          bytes = length;
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = (w - bytes % w) % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            s = cloneArray(s);
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            s = cloneArray(s);
            f(s);
          }
        }
        if (extraBytes) {
          array[j2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            s = cloneArray(s);
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@multiformats/base-x/src/index.js"(exports, module) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode: decode2
      };
    }
    module.exports = base;
  }
});

// node_modules/multibase/src/util.js
var require_util = __commonJS({
  "node_modules/multibase/src/util.js"(exports, module) {
    "use strict";
    var textDecoder = new TextDecoder();
    var decodeText = (bytes) => textDecoder.decode(bytes);
    var textEncoder = new TextEncoder();
    var encodeText = (text) => textEncoder.encode(text);
    function concat(arrs, length) {
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = { decodeText, encodeText, concat };
  }
});

// node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/multibase/src/base.js"(exports, module) {
    "use strict";
    var { encodeText } = require_util();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name, code, factory, alphabet) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`);
          }
        }
        return this.codec.decode(string);
      }
    };
    module.exports = Base;
  }
});

// node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/multibase/src/rfc4648.js"(exports, module) {
    "use strict";
    var decode2 = (string, alphabet, bitsPerChar) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string[i]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc4648 = (bitsPerChar) => (alphabet) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode(input, alphabet, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode2(input, alphabet, bitsPerChar);
        }
      };
    };
    module.exports = { rfc4648 };
  }
});

// node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "node_modules/multibase/src/constants.js"(exports, module) {
    "use strict";
    var baseX = require_src();
    var Base = require_base();
    var { rfc4648 } = require_rfc4648();
    var { decodeText, encodeText } = require_util();
    var identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity, ""],
      ["base2", "0", rfc4648(1), "01"],
      ["base8", "7", rfc4648(3), "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", rfc4648(4), "0123456789abcdef"],
      ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module.exports = {
      names,
      codes
    };
  }
});

// node_modules/multibase/src/index.js
var require_src2 = __commonJS({
  "node_modules/multibase/src/index.js"(exports, module) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat } = require_util();
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);
      return concat([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));
      return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode2(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix2 = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix2)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports = module.exports = multibase;
    exports.encode = encode;
    exports.decode = decode2;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    var names = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports.names = names;
    exports.codes = codes;
  }
});

// node_modules/multihashes/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/multihashes/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/multihashes/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/multihashes/node_modules/varint/decode.js"(exports, module) {
    module.exports = read2;
    var MSB = 128;
    var REST = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/multihashes/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/multihashes/node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/multihashes/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/multihashes/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/multihashes/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/multihashes/src/constants.js"(exports, module) {
    "use strict";
    var names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module.exports = { names };
  }
});

// node_modules/multihashes/src/index.js
var require_src3 = __commonJS({
  "node_modules/multihashes/src/index.js"(exports, module) {
    "use strict";
    var multibase = require_src2();
    var varint = require_varint();
    var { names } = require_constants2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var codes = (
      /** @type {import('./types').CodeNameMap} */
      {}
    );
    for (const key in names) {
      const name = (
        /** @type {HashName} */
        key
      );
      codes[names[name]] = name;
    }
    Object.freeze(codes);
    function toHexString(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash, "base16");
    }
    function fromHexString(hash) {
      return uint8ArrayFromString(hash, "base16");
    }
    function toB58String(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash)).slice(1);
    }
    function fromB58String(hash) {
      const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
      return multibase.decode("z" + encoded);
    }
    function decode2(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code = (
        /** @type {HashCode} */
        varint.decode(bytes)
      );
      if (!isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
      }
      bytes = bytes.slice(varint.decode.bytes);
      const len = varint.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
      };
    }
    function encode(digest, code, length) {
      if (!digest || code === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code);
      if (!(digest instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length == null) {
        length = digest.length;
      }
      if (length && digest.length !== length) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash = varint.encode(hashfn);
      const len = varint.encode(length);
      return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);
    }
    function coerceCode(name) {
      let code = name;
      if (typeof name === "string") {
        if (names[name] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name}`);
        }
        code = names[name];
      }
      if (typeof code !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
      }
      if (codes[code] === void 0 && !isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
      }
      return code;
    }
    function isAppCode(code) {
      return code > 0 && code < 16;
    }
    function isValidCode(code) {
      if (isAppCode(code)) {
        return true;
      }
      if (codes[code]) {
        return true;
      }
      return false;
    }
    function validate(multihash) {
      decode2(multihash);
    }
    function prefix2(multihash) {
      validate(multihash);
      return multihash.subarray(0, 2);
    }
    module.exports = {
      names,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode2,
      encode,
      coerceCode,
      isAppCode,
      validate,
      prefix: prefix2,
      isValidCode
    };
  }
});

// node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "node_modules/varint/decode.js"(exports, module) {
    module.exports = read2;
    var MSB = 128;
    var REST = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/multicodec/src/util.js
var require_util2 = __commonJS({
  "node_modules/multicodec/src/util.js"(exports, module) {
    "use strict";
    var varint = require_varint2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    module.exports = {
      numberToUint8Array,
      uint8ArrayToNumber,
      varintUint8ArrayEncode,
      varintEncode
    };
    function uint8ArrayToNumber(buf) {
      return parseInt(uint8ArrayToString(buf, "base16"), 16);
    }
    function numberToUint8Array(num) {
      let hexString = num.toString(16);
      if (hexString.length % 2 === 1) {
        hexString = "0" + hexString;
      }
      return uint8ArrayFromString(hexString, "base16");
    }
    function varintUint8ArrayEncode(input) {
      return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)));
    }
    function varintEncode(num) {
      return Uint8Array.from(varint.encode(num));
    }
  }
});

// node_modules/multicodec/src/generated-table.js
var require_generated_table = __commonJS({
  "node_modules/multicodec/src/generated-table.js"(exports, module) {
    "use strict";
    var baseTable = Object.freeze({
      "identity": 0,
      "cidv1": 1,
      "cidv2": 2,
      "cidv3": 3,
      "ip4": 4,
      "tcp": 6,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "dccp": 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "ip6": 41,
      "ip6zone": 42,
      "path": 47,
      "multicodec": 48,
      "multihash": 49,
      "multiaddr": 50,
      "multibase": 51,
      "dns": 53,
      "dns4": 54,
      "dns6": 55,
      "dnsaddr": 56,
      "protobuf": 80,
      "cbor": 81,
      "raw": 85,
      "dbl-sha2-256": 86,
      "rlp": 96,
      "bencode": 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      "sctp": 132,
      "dag-jose": 133,
      "dag-cose": 134,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "eth-receipt-log-trie": 153,
      "eth-reciept-log": 154,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "bitcoin-witness-commitment": 178,
      "zcash-block": 192,
      "zcash-tx": 193,
      "caip-50": 202,
      "streamid": 206,
      "stellar-block": 208,
      "stellar-tx": 209,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      "zeronet": 230,
      "secp256k1-pub": 231,
      "bls12_381-g1-pub": 234,
      "bls12_381-g2-pub": 235,
      "x25519-pub": 236,
      "ed25519-pub": 237,
      "bls12_381-g1g2-pub": 238,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      "udp": 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      "udt": 301,
      "utp": 302,
      "unix": 400,
      "thread": 406,
      "p2p": 421,
      "ipfs": 421,
      "https": 443,
      "onion": 444,
      "onion3": 445,
      "garlic64": 446,
      "garlic32": 447,
      "tls": 448,
      "noise": 454,
      "quic": 460,
      "ws": 477,
      "wss": 478,
      "p2p-websocket-star": 479,
      "http": 480,
      "swhid-1-snp": 496,
      "json": 512,
      "messagepack": 513,
      "libp2p-peer-record": 769,
      "libp2p-relay-rsvp": 770,
      "car-index-sorted": 1024,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "p256-pub": 4608,
      "p384-pub": 4609,
      "p521-pub": 4610,
      "ed448-pub": 4611,
      "x448-pub": 4612,
      "ed25519-priv": 4864,
      "secp256k1-priv": 4865,
      "x25519-priv": 4866,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082,
      "zeroxcert-imprint-256": 52753,
      "fil-commitment-unsealed": 61697,
      "fil-commitment-sealed": 61698,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332,
      "skynet-ns": 11639056,
      "arweave-ns": 11704592
    });
    module.exports = { baseTable };
  }
});

// node_modules/multicodec/src/maps.js
var require_maps = __commonJS({
  "node_modules/multicodec/src/maps.js"(exports, module) {
    "use strict";
    var { baseTable } = require_generated_table();
    var varintEncode = require_util2().varintEncode;
    var nameToVarint = (
      /** @type {NameUint8ArrayMap} */
      {}
    );
    var constantToCode = (
      /** @type {ConstantCodeMap} */
      {}
    );
    var codeToName = (
      /** @type {CodeNameMap} */
      {}
    );
    for (const name in baseTable) {
      const codecName = (
        /** @type {CodecName} */
        name
      );
      const code = baseTable[codecName];
      nameToVarint[codecName] = varintEncode(code);
      const constant = (
        /** @type {CodecConstant} */
        codecName.toUpperCase().replace(/-/g, "_")
      );
      constantToCode[constant] = code;
      if (!codeToName[code]) {
        codeToName[code] = codecName;
      }
    }
    Object.freeze(nameToVarint);
    Object.freeze(constantToCode);
    Object.freeze(codeToName);
    var nameToCode = Object.freeze(baseTable);
    module.exports = {
      nameToVarint,
      constantToCode,
      nameToCode,
      codeToName
    };
  }
});

// node_modules/multicodec/src/index.js
var require_src4 = __commonJS({
  "node_modules/multicodec/src/index.js"(exports, module) {
    "use strict";
    var varint = require_varint2();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var util2 = require_util2();
    var { nameToVarint, constantToCode, nameToCode, codeToName } = require_maps();
    function addPrefix(multicodecStrOrCode, data) {
      let prefix2;
      if (multicodecStrOrCode instanceof Uint8Array) {
        prefix2 = util2.varintUint8ArrayEncode(multicodecStrOrCode);
      } else {
        if (nameToVarint[multicodecStrOrCode]) {
          prefix2 = nameToVarint[multicodecStrOrCode];
        } else {
          throw new Error("multicodec not recognized");
        }
      }
      return uint8ArrayConcat([prefix2, data], prefix2.length + data.length);
    }
    function rmPrefix(data) {
      varint.decode(
        /** @type {Buffer} */
        data
      );
      return data.slice(varint.decode.bytes);
    }
    function getNameFromData(prefixedData) {
      const code = (
        /** @type {CodecCode} */
        varint.decode(
          /** @type {Buffer} */
          prefixedData
        )
      );
      const name = codeToName[code];
      if (name === void 0) {
        throw new Error(`Code "${code}" not found`);
      }
      return name;
    }
    function getNameFromCode(codec) {
      return codeToName[codec];
    }
    function getCodeFromName(name) {
      const code = nameToCode[name];
      if (code === void 0) {
        throw new Error(`Codec "${name}" not found`);
      }
      return code;
    }
    function getCodeFromData(prefixedData) {
      return (
        /** @type {CodecCode} */
        varint.decode(
          /** @type {Buffer} */
          prefixedData
        )
      );
    }
    function getVarintFromName(name) {
      const code = nameToVarint[name];
      if (code === void 0) {
        throw new Error(`Codec "${name}" not found`);
      }
      return code;
    }
    function getVarintFromCode(code) {
      return util2.varintEncode(code);
    }
    function getCodec(prefixedData) {
      return getNameFromData(prefixedData);
    }
    function getName(codec) {
      return getNameFromCode(codec);
    }
    function getNumber(name) {
      return getCodeFromName(name);
    }
    function getCode(prefixedData) {
      return getCodeFromData(prefixedData);
    }
    function getCodeVarint(name) {
      return getVarintFromName(name);
    }
    function getVarint(code) {
      return Array.from(getVarintFromCode(code));
    }
    module.exports = {
      addPrefix,
      rmPrefix,
      getNameFromData,
      getNameFromCode,
      getCodeFromName,
      getCodeFromData,
      getVarintFromName,
      getVarintFromCode,
      // Deprecated
      getCodec,
      getName,
      getNumber,
      getCode,
      getCodeVarint,
      getVarint,
      // Make the constants top-level constants
      ...constantToCode,
      // Export the maps
      nameToVarint,
      nameToCode,
      codeToName
    };
  }
});

// node_modules/cids/src/cid-util.js
var require_cid_util = __commonJS({
  "node_modules/cids/src/cid-util.js"(exports, module) {
    "use strict";
    var mh = require_src3();
    var CIDUtil = {
      /**
       * Test if the given input is a valid CID object.
       * Returns an error message if it is not.
       * Returns undefined if it is a valid CID.
       *
       * @param {any} other
       * @returns {string|undefined}
       */
      checkCIDComponents: function(other) {
        if (other == null) {
          return "null values are not valid CIDs";
        }
        if (!(other.version === 0 || other.version === 1)) {
          return "Invalid version, must be a number equal to 1 or 0";
        }
        if (typeof other.codec !== "string") {
          return "codec must be string";
        }
        if (other.version === 0) {
          if (other.codec !== "dag-pb") {
            return "codec must be 'dag-pb' for CIDv0";
          }
          if (other.multibaseName !== "base58btc") {
            return "multibaseName must be 'base58btc' for CIDv0";
          }
        }
        if (!(other.multihash instanceof Uint8Array)) {
          return "multihash must be a Uint8Array";
        }
        try {
          mh.validate(other.multihash);
        } catch (err) {
          let errorMsg = err.message;
          if (!errorMsg) {
            errorMsg = "Multihash validation failed";
          }
          return errorMsg;
        }
      }
    };
    module.exports = CIDUtil;
  }
});

// node_modules/cids/src/index.js
var require_src5 = __commonJS({
  "node_modules/cids/src/index.js"(exports, module) {
    "use strict";
    var mh = require_src3();
    var multibase = require_src2();
    var multicodec = require_src4();
    var CIDUtil = require_cid_util();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var codecs = multicodec.nameToCode;
    var codecInts = (
      /** @type {CodecName[]} */
      Object.keys(codecs).reduce(
        (p, name) => {
          p[codecs[name]] = name;
          return p;
        },
        /** @type {Record<CodecCode, CodecName>} */
        {}
      )
    );
    var symbol = Symbol.for("@ipld/js-cid/CID");
    var CID = class _CID {
      /**
       * Create a new CID.
       *
       * The algorithm for argument input is roughly:
       * ```
       * if (cid)
       *   -> create a copy
       * else if (str)
       *   if (1st char is on multibase table) -> CID String
       *   else -> bs58 encoded multihash
       * else if (Uint8Array)
       *   if (1st byte is 0 or 1) -> CID
       *   else -> multihash
       * else if (Number)
       *   -> construct CID by parts
       * ```
       *
       * @param {CIDVersion | string | Uint8Array | CID} version
       * @param {string|number} [codec]
       * @param {Uint8Array} [multihash]
       * @param {string} [multibaseName]
       *
       * @example
       * new CID(<version>, <codec>, <multihash>, <multibaseName>)
       * new CID(<cidStr>)
       * new CID(<cid.bytes>)
       * new CID(<multihash>)
       * new CID(<bs58 encoded multihash>)
       * new CID(<cid>)
       */
      constructor(version, codec, multihash, multibaseName) {
        this.version;
        this.codec;
        this.multihash;
        Object.defineProperty(this, symbol, { value: true });
        if (_CID.isCID(version)) {
          const cid = (
            /** @type {CID} */
            version
          );
          this.version = cid.version;
          this.codec = cid.codec;
          this.multihash = cid.multihash;
          this.multibaseName = cid.multibaseName || (cid.version === 0 ? "base58btc" : "base32");
          return;
        }
        if (typeof version === "string") {
          const baseName = multibase.isEncoded(version);
          if (baseName) {
            const cid = multibase.decode(version);
            this.version = /** @type {CIDVersion} */
            parseInt(cid[0].toString(), 16);
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = baseName;
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = mh.fromB58String(version);
            this.multibaseName = "base58btc";
          }
          _CID.validateCID(this);
          Object.defineProperty(this, "string", { value: version });
          return;
        }
        if (version instanceof Uint8Array) {
          const v = parseInt(version[0].toString(), 16);
          if (v === 1) {
            const cid = version;
            this.version = v;
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = "base32";
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = version;
            this.multibaseName = "base58btc";
          }
          _CID.validateCID(this);
          return;
        }
        this.version = version;
        if (typeof codec === "number") {
          codec = codecInts[codec];
        }
        this.codec = /** @type {CodecName} */
        codec;
        this.multihash = /** @type {Uint8Array} */
        multihash;
        this.multibaseName = multibaseName || (version === 0 ? "base58btc" : "base32");
        _CID.validateCID(this);
      }
      /**
       * The CID as a `Uint8Array`
       *
       * @returns {Uint8Array}
       *
       */
      get bytes() {
        let bytes = this._bytes;
        if (!bytes) {
          if (this.version === 0) {
            bytes = this.multihash;
          } else if (this.version === 1) {
            const codec = multicodec.getCodeVarint(this.codec);
            bytes = uint8ArrayConcat([
              [1],
              codec,
              this.multihash
            ], 1 + codec.byteLength + this.multihash.byteLength);
          } else {
            throw new Error("unsupported version");
          }
          Object.defineProperty(this, "_bytes", { value: bytes });
        }
        return bytes;
      }
      /**
       * The prefix of the CID.
       *
       * @returns {Uint8Array}
       */
      get prefix() {
        const codec = multicodec.getCodeVarint(this.codec);
        const multihash = mh.prefix(this.multihash);
        const prefix2 = uint8ArrayConcat([
          [this.version],
          codec,
          multihash
        ], 1 + codec.byteLength + multihash.byteLength);
        return prefix2;
      }
      /**
       * The codec of the CID in its number form.
       *
       * @returns {CodecCode}
       */
      get code() {
        return codecs[this.codec];
      }
      /**
       * Convert to a CID of version `0`.
       *
       * @returns {CID}
       */
      toV0() {
        if (this.codec !== "dag-pb") {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        const { name, length } = mh.decode(this.multihash);
        if (name !== "sha2-256") {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        if (length !== 32) {
          throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
        }
        return new _CID(0, this.codec, this.multihash);
      }
      /**
       * Convert to a CID of version `1`.
       *
       * @returns {CID}
       */
      toV1() {
        return new _CID(1, this.codec, this.multihash, this.multibaseName);
      }
      /**
       * Encode the CID into a string.
       *
       * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
       * @returns {string}
       */
      toBaseEncodedString(base = this.multibaseName) {
        if (this.string && this.string.length !== 0 && base === this.multibaseName) {
          return this.string;
        }
        let str;
        if (this.version === 0) {
          if (base !== "base58btc") {
            throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
          }
          str = mh.toB58String(this.multihash);
        } else if (this.version === 1) {
          str = uint8ArrayToString(multibase.encode(base, this.bytes));
        } else {
          throw new Error("unsupported version");
        }
        if (base === this.multibaseName) {
          Object.defineProperty(this, "string", { value: str });
        }
        return str;
      }
      /**
       * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
       *
       * @returns {string}
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      /**
       * Encode the CID into a string.
       *
       * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
       * @returns {string}
       */
      toString(base) {
        return this.toBaseEncodedString(base);
      }
      /**
       * Serialize to a plain object.
       *
       * @returns {SerializedCID}
       */
      toJSON() {
        return {
          codec: this.codec,
          version: this.version,
          hash: this.multihash
        };
      }
      /**
       * Compare equality with another CID.
       *
       * @param {CID} other
       * @returns {boolean}
       */
      equals(other) {
        return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);
      }
      /**
       * Test if the given input is a valid CID object.
       * Throws if it is not.
       *
       * @param {any} other - The other CID.
       * @returns {void}
       */
      static validateCID(other) {
        const errorMsg = CIDUtil.checkCIDComponents(other);
        if (errorMsg) {
          throw new Error(errorMsg);
        }
      }
      /**
       * Check if object is a CID instance
       *
       * @param {any} value
       * @returns {value is CID}
       */
      static isCID(value) {
        return value instanceof _CID || Boolean(value && value[symbol]);
      }
    };
    CID.codecs = codecs;
    module.exports = CID;
  }
});

// node_modules/explain-error/index.js
var require_explain_error = __commonJS({
  "node_modules/explain-error/index.js"(exports, module) {
    function getStack(err) {
      if (err.stack && err.name && err.message)
        return err.stack.substring(err.name.length + 3 + err.message.length).split("\n");
      else if (err.stack)
        return err.stack.split("\n");
    }
    function removePrefix(a, b) {
      return a.filter(function(e) {
        return !~b.indexOf(e);
      });
    }
    var explain = module.exports = function(err, message) {
      if (!(err.stack && err.name && err.message)) {
        console.error(new Error("stackless error"));
        return err;
      }
      var _err = new Error(message);
      var stack = removePrefix(getStack(_err).slice(1), getStack(err)).join("\n");
      _err.__proto__ = err;
      _err.stack = _err.name + ": " + _err.message + "\n" + stack + "\n  " + err.stack;
      return _err;
    };
  }
});

// node_modules/cid-tool/src/core/base32.js
var require_base32 = __commonJS({
  "node_modules/cid-tool/src/core/base32.js"(exports, module) {
    "use strict";
    var CID = require_src5();
    var explain = require_explain_error();
    module.exports = function base32(cid) {
      try {
        cid = new CID(cid);
      } catch (err) {
        throw explain(err, `invalid cid: ${cid}`);
      }
      if (cid.version !== 1) {
        cid = cid.toV1();
      }
      return cid.toBaseEncodedString("base32");
    };
  }
});

// node_modules/cid-tool/src/core/bases.js
var require_bases = __commonJS({
  "node_modules/cid-tool/src/core/bases.js"(exports, module) {
    "use strict";
    var multibase = require_src2();
    module.exports = function bases() {
      const output = [];
      for (const base of Object.values(multibase.names)) {
        output.push({ name: base.name, code: base.code });
      }
      return output;
    };
  }
});

// node_modules/cid-tool/src/core/codecs.js
var require_codecs = __commonJS({
  "node_modules/cid-tool/src/core/codecs.js"(exports, module) {
    "use strict";
    var CID = require_src5();
    module.exports = function codecs() {
      const output = [];
      for (const [key, value] of Object.entries(CID.codecs)) {
        output.push({ name: key, code: value });
      }
      return output;
    };
  }
});

// node_modules/cid-tool/node_modules/uint8arrays/util/bases.js
var require_bases2 = __commonJS({
  "node_modules/cid-tool/node_modules/uint8arrays/util/bases.js"(exports, module) {
    "use strict";
    var { bases } = (init_basics(), __toCommonJS(basics_exports));
    function createCodec(name, prefix2, encode, decode2) {
      return {
        name,
        prefix: prefix2,
        encoder: {
          name,
          prefix: prefix2,
          encode
        },
        decoder: {
          decode: decode2
        }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i = 0; i < buf.length; i++) {
        string2 += String.fromCharCode(buf[i]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    });
    var BASES = {
      "utf8": string,
      "utf-8": string,
      "hex": bases.base16,
      "latin1": ascii,
      "ascii": ascii,
      "binary": ascii,
      ...bases
    };
    module.exports = BASES;
  }
});

// node_modules/cid-tool/node_modules/uint8arrays/to-string.js
var require_to_string = __commonJS({
  "node_modules/cid-tool/node_modules/uint8arrays/to-string.js"(exports, module) {
    "use strict";
    var bases = require_bases2();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.encoder.encode(array).substring(1);
    }
    module.exports = toString;
  }
});

// node_modules/cid-tool/src/core/format.js
var require_format = __commonJS({
  "node_modules/cid-tool/src/core/format.js"(exports, module) {
    "use strict";
    var CID = require_src5();
    var bases = require_bases();
    var codecs = require_codecs();
    var explain = require_explain_error();
    var multibase = require_src2();
    var multihash = require_src3();
    var uint8ArrayToString = require_to_string();
    module.exports = function format(cid, options) {
      options = options || {};
      let formatStr = options.format || "%s";
      if (formatStr === "prefix") {
        formatStr = "%P";
      }
      if (!isString(formatStr) || formatStr.indexOf("%") === -1) {
        throw new Error(`invalid format string: ${formatStr}`);
      }
      const originalCid = cid;
      try {
        cid = new CID(cid);
      } catch (err) {
        throw explain(err, `invalid cid: ${cid}`);
      }
      if (options.cidVersion != null && cid.version !== options.cidVersion) {
        if (options.cidVersion === 0) {
          cid = cid.toV0();
        } else if (options.cidVersion === 1) {
          cid = cid.toV1();
        } else {
          throw new Error(`invalid cid version: ${options.cidVersion}`);
        }
      }
      let base = "base58btc";
      if (options.base) {
        base = findBase(options.base).name;
      } else if (isString(originalCid)) {
        base = multibase.isEncoded(originalCid) || base;
      }
      return formatStr.replace(/%([a-zA-Z%])/g, replacer(cid, base));
    };
    function isString(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    }
    function replacer(cid, base) {
      const replace = (match, specifier) => {
        switch (specifier) {
          case "%":
            return "%";
          case "b":
            return base;
          case "B":
            return findBase(base).code;
          case "v":
            return `cidv${cid.version}`;
          case "V":
            return cid.version.toString();
          case "c":
            return cid.codec;
          case "C":
            return findCodec(cid).toString();
          case "h":
            return multihash.decode(cid.multihash).name;
          case "H":
            return multihash.decode(cid.multihash).code.toString();
          case "L":
            return multihash.decode(cid.multihash).length.toString();
          case "m":
            return uint8ArrayToString(multibase.encode(base, cid.multihash));
          case "M":
            return uint8ArrayToString(cid.multihash, base);
          case "d":
            return uint8ArrayToString(multibase.encode(base, multihash.decode(cid.multihash).digest));
          case "D":
            return uint8ArrayToString(multihash.decode(cid.multihash).digest, base);
          case "s":
            return cid.toString(base);
          case "S":
            return cid.version === 1 ? cid.toString(base).slice(1) : uint8ArrayToString(cid.bytes, base);
          case "P":
            return prefix2(cid);
          default:
            throw new Error(`unrecognized specifier in format string: ${specifier}`);
        }
      };
      return replace;
    }
    function findBase(nameOrCode) {
      const baseNameCode = bases().find((b) => b.code === nameOrCode || b.name === nameOrCode);
      if (!baseNameCode) {
        throw new Error(`invalid multibase: ${nameOrCode}`);
      }
      return baseNameCode;
    }
    function findCodec(cid) {
      const codec = codecs().find((c) => c.name === cid.codec);
      if (!codec) {
        throw new Error(`invalid codec: ${cid.codec}`);
      }
      return codec.code;
    }
    function prefix2(cid) {
      const { name, length } = multihash.decode(cid.multihash);
      return `cidv${cid.version}-${cid.codec}-${name}-${length}`;
    }
  }
});

// node_modules/cid-tool/src/core/hashes.js
var require_hashes = __commonJS({
  "node_modules/cid-tool/src/core/hashes.js"(exports, module) {
    "use strict";
    var multihash = require_src3();
    module.exports = function hashes() {
      const output = [];
      for (const [name, code] of Object.entries(multihash.names)) {
        output.push({ name, code });
      }
      return output;
    };
  }
});

// node_modules/cid-tool/src/core/index.js
var require_core = __commonJS({
  "node_modules/cid-tool/src/core/index.js"(exports) {
    "use strict";
    exports.base32 = require_base32();
    exports.bases = require_bases();
    exports.codecs = require_codecs();
    exports.format = require_format();
    exports.hashes = require_hashes();
  }
});

// node_modules/cid-tool/src/index.js
var require_src6 = __commonJS({
  "node_modules/cid-tool/src/index.js"(exports, module) {
    "use strict";
    module.exports = require_core();
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports, module) {
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@thirdweb-dev/crypto/dist/thirdweb-dev-crypto.esm.js
init_sha256();
var import_js_sha3 = __toESM(require_sha3());
var _encoder, _decoder;
var TextProcessorCache = class {
  constructor() {
    __privateAdd(this, _encoder, void 0);
    __privateAdd(this, _decoder, void 0);
  }
  get encoder() {
    if (!__privateGet(this, _encoder)) {
      __privateSet(this, _encoder, new TextEncoder());
    }
    return __privateGet(this, _encoder);
  }
  get decoder() {
    if (!__privateGet(this, _decoder)) {
      __privateSet(this, _decoder, new TextDecoder());
    }
    return __privateGet(this, _decoder);
  }
};
_encoder = new WeakMap();
_decoder = new WeakMap();
var textProcessorSingleton = new TextProcessorCache();
function getCachedTextEncoder() {
  return textProcessorSingleton.encoder;
}
function getCachedTextDecoder() {
  return textProcessorSingleton.decoder;
}
var INPUT_ERROR = "input is invalid type";
var FINALIZE_ERROR = "finalize already called";
var EXTRA = [128, 32768, 8388608, -2147483648];
function formatMessage(message) {
  const type = typeof message;
  if (typeof message === "string") {
    return [message, true];
  }
  if (type !== "object" || message === null) {
    throw new Error(INPUT_ERROR);
  }
  if (message instanceof ArrayBuffer) {
    return [new Uint8Array(message), false];
  }
  if (!Array.isArray(message) && !ArrayBuffer.isView(message)) {
    throw new Error(INPUT_ERROR);
  }
  return [message, false];
}
var Md5 = class {
  constructor() {
    __publicField(this, "lastByteIndex", 0);
    const buffer = new ArrayBuffer(68);
    this.buffer8 = new Uint8Array(buffer);
    this.blocks = new Uint32Array(buffer);
    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */
  update(inputMessage) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    const [message, isString] = formatMessage(inputMessage);
    const blocks = this.blocks;
    let length = 0;
    if (ArrayBuffer.isView(message)) {
      length = message.byteLength;
    } else {
      length = message.length;
    }
    let code, index = 0, i;
    const buffer8 = this.buffer8;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }
      if (isString) {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 128) {
            buffer8[i++] = code;
          } else if (code < 2048) {
            buffer8[i++] = 192 | code >>> 6;
            buffer8[i++] = 128 | code & 63;
          } else if (code < 55296 || code >= 57344) {
            buffer8[i++] = 224 | code >>> 12;
            buffer8[i++] = 128 | code >>> 6 & 63;
            buffer8[i++] = 128 | code & 63;
          } else {
            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
            buffer8[i++] = 240 | code >>> 18;
            buffer8[i++] = 128 | code >>> 12 & 63;
            buffer8[i++] = 128 | code >>> 6 & 63;
            buffer8[i++] = 128 | code & 63;
          }
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          buffer8[i++] = message[index];
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  }
  finalize() {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    const blocks = this.blocks, i = this.lastByteIndex;
    blocks[i >>> 2] |= EXTRA[i & 3];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.bytes << 3;
    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
    this.hash();
  }
  hash() {
    const blocks = this.blocks;
    let a, b, c, d, bc, da;
    if (this.first) {
      a = blocks[0] - 680876937;
      a = (a << 7 | a >>> 25) - 271733879 << 0;
      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
      d = (d << 12 | d >>> 20) + a << 0;
      c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
      c = (c << 17 | c >>> 15) + d << 0;
      b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
      b = (b << 22 | b >>> 10) + c << 0;
    } else {
      a = this.h0;
      b = this.h1;
      c = this.h2;
      d = this.h3;
      a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
      b = (b << 22 | b >>> 10) + c << 0;
    }
    a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
    b = (b << 20 | b >>> 12) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[5] - 378558;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[8] - 2022574463;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[11] + 1839030562;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[14] - 35309556;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[1] - 1530992060;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[4] + 1272893353;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[7] - 155497632;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[10] - 1094730640;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[13] + 681279174;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[0] - 358537222;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[3] - 722521979;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[6] + 76029189;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[9] - 640364487;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[12] - 421815835;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[15] + 530742520;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[2] - 995338651;
    b = (b << 23 | b >>> 9) + c << 0;
    a += (c ^ (b | ~d)) + blocks[0] - 198630844;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[5] - 57434055;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[10] - 1051523;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[15] - 30611744;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[4] - 145523070;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[2] + 718787259;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[9] - 343485551;
    b = (b << 21 | b >>> 11) + c << 0;
    if (this.first) {
      this.h0 = a + 1732584193 << 0;
      this.h1 = b - 271733879 << 0;
      this.h2 = c - 1732584194 << 0;
      this.h3 = d + 271733878 << 0;
      this.first = false;
    } else {
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
    }
  }
  /**
   * @method arrayBuffer
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.arrayBuffer}
   * @example
   * hash.arrayBuffer();
   */
  arrayBuffer() {
    this.finalize();
    const buffer = new ArrayBuffer(16);
    const blocks = new Uint32Array(buffer);
    blocks[0] = this.h0;
    blocks[1] = this.h1;
    blocks[2] = this.h2;
    blocks[3] = this.h3;
    return buffer;
  }
};
function arrayBuffer(uint8Arr) {
  const md5 = new Md5();
  md5.update(uint8Arr);
  return md5.arrayBuffer();
}
var objectToString = Object.prototype.toString;
var uint8ArrayStringified = "[object Uint8Array]";
function isUint8Array(value) {
  if (!value) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  return objectToString.call(value) === uint8ArrayStringified;
}
function assertUint8Array(value) {
  if (!isUint8Array(value)) {
    throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
  }
}
function concatUint8Arrays(arrays, totalLength) {
  if (arrays.length === 0) {
    return new Uint8Array(0);
  }
  totalLength ?? (totalLength = arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0));
  const returnValue = new Uint8Array(totalLength);
  let offset = 0;
  for (const array of arrays) {
    assertUint8Array(array);
    returnValue.set(array, offset);
    offset += array.length;
  }
  return returnValue;
}
function assertString(value) {
  if (typeof value !== "string") {
    throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
  }
}
function base64ToBase64Url(base64) {
  return base64.replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
}
function base64UrlToBase64(base64url) {
  return base64url.replaceAll("-", "+").replaceAll("_", "/");
}
var MAX_BLOCK_SIZE = 65535;
function uint8ArrayToBase64(array) {
  let {
    urlSafe = false
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  assertUint8Array(array);
  let base64;
  if (array.length < MAX_BLOCK_SIZE) {
    base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));
  } else {
    base64 = "";
    for (const value of array) {
      base64 += String.fromCodePoint(value);
    }
    base64 = globalThis.btoa(base64);
  }
  return urlSafe ? base64ToBase64Url(base64) : base64;
}
function base64ToUint8Array(base64String) {
  assertString(base64String);
  return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), (x) => x.codePointAt(0));
}
var byteToHexLookupTable = Array.from({
  length: 256
}, (_, index) => index.toString(16).padStart(2, "0"));
function uint8ArrayToHex(array) {
  assertUint8Array(array);
  let hexString = "";
  for (let index = 0; index < array.length; index++) {
    hexString += byteToHexLookupTable[array[index]];
  }
  return hexString;
}
async function universalCrypto() {
  if ("crypto" in globalThis) {
    return globalThis.crypto;
  }
  const pto = "pto";
  return (await import("node:cry" + pto)).webcrypto;
}
var HEAD_SIZE_DWORD = 2;
var SALT_SIZE_DWORD = 2;
async function decryptCryptoJSCipherBase64(salt, ciphertext, password) {
  let {
    keySizeDWORD = 256 / 32,
    ivSizeDWORD = 128 / 32,
    iterations = 1
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const crypto = await universalCrypto();
  const {
    key,
    iv
  } = await dangerouslyDeriveParameters(password, salt, keySizeDWORD, ivSizeDWORD, iterations);
  try {
    const plainBuffer = await crypto.subtle.decrypt({
      name: "AES-CBC",
      iv
    }, key, ciphertext);
    return getCachedTextDecoder().decode(plainBuffer);
  } catch (e) {
    throw new Error("Decrypt failed");
  }
}
function parseCryptoJSCipherBase64(cryptoJSCipherBase64) {
  let salt = null;
  let ciphertext = base64ToUint8Array(cryptoJSCipherBase64);
  const [head, body] = splitUint8Array(ciphertext, HEAD_SIZE_DWORD * 4);
  const headDataView = new DataView(head.buffer);
  if (headDataView.getInt32(0) === 1398893684 && headDataView.getInt32(4) === 1701076831) {
    [salt, ciphertext] = splitUint8Array(body, SALT_SIZE_DWORD * 4);
  }
  return {
    ciphertext,
    salt
  };
}
async function dangerouslyDeriveParameters(password, salt, keySizeDWORD, ivSizeDWORD, iterations) {
  const crypto = await universalCrypto();
  const passwordUint8Array = getCachedTextEncoder().encode(password);
  const keyPlusIV = dangerousEVPKDF(passwordUint8Array, salt, keySizeDWORD + ivSizeDWORD, iterations);
  const [rawKey, iv] = splitUint8Array(keyPlusIV, keySizeDWORD * 4);
  const key = await crypto.subtle.importKey("raw", rawKey, "AES-CBC", false, ["decrypt"]);
  return {
    key,
    iv
  };
}
function dangerousEVPKDF(passwordUint8Array, saltUint8Array, keySizeDWORD, iterations) {
  let derivedKey = new Uint8Array();
  let block = new Uint8Array();
  while (derivedKey.byteLength < keySizeDWORD * 4) {
    block = new Uint8Array(arrayBuffer(concatUint8Arrays([block, passwordUint8Array, saltUint8Array])));
    for (let i = 1; i < iterations; i++) {
      block = new Uint8Array(arrayBuffer(block));
    }
    derivedKey = concatUint8Arrays([derivedKey, block]);
  }
  return derivedKey;
}
function splitUint8Array(a, i) {
  return [a.subarray(0, i), a.subarray(i, a.length)];
}
async function aesDecrypt(ciphertext, password) {
  const crypto = await universalCrypto();
  const pwUtf8 = getCachedTextEncoder().encode(password);
  const pwHash = await crypto.subtle.digest("SHA-256", pwUtf8);
  const cipherUint8Array = base64ToUint8Array(ciphertext);
  const iv = cipherUint8Array.slice(0, 12);
  const alg = {
    name: "AES-GCM",
    iv
  };
  const key = await crypto.subtle.importKey("raw", pwHash, alg, false, ["decrypt"]);
  const ctUint8 = cipherUint8Array.slice(12);
  try {
    const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8);
    return getCachedTextDecoder().decode(plainBuffer);
  } catch (e) {
    throw new Error("Decrypt failed");
  }
}
async function aesDecryptCompat(ciphertext, password) {
  const cryptoJs = parseCryptoJSCipherBase64(ciphertext);
  if (cryptoJs.salt && cryptoJs.ciphertext) {
    return decryptCryptoJSCipherBase64(cryptoJs.salt, cryptoJs.ciphertext, password);
  }
  return aesDecrypt(ciphertext, password);
}
async function aesEncrypt(plaintext, password) {
  const crypto = await universalCrypto();
  const textEncoder = getCachedTextEncoder();
  const pwUtf8 = textEncoder.encode(password);
  const pwHash = await crypto.subtle.digest("SHA-256", pwUtf8);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const alg = {
    name: "AES-GCM",
    iv
  };
  const key = await crypto.subtle.importKey("raw", pwHash, alg, false, ["encrypt"]);
  const ptUint8 = textEncoder.encode(plaintext);
  const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUint8);
  return uint8ArrayToBase64(concatUint8Arrays([iv, new Uint8Array(ctBuffer)]));
}
function sha256Sync(value) {
  return sha256(value);
}
function sha256HexSync(value) {
  return uint8ArrayToHex(sha256Sync(value));
}

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json
var IBurnableERC20_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burnFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop.json
var IDrop_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json
var IDropERC20_V2_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json
var IDropSinglePhase_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json
var IDropSinglePhase_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json
var IERC20Permit_default = [
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json
var IMintableERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMulticall.json
var IMulticall_default = [
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json
var ISignatureMintERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json
var IBurnableERC721_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json
var IClaimableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json
var IDelayedReveal_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json
var IDropERC721_V3_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "NFTRevealed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json
var IERC721Enumerable_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenOfOwnerByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json
var IERC721AQueryableUpgradeable_default = [
  {
    inputs: [],
    name: "ApprovalCallerNotOwnerNorApproved",
    type: "error"
  },
  {
    inputs: [],
    name: "ApprovalQueryForNonexistentToken",
    type: "error"
  },
  {
    inputs: [],
    name: "BalanceQueryForZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidQueryRange",
    type: "error"
  },
  {
    inputs: [],
    name: "MintERC2309QuantityExceedsLimit",
    type: "error"
  },
  {
    inputs: [],
    name: "MintToZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "MintZeroQuantity",
    type: "error"
  },
  {
    inputs: [],
    name: "OwnerQueryForNonexistentToken",
    type: "error"
  },
  {
    inputs: [],
    name: "OwnershipNotInitializedForExtraData",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferCallerNotOwnerNorApproved",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferFromIncorrectOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferToNonERC721ReceiverImplementer",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferToZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "URIQueryForNonexistentToken",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fromTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "toTokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "ConsecutiveTransfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "explicitOwnershipOf",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "addr",
            type: "address"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "bool",
            name: "burned",
            type: "bool"
          },
          {
            internalType: "uint24",
            name: "extraData",
            type: "uint24"
          }
        ],
        internalType: "struct IERC721AUpgradeable.TokenOwnership",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "tokensOfOwner",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "start",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "stop",
        type: "uint256"
      }
    ],
    name: "tokensOfOwnerIn",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json
var IERC721Supply_default = [
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json
var ILazyMint_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "extraData",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json
var IMintableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json
var ISignatureMintERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json
var ISignatureMintERC721_V1_default = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json
var LazyMintWithTier_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "tier",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [],
    name: "getBaseURICount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "getBatchIdAtIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMetadataForAllTiers",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "tier",
            type: "string"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "startIdInclusive",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endIdNonInclusive",
                type: "uint256"
              }
            ],
            internalType: "struct LazyMintWithTier_V1.TokenRange[]",
            name: "ranges",
            type: "tuple[]"
          },
          {
            internalType: "string[]",
            name: "baseURIs",
            type: "string[]"
          }
        ],
        internalType: "struct LazyMintWithTier_V1.TierMetadata[]",
        name: "metadataForAllTiers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_baseURIForTokens",
        type: "string"
      },
      {
        internalType: "string",
        name: "_tier",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json
var SharedMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_fromTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_toTokenId",
        type: "uint256"
      }
    ],
    name: "BatchMetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "MetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "description",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "imageURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "animationURI",
        type: "string"
      }
    ],
    name: "SharedMetadataUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          },
          {
            internalType: "string",
            name: "imageURI",
            type: "string"
          },
          {
            internalType: "string",
            name: "animationURI",
            type: "string"
          }
        ],
        internalType: "struct ISharedMetadata.SharedMetadataInfo",
        name: "_metadata",
        type: "tuple"
      }
    ],
    name: "setSharedMetadata",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "sharedMetadata",
    outputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "description",
        type: "string"
      },
      {
        internalType: "string",
        name: "imageURI",
        type: "string"
      },
      {
        internalType: "string",
        name: "animationURI",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json
var zora_IERC721Drop_default = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "Access_MissingRoleOrAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Access_OnlyAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Access_WithdrawNotAllowed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "proposedAddress",
        type: "address"
      }
    ],
    name: "Admin_InvalidUpgradeAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "Admin_UnableToFinalizeNotOpenEdition",
    type: "error"
  },
  {
    inputs: [],
    name: "ExternalMetadataRenderer_CallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMintSchedule",
    type: "error"
  },
  {
    inputs: [],
    name: "MarketFilterDAOAddressNotSupportedForChain",
    type: "error"
  },
  {
    inputs: [],
    name: "MintFee_FundsSendFailure",
    type: "error"
  },
  {
    inputs: [],
    name: "Mint_SoldOut",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "OperatorNotAllowed",
    type: "error"
  },
  {
    inputs: [],
    name: "Presale_Inactive",
    type: "error"
  },
  {
    inputs: [],
    name: "Presale_MerkleNotApproved",
    type: "error"
  },
  {
    inputs: [],
    name: "Presale_TooManyForAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "Purchase_TooManyForAddress",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "correctPrice",
        type: "uint256"
      }
    ],
    name: "Purchase_WrongPrice",
    type: "error"
  },
  {
    inputs: [],
    name: "RemoteOperatorFilterRegistryCallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "Sale_Inactive",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "maxRoyaltyBPS",
        type: "uint16"
      }
    ],
    name: "Setup_RoyaltyPercentageTooHigh",
    type: "error"
  },
  {
    inputs: [],
    name: "Withdraw_FundsSendFailure",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "changedBy",
        type: "address"
      }
    ],
    name: "FundsRecipientChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "withdrawnBy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "withdrawnTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeAmount",
        type: "uint256"
      }
    ],
    name: "FundsWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenContract",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "comment",
        type: "string"
      }
    ],
    name: "MintComment",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "mintFeeAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "mintFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    name: "MintFeePayout",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "numberOfMints",
        type: "uint256"
      }
    ],
    name: "OpenMintFinalized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "firstPurchasedTokenId",
        type: "uint256"
      }
    ],
    name: "Sale",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "changedBy",
        type: "address"
      }
    ],
    name: "SalesConfigChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "contract IMetadataRenderer",
        name: "renderer",
        type: "address"
      }
    ],
    name: "UpdatedMetadataRenderer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      }
    ],
    name: "adminMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "to",
        type: "address[]"
      }
    ],
    name: "adminMintAirdrop",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "isAdmin",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "minter",
        type: "address"
      }
    ],
    name: "mintedPerAddress",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "totalMints",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "presaleMints",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "publicMints",
            type: "uint256"
          }
        ],
        internalType: "struct IERC721Drop.AddressMintDetails",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      }
    ],
    name: "purchase",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxQuantity",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "merkleProof",
        type: "bytes32[]"
      }
    ],
    name: "purchasePresale",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "saleDetails",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "publicSaleActive",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "presaleActive",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "publicSalePrice",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "publicSaleStart",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "publicSaleEnd",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "presaleStart",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "presaleEnd",
            type: "uint64"
          },
          {
            internalType: "bytes32",
            name: "presaleMerkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxSalePurchasePerAddress",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalMinted",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxSupply",
            type: "uint256"
          }
        ],
        internalType: "struct IERC721Drop.SaleDetails",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IMetadataRenderer",
        name: "newRenderer",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "setupRenderer",
        type: "bytes"
      }
    ],
    name: "setMetadataRenderer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint104",
        name: "publicSalePrice",
        type: "uint104"
      },
      {
        internalType: "uint32",
        name: "maxSalePurchasePerAddress",
        type: "uint32"
      },
      {
        internalType: "uint64",
        name: "publicSaleStart",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "publicSaleEnd",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "presaleStart",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "presaleEnd",
        type: "uint64"
      },
      {
        internalType: "bytes32",
        name: "presaleMerkleRoot",
        type: "bytes32"
      }
    ],
    name: "setSaleConfiguration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json
var ILoyaltyCard_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "cancel",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "revoke",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json
var INFTMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_fromTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_toTokenId",
        type: "uint256"
      }
    ],
    name: "BatchMetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "MetadataFrozen",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "MetadataUpdate",
    type: "event"
  },
  {
    inputs: [],
    name: "freezeMetadata",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setTokenURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json
var IBurnableERC1155_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "burnBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json
var IClaimableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json
var IDrop1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json
var IDropERC1155_V2_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "saleRecipient",
        type: "address"
      }
    ],
    name: "SaleRecipientForTokenUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      }
    ],
    name: "lazyMint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json
var IDropSinglePhase1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json
var IDropSinglePhase1155_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase1155_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json
var IERC1155Supply_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json
var IERC1155Enumerable_default = [
  {
    inputs: [],
    name: "nextTokenIdToMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json
var IMintableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json
var ISignatureMintERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json
var IERC2771Context_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAppURI.json
var IAppURI_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "AppURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "appURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setAppURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json
var IContractMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json
var IDirectListings_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "buyer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "BuyerApprovedForListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      }
    ],
    name: "CancelledListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      }
    ],
    name: "CurrencyApprovedForListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        indexed: false,
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    name: "NewListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "buyer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityBought",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPricePaid",
        type: "uint256"
      }
    ],
    name: "NewSale",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        indexed: false,
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    name: "UpdatedListing",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_buyer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveBuyerForListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_pricePerTokenInCurrency",
        type: "uint256"
      }
    ],
    name: "approveCurrencyForListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_buyFor",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_expectedTotalPrice",
        type: "uint256"
      }
    ],
    name: "buyFromListing",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      }
    ],
    name: "cancelListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.ListingParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "createListing",
    outputs: [
      {
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllListings",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.Listing[]",
        name: "listings",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidListings",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.Listing[]",
        name: "listings",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      }
    ],
    name: "getListing",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalListings",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.ListingParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "updateListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json
var IEnglishAuctions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "closer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "winningBidder",
        type: "address"
      }
    ],
    name: "AuctionClosed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      }
    ],
    name: "CancelledAuction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    name: "NewAuction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "bidder",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "bidAmount",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    name: "NewBid",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_bidAmount",
        type: "uint256"
      }
    ],
    name: "bidInAuction",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "cancelAuction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "collectAuctionPayout",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "collectAuctionTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          }
        ],
        internalType: "struct IEnglishAuctions.AuctionParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "createAuction",
    outputs: [
      {
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllAuctions",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction[]",
        name: "auctions",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidAuctions",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction[]",
        name: "auctions",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "getAuction",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "getWinningBid",
    outputs: [
      {
        internalType: "address",
        name: "bidder",
        type: "address"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bidAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "isAuctionExpired",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_bidAmount",
        type: "uint256"
      }
    ],
    name: "isNewWinningBid",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IOffers.json
var IOffers_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityBought",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPricePaid",
        type: "uint256"
      }
    ],
    name: "AcceptedOffer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      }
    ],
    name: "CancelledOffer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IOffers.Offer",
        name: "offer",
        type: "tuple"
      }
    ],
    name: "NewOffer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "acceptOffer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "cancelOffer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllOffers",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer[]",
        name: "offers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidOffers",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer[]",
        name: "offers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "getOffer",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer",
        name: "offer",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          }
        ],
        internalType: "struct IOffers.OfferParams",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "makeOffer",
    outputs: [
      {
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json
var IPackVRFDirect_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPacksCreated",
        type: "uint256"
      }
    ],
    name: "PackCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "opener",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToOpen",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    name: "PackOpenRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "opener",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "numOfPacksOpened",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        indexed: false,
        internalType: "struct ITokenBundle.Token[]",
        name: "rewardUnitsDistributed",
        type: "tuple[]"
      }
    ],
    name: "PackOpened",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    name: "PackRandomnessFulfilled",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_opener",
        type: "address"
      }
    ],
    name: "canClaimRewards",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "claimRewards",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        internalType: "struct ITokenBundle.Token[]",
        name: "rewardUnits",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        internalType: "struct ITokenBundle.Token[]",
        name: "contents",
        type: "tuple[]"
      },
      {
        internalType: "uint256[]",
        name: "numOfRewardUnits",
        type: "uint256[]"
      },
      {
        internalType: "string",
        name: "packUri",
        type: "string"
      },
      {
        internalType: "uint128",
        name: "openStartTimestamp",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "amountDistributedPerOpen",
        type: "uint128"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "createPack",
    outputs: [
      {
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "packTotalSupply",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountToOpen",
        type: "uint256"
      }
    ],
    name: "openPack",
    outputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_amountToOpen",
        type: "uint256"
      },
      {
        internalType: "uint32",
        name: "_callBackGasLimit",
        type: "uint32"
      }
    ],
    name: "openPackAndClaimRewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissions.json
var IPermissions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json
var IPermissionsEnumerable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json
var IPlatformFee_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "flatFee",
        type: "uint256"
      }
    ],
    name: "FlatPlatformFeeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "platformFeeBps",
        type: "uint256"
      }
    ],
    name: "PlatformFeeInfoUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "enum IPlatformFee.PlatformFeeType",
        name: "feeType",
        type: "uint8"
      }
    ],
    name: "PlatformFeeTypeUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getPlatformFeeInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_platformFeeRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_platformFeeBps",
        type: "uint256"
      }
    ],
    name: "setPlatformFeeInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json
var IPrimarySale_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "PrimarySaleRecipientUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "primarySaleRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_saleRecipient",
        type: "address"
      }
    ],
    name: "setPrimarySaleRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json
var IRoyalty_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRoyaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRoyaltyBps",
        type: "uint256"
      }
    ],
    name: "DefaultRoyalty",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "royaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "royaltyBps",
        type: "uint256"
      }
    ],
    name: "RoyaltyForToken",
    type: "event"
  },
  {
    inputs: [],
    name: "getDefaultRoyaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getRoyaltyInfoForToken",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salePrice",
        type: "uint256"
      }
    ],
    name: "royaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "royaltyAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_royaltyRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_royaltyBps",
        type: "uint256"
      }
    ],
    name: "setDefaultRoyaltyInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bps",
        type: "uint256"
      }
    ],
    name: "setRoyaltyInfoForToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/Ownable.json
var Ownable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "prevOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnerUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newOwner",
        type: "address"
      }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json
var IAirdropERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "AirdropFailed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IAirdropERC20.AirdropContent[]",
        name: "contents",
        type: "tuple[]"
      }
    ],
    name: "airdropERC20",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json
var IAirdropERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "AirdropFailed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        internalType: "struct IAirdropERC721.AirdropContent[]",
        name: "contents",
        type: "tuple[]"
      }
    ],
    name: "airdropERC721",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json
var IAirdropERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "AirdropFailed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IAirdropERC1155.AirdropContent[]",
        name: "contents",
        type: "tuple[]"
      }
    ],
    name: "airdropERC1155",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json
var IAccountFactoryCore_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "accountAdmin",
        type: "address"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerRemoved",
    type: "event"
  },
  {
    inputs: [],
    name: "accountImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "createAccount",
    outputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "getAccountsOfSigner",
    outputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "adminSigner",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "getAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllAccounts",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json
var IAccountPermissions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isAdmin",
        type: "bool"
      }
    ],
    name: "AdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizingSigner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "targetSigner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "uint8",
            name: "isAdmin",
            type: "uint8"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct IAccountPermissions.SignerPermissionRequest",
        name: "permissions",
        type: "tuple"
      }
    ],
    name: "SignerPermissionsUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getAllActiveSigners",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissions[]",
        name: "signers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllAdmins",
    outputs: [
      {
        internalType: "address[]",
        name: "admins",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllSigners",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissions[]",
        name: "signers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "getPermissionsForSigner",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissions",
        name: "permissions",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "isActiveSigner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "isAdmin",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "uint8",
            name: "isAdmin",
            type: "uint8"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissionRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "setPermissionsForSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "uint8",
            name: "isAdmin",
            type: "uint8"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissionRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verifySignerPermissionRequest",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json
var IAccountPermissions_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isAdmin",
        type: "bool"
      }
    ],
    name: "AdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizingSigner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "targetSigner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct IAccountPermissions_V1.SignerPermissionRequest",
        name: "permissions",
        type: "tuple"
      }
    ],
    name: "SignerPermissionsUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getAllActiveSigners",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions_V1.SignerPermissions[]",
        name: "signers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllAdmins",
    outputs: [
      {
        internalType: "address[]",
        name: "admins",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllSigners",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions_V1.SignerPermissions[]",
        name: "signers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "getPermissionsForSigner",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions_V1.SignerPermissions",
        name: "permissions",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "isActiveSigner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "isAdmin",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "bool",
        name: "isAdmin",
        type: "bool"
      }
    ],
    name: "setAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct IAccountPermissions_V1.SignerPermissionRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "setPermissionsForSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct IAccountPermissions_V1.SignerPermissionRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verifySignerPermissionRequest",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccount.json
var IAccount_default = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "missingAccountFunds",
        type: "uint256"
      }
    ],
    name: "validateUserOp",
    outputs: [
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js
var import_cid_tool = __toESM(require_src6());
var import_form_data = __toESM(require_browser());
function getProcessEnv(key) {
  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (typeof process !== "undefined") {
    if (process.env[key]) {
      return process.env[key];
    }
  }
  return defaultValue;
}
var TW_HOSTNAME_SUFFIX = ".ipfscdn.io";
var TW_STAGINGHOSTNAME_SUFFIX = ".thirdwebstorage-staging.com";
var TW_GATEWAY_URLS = [`https://{clientId}${TW_HOSTNAME_SUFFIX}/ipfs/{cid}/{path}`];
function isTwGatewayUrl(url) {
  const hostname = new URL(url).hostname;
  const isProd = hostname.endsWith(TW_HOSTNAME_SUFFIX);
  if (isProd) {
    return true;
  }
  return hostname.endsWith(TW_STAGINGHOSTNAME_SUFFIX);
}
var PUBLIC_GATEWAY_URLS = ["https://{cid}.ipfs.cf-ipfs.com/{path}", "https://{cid}.ipfs.dweb.link/{path}", "https://ipfs.io/ipfs/{cid}/{path}", "https://cloudflare-ipfs.com/ipfs/{cid}/{path}", "https://{cid}.ipfs.w3s.link/{path}", "https://w3s.link/ipfs/{cid}/{path}", "https://nftstorage.link/ipfs/{cid}/{path}", "https://gateway.pinata.cloud/ipfs/{cid}/{path}"];
var DEFAULT_GATEWAY_URLS = {
  // Note: Gateway URLs should have trailing slashes (we clean this on user input)
  "ipfs://": [...TW_GATEWAY_URLS, ...PUBLIC_GATEWAY_URLS]
};
var TW_UPLOAD_SERVER_URL = getProcessEnv("CUSTOM_UPLOAD_SERVER_URL", "https://storage.thirdweb.com");
function parseGatewayUrls(gatewayUrls) {
  if (Array.isArray(gatewayUrls)) {
    return {
      "ipfs://": gatewayUrls
    };
  }
  return gatewayUrls || {};
}
function getGatewayUrlForCid(gatewayUrl, cid, clientId) {
  const parts = cid.split("/");
  const hash = convertCidToV1(parts[0]);
  const filePath = parts.slice(1).join("/");
  let url = gatewayUrl;
  if (gatewayUrl.includes("{cid}") && gatewayUrl.includes("{path}")) {
    url = url.replace("{cid}", hash).replace("{path}", filePath);
  } else if (gatewayUrl.includes("{cid}")) {
    url = url.replace("{cid}", hash);
  } else {
    url += `${hash}/${filePath}`;
  }
  if (gatewayUrl.includes("{clientId}")) {
    if (!clientId) {
      throw new Error("Cannot use {clientId} in gateway URL without providing a client ID");
    }
    url = url.replace("{clientId}", clientId);
  }
  return url;
}
function prepareGatewayUrls(gatewayUrls, clientId, secretKey) {
  const allGatewayUrls = {
    ...DEFAULT_GATEWAY_URLS,
    ...gatewayUrls
  };
  for (const key of Object.keys(allGatewayUrls)) {
    const cleanedGatewayUrls = allGatewayUrls[key].map((url) => {
      if (clientId && url.includes("{clientId}")) {
        return url.replace("{clientId}", clientId);
      } else if (secretKey && url.includes("{clientId}")) {
        if (typeof window !== "undefined") {
          throw new Error("Cannot use secretKey in browser context");
        }
        const hashedSecretKey = sha256HexSync(secretKey);
        const derivedClientId = hashedSecretKey.slice(0, 32);
        return url.replace("{clientId}", derivedClientId);
      } else if (url.includes("{clientId}")) {
        return void 0;
      } else {
        return url;
      }
    }).filter((url) => url !== void 0);
    allGatewayUrls[key] = cleanedGatewayUrls;
  }
  return allGatewayUrls;
}
function convertCidToV1(cid) {
  let normalized = "";
  try {
    const hash = cid.split("/")[0];
    normalized = import_cid_tool.default.base32(hash);
  } catch (e) {
    throw new Error(`The CID ${cid} is not valid.`);
  }
  return normalized;
}
function isBrowser() {
  return typeof window !== "undefined";
}
function isFileInstance(data) {
  return global.File && data instanceof File;
}
function isBufferInstance(data) {
  return global.Buffer && data instanceof Buffer;
}
function isBufferOrStringWithName(data) {
  return !!(data && data.name && data.data && typeof data.name === "string" && (typeof data.data === "string" || isBufferInstance(data.data)));
}
function isFileOrBuffer(data) {
  return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);
}
function isFileBufferOrStringEqual(input1, input2) {
  if (isFileInstance(input1) && isFileInstance(input2)) {
    if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {
      return true;
    }
  } else if (isBufferInstance(input1) && isBufferInstance(input2)) {
    return input1.equals(input2);
  } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {
    if (input1.name === input2.name) {
      if (typeof input1.data === "string" && typeof input2.data === "string") {
        return input1.data === input2.data;
      } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {
        return input1.data.equals(input2.data);
      }
    }
  }
  return false;
}
function parseCidAndPath(gatewayUrl, uri) {
  var _a, _b;
  const regexString = gatewayUrl.replace("{cid}", "(?<hash>[^/]+)").replace("{path}", "(?<path>[^?#]+)");
  const regex = new RegExp(regexString);
  const match = uri.match(regex);
  if (match) {
    const hash = (_a = match.groups) == null ? void 0 : _a.hash;
    const path = (_b = match.groups) == null ? void 0 : _b.path;
    const queryString = uri.includes("?") ? uri.substring(uri.indexOf("?") + 1) : "";
    return {
      hash,
      path,
      query: queryString
    };
  }
}
function replaceGatewayUrlWithScheme(uri, gatewayUrls) {
  for (const scheme of Object.keys(gatewayUrls)) {
    for (const gatewayUrl of gatewayUrls[scheme]) {
      if (gatewayUrl.includes("{cid}")) {
        const parsed = parseCidAndPath(gatewayUrl, uri);
        if ((parsed == null ? void 0 : parsed.hash) && (parsed == null ? void 0 : parsed.path)) {
          const queryString = (parsed == null ? void 0 : parsed.query) ? `?${parsed == null ? void 0 : parsed.query}` : "";
          return `${scheme}${parsed == null ? void 0 : parsed.hash}/${parsed == null ? void 0 : parsed.path}${queryString}`;
        } else {
          return uri;
        }
      } else if (uri.startsWith(gatewayUrl)) {
        return uri.replace(gatewayUrl, scheme);
      }
    }
  }
  return uri;
}
function replaceSchemeWithGatewayUrl(uri, gatewayUrls) {
  let index = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let clientId = arguments.length > 3 ? arguments[3] : void 0;
  const scheme = Object.keys(gatewayUrls).find((s) => uri.startsWith(s));
  const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];
  if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {
    return void 0;
  }
  if (!scheme) {
    return uri;
  }
  const path = uri.replace(scheme, "");
  try {
    const gatewayUrl = getGatewayUrlForCid(schemeGatewayUrls[index], path, clientId);
    return gatewayUrl;
  } catch (err) {
    console.warn(`The IPFS uri: ${path} is not valid.`);
    return void 0;
  }
}
function replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {
  if (typeof data === "string") {
    return replaceGatewayUrlWithScheme(data, gatewayUrls);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));
    }
    return Object.fromEntries(Object.entries(data).map((_ref) => {
      let [key, value] = _ref;
      return [key, replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)];
    }));
  }
  return data;
}
function replaceObjectSchemesWithGatewayUrls(data, gatewayUrls, clientId) {
  if (typeof data === "string") {
    return replaceSchemeWithGatewayUrl(data, gatewayUrls, 0, clientId);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls, clientId));
    }
    return Object.fromEntries(Object.entries(data).map((_ref2) => {
      let [key, value] = _ref2;
      return [key, replaceObjectSchemesWithGatewayUrls(value, gatewayUrls, clientId)];
    }));
  }
  return data;
}
function extractObjectFiles(data) {
  let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (isFileOrBuffer(data)) {
    files.push(data);
    return files;
  }
  if (typeof data === "object") {
    if (!data) {
      return files;
    }
    if (Array.isArray(data)) {
      data.forEach((entry) => extractObjectFiles(entry, files));
    } else {
      Object.keys(data).map((key) => extractObjectFiles(data[key], files));
    }
  }
  return files;
}
function replaceObjectFilesWithUris(data, uris) {
  if (isFileOrBuffer(data)) {
    if (uris.length) {
      data = uris.shift();
      return data;
    } else {
      console.warn("Not enough URIs to replace all files in object.");
    }
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectFilesWithUris(entry, uris));
    } else {
      return Object.fromEntries(Object.entries(data).map((_ref3) => {
        let [key, value] = _ref3;
        return [key, replaceObjectFilesWithUris(value, uris)];
      }));
    }
  }
  return data;
}
var pkg = {
  name: "@thirdweb-dev/storage",
  version: "2.0.9",
  main: "dist/thirdweb-dev-storage.cjs.js",
  module: "dist/thirdweb-dev-storage.esm.js",
  exports: {
    ".": {
      module: "./dist/thirdweb-dev-storage.esm.js",
      "default": "./dist/thirdweb-dev-storage.cjs.js"
    },
    "./package.json": "./package.json"
  },
  repository: "https://github.com/thirdweb-dev/js/tree/main/packages/storage",
  author: "thirdweb eng <eng@thirdweb.com>",
  license: "Apache-2.0",
  sideEffects: false,
  scripts: {
    format: "prettier --write 'src/**/*'",
    lint: "eslint src/ && bunx publint --strict --level warning",
    fix: "eslint src/ --fix",
    clean: "rm -rf dist/",
    build: "tsc && preconstruct build",
    "test:all": "NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000 --parallel './test/**/*.test.ts'",
    test: "pnpm test:all",
    "test:single": "NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000",
    push: "yalc push",
    typedoc: "node scripts/typedoc.mjs"
  },
  files: [
    "dist/"
  ],
  preconstruct: {
    exports: true
  },
  devDependencies: {
    "@babel/preset-env": "^7.23.8",
    "@babel/preset-typescript": "^7.23.3",
    "@microsoft/api-documenter": "^7.22.30",
    "@microsoft/api-extractor": "^7.36.3",
    "@microsoft/tsdoc": "^0.14.1",
    "@preconstruct/cli": "2.7.0",
    "@swc-node/register": "^1.6.8",
    "@thirdweb-dev/tsconfig": "workspace:*",
    "@types/chai": "^4.3.5",
    "@types/mocha": "^10.0.0",
    "@types/uuid": "^9.0.5",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.19.1",
    chai: "^4.3.6",
    eslint: "^8.56.0",
    "eslint-config-thirdweb": "workspace:*",
    "eslint-plugin-tsdoc": "^0.2.16",
    esm: "^3.2.25",
    mocha: "^10.2.0",
    rimraf: "^3.0.2",
    "typedoc-gen": "workspace:*",
    typescript: "^5.3.3"
  },
  dependencies: {
    "@thirdweb-dev/crypto": "workspace:*",
    "cid-tool": "^3.0.0",
    "form-data": "^4.0.0",
    uuid: "^9.0.1"
  },
  engines: {
    node: ">=18"
  }
};
var operatingSystemRules = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function detectOS(ua) {
  for (let ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    const result = operatingSystemRules[ii];
    if (!result) {
      continue;
    }
    const [os, regex] = result;
    const match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getOperatingSystem() {
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return "";
  } else if (typeof window !== "undefined") {
    const userAgent = navigator.userAgent;
    return detectOS(userAgent) || "";
  } else {
    return process.platform;
  }
}
function setAnalyticsHeaders(headers) {
  const globals = getAnalyticsGlobals();
  headers["x-sdk-version"] = globals.x_sdk_version;
  headers["x-sdk-name"] = globals.x_sdk_name;
  headers["x-sdk-platform"] = globals.x_sdk_platform;
  headers["x-sdk-os"] = globals.x_sdk_os;
}
function setAnalyticsHeadersForXhr(xhr) {
  const globals = getAnalyticsGlobals();
  xhr.setRequestHeader("x-sdk-version", globals.x_sdk_version);
  xhr.setRequestHeader("x-sdk-os", globals.x_sdk_os);
  xhr.setRequestHeader("x-sdk-name", globals.x_sdk_name);
  xhr.setRequestHeader("x-sdk-platform", globals.x_sdk_platform);
  xhr.setRequestHeader("x-bundle-id", globals.app_bundle_id);
}
function getAnalyticsGlobals() {
  if (typeof globalThis === "undefined") {
    return {
      x_sdk_name: pkg.name,
      x_sdk_platform: getPlatform(),
      x_sdk_version: pkg.version,
      x_sdk_os: getOperatingSystem(),
      app_bundle_id: void 0
    };
  }
  if (globalThis.X_SDK_NAME === void 0) {
    globalThis.X_SDK_NAME = pkg.name;
    globalThis.X_SDK_PLATFORM = getPlatform();
    globalThis.X_SDK_VERSION = pkg.version;
    globalThis.X_SDK_OS = getOperatingSystem();
    globalThis.APP_BUNDLE_ID = void 0;
  }
  return {
    x_sdk_name: globalThis.X_SDK_NAME,
    x_sdk_platform: globalThis.X_SDK_PLATFORM,
    x_sdk_version: globalThis.X_SDK_VERSION,
    x_sdk_os: globalThis.X_SDK_OS,
    app_bundle_id: globalThis.APP_BUNDLE_ID || ""
    // if react, this will be empty
  };
}
function getPlatform() {
  return typeof navigator !== "undefined" && navigator.product === "ReactNative" ? "mobile" : typeof window !== "undefined" ? "browser" : "node";
}
var StorageDownloader = class {
  constructor(options) {
    __publicField(this, "DEFAULT_TIMEOUT_IN_SECONDS", 60);
    __publicField(this, "DEFAULT_MAX_RETRIES", 3);
    this.secretKey = options.secretKey;
    this.clientId = options.clientId;
    this.defaultTimeout = options.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS;
  }
  async download(uri, gatewayUrls, options) {
    let attempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const maxRetries = (options == null ? void 0 : options.maxRetries) || this.DEFAULT_MAX_RETRIES;
    if (attempts > maxRetries) {
      console.error("[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.");
      return new Response(JSON.stringify({
        error: "Not Found"
      }), {
        status: 404,
        headers: {
          "Content-Type": "application/json"
        }
      });
    }
    let resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts, this.clientId);
    if (!resolvedUri) {
      console.error("[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.");
      return new Response(JSON.stringify({
        error: "Not Found"
      }), {
        status: 404,
        headers: {
          "Content-Type": "application/json"
        }
      });
    } else if (attempts > 0) {
      console.warn(`Retrying download with backup gateway URL: ${resolvedUri}`);
    }
    let headers = {};
    if (isTwGatewayUrl(resolvedUri)) {
      const bundleId = getAnalyticsGlobals().app_bundle_id;
      if (this.secretKey) {
        headers = {
          "x-secret-key": this.secretKey
        };
      } else if (this.clientId) {
        if (!resolvedUri.includes("bundleId")) {
          resolvedUri = resolvedUri + (bundleId ? `?bundleId=${bundleId}` : "");
        }
        headers["x-client-Id"] = this.clientId;
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers = {
          ...headers,
          authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`
        };
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers = {
          ...headers,
          authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`
        };
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
    }
    if (isTooManyRequests(resolvedUri)) {
      return this.download(uri, gatewayUrls, options, attempts + 1);
    }
    const controller = new AbortController();
    const timeoutInSeconds = (options == null ? void 0 : options.timeoutInSeconds) || this.defaultTimeout;
    const timeout = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);
    const resOrErr = await fetch(resolvedUri, {
      headers,
      signal: controller.signal
    }).catch((err) => err);
    if (timeout) {
      clearTimeout(timeout);
    }
    if (!("status" in resOrErr)) {
      throw new Error(`Request timed out after ${timeoutInSeconds} seconds. ${isTwGatewayUrl(resolvedUri) ? "You can update the timeoutInSeconds option to increase the timeout." : "You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway."}`);
    }
    if (resOrErr.ok) {
      return resOrErr;
    }
    if (resOrErr.status === 429) {
      tooManyRequestsBackOff(resolvedUri, resOrErr);
      return this.download(uri, gatewayUrls, options, attempts + 1);
    }
    if (resOrErr.status === 410) {
      console.error(`Request to ${resolvedUri} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${resolvedUri} `);
      return resOrErr;
    }
    console.warn(`Request to ${resolvedUri} failed with status ${resOrErr.status} - ${resOrErr.statusText}`);
    if (resOrErr.status === 404 && isTwGatewayUrl(resolvedUri)) {
      return resOrErr;
    }
    if (resOrErr.status !== 408 && resOrErr.status !== 429 && resOrErr.status < 500) {
      return resOrErr;
    }
    return this.download(uri, gatewayUrls, options, attempts + 1);
  }
};
var TOO_MANY_REQUESTS_TRACKER = /* @__PURE__ */ new Map();
function isTooManyRequests(gatewayUrl) {
  return TOO_MANY_REQUESTS_TRACKER.has(gatewayUrl);
}
var TIMEOUT_MAP = /* @__PURE__ */ new Map();
function tooManyRequestsBackOff(gatewayUrl, response) {
  if (TIMEOUT_MAP.has(gatewayUrl)) {
    clearTimeout(TIMEOUT_MAP.get(gatewayUrl));
  }
  const retryAfter = response.headers.get("Retry-After");
  let backOff = 5e3;
  if (retryAfter) {
    const retryAfterSeconds = parseInt(retryAfter);
    if (!isNaN(retryAfterSeconds)) {
      backOff = retryAfterSeconds * 1e3;
    }
  }
  TOO_MANY_REQUESTS_TRACKER.set(gatewayUrl, true);
  TIMEOUT_MAP.set(gatewayUrl, setTimeout(() => TOO_MANY_REQUESTS_TRACKER.delete(gatewayUrl), backOff));
}
var IpfsUploader = class {
  constructor(options) {
    this.uploadWithGatewayUrl = (options == null ? void 0 : options.uploadWithGatewayUrl) || false;
    this.uploadServerUrl = (options == null ? void 0 : options.uploadServerUrl) || TW_UPLOAD_SERVER_URL;
    this.clientId = options == null ? void 0 : options.clientId;
    this.secretKey = options == null ? void 0 : options.secretKey;
  }
  async uploadBatch(data, options) {
    if ((options == null ? void 0 : options.uploadWithoutDirectory) && data.length > 1) {
      throw new Error("[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!");
    }
    const formData = new import_form_data.default();
    const {
      form,
      fileNames
    } = this.buildFormData(formData, data, options);
    if (isBrowser()) {
      return this.uploadBatchBrowser(form, fileNames, options);
    } else {
      return this.uploadBatchNode(form, fileNames, options);
    }
  }
  buildFormData(form, files, options) {
    const fileNameToFileMap = /* @__PURE__ */ new Map();
    const fileNames = [];
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      let fileName = "";
      let fileData = file;
      if (isFileInstance(file)) {
        if (options == null ? void 0 : options.rewriteFileNames) {
          let extensions = "";
          if (file.name) {
            const extensionStartIndex = file.name.lastIndexOf(".");
            if (extensionStartIndex > -1) {
              extensions = file.name.substring(extensionStartIndex);
            }
          }
          fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;
        } else {
          fileName = `${file.name}`;
        }
      } else if (isBufferOrStringWithName(file)) {
        fileData = file.data;
        if (options == null ? void 0 : options.rewriteFileNames) {
          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${file.name}`;
        }
      } else {
        if (options == null ? void 0 : options.rewriteFileNames) {
          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${i}`;
        }
      }
      const filepath = (options == null ? void 0 : options.uploadWithoutDirectory) ? `files` : `files/${fileName}`;
      if (fileNameToFileMap.has(fileName)) {
        if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {
          fileNames.push(fileName);
          continue;
        }
        throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
      }
      fileNameToFileMap.set(fileName, file);
      fileNames.push(fileName);
      if (!isBrowser()) {
        form.append("file", fileData, {
          filepath
        });
      } else {
        form.append("file", new Blob([fileData]), filepath);
      }
    }
    const metadata = {
      name: `Storage SDK`,
      keyvalues: {
        ...options == null ? void 0 : options.metadata
      }
    };
    form.append("pinataMetadata", JSON.stringify(metadata));
    if (options == null ? void 0 : options.uploadWithoutDirectory) {
      form.append("pinataOptions", JSON.stringify({
        wrapWithDirectory: false
      }));
    }
    return {
      form,
      // encode the file names on the way out (which is what the upload backend expects)
      fileNames: fileNames.map((fName) => encodeURIComponent(fName))
    };
  }
  async uploadBatchBrowser(form, fileNames, options) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      let timer = setTimeout(() => {
        xhr.abort();
        reject(new Error("Request to upload timed out! No upload progress received in 30s"));
      }, 3e4);
      xhr.upload.addEventListener("loadstart", () => {
        console.log(`[${Date.now()}] [IPFS] Started`);
      });
      xhr.upload.addEventListener("progress", (event) => {
        console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);
        clearTimeout(timer);
        if (event.loaded < event.total) {
          timer = setTimeout(() => {
            xhr.abort();
            reject(new Error("Request to upload timed out! No upload progress received in 30s"));
          }, 3e4);
        } else {
          console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);
        }
        if (event.lengthComputable && (options == null ? void 0 : options.onProgress)) {
          options == null ? void 0 : options.onProgress({
            progress: event.loaded,
            total: event.total
          });
        }
      });
      xhr.addEventListener("load", () => {
        console.log(`[${Date.now()}] [IPFS] Load`);
        clearTimeout(timer);
        if (xhr.status >= 200 && xhr.status < 300) {
          let body;
          try {
            body = JSON.parse(xhr.responseText);
          } catch (err) {
            return reject(new Error("Failed to parse JSON from upload response"));
          }
          const cid = body.IpfsHash;
          if (!cid) {
            throw new Error("Failed to get IPFS hash from upload response");
          }
          if (options == null ? void 0 : options.uploadWithoutDirectory) {
            return resolve([`ipfs://${cid}`]);
          } else {
            return resolve(fileNames.map((n) => `ipfs://${cid}/${n}`));
          }
        }
        return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));
      });
      xhr.addEventListener("error", () => {
        console.log("[IPFS] Load");
        clearTimeout(timer);
        if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {
          return reject(new Error("Upload failed due to a network error."));
        }
        return reject(new Error("Unknown upload error occured"));
      });
      xhr.open("POST", `${this.uploadServerUrl}/ipfs/upload`);
      if (this.secretKey) {
        xhr.setRequestHeader("x-secret-key", this.secretKey);
      } else if (this.clientId) {
        xhr.setRequestHeader("x-client-id", this.clientId);
      }
      setAnalyticsHeadersForXhr(xhr);
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        xhr.setRequestHeader("authorization", `Bearer ${globalThis.TW_AUTH_TOKEN}`);
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        xhr.setRequestHeader("authorization", `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`);
        xhr.setRequestHeader("x-authorize-wallet", `true`);
      }
      xhr.send(form);
    });
  }
  async uploadBatchNode(form, fileNames, options) {
    if (options == null ? void 0 : options.onProgress) {
      console.warn("The onProgress option is only supported in the browser");
    }
    const headers = {};
    if (this.secretKey) {
      headers["x-secret-key"] = this.secretKey;
    } else if (this.clientId) {
      headers["x-client-id"] = this.clientId;
    }
    if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
      headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
    }
    if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
      headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
      headers["x-authorize-wallet"] = "true";
    }
    setAnalyticsHeaders(headers);
    const res = await fetch(`${this.uploadServerUrl}/ipfs/upload`, {
      method: "POST",
      headers: {
        ...headers,
        ...form.getHeaders()
      },
      body: form.getBuffer()
    });
    if (!res.ok) {
      if (res.status === 401) {
        throw new Error("Unauthorized - You don't have permission to use this service.");
      }
      throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText} - ${await res.text()}`);
    }
    const body = await res.json();
    const cid = body.IpfsHash;
    if (!cid) {
      throw new Error("Failed to upload files to IPFS - Bad CID");
    }
    if (options == null ? void 0 : options.uploadWithoutDirectory) {
      return [`ipfs://${cid}`];
    } else {
      return fileNames.map((name) => `ipfs://${cid}/${name}`);
    }
  }
};
var ThirdwebStorage = class {
  constructor(options) {
    this.uploader = (options == null ? void 0 : options.uploader) || new IpfsUploader({
      clientId: options == null ? void 0 : options.clientId,
      secretKey: options == null ? void 0 : options.secretKey,
      uploadServerUrl: options == null ? void 0 : options.uploadServerUrl
    });
    this.downloader = (options == null ? void 0 : options.downloader) || new StorageDownloader({
      secretKey: options == null ? void 0 : options.secretKey,
      clientId: options == null ? void 0 : options.clientId
    });
    this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options == null ? void 0 : options.gatewayUrls), options == null ? void 0 : options.clientId, options == null ? void 0 : options.secretKey);
    this.clientId = options == null ? void 0 : options.clientId;
  }
  /**
   * Resolve any scheme on a URL to get a retrievable URL for the data
   *
   * @param url - The URL to resolve the scheme of
   * @returns The URL with its scheme resolved
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const url = storage.resolveScheme(uri);
   * console.log(url);
   * ```
   */
  resolveScheme(url) {
    return replaceSchemeWithGatewayUrl(url, this.gatewayUrls, 0, this.clientId);
  }
  /**
   * Downloads arbitrary data from any URL scheme.
   *
   * @param url - The URL of the data to download
   * @returns The response object fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const data = await storage.download(uri);
   * ```
   */
  async download(url, options) {
    return this.downloader.download(url, this.gatewayUrls, options);
  }
  /**
   * Downloads JSON data from any URL scheme.
   * Resolves any URLs with schemes to retrievable gateway URLs.
   *
   * @param url - The URL of the JSON data to download
   * @returns The JSON data fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const json = await storage.downloadJSON(uri);
   * ```
   */
  async downloadJSON(url, options) {
    const res = await this.download(url, options);
    const json = await res.json();
    return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls, this.clientId);
  }
  /**
   * Upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns  The URI of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload file data
   * const file = readFileSync("../file.jpg");
   * const fileUri = await storage.upload(file);
   *
   * // Or upload a JSON object
   * const json = { name: "JSON", image: file };
   * const jsonUri = await storage.upload(json);
   * ```
   */
  async upload(data, options) {
    const [uri] = await this.uploadBatch([data], options);
    return uri;
  }
  /**
   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Array of arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns  The URIs of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload an array of file data
   * const files = [
   *  readFileSync("../file1.jpg"),
   *  readFileSync("../file2.jpg"),
   * ];
   * const fileUris = await storage.uploadBatch(files);
   *
   * // Upload an array of JSON objects
   * const objects = [
   *  { name: "JSON 1", image: files[0] },
   *  { name: "JSON 2", image: files[1] },
   * ];
   * const jsonUris = await storage.uploadBatch(objects);
   * ```
   */
  async uploadBatch(data, options) {
    data = data.filter((item) => item !== void 0);
    if (!data.length) {
      return [];
    }
    const isFileArray = data.map((item) => isFileOrBuffer(item) || typeof item === "string").every((item) => !!item);
    let uris = [];
    if (isFileArray) {
      uris = await this.uploader.uploadBatch(data, options);
    } else {
      const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      });
      uris = await this.uploader.uploadBatch(metadata, options);
    }
    if ((options == null ? void 0 : options.uploadWithGatewayUrl) || this.uploader.uploadWithGatewayUrl) {
      return uris.map((uri) => this.resolveScheme(uri));
    } else {
      return uris;
    }
  }
  getGatewayUrls() {
    return this.gatewayUrls;
  }
  async uploadAndReplaceFilesWithHashes(data, options) {
    let cleaned = data;
    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);
    const files = extractObjectFiles(cleaned);
    if (files.length) {
      const uris = await this.uploader.uploadBatch(files, options);
      cleaned = replaceObjectFilesWithUris(cleaned, uris);
    }
    if ((options == null ? void 0 : options.uploadWithGatewayUrl) || this.uploader.uploadWithGatewayUrl) {
      cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls, this.clientId);
    }
    return cleaned;
  }
};

// node_modules/@thirdweb-dev/sdk/dist/index-e7118e8b.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_utils = __toESM(require_utils());
function getProcessEnv2(key) {
  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (typeof process !== "undefined") {
    if (process.env[key]) {
      return process.env[key];
    }
  }
  return defaultValue;
}
var ContractPublisher_address = "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808";
function getContractPublisherAddress() {
  return getProcessEnv2("contractPublisherAddress", ContractPublisher_address);
}
function isSigner(value) {
  return !!(value && value._isSigner);
}
function isProvider(value) {
  return !!(value && value._isProvider);
}
var DEFAULT_BATCH_TIME_LIMIT_MS = 10;
var DEFAULT_BATCH_SIZE_LIMIT = 200;
var DEFAULT_BATCH_OPTIONS = {
  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,
  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT
};
var StaticJsonRpcBatchProvider = class extends lib_exports2.StaticJsonRpcProvider {
  constructor(url, network) {
    let batchOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_BATCH_OPTIONS;
    super(url, network);
    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_TIME_LIMIT_MS;
    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_SIZE_LIMIT;
    this._pendingBatchAggregator = null;
    this._pendingBatch = null;
  }
  sendCurrentBatch(request) {
    if (this._pendingBatchAggregator) {
      clearTimeout(this._pendingBatchAggregator);
    }
    const batch = this._pendingBatch || [];
    this._pendingBatch = null;
    this._pendingBatchAggregator = null;
    const request_ = batch.map((inflight) => inflight.request);
    this.emit("debug", {
      action: "requestBatch",
      request: utils_exports.deepCopy(request),
      provider: this
    });
    return utils_exports.fetchJson(this.connection, JSON.stringify(request_)).then((result) => {
      this.emit("debug", {
        action: "response",
        request: request_,
        response: result,
        provider: this
      });
      batch.forEach((inflightRequest_, index) => {
        const payload = result[index];
        if (payload) {
          if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            inflightRequest_.reject(error);
          } else {
            inflightRequest_.resolve(payload.result);
          }
        } else {
          inflightRequest_.reject(new Error("No response for request"));
        }
      });
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request_,
        provider: this
      });
      batch.forEach((inflightRequest_) => {
        inflightRequest_.reject(error);
      });
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch === null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (this._pendingBatch.length === this._sizeLimit) {
      this.sendCurrentBatch(request);
    }
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        this.sendCurrentBatch(request);
      }, this._timeLimitMs);
    }
    return promise;
  }
};
var ChainInfoInputSchema = (() => z.object({
  rpc: z.array(z.string().url()),
  chainId: z.number(),
  nativeCurrency: z.object({
    name: z.string(),
    symbol: z.string(),
    decimals: z.number()
  }),
  slug: z.string()
}))();
var SDKOptionsSchema = (() => z.object({
  // @ts-expect-error - zod doesn't know anything about readonly
  supportedChains: z.array(ChainInfoInputSchema).default(defaultChains),
  clientId: z.string().optional(),
  secretKey: z.string().optional(),
  readonlySettings: z.object({
    rpcUrl: z.string().url(),
    chainId: z.number().optional()
  }).optional(),
  gasSettings: z.object({
    maxPriceInGwei: z.number().min(1, "gas price cannot be less than 1").default(300),
    speed: z.enum(["standard", "fast", "fastest"]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: z.union([z.object({
    openzeppelin: z.object({
      relayerUrl: z.string().url(),
      relayerForwarderAddress: z.string().optional(),
      useEOAForwarder: z.boolean().default(false),
      domainName: z.string().default("GSNv2 Forwarder"),
      domainVersion: z.string().default("0.0.1")
    }),
    experimentalChainlessSupport: z.boolean().default(false)
  }), z.object({
    biconomy: z.object({
      apiId: z.string(),
      apiKey: z.string(),
      deadlineSeconds: z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
    })
  }), z.object({
    engine: z.object({
      relayerUrl: z.string().url().transform((url) => url.replace(/\/$/, "")),
      relayerForwarderAddress: z.string().optional(),
      domainName: z.string().default("GSNv2 Forwarder"),
      domainVersion: z.string().default("0.0.1")
    }),
    experimentalChainlessSupport: z.boolean().default(false)
  })]).optional(),
  gatewayUrls: z.array(z.string()).optional(),
  rpcBatchSettings: z.object({
    sizeLimit: z.number().default(200),
    timeLimit: z.number().default(10)
  }).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
}))();
var pkg2 = {
  name: "@thirdweb-dev/sdk",
  version: "4.0.36",
  description: "The main thirdweb SDK.",
  repository: "https://github.com/thirdweb-dev/js/tree/main/packages/sdk",
  license: "Apache-2.0",
  main: "dist/thirdweb-dev-sdk.cjs.js",
  module: "dist/thirdweb-dev-sdk.esm.js",
  browser: {
    "./dist/thirdweb-dev-sdk.esm.js": "./dist/thirdweb-dev-sdk.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        browser: "./dist/thirdweb-dev-sdk.browser.esm.js",
        "default": "./dist/thirdweb-dev-sdk.esm.js"
      },
      "default": "./dist/thirdweb-dev-sdk.cjs.js"
    },
    "./evm": {
      module: {
        browser: "./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js",
        "default": "./evm/dist/thirdweb-dev-sdk-evm.esm.js"
      },
      "default": "./evm/dist/thirdweb-dev-sdk-evm.cjs.js"
    },
    "./evm/zksync": {
      module: {
        browser: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js",
        "default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js"
      },
      "default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js"
    },
    "./evm/functions": {
      module: {
        browser: "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js",
        "default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js"
      },
      "default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js"
    },
    "./package.json": "./package.json"
  },
  files: [
    "dist/",
    "evm/",
    "server/"
  ],
  preconstruct: {
    entrypoints: [
      "index.ts",
      "evm/index.ts",
      "evm/functions/index.ts",
      "evm/zksync/index.ts"
    ],
    exports: {
      envConditions: [
        "browser"
      ]
    }
  },
  sideEffects: false,
  scripts: {
    format: "prettier --write 'src/**/*'",
    lint: "eslint src/",
    fix: "eslint src/ --fix",
    clean: "rm -rf dist/",
    "generate-docs": "mkdir -p etc && pnpm generate-docs:evm && pnpm generate-snippets",
    "generate-docs:evm": "api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm",
    "generate-snippets": "node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs",
    build: "tsc && preconstruct build",
    "test:all": "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 90000 --parallel './test/evm/**/*.test.ts'",
    test: "make test-evm",
    "test:single": "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000",
    push: "yalc push",
    typedoc: "node scripts/typedoc.mjs"
  },
  devDependencies: {
    "@aws-sdk/client-secrets-manager": "^3.378.0",
    "@ethersproject/abstract-provider": "^5.7.0",
    "@microsoft/api-documenter": "^7.22.30",
    "@microsoft/api-extractor": "^7.36.3",
    "@microsoft/tsdoc": "^0.14.1",
    "@nomiclabs/hardhat-ethers": "^2.2.3",
    "@preconstruct/cli": "2.7.0",
    "@project-serum/anchor": "^0.25.0",
    "@swc-node/register": "^1.6.8",
    "@swc/core": "^1.3.71",
    "@thirdweb-dev/tsconfig": "workspace:*",
    "@types/bn.js": "^5.1.1",
    "@types/chai": "^4.3.5",
    "@types/deep-equal-in-any-order": "^1.0.1",
    "@types/mocha": "^10.0.0",
    "@types/node": "^18.17.1",
    "@types/uuid": "^9.0.5",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.19.1",
    chai: "^4.3.6",
    "deep-equal-in-any-order": "^1.1.18",
    "dotenv-mono": "^1.3.10",
    eslint: "^8.56.0",
    "eslint-config-prettier": "^8.9.0",
    "eslint-config-thirdweb": "workspace:*",
    "eslint-plugin-better-tree-shaking": "0.0.4",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-inclusive-language": "^2.2.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-tsdoc": "^0.2.16",
    ethers: "^5.7.2",
    "ethers-aws-kms-signer": "^1.3.2",
    hardhat: "^2.17.0",
    mocha: "^10.2.0",
    nyc: "^15.1.0",
    prettier: "^3.1.1",
    rimraf: "^3.0.2",
    "typedoc-gen": "workspace:*",
    typescript: "^5.3.3",
    "zksync-web3": "^0.14.3"
  },
  peerDependencies: {
    "@aws-sdk/client-secrets-manager": "^3.215.0",
    ethers: "^5",
    "ethers-aws-kms-signer": "^1.3.2",
    "zksync-web3": "^0.14.3"
  },
  peerDependenciesMeta: {
    "@aws-sdk/client-secrets-manager": {
      optional: true
    },
    "ethers-aws-kms-signer": {
      optional: true
    },
    "zksync-web3": {
      optional: true
    }
  },
  dependencies: {
    "@thirdweb-dev/chains": "workspace:*",
    "@thirdweb-dev/contracts-js": "workspace:*",
    "@thirdweb-dev/crypto": "workspace:*",
    "@thirdweb-dev/generated-abis": "workspace:*",
    "@thirdweb-dev/merkletree": "workspace:*",
    "@thirdweb-dev/storage": "workspace:*",
    abitype: "^0.2.5",
    "bn.js": "^5.2.1",
    bs58: "^5.0.0",
    buffer: "^6.0.3",
    eventemitter3: "^5.0.1",
    "fast-deep-equal": "^3.1.3",
    "tiny-invariant": "^1.2.0",
    tweetnacl: "^1.0.3",
    uuid: "^9.0.1",
    yaml: "^2.3.4",
    zod: "^3.22.3"
  },
  bugs: {
    url: "https://github.com/thirdweb-dev/js/issues"
  },
  author: "thirdweb eng <eng@thirdweb.com>",
  engines: {
    node: ">=18"
  }
};
var operatingSystemRules2 = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function detectOS2(ua) {
  for (let ii = 0, count = operatingSystemRules2.length; ii < count; ii++) {
    const result = operatingSystemRules2[ii];
    if (!result) {
      continue;
    }
    const [os, regex] = result;
    const match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getOperatingSystem2() {
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return "";
  } else {
    const userAgent = navigator.userAgent;
    return detectOS2(userAgent) || "";
  }
}
function setAnalyticsHeaders2(headers) {
  const globals = getAnalyticsGlobals2();
  headers["x-sdk-version"] = globals.x_sdk_version;
  headers["x-sdk-name"] = globals.x_sdk_name;
  headers["x-sdk-platform"] = globals.x_sdk_platform;
  headers["x-sdk-os"] = globals.x_sdk_os;
}
function getAnalyticsHeaders() {
  const globals = getAnalyticsGlobals2();
  return {
    "x-sdk-version": globals.x_sdk_version,
    "x-sdk-os": globals.x_sdk_os,
    "x-sdk-name": globals.x_sdk_name,
    "x-sdk-platform": globals.x_sdk_platform,
    "x-bundle-id": globals.app_bundle_id
  };
}
function getAnalyticsGlobals2() {
  if (typeof globalThis === "undefined") {
    return {
      x_sdk_name: pkg2.name,
      x_sdk_platform: getPlatform2(),
      x_sdk_version: pkg2.version,
      x_sdk_os: getOperatingSystem2(),
      app_bundle_id: void 0
    };
  }
  if (globalThis.X_SDK_NAME === void 0) {
    globalThis.X_SDK_NAME = pkg2.name;
    globalThis.X_SDK_PLATFORM = getPlatform2();
    globalThis.X_SDK_VERSION = pkg2.version;
    globalThis.X_SDK_OS = getOperatingSystem2();
    globalThis.APP_BUNDLE_ID = void 0;
  }
  return {
    x_sdk_name: globalThis.X_SDK_NAME,
    x_sdk_platform: globalThis.X_SDK_PLATFORM,
    x_sdk_version: globalThis.X_SDK_VERSION,
    x_sdk_os: globalThis.X_SDK_OS,
    app_bundle_id: globalThis.APP_BUNDLE_ID || ""
    // if react, this will be empty
  };
}
function getPlatform2() {
  return typeof navigator !== "undefined" && navigator.product === "ReactNative" ? "mobile" : "browser";
}
function buildDefaultMap(options) {
  return options.supportedChains.reduce((previousValue, currentValue) => {
    previousValue[currentValue.chainId] = currentValue;
    return previousValue;
  }, {});
}
function getChainProvider(network, sdkOptions) {
  if (typeof network === "string" && isRpcUrl(network)) {
    return getProviderFromRpcUrl(network, sdkOptions);
  }
  const options = SDKOptionsSchema.parse(sdkOptions);
  if (isChainConfig(network)) {
    options.supportedChains = [
      // @ts-expect-error - we know this is a chain and it will work to build the map
      network,
      ...options.supportedChains.filter((c) => c.chainId === network.chainId)
    ];
  }
  const rpcMap = buildDefaultMap(options);
  let rpcUrl = "";
  let chainId;
  try {
    chainId = getChainIdFromNetwork(network, options);
    rpcUrl = getValidChainRPCs(rpcMap[chainId], options.clientId)[0];
  } catch (e) {
  }
  if (!rpcUrl) {
    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options.clientId || ""}`;
  }
  if (!rpcUrl) {
    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
  }
  return getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId);
}
function getChainIdFromNetwork(network, options) {
  if (isChainConfig(network)) {
    return network.chainId;
  } else if (typeof network === "number") {
    return network;
  } else {
    const chainNameToId = options.supportedChains.reduce((acc, curr) => {
      acc[curr.slug] = curr.chainId;
      return acc;
    }, {});
    if (network in chainNameToId) {
      return chainNameToId[network];
    }
  }
  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);
}
async function getChainIdOrName(network) {
  if (isChainConfig(network)) {
    return network.chainId;
  } else if (typeof network === "number") {
    return network;
  } else if (typeof network === "number") {
    return network;
  } else if (isProvider(network)) {
    return network.getNetwork().then((n) => n.chainId);
  } else if (isSigner(network)) {
    if (!network.provider) {
      throw new Error("Signer does not have a provider");
    }
    return network.provider.getNetwork().then((n) => n.chainId);
  }
  throw new Error(`Cannot resolve chainId from: ${network}.`);
}
function isChainConfig(network) {
  return typeof network !== "string" && typeof network !== "number" && !isSigner(network) && !isProvider(network);
}
function isRpcUrl(url) {
  const match = url.match(/^(ws|http)s?:/i);
  if (match) {
    switch (match[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return true;
    }
  }
  return false;
}
var RPC_PROVIDER_MAP = /* @__PURE__ */ new Map();
function getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId) {
  try {
    const headers = {};
    let authStrategy = "none";
    if (isTwUrl(rpcUrl)) {
      if (sdkOptions == null ? void 0 : sdkOptions.secretKey) {
        if (true) {
          throw new Error("Cannot use secretKey in browser context");
        }
        const hashedSecretKey = sha256HexSync(sdkOptions.secretKey);
        const derivedClientId = hashedSecretKey.slice(0, 32);
        const utilizedRpcUrl = new URL(rpcUrl);
        utilizedRpcUrl.pathname = derivedClientId;
        headers["x-client-id"] = derivedClientId;
        headers["x-secret-key"] = sdkOptions.secretKey;
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "secretKey";
      } else if (sdkOptions == null ? void 0 : sdkOptions.clientId) {
        const utilizedRpcUrl = new URL(rpcUrl);
        utilizedRpcUrl.pathname = sdkOptions.clientId;
        headers["x-client-id"] = sdkOptions.clientId;
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "clientId";
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
        authStrategy = "twAuthToken";
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders2(headers);
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (!rpcUrl.includes("bundleId")) {
        rpcUrl = rpcUrl + (bundleId ? `?bundleId=${bundleId}` : "");
      }
    }
    const match = rpcUrl.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          const seralizedOpts = `${rpcUrl}-${chainId || -1}-${authStrategy}`;
          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);
          if (existingProvider) {
            return existingProvider;
          }
          let _skipFetchSetup = false;
          if (typeof globalThis !== "undefined" && "TW_SKIP_FETCH_SETUP" in globalThis && typeof globalThis.TW_SKIP_FETCH_SETUP === "boolean") {
            _skipFetchSetup = globalThis.TW_SKIP_FETCH_SETUP;
          }
          const newProvider = chainId ? (
            // If we know the chainId we should use the StaticJsonRpcBatchProvider
            new StaticJsonRpcBatchProvider({
              url: rpcUrl,
              headers,
              skipFetchSetup: _skipFetchSetup
            }, chainId, sdkOptions == null ? void 0 : sdkOptions.rpcBatchSettings)
          ) : (
            // Otherwise fall back to the built in json rpc batch provider
            new lib_exports2.JsonRpcBatchProvider({
              url: rpcUrl,
              headers,
              skipFetchSetup: _skipFetchSetup
            })
          );
          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);
          return newProvider;
        case "ws":
        case "wss":
          return new lib_exports2.WebSocketProvider(rpcUrl, chainId);
      }
    }
  } catch (e) {
  }
  return lib_exports2.getDefaultProvider(rpcUrl);
}
function isTwUrl(url) {
  return new URL(url).hostname.endsWith(".thirdweb.com");
}
function getSignerAndProvider(network, options) {
  let signer;
  let provider2;
  if (isSigner(network)) {
    signer = network;
    if (network.provider) {
      provider2 = network.provider;
    }
  } else if (isProvider(network)) {
    provider2 = network;
  } else {
    provider2 = getChainProvider(network, options);
  }
  if (options == null ? void 0 : options.readonlySettings) {
    provider2 = getProviderFromRpcUrl(options.readonlySettings.rpcUrl, options, options.readonlySettings.chainId);
  }
  if (!provider2) {
    if (signer) {
      throw new Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
    }
    throw new Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!");
  }
  return [signer, provider2];
}
var provider;
var ENS_CACHE = /* @__PURE__ */ new Map();
async function resolveEns(ens) {
  let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!provider) {
    provider = getSignerAndProvider("ethereum")[1];
  }
  let ensPromise;
  if (ENS_CACHE.has(ens)) {
    ensPromise = ENS_CACHE.get(ens);
  } else {
    ensPromise = provider.resolveName(ens).then((address) => {
      if (!address) {
        return {
          address: null,
          expirationTime: new Date(Date.now() + 1e3 * 30)
        };
      }
      return {
        address,
        expirationTime: new Date(Date.now() + 1e3 * 60 * 5)
      };
    });
  }
  const resolvedPromise = await ensPromise;
  if (resolvedPromise.expirationTime < /* @__PURE__ */ new Date()) {
    ENS_CACHE.delete(ens);
    if (depth === 0) {
      resolveEns(ens, depth + 1);
    }
  }
  return resolvedPromise.address;
}
var EnsSchema = (() => z.custom((ens) => typeof ens === "string" && (ens.endsWith(".eth") || ens.endsWith(".cb.id"))).transform(async (ens) => resolveEns(ens)).refine((address) => !!address && utils_exports.isAddress(address), {
  message: "Provided value was not a valid ENS name"
}))();
var AddressSchema = (() => z.custom((address) => typeof address === "string" && utils_exports.isAddress(address), (out) => {
  return {
    message: `${out} is not a valid address`
  };
}))();
var AddressOrEnsSchema = (() => z.union([AddressSchema, EnsSchema], {
  invalid_type_error: "Provided value was not a valid address or ENS name"
}))();
async function resolveAddress(addressOrEns) {
  return AddressOrEnsSchema.parseAsync(addressOrEns);
}
var FileOrBufferUnionSchema = (() => z.instanceof(File))();
var FileOrBufferSchema = (() => z.union([FileOrBufferUnionSchema, z.object({
  data: z.union([FileOrBufferUnionSchema, z.string()]),
  name: z.string()
})]))();
var FileOrBufferOrStringSchema = (() => z.union([FileOrBufferSchema, z.string()]))();
var MAX_BPS = 1e4;
var BytesLikeSchema = (() => z.union([z.array(z.number()), z.string()]))();
var BigNumberTransformSchema$1 = (() => z.union([z.bigint(), z.custom((data) => {
  return BigNumber.isBigNumber(data);
}), z.custom((data) => {
  return import_bn.default.isBN(data);
})]).transform((arg) => {
  if (import_bn.default.isBN(arg)) {
    return new import_bn.default(arg).toString();
  }
  return BigNumber.from(arg).toString();
}))();
var BasisPointsSchema = (() => z.number().max(MAX_BPS, "Cannot exceed 100%").min(0, "Cannot be below 0%"))();
var PercentSchema = (() => z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"))();
var HexColor = (() => z.union([z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform((val) => val.replace("#", "")), z.string().length(0)]))();
var AmountSchema = (() => z.union([z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), z.number().min(0, "Amount cannot be negative")]).transform((arg) => typeof arg === "number" ? arg.toString() : arg))();
var QuantitySchema = (() => z.union([AmountSchema, z.literal("unlimited")]).default("unlimited"))();
var MAX_LENGTH = 256;
var NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
var MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
var REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);
function toSemver(version) {
  if (version.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version.trim().match(REGEX_MAIN_VERSION);
  if (!matches || (matches == null ? void 0 : matches.length) !== 4) {
    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [major, minor, patch].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}
function isIncrementalVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}
function isDowngradeVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major < currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor < currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;
}
var BigNumberSchema = (() => z.union([z.string(), z.number(), z.bigint(), z.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => BigNumber.from(arg)))();
var BigNumberishSchema = (() => BigNumberSchema.transform((arg) => arg.toString()))();
var BigNumberTransformSchema = (() => z.union([z.bigint(), z.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => {
  return BigNumber.from(arg).toString();
}))();
var CommonContractSchema = (() => z.object({
  name: z.string(),
  description: z.string().optional(),
  image: FileOrBufferOrStringSchema.optional(),
  external_link: z.string().optional(),
  app_uri: z.string().optional(),
  social_urls: z.record(z.string()).optional()
}).catchall(z.unknown()))();
var CommonContractOutputSchema = (() => CommonContractSchema.extend({
  image: z.string().optional()
}).catchall(z.unknown()))();
var CommonRoyaltySchema = (() => z.object({
  /**
   * The amount of royalty collected on all royalties represented as basis points.
   * The default is 0 (no royalties).
   *
   * 1 basis point = 0.01%
   *
   * For example: if this value is 100, then the royalty is 1% of the total sales.
   *
   * @internal
   * @remarks used by OpenSea "seller_fee_basis_points"
   */
  seller_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * The address of the royalty recipient. All royalties will be sent
   * to this address.
   * @internal
   * @remarks used by OpenSea "fee_recipient"
   */
  fee_recipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var CommonPrimarySaleSchema = (() => z.object({
  /**
   * primary sale recipient address
   */
  primary_sale_recipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var CommonPlatformFeeSchema = (() => z.object({
  /**
   * platform fee basis points
   */
  platform_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * platform fee recipient address
   */
  platform_fee_recipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var CommonTrustedForwarderSchema = (() => z.object({
  trusted_forwarders: z.array(AddressOrEnsSchema).default([])
}))();
var CommonSymbolSchema = (() => z.object({
  symbol: z.string().default("")
}))();
var MerkleSchema = (() => z.object({
  merkle: z.record(z.string()).default({})
}))();
var SnapshotEntryInput = (() => z.object({
  address: AddressOrEnsSchema,
  maxClaimable: QuantitySchema.default(0),
  // defaults to 0
  price: QuantitySchema.optional(),
  // defaults to unlimited, but can be undefined in old snapshots
  currencyAddress: AddressOrEnsSchema.default(lib_exports.AddressZero).optional()
  // defaults to AddressZero, but can be undefined for old snapshots
}))();
var SnapshotInputSchema = (() => z.union([z.array(z.string()).transform(async (strings) => await Promise.all(strings.map((address) => SnapshotEntryInput.parseAsync({
  address
})))), z.array(SnapshotEntryInput)]))();
var SnapshotEntryWithProofSchema = (() => SnapshotEntryInput.extend({
  proof: z.array(z.string())
}))();
var SnapshotSchema = (() => z.object({
  /**
   * The merkle root
   */
  merkleRoot: z.string(),
  claims: z.array(SnapshotEntryWithProofSchema)
}))();
var SnapshotInfoSchema = (() => z.object({
  merkleRoot: z.string(),
  snapshotUri: z.string()
}))();
var BYOCContractMetadataSchema = (() => CommonContractSchema.catchall(z.union([BigNumberTransformSchema, z.unknown()])))();
var CustomContractInput = (() => BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();
var CustomContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();
var CustomContractDeploy = (() => CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial()))();
var CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};
var AbiTypeBaseSchema = (() => z.object({
  type: z.string(),
  name: z.string().default("")
}).catchall(z.any()))();
var AbiTypeSchema = (() => AbiTypeBaseSchema.extend({
  stateMutability: z.string().optional(),
  components: z.array(AbiTypeBaseSchema).optional()
}).catchall(z.any()))();
var AbiObjectSchema = (() => z.object({
  type: z.string(),
  name: z.string().default(""),
  inputs: z.array(AbiTypeSchema).default([]),
  outputs: z.array(AbiTypeSchema).default([])
}).catchall(z.any()))();
var AbiSchema = (() => z.array(AbiObjectSchema))();
var PreDeployMetadata = (() => z.object({
  name: z.string(),
  metadataUri: z.string(),
  bytecodeUri: z.string(),
  analytics: z.any().optional()
}).catchall(z.any()))();
var ChainIdToAddressSchema = (() => z.record(z.string(), z.string()))();
var CustomFactoryInput = (() => z.object({
  factoryFunction: z.string(),
  params: z.array(z.object({
    name: z.string(),
    type: z.string()
  })).default([]),
  customFactoryAddresses: ChainIdToAddressSchema
}))();
var FactoryDeploymentSchema = (() => z.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: z.string().default("initialize"),
  customFactoryInput: CustomFactoryInput.optional(),
  factoryAddresses: ChainIdToAddressSchema.optional()
}))();
var DeployTypeInput = (() => z.union([z.literal("standard"), z.literal("autoFactory"), z.literal("customFactory")]))();
var RouterTypeInput = (() => z.union([z.literal("none"), z.literal("plugin"), z.literal("dynamic")]))();
var DeploymentNetworkInput = (() => z.object({
  allNetworks: z.boolean().optional(),
  networksEnabled: z.array(z.number()).default([])
}))();
var ExtraPublishMetadataSchemaInput = (() => z.object({
  version: z.string().refine((v) => {
    try {
      toSemver(v);
      return true;
    } catch (e) {
      return false;
    }
  }, (out) => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: z.string().optional(),
  description: z.string().optional(),
  readme: z.string().optional(),
  license: z.string().optional(),
  changelog: z.string().optional(),
  tags: z.array(z.string()).optional(),
  audit: FileOrBufferOrStringSchema.nullable().optional(),
  logo: FileOrBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: z.boolean().optional(),
  isDeployableViaProxy: z.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.optional(),
  deployType: DeployTypeInput.optional(),
  routerType: RouterTypeInput.optional(),
  defaultExtensions: z.array(z.object({
    extensionName: z.string(),
    extensionVersion: z.string().default("latest"),
    publisherAddress: AddressOrEnsSchema
  })).optional(),
  networksForDeployment: DeploymentNetworkInput.optional(),
  constructorParams: z.record(z.string(), z.object({
    displayName: z.string().optional(),
    description: z.string().optional(),
    defaultValue: z.string().optional(),
    hidden: z.boolean().optional()
  }).catchall(z.any())).optional(),
  compositeAbi: AbiSchema.optional()
}).catchall(z.any()))();
var ExtraPublishMetadataSchemaOutput = (() => ExtraPublishMetadataSchemaInput.extend({
  audit: z.string().nullable().optional(),
  logo: z.string().nullable().optional()
}))();
var FullPublishMetadataSchemaInput = (() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();
var FullPublishMetadataSchemaOutput = (() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();
var ProfileSchemaInput = (() => z.object({
  name: z.string().optional(),
  bio: z.string().optional(),
  avatar: FileOrBufferOrStringSchema.nullable().optional(),
  website: z.string().optional(),
  twitter: z.string().optional(),
  telegram: z.string().optional(),
  facebook: z.string().optional(),
  github: z.string().optional(),
  medium: z.string().optional(),
  linkedin: z.string().optional(),
  reddit: z.string().optional(),
  discord: z.string().optional()
}))();
var ProfileSchemaOutput = (() => ProfileSchemaInput.extend({
  avatar: z.string().nullable().optional()
}))();
var PublishedContractSchema = (() => z.object({
  id: z.string(),
  timestamp: BigNumberishSchema,
  metadataUri: z.string()
}))();
var ContractInfoSchema = (() => z.object({
  title: z.string().optional(),
  author: z.string().optional(),
  details: z.string().optional(),
  notice: z.string().optional()
}))();
var CompilerMetadataFetchedSchema = (() => z.object({
  name: z.string(),
  abi: AbiSchema,
  metadata: z.record(z.string(), z.any()),
  info: ContractInfoSchema,
  licenses: z.array(z.string().optional()).default([]).transform((v) => {
    return v.filter((license) => license !== void 0);
  }),
  isPartialAbi: z.boolean().optional()
}))();
var PreDeployMetadataFetchedSchema = (() => PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: z.string()
}))();
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await (await storage.download(publishMetadataUri)).text();
  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));
}
var CONTRACT_METADATA_TIMEOUT_SEC = 2;
async function fetchContractMetadata(compilerMetadataUri, storage) {
  const metadata = await storage.downloadJSON(compilerMetadataUri, {
    timeoutInSeconds: CONTRACT_METADATA_TIMEOUT_SEC
  });
  if (!metadata || !metadata.output) {
    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);
  }
  return formatCompilerMetadata(metadata);
}
function formatCompilerMetadata(metadata) {
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [...new Set(Object.entries(metadata.sources).map((_ref) => {
    let [, src2] = _ref;
    return src2.license;
  }))];
  return {
    name,
    abi,
    metadata,
    info,
    licenses,
    isPartialAbi: metadata.isPartialAbi
  };
}
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));
}
async function fetchPreDeployMetadata(publishMetadataUri, storage) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();
  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);
  return PreDeployMetadataFetchedSchema.parse({
    ...rawMeta,
    ...parsedMeta,
    bytecode: deployBytecode
  });
}
var isBrowser2 = () => true;
var isNode = () => !isBrowser2();
function unique(a, fn) {
  if (a.length === 0 || a.length === 1) {
    return a;
  }
  if (!fn) {
    return a;
  }
  for (let i = 0; i < a.length; i++) {
    for (let j = i + 1; j < a.length; j++) {
      if (fn(a[i], a[j])) {
        a.splice(j, 1);
      }
    }
  }
  return a;
}
function createLruCache(maxEntries) {
  let store = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Map();
  function put(key, value) {
    if (store.size >= maxEntries) {
      const keyToDelete = store.keys().next().value;
      store.delete(keyToDelete);
    }
    store.set(key, value);
  }
  function get(key) {
    const hasKey = store.has(key);
    if (!hasKey) {
      return void 0;
    }
    const entry = store.get(key);
    store.delete(key);
    store.set(key, entry);
    return entry;
  }
  function has(key) {
    return store.has(key);
  }
  return {
    put,
    get,
    has,
    maxEntries,
    store
  };
}
var deployMetadataCache = createLruCache(20);
async function fetchAndCacheDeployMetadata(publishMetadataUri, storage) {
  const cached = deployMetadataCache.get(publishMetadataUri);
  if (cached) {
    return cached;
  }
  const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, storage);
  let extendedMetadata;
  try {
    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);
  } catch (e) {
  }
  const data = {
    compilerMetadata,
    extendedMetadata
  };
  deployMetadataCache.put(publishMetadataUri, data);
  return data;
}
var supportedChains = defaultChains;
function setSupportedChains(chains) {
  if (chains && chains.length > 0) {
    supportedChains = chains;
  } else {
    supportedChains = defaultChains;
  }
}
function getSupportedChains() {
  return supportedChains;
}
var THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
async function fetchPublishedContractFromPolygon(publisherAddress, contractName) {
  let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let storage = arguments.length > 3 ? arguments[3] : void 0;
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const polygonChain = getSupportedChains().find((c) => c.chainId === 137);
  const chain = polygonChain || c137;
  const publisher = await resolveAddress(publisherAddress);
  const ContractPublisherAbi = (await import("./ContractPublisher-L2TK5UGV.js")).default;
  const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider(chain, {
    clientId,
    secretKey
  }));
  let publishedContract;
  if (!version || version === "latest") {
    const model = await contract.getPublishedContract(publisher, contractName);
    publishedContract = PublishedContractSchema.parse({
      id: model.contractId,
      timestamp: model.publishTimestamp,
      metadataUri: model.publishMetadataUri
    });
  } else {
    const allVersions = (await contract.getPublishedContractVersions(publisher, contractName)).map((c) => {
      return PublishedContractSchema.parse({
        id: c.contractId,
        timestamp: c.publishTimestamp,
        metadataUri: c.publishMetadataUri
      });
    });
    const versionMetadata = (await Promise.all(allVersions.map((c) => fetchAndCacheDeployMetadata(c.metadataUri, storage)))).map((item, index) => ({
      name: allVersions[index].id,
      publishedTimestamp: allVersions[index].timestamp,
      publishedMetadata: item
    }));
    const versionMatch = versionMetadata.find((metadata) => {
      var _a;
      return ((_a = metadata.publishedMetadata.extendedMetadata) == null ? void 0 : _a.version) === version;
    });
    invariant(versionMatch, "Contract version not found");
    publishedContract = allVersions.find((c) => c.timestamp === versionMatch.publishedTimestamp);
  }
  if (!publishedContract) {
    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER}'`);
  }
  return publishedContract;
}
async function getPrebuiltInfo(address, provider2) {
  try {
    const IThirdwebContractABI = (await import("./IThirdwebContract-MNY6RXWH.js")).default;
    const contract = new Contract(address, IThirdwebContractABI, provider2);
    const [_type, version] = await Promise.all([contract.contractType(), contract.contractVersion()]);
    const type = utils_exports.toUtf8String(_type).replace(/\x00/g, "");
    return {
      type,
      version
    };
  } catch (e) {
    return void 0;
  }
}
var decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
var src;
var srcEnd;
var position = 0;
var LEGACY_RECORD_INLINE_ID = 105;
var RECORD_DEFINITIONS_ID = 57342;
var RECORD_INLINE_ID = 57343;
var BUNDLED_STRINGS_ID = 57337;
var PACKED_REFERENCE_TAG_ID = 6;
var STOP_CODE = {};
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var currentExtensionRanges = [];
var packedValues;
var dataView;
var restoreMapsAsObject;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var sequentialMode = false;
var Decoder = class _Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0) {
        options.mapsAsObjects = true;
      }
      if (options.getStructures) {
        options.getShared = options.getStructures;
      }
      if (options.getShared && !options.structures) {
        (options.structures = []).uninitialized = true;
      }
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(options.keyMap)) {
          this.mapKey.set(v, k);
        }
      }
    }
    Object.assign(this, options);
  }
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  decode(source, end) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source === "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof _Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
};
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0) {
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          }
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 4294967296;
          token += dataView.getUint32(position + 4);
        } else {
          token = dataView.getBigUint64(position);
        }
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(key)] = read();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  map.set(currentDecoder.decodeKey(key), read());
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  map.set(key, read());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4:
      let array = new Array(token);
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
          }
        } else {
          for (let i = 0; i < token; i++) {
            object[safeKey(read())] = read();
          }
        }
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            map.set(currentDecoder.decodeKey(read()), read());
          }
        } else {
          for (let i = 0; i < token; i++) {
            map.set(read(), read());
          }
        }
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure);
          }
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            return recordDefinition(read());
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition([id++, read()]);
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read) {
                structure.read = createStructureReader(structure);
              }
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead) {
          return extension(read);
        } else {
          return extension(read());
        }
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0) {
            return value;
          }
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0) {
            return packedValue;
          }
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    let length = src[position++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position++];
          break;
        case 25:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length) {
        return compiledReader(read);
      }
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= 3) {
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader) {
        compiledReader.next = this.compiledReader;
      }
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap) {
      for (let i = 0; i < length; i++) {
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
      }
    } else {
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
var readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length)) {
      return result;
    }
  }
  if (length > 64 && decoder) {
    return decoder.decode(src.subarray(position, position += length));
  }
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      } else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length < 3) {
        return fromCharCode(a, b);
      }
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4) {
        return fromCharCode(a, b, c, d);
      } else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length < 7) {
        return fromCharCode(a, b, c, d, e, f);
      }
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8) {
          return fromCharCode(a, b, c, d, e, f, g, h);
        } else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length < 11) {
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        }
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12) {
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          } else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length < 15) {
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          }
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3) {
      return NaN;
    }
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
var Tag = class {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
};
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = (buffer) => {
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction) => {
  return Number(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
var recordDefinition = (definition) => {
  let id = definition[0] - 57344;
  let structure = definition[1];
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
  let object = {};
  if (currentDecoder.keyMap) {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = currentDecoder.decodeKey(structure[i - 2]);
      object[safeKey(key)] = definition[i];
    }
  } else {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = definition[i];
    }
  }
  return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = (value) => {
  if (bundledStrings) {
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  }
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings) {
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  }
  return new Tag(value, 15);
};
var glbl = {
  Error,
  RegExp
};
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (_read) => {
  if (src[position++] != 132) {
    throw new Error("Packed values structure must be followed by a 4 element array");
  }
  let newPackedValues = _read();
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = _read();
  packedValues.suffixes = _read();
  return _read();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
  }
  if (typeof data === "number") {
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  }
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[25] = (id) => {
  return stringRefs[id];
};
currentExtensions[256] = (_read) => {
  stringRefs = [];
  try {
    return _read();
  } finally {
    stringRefs = null;
  }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = (_read) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src[position];
  let target;
  if (token >> 5 == 4) {
    target = [];
  } else {
    target = {};
  }
  let refEntry = {
    target
  };
  referenceMap.set(id, refEntry);
  let targetProperties = _read();
  if (refEntry.used) {
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (_read) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return _read();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string") {
    return a + b;
  }
  if (a instanceof Array) {
    return a.concat(b);
  }
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      throw new Error("No packed values available");
    }
  }
  return packedValues;
}
var SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) {
    return combine(getPackedValues().prefixes[tag - 224], input);
  }
  if (tag >= 28704 && tag <= 32767) {
    return combine(getPackedValues().prefixes[tag - 28672], input);
  }
  if (tag >= 1879052288 && tag <= 2147483647) {
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  }
  if (tag >= 216 && tag <= 223) {
    return combine(input, getPackedValues().suffixes[tag - 216]);
  }
  if (tag >= 27647 && tag <= 28671) {
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  }
  if (tag >= 1811940352 && tag <= 1879048191) {
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  }
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799) {
    return input;
  }
});
var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
var typedArrays = [Uint8Array];
var typedArrayTags = [64];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function") {
    TypedArray = null;
  }
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1) {
      continue;
    }
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    let bundleLength = readJustLength();
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) {
      currentDecoder.structures = currentStructures = updatedStructures;
    } else {
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = Number("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultDecoder = new Decoder({
  useRecords: false
});
var decode = defaultDecoder.decode;
function hexToBytes(hex) {
  hex = hex.toString(16);
  if (!hex.startsWith("0x")) {
    hex = `0x${hex}`;
  }
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }
  hex = hex.replace(/^0x/i, "");
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.slice(c, c + 2), 16));
  }
  return bytes;
}
function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());
}
function extractIPFSHashFromBytecode(bytecode2) {
  const numericBytecode = hexToBytes(bytecode2);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 256 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decode(bytecodeBuffer);
  if ("ipfs" in cborData && cborData["ipfs"]) {
    try {
      return `ipfs://${import_bs58.default.encode(cborData["ipfs"])}`;
    } catch (e) {
      console.warn("feature-detection ipfs cbor failed", e);
    }
  }
  return void 0;
}
function extractMinimalProxyImplementationAddress(bytecode2) {
  if (bytecode2.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode2.slice(22, 62);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x36603057343d5230")) {
    const implementationAddress = bytecode2.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x3d3d3d3d363d3d37363d73")) {
    const implementationAddress = bytecode2.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode2.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x36600080376020600036600073")) {
    const implementationAddress = bytecode2.slice(28, 28 + 40);
    return `0x${implementationAddress}`;
  }
  return void 0;
}
async function resolveContractUriFromAddress(address, provider2) {
  const {
    bytecode: bytecode2
  } = await resolveImplementation(address, provider2);
  return extractIPFSHashFromBytecode(bytecode2);
}
async function resolveContractUriAndBytecode(address, provider2) {
  const {
    bytecode: bytecode2
  } = await resolveImplementation(address, provider2);
  return {
    uri: extractIPFSHashFromBytecode(bytecode2),
    bytecode: bytecode2
  };
}
async function resolveImplementation(address, provider2) {
  const [bytecode2, beacon] = await Promise.all([fetchBytecode(address, provider2), getBeaconFromStorageSlot(address, provider2)]);
  const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(bytecode2);
  if (minimalProxyImplementationAddress) {
    return {
      address: minimalProxyImplementationAddress,
      bytecode: await fetchBytecode(minimalProxyImplementationAddress, provider2)
    };
  }
  if (beacon && beacon !== lib_exports.AddressZero) {
    address = beacon;
  }
  const impl = await Promise.all([getImplementationFromStorageSlot(address, provider2), getImplementationFromContractCall(address, provider2)]);
  for (const implementationAddress of impl) {
    if (implementationAddress && utils_exports.isAddress(implementationAddress) && implementationAddress !== lib_exports.AddressZero) {
      try {
        const implBytecode = await fetchBytecode(implementationAddress, provider2);
        return {
          address: implementationAddress,
          bytecode: implBytecode
        };
      } catch (e) {
        if (e instanceof Error) {
          if (!e.message.includes(`Contract at ${implementationAddress} does not exist on chain`)) {
            throw e;
          }
        }
      }
    }
  }
  return {
    address,
    bytecode: bytecode2
  };
}
async function fetchBytecode(address, provider2) {
  try {
    const bytecode2 = await provider2.getCode(address);
    if (bytecode2 === "0x") {
      const chain = await provider2.getNetwork();
      throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
    }
    return bytecode2;
  } catch (e) {
    throw new Error(`Failed to get bytecode for address ${address}: ${e}`);
  }
}
async function getImplementationFromStorageSlot(address, provider2) {
  try {
    const proxyStorage = await provider2.getStorageAt(address, BigNumber.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
    return `0x${proxyStorage.slice(-40)}`;
  } catch (e) {
    return void 0;
  }
}
async function getBeaconFromStorageSlot(address, provider2) {
  try {
    const proxyStorage = await provider2.getStorageAt(address, BigNumber.from("0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"));
    return `0x${proxyStorage.slice(-40)}`;
  } catch (e) {
    return void 0;
  }
}
async function getImplementationFromContractCall(address, provider2) {
  try {
    const proxy = new Contract(address, UPGRADEABLE_PROXY_ABI, provider2);
    return await proxy.implementation();
  } catch (e) {
    return void 0;
  }
}
var UPGRADEABLE_PROXY_ABI = [{
  type: "function",
  name: "implementation",
  inputs: [],
  outputs: [{
    type: "address",
    name: "",
    internalType: "address"
  }],
  stateMutability: "view"
}];
var MultichainRegistry_address = "0xcdAD8FA86e18538aC207872E8ff3536501431B73";
function getMultichainRegistryAddress() {
  return getProcessEnv2("multiChainRegistryAddress", MultichainRegistry_address);
}
function joinABIs(abis, abiWithConstructor) {
  const parsedABIs = abis.map((abi) => AbiSchema.parse(abi)).flat();
  const filteredABIs = parsedABIs.filter((item) => item.type !== "constructor");
  if (abiWithConstructor) {
    filteredABIs.push(...AbiSchema.parse(abiWithConstructor));
  }
  const finalABIs = unique(filteredABIs, (a, b) => {
    return a.name === b.name && a.type === b.type && a.inputs.length === b.inputs.length;
  });
  return AbiSchema.parse(finalABIs);
}
var FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {
  name: "ERC20ClaimConditionsV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [IERC20_default, IDropSinglePhase_V1_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {
  name: "ERC20ClaimConditionsV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [IERC20_default, IDropSinglePhase_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_PHASES_V2 = {
  name: "ERC20ClaimPhasesV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [IERC20_default, IDrop_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_PHASES_V1 = {
  name: "ERC20ClaimPhasesV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [IDropERC20_V2_default],
  features: {}
};
var FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "erc20burnable"
  },
  abis: [IERC20_default, IBurnableERC20_default],
  features: {}
};
var FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "erc20signaturemint"
  },
  abis: [IERC20_default, ISignatureMintERC20_default],
  features: {}
};
var FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "erc20batchmintable"
  },
  abis: [IERC20_default, IMintableERC20_default, IMulticall_default],
  features: {}
};
var FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "erc20mintable"
  },
  abis: [IERC20_default, IMintableERC20_default],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
var FEATURE_TOKEN_PERMIT = {
  name: "ERC20Permit",
  namespace: "token.permit",
  docLinks: {
    sdk: "sdk.erc20permit",
    contracts: "erc20permit"
  },
  abis: [IERC20_default, IERC20Permit_default],
  features: {}
};
var FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "erc20"
  },
  abis: [IERC20_default, IERC20Metadata_default],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,
    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,
    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT
  }
};
var FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "erc721burnable"
  },
  abis: [IERC721_default, IBurnableERC721_default],
  features: {}
};
var FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.delayedreveal",
    contracts: "erc721revealable"
  },
  abis: [IERC721_default, ILazyMint_default, IDelayedReveal_default],
  features: {}
};
var FEATURE_NFT_TIERED_DROP = {
  name: "ERC721TieredDrop",
  namespace: "nft.tieredDrop",
  docLinks: {
    sdk: "sdk.erc721tiereddrop",
    //TODO
    contracts: ""
  },
  abis: [IERC721_default, LazyMintWithTier_V1_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CONDITIONS_V1 = {
  name: "ERC721ClaimConditionsV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [IERC721_default, IDropSinglePhase_V1_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CONDITIONS_V2 = {
  name: "ERC721ClaimConditionsV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [IERC721_default, IDropSinglePhase_default],
  features: {}
};
var FEATURE_NFT_CLAIM_PHASES_V1 = {
  name: "ERC721ClaimPhasesV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [IDropERC721_V3_default],
  features: {}
};
var FEATURE_NFT_CLAIM_PHASES_V2 = {
  name: "ERC721ClaimPhasesV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [IERC721_default, IDrop_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CUSTOM = {
  name: "ERC721ClaimCustom",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimcustom"
  },
  abis: [IERC721_default, IClaimableERC721_default],
  features: {}
};
var FEATURE_NFT_CLAIM_ZORA = {
  name: "ERC721ClaimZora",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimzora"
  },
  abis: [IERC721_default, zora_IERC721Drop_default],
  features: {}
};
var FEATURE_NFT_LAZY_MINTABLE = {
  name: "ERC721LazyMintable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721lazymintable",
    contracts: "lazymint"
  },
  abis: [IERC721_default, ILazyMint_default],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE
  }
};
var FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "erc721batchmintable"
  },
  abis: [IERC721_default, IMintableERC721_default, IMulticall_default],
  features: {}
};
var FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "erc721mintable"
  },
  abis: [IERC721_default, IMintableERC721_default],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
var FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {
  name: "ERC721SignatureMintV2",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [IERC721_default, ISignatureMintERC721_default],
  features: {}
};
var FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {
  name: "ERC721SignatureMintV1",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [ISignatureMintERC721_V1_default],
  features: {}
};
var FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "erc721enumerable"
  },
  abis: [IERC721_default, IERC721Enumerable_default],
  features: {}
};
var FEATURE_NFT_QUERYABLE = {
  name: "ERC721AQueryable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [IERC721AQueryableUpgradeable_default],
  features: {}
};
var FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "erc721supply"
  },
  abis: [IERC721_default, IERC721Supply_default],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE,
    [FEATURE_NFT_QUERYABLE.name]: FEATURE_NFT_QUERYABLE
  }
};
var FEATURE_NFT_SHARED_METADATA = {
  name: "ERC721SharedMetadata",
  namespace: "nft.sharedmetadata",
  docLinks: {
    sdk: "sdk.sharedmetadata",
    contracts: "SharedMetadata"
  },
  abis: [IERC721_default, SharedMetadata_default],
  features: {}
};
var FEATURE_NFT_LOYALTY_CARD = {
  name: "ERC721LoyaltyCard",
  namespace: "nft.loyaltyCard",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [ILoyaltyCard_default],
  features: {}
};
var FEATURE_NFT_UPDATABLE_METADATA = {
  name: "ERC721UpdatableMetadata",
  namespace: "nft.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IERC721_default, INFTMetadata_default],
  features: {}
};
var FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "erc721"
  },
  abis: [IERC721_default, IERC721Metadata_default],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,
    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,
    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,
    [FEATURE_NFT_CLAIM_ZORA.name]: FEATURE_NFT_CLAIM_ZORA,
    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,
    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,
    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,
    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2,
    [FEATURE_NFT_SHARED_METADATA.name]: FEATURE_NFT_SHARED_METADATA,
    [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
    [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA
  }
};
var NAME_SYMBOL_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "symbol",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "erc1155burnable"
  },
  abis: [IERC1155_default, IBurnableERC1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {
  name: "ERC1155ClaimConditionsV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155dropsinglephase"
  },
  abis: [IERC1155_default, IDropSinglePhase1155_V1_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {
  name: "ERC1155ClaimConditionsV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimconditions"
  },
  abis: [IERC1155_default, IDropSinglePhase1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_PHASES_V2 = {
  name: "ERC1155ClaimPhasesV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [IERC1155_default, IDrop1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_PHASES_V1 = {
  name: "ERC1155ClaimPhasesV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [IDropERC1155_V2_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CUSTOM = {
  name: "ERC1155ClaimCustom",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimcustom"
  },
  abis: [IERC1155_default, IClaimableERC1155_default],
  features: {}
};
var FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "erc1155revealable"
  },
  abis: [IERC1155_default, ILazyMint_default, IDelayedReveal_default],
  features: {}
};
var FEATURE_EDITION_LAZY_MINTABLE_V2 = {
  name: "ERC1155LazyMintableV2",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [IERC1155_default, ILazyMint_default],
  features: {
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE
  }
};
var FEATURE_EDITION_LAZY_MINTABLE_V1 = {
  name: "ERC1155LazyMintableV1",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [IDropERC1155_V2_default],
  features: {
    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1
  }
};
var FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "erc1155signaturemint"
  },
  abis: [IERC1155_default, ISignatureMintERC1155_default],
  features: {}
};
var FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "erc1155batchmintable"
  },
  abis: [IERC1155_default, IMintableERC1155_default, IMulticall_default],
  features: {}
};
var FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "erc1155mintable"
  },
  abis: [IERC1155_default, IMintableERC1155_default],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
var FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "erc1155enumerable"
  },
  abis: [IERC1155_default, IERC1155Enumerable_default],
  features: {}
};
var FEATURE_EDITION_UPDATABLE_METADATA = {
  name: "ERC1155UpdatableMetadata",
  namespace: "edition.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IERC1155_default, INFTMetadata_default],
  features: {}
};
var FEATURE_EDITION_SUPPLY = {
  name: "ERC1155Supply",
  namespace: "edition.supply",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [IERC1155_default, IERC1155Supply_default],
  features: {}
};
var FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "erc1155"
  },
  abis: [IERC1155_default, IERC1155Metadata_default, NAME_SYMBOL_ABI],
  features: {
    [FEATURE_EDITION_SUPPLY.name]: FEATURE_EDITION_SUPPLY,
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,
    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,
    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,
    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2,
    [FEATURE_EDITION_UPDATABLE_METADATA.name]: FEATURE_EDITION_UPDATABLE_METADATA
  }
};
var fallbackAbi = [{
  stateMutability: "payable",
  type: "fallback"
}];
var getAllPluginsAbi = [{
  inputs: [],
  name: "getAllPlugins",
  outputs: [{
    components: [{
      internalType: "bytes4",
      name: "functionSelector",
      type: "bytes4"
    }, {
      internalType: "string",
      name: "functionSignature",
      type: "string"
    }, {
      internalType: "address",
      name: "pluginAddress",
      type: "address"
    }],
    internalType: "struct IPluginMap.Plugin[]",
    name: "registered",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
var getAllExtensionsAbi = [{
  inputs: [],
  name: "getAllExtensions",
  outputs: [{
    components: [{
      components: [{
        internalType: "string",
        name: "name",
        type: "string"
      }, {
        internalType: "string",
        name: "metadataURI",
        type: "string"
      }, {
        internalType: "address",
        name: "implementation",
        type: "address"
      }],
      internalType: "struct IExtension.ExtensionMetadata",
      name: "metadata",
      type: "tuple"
    }, {
      components: [{
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      }, {
        internalType: "string",
        name: "functionSignature",
        type: "string"
      }],
      internalType: "struct IExtension.ExtensionFunction[]",
      name: "functions",
      type: "tuple[]"
    }],
    internalType: "struct IExtension.Extension[]",
    name: "allExtensions",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
var FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "royalty"
  },
  abis: [IRoyalty_default],
  features: {}
};
var FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "primarysale"
  },
  abis: [IPrimarySale_default],
  features: {}
};
var FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFees",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "platformfee"
  },
  abis: [IPlatformFee_default],
  features: {}
};
var FEATURE_PERMISSIONS_ENUMERABLE = {
  name: "PermissionsEnumerable",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissionsenumerable"
  },
  abis: [IPermissionsEnumerable_default],
  features: {}
};
var FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissions"
  },
  abis: [IPermissions_default],
  features: {
    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE
  }
};
var FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "contractmetadata"
  },
  abis: [IContractMetadata_default],
  features: {}
};
var FEATURE_APPURI = {
  name: "AppURI",
  namespace: "appURI",
  docLinks: {
    sdk: "sdk.appURI",
    //TODO
    contracts: ""
  },
  abis: [IAppURI_default],
  features: {}
};
var FEATURE_OWNER = {
  name: "Ownable",
  namespace: "owner",
  docLinks: {
    sdk: "sdk.owner",
    contracts: "ownable"
  },
  abis: [Ownable_default],
  features: {}
};
var FEATURE_GASLESS = {
  name: "Gasless",
  namespace: "gasless",
  docLinks: {
    sdk: "sdk.gaslesstransaction",
    // TODO add the correct name for this once it's added to portal
    contracts: "IERC2771Context"
  },
  abis: [IERC2771Context_default],
  features: {}
};
var FEATURE_PACK_VRF = {
  name: "PackVRF",
  namespace: "pack.vrf",
  docLinks: {
    sdk: "sdk.packvrf",
    //TODO
    contracts: "IPackVRF"
  },
  abis: [IPackVRFDirect_default],
  features: {}
};
var FEATURE_PLUGIN_ROUTER = {
  name: "PluginRouter",
  namespace: "plugin.router",
  docLinks: {
    sdk: "sdk.pluginrouter",
    //TODO
    contracts: "PluginRouter"
  },
  abis: [getAllPluginsAbi],
  features: {}
};
var FEATURE_DYNAMIC_CONTRACT = {
  name: "DynamicContract",
  namespace: "dynamic.contract",
  docLinks: {
    sdk: "",
    //TODO
    contracts: "IExtensionsManager"
  },
  abis: [getAllExtensionsAbi],
  features: {}
};
var FEATURE_DIRECT_LISTINGS = {
  name: "DirectListings",
  namespace: "direct.listings",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IDirectListings"
  },
  abis: [IDirectListings_default],
  features: {}
};
var FEATURE_ENGLISH_AUCTIONS = {
  name: "EnglishAuctions",
  namespace: "english.auctions",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IEnglishAuctions"
  },
  abis: [IEnglishAuctions_default],
  features: {}
};
var FEATURE_OFFERS = {
  name: "Offers",
  namespace: "offers",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IOffers"
  },
  abis: [IOffers_default],
  features: {}
};
var FEATURE_ACCOUNT_FACTORY = {
  name: "AccountFactory",
  namespace: "accountFactory",
  docLinks: {
    // TODO
    sdk: "sdk.accountFactory",
    contracts: "IAccountFactory"
  },
  abis: [IAccountFactoryCore_default],
  features: {}
};
var FEATURE_ACCOUNT_PERMISSIONS_V1 = {
  name: "AccountPermissionsV1",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissions_V1_default],
  features: {}
};
var FEATURE_ACCOUNT_PERMISSIONS = {
  name: "AccountPermissions",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissions_default],
  features: {}
};
var FEATURE_ACCOUNT = {
  name: "Account",
  namespace: "account",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccount"
  },
  abis: [IAccount_default],
  features: {
    [FEATURE_ACCOUNT_PERMISSIONS.name]: FEATURE_ACCOUNT_PERMISSIONS,
    [FEATURE_ACCOUNT_PERMISSIONS_V1.name]: FEATURE_ACCOUNT_PERMISSIONS_V1
  }
};
var FEATURE_AIRDROP_ERC20 = {
  name: "AirdropERC20",
  namespace: "airdrop20",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC20"
  },
  abis: [IAirdropERC20_default],
  features: {}
};
var FEATURE_AIRDROP_ERC721 = {
  name: "AirdropERC721",
  namespace: "airdrop721",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC721"
  },
  abis: [IAirdropERC721_default],
  features: {}
};
var FEATURE_AIRDROP_ERC1155 = {
  name: "AirdropERC1155",
  namespace: "airdrop1155",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC1155"
  },
  abis: [IAirdropERC1155_default],
  features: {}
};
var FEATURE_FALLBACK = {
  name: "Fallback",
  namespace: "fallback",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [fallbackAbi],
  features: {}
};
var SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA,
  [FEATURE_APPURI.name]: FEATURE_APPURI,
  [FEATURE_OWNER.name]: FEATURE_OWNER,
  [FEATURE_GASLESS.name]: FEATURE_GASLESS,
  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,
  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,
  [FEATURE_DYNAMIC_CONTRACT.name]: FEATURE_DYNAMIC_CONTRACT,
  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,
  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,
  [FEATURE_OFFERS.name]: FEATURE_OFFERS,
  [FEATURE_AIRDROP_ERC20.name]: FEATURE_AIRDROP_ERC20,
  [FEATURE_AIRDROP_ERC721.name]: FEATURE_AIRDROP_ERC721,
  [FEATURE_AIRDROP_ERC1155.name]: FEATURE_AIRDROP_ERC1155,
  [FEATURE_ACCOUNT_FACTORY.name]: FEATURE_ACCOUNT_FACTORY,
  [FEATURE_ACCOUNT.name]: FEATURE_ACCOUNT,
  [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
  [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA,
  [FEATURE_FALLBACK.name]: FEATURE_FALLBACK
};
function toJSType(contractType) {
  let isReturnType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let withName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let jsType = contractType.type;
  let isArray = false;
  if (jsType.endsWith("[]")) {
    isArray = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType.components) {
      jsType = `{ ${contractType.components.map((a) => toJSType(a, false, true)).join(", ")} }`;
    }
  }
  if (isArray) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType.name}: ${jsType}`;
  }
  return jsType;
}
function extractCommentFromMetadata(name, metadata, type) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return ((_e = (_d = (_b = (_a = metadata == null ? void 0 : metadata.output) == null ? void 0 : _a.userdoc) == null ? void 0 : _b[type]) == null ? void 0 : _d[Object.keys(((_c = metadata == null ? void 0 : metadata.output) == null ? void 0 : _c.userdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _e.notice) || ((_j = (_i = (_g = (_f = metadata == null ? void 0 : metadata.output) == null ? void 0 : _f.devdoc) == null ? void 0 : _g[type]) == null ? void 0 : _i[Object.keys(((_h = metadata == null ? void 0 : metadata.output) == null ? void 0 : _h.devdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _j.details);
}
function extractFunctionsFromAbi(abi, metadata) {
  var _a, _b, _c, _d;
  const functions = (abi || []).filter((el) => el.type === "function");
  const parsed = [];
  for (const f of functions) {
    const doc = extractCommentFromMetadata(f.name, metadata, "methods");
    const args = ((_b = (_a = f.inputs) == null ? void 0 : _a.map((i) => `${i.name || "key"}: ${toJSType(i)}`)) == null ? void 0 : _b.join(", ")) || "";
    const fargs = args ? `, [${args}]` : "";
    const out = (_d = (_c = f.outputs) == null ? void 0 : _c.map((o) => toJSType(o, true))) == null ? void 0 : _d.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature = `contract.call("${f.name}"${fargs})${promise}`;
    parsed.push({
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      inputs: f.inputs || [],
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      outputs: f.outputs || [],
      name: f.name || "unknown",
      signature,
      stateMutability: f.stateMutability || "",
      comment: doc
    });
  }
  return parsed;
}
function hasMatchingAbi(contractAbi, featureAbis) {
  const contractFn = extractFunctionsFromAbi(contractAbi);
  const interfaceFn = featureAbis.flatMap((i) => extractFunctionsFromAbi(i));
  const intersection = contractFn.filter((fn) => {
    const match = interfaceFn.find((iFn) => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {
      var _a;
      if (i.type === "tuple" || i.type === "tuple[]") {
        return i.type === fn.inputs[index].type && ((_a = i.components) == null ? void 0 : _a.every((c, cIndex) => {
          var _a2, _b;
          return c.type === ((_b = (_a2 = fn.inputs[index].components) == null ? void 0 : _a2[cIndex]) == null ? void 0 : _b.type);
        }));
      }
      return i.type === fn.inputs[index].type;
    }));
    return match !== void 0;
  });
  return intersection.length === interfaceFn.length;
}
function matchesAbiFromBytecode(contractBytecode, featureAbis) {
  const interfaces = featureAbis.map((abi) => new import_utils.Interface(abi));
  const selectors = interfaces.flatMap((i) => {
    return Object.values(i.functions).map((fn) => Number(i.getSighash(fn)).toString(16));
  });
  const uniqueSelectors = [...new Set(selectors)];
  return uniqueSelectors.every((selector) => contractBytecode.includes(selector));
}
var lruCache = createLruCache(10);
function detectFeatures(abi) {
  let features = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SUPPORTED_FEATURES;
  const cacheKey = JSON.stringify(abi);
  if (lruCache.has(cacheKey)) {
    return lruCache.get(cacheKey);
  }
  const results = detectFeaturesInternal(abi, features);
  lruCache.put(cacheKey, results);
  return results;
}
function detectFeaturesInternal(abi, features) {
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeaturesInternal(abi, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}
function detectFeaturesFromBytecode(bytecode2) {
  let features = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SUPPORTED_FEATURES;
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiFromBytecode(bytecode2, feature.abis);
    const childResults = detectFeaturesFromBytecode(bytecode2, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}
function matchesAbiInterface(abi, feature) {
  return hasMatchingAbi(abi, feature.abis);
}
function extractFeatures(input, enabledExtensions) {
  if (!input) {
    return;
  }
  for (const extensionKey in input) {
    const extension = input[extensionKey];
    if (extension.enabled) {
      enabledExtensions.push(extension);
    }
    extractFeatures(extension.features, enabledExtensions);
  }
}
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}
function getAllDetectedExtensionsFromBytecode(bytecode2) {
  const features = [];
  extractFeatures(detectFeaturesFromBytecode(bytecode2), features);
  return features;
}
function constructAbiFromBytecode(bytecode2) {
  let extensions = getAllDetectedExtensionsFromBytecode(bytecode2);
  if (extensions.find((f) => f.name === "ERC721")) {
    extensions = extensions.filter((f) => f.name !== "ERC20");
  }
  const abi = joinABIs(extensions.map((f) => joinABIs(f.abis)));
  return abi;
}
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map((f) => ({
    ...f,
    extensions: f.features
  }));
}
var CONTRACT_RESOLVER_BASE_URL = "https://contract.thirdweb.com/metadata";
var metadataCache = createLruCache(20);
var multichainRegistry = void 0;
function getCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function putInCache(address, chainId, metadata) {
  metadataCache.put(getCacheKey(address, chainId), metadata);
}
function getContractMetadataFromCache(address, chainId) {
  return metadataCache.get(getCacheKey(address, chainId));
}
async function fetchContractMetadataFromAddress(address, provider2, storage) {
  let sdkOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const chainId = (await provider2.getNetwork()).chainId;
  const cached = getContractMetadataFromCache(address, chainId);
  if (cached) {
    return cached;
  }
  let metadata;
  const isLocalChain = chainId === 31337 || chainId === 1337;
  if (!isLocalChain) {
    try {
      const response = await fetch(`${CONTRACT_RESOLVER_BASE_URL}/${chainId}/${address}`, {
        headers: {
          ...getAnalyticsHeaders()
        }
      });
      if (response.ok) {
        const resolvedData = await response.json();
        metadata = formatCompilerMetadata(resolvedData);
      }
    } catch (e) {
    }
  }
  if (!metadata) {
    metadata = await fetchContractMetadataFromBytecode(address, chainId, provider2, storage, sdkOptions);
  }
  if (!metadata) {
    throw new Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  if (!metadata.isPartialAbi) {
    putInCache(address, chainId, metadata);
  } else {
    console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  return metadata;
}
async function fetchContractMetadataFromBytecode(address, chainId, provider2, storage) {
  let sdkOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  let metadata;
  const [ipfsData, registryData] = await Promise.all([resolveContractUriAndBytecode(address, provider2).catch(() => void 0), getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions).then((uri) => {
    if (!uri) {
      return void 0;
    }
    return {
      uri,
      bytecode: ""
    };
  }).catch(() => void 0)]);
  const bytecode2 = ipfsData == null ? void 0 : ipfsData.bytecode;
  const metadataUri = (registryData == null ? void 0 : registryData.uri) || (ipfsData == null ? void 0 : ipfsData.uri);
  if (!metadataUri && !bytecode2) {
    throw new Error(`Could not fetch bytecode for contract at ${address} on chain ${chainId}, double check that the address and chainId are correct.`);
  }
  try {
    metadata = await fetchContractMetadata(metadataUri, storage);
  } catch (e) {
  }
  if (!metadata && bytecode2) {
    const abi = constructAbiFromBytecode(bytecode2);
    if (abi && abi.length > 0) {
      metadata = {
        name: "Unimported Contract",
        abi,
        metadata: {},
        info: {},
        licenses: [],
        isPartialAbi: true
      };
      return metadata;
    }
  }
  return metadata;
}
async function getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions) {
  var _a;
  const TWRegistryABI = (await import("./TWMultichainRegistryLogic-UZB7PHP3.js")).default;
  if (!multichainRegistry) {
    const polygonChain = (_a = sdkOptions == null ? void 0 : sdkOptions.supportedChains) == null ? void 0 : _a.find((c) => c.chainId === 137);
    const chain = polygonChain || c137;
    multichainRegistry = new Contract(getMultichainRegistryAddress(), TWRegistryABI, getChainProvider(chain, sdkOptions));
  }
  const importedUri = await multichainRegistry.getMetadataUri(chainId, address);
  return importedUri;
}
async function fetchAbiFromAddress(address, provider2, storage) {
  try {
    const metadata = await fetchContractMetadataFromAddress(address, provider2, storage);
    if (metadata && metadata.abi) {
      return metadata.abi;
    }
  } catch (e) {
  }
  return void 0;
}
async function getCompositeABIfromRelease(publishMetadataUri, storage) {
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  const compositeAbi = (extendedMetadata == null ? void 0 : extendedMetadata.compositeAbi) || [];
  return compositeAbi;
}
var ERROR_SUBSTRINGS = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"];
var ERROR_SUBSTRINGS_COMPOSITE = [["account", "not found"], ["wrong", "chainid"]];
var CUSTOM_GAS_FOR_CHAIN = {
  [5001]: {
    name: "Mantle Testnet",
    gasPrice: 1
  },
  [71402]: {
    name: "Godwoken Mainnet",
    gasPrice: 4e4 * 10 ** 9
  },
  [1351057110]: {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 1e5
  },
  [361]: {
    name: "Theta Mainnet",
    gasPrice: 4e3 * 10 ** 9
  },
  [365]: {
    name: "Theta Testnet",
    gasPrice: 4e3 * 10 ** 9
  },
  [7700]: {
    name: "Canto",
    gasPrice: 1e3 * 10 ** 9
  },
  [7701]: {
    name: "Canto Testnet",
    gasPrice: 1e3 * 10 ** 9
  },
  [338]: {
    name: "Cronos Testnet",
    gasPrice: 2e3 * 10 ** 9
  },
  [47]: {
    name: "Xpla Testnet",
    gasPrice: 850 * 10 ** 9
  },
  [37]: {
    name: "Xpla Mainnet",
    gasPrice: 5100 * 10 ** 9
  },
  [199]: {
    name: "BitTorrent Chain",
    gasPrice: 3e5 * 10 ** 9
  },
  [88882]: {
    name: "Spicy Chain",
    gasPrice: 2500 * 10 ** 9,
    gasLimit: 2e5
  },
  [88888]: {
    name: "Chiliz Chain",
    gasPrice: 2500 * 10 ** 9,
    gasLimit: 2e5
  }
};
function matchError(error) {
  const errorIndex = ERROR_SUBSTRINGS.findIndex((substring) => error.includes(substring));
  const compositeErrorIndex = ERROR_SUBSTRINGS_COMPOSITE.findIndex((arr) => {
    let foundError = true;
    arr.forEach((substring) => {
      foundError && (foundError = error.includes(substring));
    });
    return foundError;
  });
  return errorIndex !== -1 || compositeErrorIndex !== -1;
}
var CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
var SIGNATURE = {
  v: 27,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
var COMMON_FACTORY = "0x4e59b44847b379578588920cA78FbF26c0B4956C";
var GAS_LIMIT_FOR_DEPLOYER = 5e6;
var DEPLOYER_BYTECODE = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033";
var DEPLOYER_ABI = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "predictedAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "to",
      type: "address"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IDeployer.Transaction[]",
    name: "transactions",
    type: "tuple[]"
  }],
  stateMutability: "payable",
  type: "constructor"
}];
async function isContractDeployed(address, provider2) {
  const code = await provider2.getCode(address);
  return code !== "0x" && code !== "0x0";
}
async function isEIP155Enforced(provider2) {
  try {
    await provider2.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e) {
    const errorMsg = e.toString().toLowerCase();
    const errorJson = JSON.stringify(e).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      return true;
    }
    return false;
  }
  return false;
}
function getKeylessTxn(transaction, signature) {
  const digest = utils_exports.arrayify(utils_exports.keccak256(utils_exports.serializeTransaction(transaction)));
  const signer = utils_exports.recoverAddress(digest, signature);
  const signedSerializedTx = utils_exports.serializeTransaction(transaction, signature);
  return {
    signer,
    transaction: signedSerializedTx
  };
}
function getCreate2FactoryDeploymentInfo(chainId, gasOptions) {
  const signature = utils_exports.joinSignature(SIGNATURE);
  const deploymentTransaction = getKeylessTxn({
    gasPrice: gasOptions.gasPrice ? gasOptions.gasPrice : 100 * 10 ** 9,
    gasLimit: gasOptions.gasLimit ? gasOptions.gasLimit : 1e5,
    nonce: 0,
    data: CREATE2_FACTORY_BYTECODE,
    chainId
  }, signature);
  const create2FactoryAddress = utils_exports.getContractAddress({
    from: deploymentTransaction.signer,
    nonce: 0
  });
  return {
    ...deploymentTransaction,
    deployment: create2FactoryAddress
  };
}
async function getCreate2FactoryAddress(provider2) {
  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, provider2);
  if (commonFactoryExists) {
    return COMMON_FACTORY;
  }
  const enforceEip155 = await isEIP155Enforced(provider2);
  const networkId = (await provider2.getNetwork()).chainId;
  const chainId = enforceEip155 ? networkId : 0;
  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, {
    gasPrice: CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice,
    gasLimit: CUSTOM_GAS_FOR_CHAIN[networkId].gasLimit
  }) : getCreate2FactoryDeploymentInfo(chainId, {});
  return deploymentInfo.deployment;
}
var bytecode = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";
function getSaltHash(bytecode2) {
  const bytecodePrefixed = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
  const bytecodeHash = utils_exports.id(bytecodePrefixed);
  const salt = `tw.${bytecodeHash}`;
  const saltHash = utils_exports.id(salt);
  return saltHash;
}
function getInitBytecodeWithSalt(bytecode2, encodedArgs, salt) {
  const bytecodePrefixed = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
  const saltHash = salt ? utils_exports.id(salt) : getSaltHash(bytecodePrefixed);
  const initBytecodeWithSalt = utils_exports.solidityPack(["bytes32", "bytes", "bytes"], [saltHash, bytecodePrefixed, encodedArgs]);
  return initBytecodeWithSalt;
}
function computeDeploymentAddress(bytecode2, encodedArgs, create2FactoryAddress, salt) {
  const bytecodePrefixed = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
  const saltHash = salt ? utils_exports.id(salt) : getSaltHash(bytecodePrefixed);
  const initBytecode = utils_exports.solidityPack(["bytes", "bytes"], [bytecodePrefixed, encodedArgs]);
  const deployInfoPacked = utils_exports.solidityPack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", create2FactoryAddress, saltHash, utils_exports.solidityKeccak256(["bytes"], [initBytecode])]);
  const hashedDeployInfo = utils_exports.solidityKeccak256(["bytes"], [deployInfoPacked]);
  return `0x${hashedDeployInfo.slice(26)}`;
}
var ChainId = function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
  ChainId2[ChainId2["Mumbai"] = 80001] = "Mumbai";
  ChainId2[ChainId2["Localhost"] = 1337] = "Localhost";
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Fantom"] = 250] = "Fantom";
  ChainId2[ChainId2["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId2[ChainId2["Avalanche"] = 43114] = "Avalanche";
  ChainId2[ChainId2["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId2[ChainId2["Optimism"] = 10] = "Optimism";
  ChainId2[ChainId2["OptimismGoerli"] = 420] = "OptimismGoerli";
  ChainId2[ChainId2["Arbitrum"] = 42161] = "Arbitrum";
  ChainId2[ChainId2["ArbitrumGoerli"] = 421613] = "ArbitrumGoerli";
  ChainId2[ChainId2["BinanceSmartChainMainnet"] = 56] = "BinanceSmartChainMainnet";
  ChainId2[ChainId2["BinanceSmartChainTestnet"] = 97] = "BinanceSmartChainTestnet";
  return ChainId2;
}({});
var NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "Görli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  11155111: {
    name: "Sepolia Ether",
    symbol: "SEP",
    decimals: 18,
    wrapped: {
      address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumGoerli]: {
    name: "Arbitrum Goerli Ether",
    symbol: "AGOR",
    decimals: 18,
    wrapped: {
      address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismGoerli]: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.BinanceSmartChainMainnet]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18,
    wrapped: {
      address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      name: "Wrapped Binance Chain Token",
      symbol: "WBNB"
    }
  },
  [ChainId.BinanceSmartChainTestnet]: {
    name: "Binance Chain Native Token",
    symbol: "TBNB",
    decimals: 18,
    wrapped: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      name: "Wrapped Binance Chain Testnet Token",
      symbol: "WBNB"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Localhost]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  84531: {
    name: "Base Goerli Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  // eslint-disable-next-line no-useless-computed-key
  [280]: {
    name: "zkSync Era Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  }
};
function getNativeTokenByChainId(chainId) {
  const chain = getSupportedChains().find((c) => c.chainId === chainId);
  if (chain && chain.nativeCurrency) {
    return {
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: 18,
      wrapped: {
        address: lib_exports.AddressZero,
        name: `Wrapped ${chain.nativeCurrency.name}`,
        symbol: `W${chain.nativeCurrency.symbol}`
      }
    };
  }
  return NATIVE_TOKENS[chainId] || {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: lib_exports.AddressZero,
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  };
}
var LINK_TOKEN_ADDRESS = {
  [ChainId.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
  [ChainId.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
  [ChainId.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
  [ChainId.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
  [ChainId.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
  [ChainId.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
  [ChainId.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
};
function extractConstructorParamsFromAbi(abi) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "constructor") {
      return input.inputs || [];
    }
  }
  return [];
}
var caches = {
  deploymentPresets: {}
};
function getRoyaltyEngineV1ByChainId(chainId) {
  return ROYALTY_ENGINE_V1_ADDRESS[chainId] || lib_exports.AddressZero;
}
var ROYALTY_ENGINE_V1_ADDRESS = {
  [ChainId.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
  [ChainId.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
  [ChainId.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
  [ChainId.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
};
var AddressZero = "0x0000000000000000000000000000000000000000";
async function computeDeploymentInfo(contractType, provider2, storage, create2Factory, contractOptions, clientId, secretKey) {
  const contractName = contractOptions && contractOptions.contractName;
  const version = contractOptions && contractOptions.version;
  let publisherAddress = contractOptions && contractOptions.publisherAddress;
  let metadata = contractOptions && contractOptions.metadata;
  invariant(contractName || metadata, "Require contract name or metadata");
  if (contractName && caches.deploymentPresets[contractName]) {
    return caches.deploymentPresets[contractName];
  }
  if (contractName === "WETH9") {
    const address2 = computeDeploymentAddress(bytecode, [], create2Factory);
    const contractDeployed2 = await isContractDeployed(address2, provider2);
    let initBytecodeWithSalt2 = "";
    if (!contractDeployed2) {
      initBytecodeWithSalt2 = getInitBytecodeWithSalt(bytecode, []);
    }
    return {
      name: contractName,
      type: contractType,
      transaction: {
        predictedAddress: address2,
        to: create2Factory,
        data: initBytecodeWithSalt2
      }
    };
  }
  if (!metadata) {
    invariant(contractName, "Require contract name");
    if (!publisherAddress) {
      publisherAddress = THIRDWEB_DEPLOYER;
    }
    const publishedContract = await fetchPublishedContractFromPolygon(publisherAddress, contractName, version, storage, clientId, secretKey);
    metadata = (await fetchAndCacheDeployMetadata(publishedContract.metadataUri, storage)).compilerMetadata;
  }
  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider2, storage, create2Factory, contractOptions == null ? void 0 : contractOptions.constructorParams, clientId, secretKey);
  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);
  const contractDeployed = await isContractDeployed(address, provider2);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);
  }
  return {
    name: contractName,
    type: contractType,
    transaction: {
      predictedAddress: address,
      to: create2Factory,
      data: initBytecodeWithSalt
    },
    encodedArgs
  };
}
async function encodeConstructorParamsForImplementation(compilerMetadata, provider2, storage, create2Factory, constructorParamMap, clientId, secretKey) {
  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata.abi);
  const constructorParamTypes = constructorParams.map((p) => {
    if (p.type === "tuple[]" || p.type === "tuple") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const constructorParamValues = await Promise.all(constructorParams.map(async (p) => {
    if (constructorParamMap && constructorParamMap[p.name]) {
      if (constructorParamMap[p.name].type) {
        invariant(constructorParamMap[p.name].type === p.type, `Provided type ${constructorParamMap[p.name].type} doesn't match the actual type ${p.type} from Abi`);
      }
      return constructorParamMap[p.name].value;
    }
    if (p.name && p.name.includes("nativeTokenWrapper")) {
      return await nativeTokenInputArg(provider2, storage, create2Factory, clientId, secretKey);
    } else if (p.name && p.name.includes("trustedForwarder")) {
      if (compilerMetadata.name === "Pack") {
        return AddressZero;
      }
      const deploymentInfo = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
        contractName: "Forwarder"
      }, clientId, secretKey);
      if (!caches.deploymentPresets["Forwarder"]) {
        caches.deploymentPresets["Forwarder"] = deploymentInfo;
      }
      return deploymentInfo.transaction.predictedAddress;
    } else if (p.name && p.name.includes("royaltyEngineAddress")) {
      const chainId = (await provider2.getNetwork()).chainId;
      return getRoyaltyEngineV1ByChainId(chainId);
    } else if (p.name && p.name.includes("marketplaceV3Params")) {
      const chainId = (await provider2.getNetwork()).chainId;
      const royaltyEngineAddress = getRoyaltyEngineV1ByChainId(chainId);
      const nativeTokenWrapper = await nativeTokenInputArg(provider2, storage, create2Factory, clientId, secretKey);
      const extensions = constructorParamMap ? constructorParamMap["_extensions"].value : [];
      return {
        extensions,
        royaltyEngineAddress,
        nativeTokenWrapper
      };
    } else {
      throw new Error("Can't resolve constructor arguments");
    }
  }));
  const encodedArgs = utils_exports.defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);
  return encodedArgs;
}
async function nativeTokenInputArg(provider2, storage, create2Factory, clientId, secretKey) {
  const chainId = (await provider2.getNetwork()).chainId;
  let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;
  if (nativeTokenWrapperAddress === lib_exports.AddressZero) {
    const deploymentInfo = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
      contractName: "WETH9"
    }, clientId, secretKey);
    if (!caches.deploymentPresets["WETH9"]) {
      caches.deploymentPresets["WETH9"] = deploymentInfo;
    }
    nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;
  }
  return nativeTokenWrapperAddress;
}
async function computeEOAForwarderAddress(provider2, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "ForwarderEOAOnly"
  }, clientId, secretKey)).transaction.predictedAddress;
}
async function computeForwarderAddress(provider2, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "Forwarder"
  }, clientId, secretKey)).transaction.predictedAddress;
}
var NotFoundError = class extends Error {
  /** @internal */
  constructor(identifier) {
    super(identifier ? `Object with id ${identifier} NOT FOUND` : "NOT_FOUND");
  }
};
var InvalidAddressError = class extends Error {
  /** @internal */
  constructor(address) {
    super(address ? `'${address}' is an invalid address` : "Invalid address passed");
  }
};
var MissingRoleError = class extends Error {
  /** @internal */
  /** @internal */
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
};
var AssetNotFoundError = class extends Error {
  /** @internal */
  /** @internal */
  constructor() {
    let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "The asset you're trying to use could not be found.";
    super(`message: ${message}`);
  }
};
var UploadError = class extends Error {
  /** @internal */
  constructor(message) {
    super(`UPLOAD_FAILED: ${message}`);
  }
};
var FileNameMissingError = class extends Error {
  /** @internal */
  constructor() {
    super("File name is required when object is not a `File` type object.");
  }
};
var DuplicateFileNameError = class extends Error {
  /** @internal */
  constructor(fileName) {
    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);
  }
};
var NotEnoughTokensError = class extends Error {
  /** @internal */
  constructor(contractAddress, quantity, available) {
    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);
  }
};
var MissingOwnerRoleError = class extends Error {
  /** @internal */
  constructor() {
    super(`LIST ERROR: you should be the owner of the token to list it.`);
  }
};
var QuantityAboveLimitError = class extends Error {
  /** @internal */
  constructor(quantity) {
    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);
  }
};
var FetchError = class extends Error {
  /** @internal */
  constructor(message, innerError) {
    super(`FETCH_FAILED: ${message}`);
    this.innerError = innerError;
  }
};
var DuplicateLeafsError = class extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
};
var AuctionAlreadyStartedError = class extends Error {
  constructor(id) {
    super(`Auction already started with existing bid${id ? `, id: ${id}` : ""}`);
  }
};
var FunctionDeprecatedError = class extends Error {
  /** @internal */
  constructor(message) {
    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : ""}`);
  }
};
var ListingNotFoundError = class extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
};
var WrongListingTypeError = class extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
};
var RestrictedTransferError = class extends Error {
  constructor(assetAddress) {
    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : ""}`);
  }
};
var AdminRoleMissingError = class extends Error {
  constructor(address, contractAddress) {
    let message = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Failed to execute transaction";
    super(`${message}, admin role is missing${address ? ` on address: ${address}` : ""}${contractAddress ? ` on contract: ${contractAddress}` : ""}`);
  }
};
var AuctionHasNotEndedError = class extends Error {
  constructor(id, endTime) {
    super(`Auction has not ended yet${id ? `, id: ${id}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
};
var ExtensionNotImplementedError = class extends Error {
  constructor(feature) {
    super(`This functionality is not available because the contract does not implement the '${feature.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/contracts/build/extensions `);
  }
};
var _reason, _info, _raw;
var TransactionError = class extends Error {
  constructor(info, raw) {
    var _a;
    let errorMessage = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
    errorMessage += `Reason: ${info.reason}`;
    errorMessage += `


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
`;
    errorMessage += withSpaces("from", info.from);
    if (info.to) {
      errorMessage += withSpaces("to", info.contractName ? `${info.to} (${info.contractName})` : info.to);
    }
    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);
    if (info.rpcUrl) {
      try {
        const url = new URL(info.rpcUrl);
        errorMessage += withSpaces(`rpc`, url.hostname);
      } catch (e2) {
      }
    }
    if (info.hash) {
      errorMessage += withSpaces(`tx hash`, info.hash);
    }
    if (info.value && info.value.gt(0)) {
      errorMessage += withSpaces("value", `${utils_exports.formatEther(info.value)} ${((_a = NATIVE_TOKENS[info.network.chainId]) == null ? void 0 : _a.symbol) || ""}`);
    }
    errorMessage += withSpaces(`data`, `${info.data}`);
    if (info.method) {
      errorMessage += withSpaces("method", info.method);
    }
    if (info.sources) {
      const revertFile = info.sources.find((file) => file.source.includes(info.reason));
      if (revertFile) {
        const lines = revertFile.source.split("\n").map((line, index) => `${index + 1}  ${line}`);
        const revertLine = lines.findIndex((line) => line.includes(info.reason));
        lines[revertLine] += "   <-- REVERT";
        const errorLines = lines.slice(revertLine - 8, revertLine + 4);
        errorMessage += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

`;
        errorMessage += `File: ${revertFile.filename.replace("node_modules/", "")}

`;
        errorMessage += errorLines.join("\n");
      }
    }
    errorMessage += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

`;
    errorMessage += `Need helping debugging? Visit our support site: https://thirdweb.com/support`;
    errorMessage += `

`;
    super(errorMessage);
    __privateAdd(this, _reason, void 0);
    __privateAdd(this, _info, void 0);
    __privateAdd(this, _raw, void 0);
    __privateSet(this, _reason, info.reason);
    __privateSet(this, _info, info);
    __privateSet(this, _raw, raw);
  }
  // Keep reason here for backwards compatibility
  get reason() {
    return __privateGet(this, _reason);
  }
  get raw() {
    return __privateGet(this, _raw);
  }
  get info() {
    return __privateGet(this, _info);
  }
};
_reason = new WeakMap();
_info = new WeakMap();
_raw = new WeakMap();
function parseRevertReason(error) {
  if (error.reason && !error.reason.includes("cannot estimate gas")) {
    return error.reason;
  }
  if (error.error) {
    return error.error;
  }
  let errorString = error;
  if (typeof error === "object") {
    errorString = JSON.stringify(error);
  } else if (typeof error !== "string") {
    errorString = error.toString();
  }
  return parseMessageParts(/.*?"message":"([^"\\]*).*?/, errorString) || parseMessageParts(/.*?"reason":"([^"\\]*).*?/, errorString) || error.message || "";
}
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  if (content.includes("\n")) {
    content = "\n\n  " + content.split("\n").join(`
  `);
  } else {
    content = `${spaces}${content}`;
  }
  return `
${label}:${content}`;
}
function parseMessageParts(regex, raw) {
  const msgMatches = raw.match(regex) || [];
  let extracted = "";
  if ((msgMatches == null ? void 0 : msgMatches.length) > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}
function includesErrorMessage(err, message) {
  if (!err) {
    return false;
  }
  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);
}
async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async (_ref) => {
    let [path, info] = _ref;
    const urls = info.urls;
    const ipfsLink = urls ? urls.find((url) => url.includes("ipfs")) : void 0;
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 3e3));
      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: info.content || "Could not find source for this contract"
      };
    }
  }));
}
var ForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}];
var ChainAwareForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}, {
  name: "chainid",
  type: "uint256"
}];
var BiconomyForwarderAbi = [{
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "uint256",
    name: "batchId",
    type: "uint256"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
var _nonces = {};
var _noncesSyncTimestamp = {};
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  const shouldSync = Date.now() - timestamp >= 2e3;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = BigNumber.from(_nonces[address]).add(1);
  return nonce;
}
async function signTypedDataInternal(signerInput, domain, types, message) {
  var _a, _b;
  let signer = signerInput;
  if (signerInput.originalSigner) {
    signer = signerInput.originalSigner;
  }
  const provider2 = signer == null ? void 0 : signer.provider;
  if (!provider2) {
    throw new Error("missing provider");
  }
  const payload = utils_exports._TypedDataEncoder.getPayload(domain, types, message);
  let signature = "";
  const signerAddress = (await signer.getAddress()).toLowerCase();
  if ((_a = provider2 == null ? void 0 : provider2.provider) == null ? void 0 : _a.isWalletConnect) {
    signature = await provider2.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
  } else {
    try {
      signature = await signer._signTypedData(domain, types, message);
    } catch (err) {
      if ((_b = err == null ? void 0 : err.message) == null ? void 0 : _b.includes("eth_signTypedData_v4")) {
        signature = await provider2.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
      } else {
        try {
          await provider2.send("eth_signTypedData_v4", [signerAddress, JSON.stringify(payload)]);
        } catch (finalErr) {
          throw finalErr;
        }
      }
    }
  }
  return {
    payload,
    signature: utils_exports.joinSignature(utils_exports.splitSignature(signature))
  };
}
var NAME_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var DOMAIN_SEPARATOR_ABI = [{
  constant: true,
  inputs: [],
  name: "DOMAIN_SEPARATOR",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getDomainSeperator",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}];
var NONCES_ABI = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "nonces",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "user",
    type: "address"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "nonce",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
async function getSignerNonce(signer, contractAddress) {
  const contract = new Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
async function getDomainSeperator(signer, contractAddress) {
  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    try {
      return await contract.getDomainSeperator();
    } catch (err2) {
      console.error("Error getting domain separator", err2);
    }
  }
}
async function getTokenName(signer, contractAddress) {
  return new Contract(contractAddress, NAME_ABI, signer).name();
}
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: utils_exports.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (utils_exports._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {
  const [name, chainId, signerNonce] = await Promise.all([getTokenName(signer, currencyAddress), signer.getChainId(), getSignerNonce(signer, currencyAddress)]);
  const domain = await getChainDomainSeperator(signer, {
    name,
    version: "1",
    chainId,
    verifyingContract: currencyAddress
  });
  nonce = nonce || signerNonce.toString();
  deadline = deadline || lib_exports.MaxUint256;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types = {
    Permit: [{
      name: "owner",
      type: "address"
    }, {
      name: "spender",
      type: "address"
    }, {
      name: "value",
      type: "uint256"
    }, {
      name: "nonce",
      type: "uint256"
    }, {
      name: "deadline",
      type: "uint256"
    }]
  };
  const {
    signature
  } = await signTypedDataInternal(signer, domain, types, message);
  return {
    message,
    signature
  };
}
var TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
var TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";
var OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";
var CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Goerli]: {
    openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.FantomTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
    biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.ArbitrumGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Optimism]: {
    openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.OptimismGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.BinanceSmartChainMainnet]: {
    openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
    openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.BinanceSmartChainTestnet]: {
    openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.Hardhat]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Localhost]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  }
};
function getContractAddressByChainId(chainId, contractName) {
  var _a;
  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {
    if (contractName === "twFactory") {
      return getProcessEnv2("factoryAddress");
    } else if (contractName === "twRegistry") {
      return getProcessEnv2("registryAddress");
    } else {
      return AddressZero;
    }
  }
  return (_a = CONTRACT_ADDRESSES[chainId]) == null ? void 0 : _a[contractName];
}
var EventType = function(EventType2) {
  EventType2["Transaction"] = "transaction";
  EventType2["Signature"] = "signature";
  return EventType2;
}({});
var CallOverrideSchema = (() => z.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: z.union([z.string(), z.number()]).optional(),
  from: AddressOrEnsSchema.optional(),
  type: z.number().optional()
}).strict())();
var RPCConnectionHandler = class extends eventemitter3_default {
  constructor(network, options) {
    super();
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    const [signer, provider2] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider2;
  }
  /**
   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.
   *
   * @param network - a network, signer or provider that ethers js can interpret
   */
  updateSignerOrProvider(network) {
    const [signer, provider2] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider2;
  }
  /**
   *
   * @returns whether or not a signer is set, `true` if there is no signer so the class is in "read only" mode
   */
  isReadOnly() {
    return !isSigner(this.signer);
  }
  /**
   * Explicitly get the active signer.
   * @returns The active signer, if there is one
   */
  getSigner() {
    return this.signer;
  }
  /**
   * Explicitly get the active provider.
   * @returns The active provider
   */
  getProvider() {
    return this.provider;
  }
  /**
   *
   * @returns The current signer if there is one, otherwise the active provider
   */
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
};
var ContractWrapper = class _ContractWrapper extends RPCConnectionHandler {
  /**
   * @internal
   */
  constructor(network, contractAddress, contractAbi, options, storage) {
    super(network, options);
    __publicField(this, "isValidContract", false);
    __publicField(this, "customOverrides", () => ({}));
    this.abi = AbiSchema.parse(contractAbi);
    this.address = contractAddress;
    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
    this.storage = storage;
    this.functions = extractFunctionsFromAbi(this.abi);
    this.extensions = detectFeatures(this.abi);
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateAbi(updatedAbi) {
    this.writeContract = new Contract(this.address, updatedAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
    this.abi = AbiSchema.parse(updatedAbi);
    this.functions = extractFunctionsFromAbi(this.abi);
    this.extensions = detectFeatures(this.abi);
  }
  /**
   * @internal
   */
  async getChainID() {
    const provider2 = this.getProvider();
    const {
      chainId
    } = await provider2.getNetwork();
    return chainId;
  }
  /**
   * @internal
   */
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }
  /**
   * @internal
   */
  callStatic() {
    return this.writeContract.callStatic;
  }
  /**
   * @internal
   */
  async getCallOverrides() {
    {
      return {};
    }
  }
  /**
   * @internal
   */
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }
  /**
   * @internal
   */
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [encoded]);
  }
  /**
   * @internal
   */
  async estimateGas(fn, args) {
    return this.writeContract.estimateGas[fn](...args);
  }
  /**
   * @internal
   */
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }
  /**
   *
   * @param functionName - The function name on the contract to call
   * @param args - The arguments to be passed to the functionName
   * @returns The return value of the function call
   */
  async read(functionName, args) {
    const functions = this.functions.filter((f) => f.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName.toString()}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find((f) => f.name === functionName && f.inputs.length === args.length);
    if (!fn) {
      throw new Error(`Function "${functionName.toString()}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName.toString()}(${fn.inputs.map((i) => i.type).join()})`;
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      const result = await this.readContract[fnName.toString()](...args);
      return result;
    }
    throw new Error("Cannot call a write function with read()");
  }
  /**
   * @internal
   */
  async call(functionName) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let overrides = arguments.length > 2 ? arguments[2] : void 0;
    const txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : void 0;
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter((f) => f.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find((f) => f.name === functionName && f.inputs.length === args.length);
    if (!fn) {
      throw new Error(`Function "${functionName}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName}(${fn.inputs.map((i) => i.type).join()})`;
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);
    } else {
      const receipt = await this.sendTransaction(fnName, args, txOptions);
      return {
        receipt
      };
    }
  }
  /**
   * @internal
   */
  async sendTransaction(fn, args, callOverrides) {
    var _a;
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    callOverrides = {
      ...callOverrides,
      ...this.customOverrides()
    };
    this.customOverrides = () => ({});
    if (((_a = this.options) == null ? void 0 : _a.gasless) && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless || "engine" in this.options.gasless)) {
      if (fn === "multicall" && Array.isArray(args[0]) && args[0].length > 0) {
        const from = await this.getSignerAddress();
        args[0] = args[0].map((tx) => utils_exports.solidityPack(["bytes", "address"], [tx, from]));
      }
      const provider2 = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider2.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      if (!this.isValidContract) {
        const code = await this.getProvider().getCode(this.address);
        this.isValidContract = code !== "0x";
        if (!this.isValidContract) {
          throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
        }
      }
      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);
      let receipt;
      try {
        receipt = await tx.wait();
      } catch (err) {
        try {
          await this.writeContract.callStatic[fn](...args, ...callOverrides.value ? [{
            value: callOverrides.value
          }] : []);
        } catch (staticErr) {
          throw await this.formatError(staticErr, fn, args, callOverrides);
        }
        throw await this.formatError(err, fn, args, callOverrides);
      }
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }
  /**
   * @internal
   */
  async sendTransactionByFunction(fn, args, callOverrides) {
    const func = this.writeContract.functions[fn];
    if (!func) {
      throw new Error(`invalid function: "${fn.toString()}"`);
    }
    if (!callOverrides.gasLimit) {
      try {
        callOverrides.gasLimit = await this.writeContract.estimateGas[fn](...args, callOverrides);
      } catch (e) {
        try {
          await this.writeContract.callStatic[fn](...args, ...callOverrides.value ? [{
            value: callOverrides.value
          }] : []);
        } catch (err) {
          throw await this.formatError(err, fn, args, callOverrides);
        }
      }
    }
    try {
      return await func(...args, callOverrides);
    } catch (err) {
      throw await this.formatError(err, fn, args, callOverrides);
    }
  }
  async formatError(error, fn, args, callOverrides) {
    var _a, _b, _c;
    const provider2 = this.getProvider();
    const network = await provider2.getNetwork();
    const from = await (callOverrides.from || this.getSignerAddress());
    const to = this.address;
    const data = this.readContract.interface.encodeFunctionData(fn, args);
    const value = BigNumber.from(callOverrides.value || 0);
    const rpcUrl = (_a = provider2.connection) == null ? void 0 : _a.url;
    const functionSignature = this.readContract.interface.getFunction(fn);
    const methodArgs = args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash = error.transactionHash || ((_b = error.transaction) == null ? void 0 : _b.hash) || ((_c = error.receipt) == null ? void 0 : _c.transactionHash);
    const reason = parseRevertReason(error);
    let sources = void 0;
    let contractName = void 0;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
    }
    return new TransactionError({
      reason,
      from,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash,
      contractName,
      sources
    }, error);
  }
  /**
   * @internal
   */
  async sendGaslessTransaction(fn) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let callOverrides = arguments.length > 2 ? arguments[2] : void 0;
    const signer = this.getSigner();
    invariant(signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = (callOverrides == null ? void 0 : callOverrides.value) || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.readContract.estimateGas[fn](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(callOverrides.gasLimit);
    }
    const tx = {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter((x) => x.topics.indexOf(topic) >= 0);
    return parsedLogs.map((l) => this.writeContract.interface.parseLog(l));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    } else if (this.options.gasless && "openzeppelin" in this.options.gasless) {
      return this.defenderSendFunction(transaction);
    }
    return this.engineSendFunction(transaction);
  }
  async engineSendFunction(transaction) {
    var _a;
    invariant(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without engine config in the SDK options");
    const request = await this.enginePrepareRequest(transaction);
    const res = await fetch(this.options.gasless.engine.relayerUrl, {
      ...request,
      headers: {
        "Content-Type": "application/json"
      }
    });
    const data = await res.json();
    if (data.error) {
      throw new Error(((_a = data.error) == null ? void 0 : _a.message) || JSON.stringify(data.error));
    }
    const queueId = data.result.queueId;
    const engineUrl = this.options.gasless.engine.relayerUrl.split("/relayer/")[0];
    const startTime = Date.now();
    while (true) {
      const txRes = await fetch(`${engineUrl}/transaction/status/${queueId}`);
      const txData = await txRes.json();
      if (txData.result.transactionHash) {
        return txData.result.transactionHash;
      }
      if (Date.now() - startTime > 30 * 1e3) {
        throw new Error("timeout");
      }
      await new Promise((resolve) => setTimeout(resolve, 2e3));
    }
  }
  async enginePrepareRequest(transaction) {
    var _a;
    invariant(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    const storage = this.storage;
    invariant(signer, "signer is not set");
    try {
      const {
        abi
      } = await fetchContractMetadataFromAddress(transaction.to, provider2, storage);
      const chainId = (await provider2.getNetwork()).chainId;
      const contract = new _ContractWrapper(signer, transaction.to, abi, {}, storage);
      if (abi.find((item) => item.name === "executeMetaTransaction")) {
        const name = await contract.call("name", []);
        const domain = {
          name,
          version: "1",
          salt: "0x" + chainId.toString(16).padStart(64, "0"),
          // Use 64 length hex chain id as salt
          verifyingContract: transaction.to
        };
        const types = {
          MetaTransaction: [{
            name: "nonce",
            type: "uint256"
          }, {
            name: "from",
            type: "address"
          }, {
            name: "functionSignature",
            type: "bytes"
          }]
        };
        const nonce = await contract.call("getNonce", [transaction.from]);
        const message = {
          nonce,
          from: transaction.from,
          functionSignature: transaction.data
        };
        const {
          signature
        } = await signTypedDataInternal(signer, domain, types, message);
        return {
          method: "POST",
          body: JSON.stringify({
            type: "execute-meta-transaction",
            request: {
              from: transaction.from,
              to: transaction.to,
              data: transaction.data
            },
            signature
          })
        };
      }
    } catch {
    }
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);
      const message = {
        to: transaction.to,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString()
      };
      return {
        method: "POST",
        body: JSON.stringify({
          type: "permit",
          request: message,
          signature: sig
        })
      };
    } else {
      const forwarderAddress = this.options.gasless.engine.relayerForwarderAddress || ((_a = CONTRACT_ADDRESSES[transaction.chainId]) == null ? void 0 : _a.openzeppelinForwarder) || await computeForwarderAddress(provider2, storage);
      const ForwarderABI = (await import("./Forwarder-7RZQS6L7.js")).default;
      const forwarder = new Contract(forwarderAddress, ForwarderABI, provider2);
      const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
      let domain;
      let types;
      let message;
      if (this.options.gasless.experimentalChainlessSupport) {
        domain = {
          name: "GSNv2 Forwarder",
          version: "0.0.1",
          verifyingContract: forwarderAddress
        };
        types = {
          ForwardRequest: ChainAwareForwardRequest
        };
        message = {
          from: transaction.from,
          to: transaction.to,
          value: BigNumber.from(0).toString(),
          gas: BigNumber.from(transaction.gasLimit).toString(),
          nonce: BigNumber.from(nonce).toString(),
          data: transaction.data,
          chainid: BigNumber.from(transaction.chainId).toString()
        };
      } else {
        domain = {
          name: this.options.gasless.engine.domainName,
          version: this.options.gasless.engine.domainVersion,
          chainId: transaction.chainId,
          verifyingContract: forwarderAddress
        };
        types = {
          ForwardRequest
        };
        message = {
          from: transaction.from,
          to: transaction.to,
          value: BigNumber.from(0).toString(),
          gas: BigNumber.from(transaction.gasLimit).toString(),
          nonce: BigNumber.from(nonce).toString(),
          data: transaction.data
        };
      }
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      const signature = sig;
      return {
        method: "POST",
        body: JSON.stringify({
          type: "forward",
          request: message,
          signature,
          forwarderAddress
        })
      };
    }
  }
  async biconomySendFunction(transaction) {
    var _a, _b;
    invariant(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    invariant(signer && provider2, "signer and provider must be set");
    const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider2);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: lib_exports.AddressZero,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1e3 + (((_a = this.options) == null ? void 0 : _a.gasless) && "biconomy" in this.options.gasless && ((_b = this.options.gasless.biconomy) == null ? void 0 : _b.deadlineSeconds) || 3600)),
      data: transaction.data
    };
    const hashToSign = utils_exports.arrayify(utils_exports.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils_exports.keccak256(request.data)]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature
    });
    const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [request, signature],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    var _a, _b;
    invariant(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    invariant(signer, "provider is not set");
    invariant(provider2, "provider is not set");
    const ForwarderABI = (await import("./Forwarder-7RZQS6L7.js")).default;
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? ((_a = CONTRACT_ADDRESSES[transaction.chainId]) == null ? void 0 : _a.openzeppelinForwarderEOA) || await computeEOAForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey) : ((_b = CONTRACT_ADDRESSES[transaction.chainId]) == null ? void 0 : _b.openzeppelinForwarder) || await computeForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey));
    const forwarder = new Contract(forwarderAddress, ForwarderABI, provider2);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types;
    let message;
    if (this.options.gasless.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: this.options.gasless.openzeppelin.domainName,
        version: this.options.gasless.openzeppelin.domainVersion,
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    let signature;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);
      const {
        r,
        s,
        v
      } = utils_exports.splitSignature(sig);
      message = {
        to: this.address,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString(),
        r,
        s,
        v
      };
      signature = sig;
    } else {
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      signature = sig;
    }
    let messageType = "forward";
    if (message == null ? void 0 : message.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature
    });
    const response = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
};
function isFeatureEnabled(abi, featureName, features) {
  return _featureEnabled(features, featureName);
}
function isExtensionEnabled(abi, featureName, features) {
  return isFeatureEnabled(abi, featureName, features);
}
function _featureEnabled(features, featureName) {
  const keys = Object.keys(features);
  if (!keys.includes(featureName)) {
    let found = false;
    for (const key of keys) {
      const f = features[key];
      found = _featureEnabled(f.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}
async function getPluginABI(addresses, provider2, storage) {
  return (await Promise.all(addresses.map((address) => fetchContractMetadataFromAddress(address, provider2, storage).catch((err) => {
    console.error(`Failed to fetch plug-in for ${address}`, err);
    return {
      abi: []
    };
  })))).map((metadata) => metadata.abi);
}
async function getCompositeABI(address, abi, provider2, options, storage) {
  let pluginABIs = [];
  try {
    const features = detectFeatures(abi);
    const isPluginRouter = isExtensionEnabled(abi, "PluginRouter", features);
    const isbaseRouter = isExtensionEnabled(abi, "DynamicContract", features);
    const isFallback = isExtensionEnabled(abi, "Fallback", features);
    if (isbaseRouter) {
      const contract = new ContractWrapper(provider2, address, getAllExtensionsAbi, options, storage);
      const plugins = await contract.call("getAllExtensions");
      const pluginAddresses = plugins.map((item) => item.metadata.implementation);
      pluginABIs = await getPluginABI(pluginAddresses, provider2, storage);
    } else if (isPluginRouter) {
      const contract = new ContractWrapper(provider2, address, getAllPluginsAbi, options, storage);
      const pluginMap = await contract.call("getAllPlugins");
      const allPlugins = pluginMap.map((item) => item.pluginAddress);
      const plugins = Array.from(new Set(allPlugins));
      pluginABIs = await getPluginABI(plugins, provider2, storage);
    } else if (isFallback) {
      const dimaondAbi = ["function facets() external view returns (tuple(address,bytes4[])[])"];
      const contract = new Contract(address, dimaondAbi, provider2);
      const facets = await contract.facets();
      const facetAddresses = facets.map((item) => item[0]);
      pluginABIs = await getPluginABI(facetAddresses, provider2, storage);
    }
  } catch (err) {
  }
  return pluginABIs.length > 0 ? joinABIs([...pluginABIs], abi) : abi;
}
var roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE",
  factory: "FACTORY_ROLE",
  signer: "SIGNER_ROLE",
  metadata: "METADATA_ROLE",
  revoke: "REVOKE_ROLE",
  migration: "MIGRATION_ROLE"
};
var ALL_ROLES = (() => Object.keys(roleMap))();
function getRoleHash(role) {
  if (role === "admin") {
    return utils_exports.hexZeroPad([0], 32);
  }
  return utils_exports.id(roleMap[role]);
}
var DropErc1155ContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
var DropErc1155ContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
var DropErc1155ContractDeploy = (() => DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};
var DropErc20ContractInput = (() => CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema))();
var DropErc20ContractOutput = (() => CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema))();
var DropErc20ContractDeploy = (() => DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};
var DropErc721ContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
var DropErc721ContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
var DropErc721ContractDeploy = (() => DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};
var MarketplaceContractInput = CommonContractSchema;
var MarketplaceContractOutput = CommonContractOutputSchema;
var MarketplaceContractDeploy = (() => MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema))();
var MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};
var MultiwrapContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var MultiwrapContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var MultiwrapContractDeploy = (() => MultiwrapContractInput.merge(CommonTrustedForwarderSchema))();
var MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};
var PackContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var PackContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var PackContractDeploy = (() => PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema))();
var PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};
var SplitRecipientInputSchema = (() => z.object({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
}))();
var SplitRecipientOuputSchema = (() => SplitRecipientInputSchema.extend({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema
}))();
var SplitsContractInput = (() => CommonContractSchema.extend({
  recipients: z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index = 0; index < val.length; index++) {
      const entry = val[index];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [index, `address`]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 1e4) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [index, `sharesBps`]
        });
      }
    }
    if (totalShares !== 1e4) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
}))();
var SplitsContractOutput = (() => CommonContractOutputSchema.extend({
  recipients: z.array(SplitRecipientOuputSchema)
}))();
var SplitsContractDeploy = (() => SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema))();
var SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};
var TokenErc1155ContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var TokenErc1155ContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var TokenErc1155ContractDeploy = (() => TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};
var TokenErc20ContractInput = (() => CommonContractSchema.merge(CommonSymbolSchema))();
var TokenErc20ContractOutput = (() => CommonContractOutputSchema.merge(CommonSymbolSchema))();
var TokenErc20ContractDeploy = (() => TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};
var TokenErc721ContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var TokenErc721ContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var TokenErc721ContractDeploy = (() => TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};
var VoteSettingsInputSchema = (() => z.object({
  voting_delay_in_blocks: z.number().min(0).default(0),
  voting_period_in_blocks: z.number().min(1).default(1),
  voting_token_address: AddressOrEnsSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
}))();
var VoteSettingsOuputSchema = (() => VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema
}))();
var VoteContractInput = (() => CommonContractSchema.merge(VoteSettingsInputSchema))();
var VoteContractOutput = (() => CommonContractOutputSchema.merge(VoteSettingsOuputSchema))();
var VoteContractDeploy = (() => VoteContractInput.merge(CommonTrustedForwarderSchema))();
var VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
var ProposalOutputSchema = (() => z.object({
  proposalId: BigNumberSchema,
  proposer: z.string(),
  targets: z.array(z.string()),
  values: z.array(BigNumberSchema),
  signatures: z.array(z.string()),
  calldatas: z.array(z.string()),
  startBlock: BigNumberSchema,
  endBlock: BigNumberSchema,
  description: z.string()
}))();
var ADMIN_ROLE = ["admin"];
var NFT_BASE_CONTRACT_ROLES = ["admin", "minter", "transfer", "metadata"];
var MARKETPLACE_CONTRACT_ROLES = ["admin", "lister", "asset"];
var PACK_CONTRACT_ROLES = ["admin", "minter", "asset", "transfer"];
var TOKEN_DROP_CONTRACT_ROLES = ["admin", "transfer"];
var MULTIWRAP_CONTRACT_ROLES = ["admin", "transfer", "minter", "unwrap", "asset"];
var prebuiltContractTypes = {
  vote: "vote",
  token: "token",
  "edition-drop": "edition-drop",
  edition: "edition",
  marketplace: "marketplace",
  "marketplace-v3": "marketplace-v3",
  multiwrap: "multiwrap",
  "nft-collection": "nft-collection",
  "nft-drop": "nft-drop",
  pack: "pack",
  "signature-drop": "signature-drop",
  split: "split",
  "token-drop": "token-drop"
};
var EditionDropInitializer = {
  name: "DropERC1155",
  contractType: prebuiltContractTypes["edition-drop"],
  schema: DropErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    let [network, address, storage, options] = _ref;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionDropInitializer.getAbi(address, provider2, storage), import("./edition-drop-d7a823c2.browser.esm-464K6ZAV.js"), provider2.getNetwork()]);
    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 2 ? (await import("./DropERC1155-XHU3DBV4.js")).default : (await import("./DropERC1155_V2-CPV6E42I.js")).default;
  }
};
var EditionInitializer = {
  name: "TokenERC1155",
  contractType: prebuiltContractTypes["edition"],
  schema: TokenErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    let [network, address, storage, options] = _ref2;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider2, storage), import("./edition-da051f66.browser.esm-DFAHDDDH.js"), provider2.getNetwork()]);
    return new contract.Edition(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./TokenERC1155-5JMY6JGM.js")).default;
  }
};
var MarketplaceInitializer = {
  name: "Marketplace",
  contractType: prebuiltContractTypes.marketplace,
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _ref3[_key3] = arguments[_key3];
    }
    let [network, address, storage, options] = _ref3;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider2, storage), import("./marketplace-3f9edf56.browser.esm-JLF4B7XT.js"), provider2.getNetwork()]);
    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./Marketplace-NXUF3EVB.js")).default;
  }
};
var MarketplaceV3Initializer = {
  name: "MarketplaceV3",
  contractType: prebuiltContractTypes["marketplace-v3"],
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      _ref4[_key4] = arguments[_key4];
    }
    let [network, address, storage, options] = _ref4;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider2, storage, options), import("./marketplacev3-d4336a42.browser.esm-I2GDEPRD.js"), provider2.getNetwork()]);
    return new contract.MarketplaceV3(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage, options) => {
    const chainId = (await provider2.getNetwork()).chainId;
    const isZkSync = chainId === 280 || chainId === 324;
    if (isZkSync) {
      const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, "MarketplaceV3", "latest", storage, options == null ? void 0 : options.clientId, options == null ? void 0 : options.secretKey);
      const uri = publishedContract.metadataUri;
      const compositeAbi = await getCompositeABIfromRelease(uri, storage);
      return compositeAbi;
    }
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return await getCompositeABI(address, abi, provider2, {}, storage);
    }
    const localAbi = (await import("./MarketplaceV3-ZS5FJWED.js")).default;
    return await getCompositeABI(address, AbiSchema.parse(localAbi || []), provider2, {}, storage);
  }
};
var MultiwrapInitializer = {
  name: "Multiwrap",
  contractType: prebuiltContractTypes.multiwrap,
  schema: MultiwrapContractSchema,
  roles: MULTIWRAP_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      _ref5[_key5] = arguments[_key5];
    }
    let [network, address, storage, options] = _ref5;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider2, storage), import("./multiwrap-cff091c3.browser.esm-AYTDVNZT.js"), provider2.getNetwork()]);
    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./Multiwrap-GLWOSNLD.js")).default;
  }
};
var NFTCollectionInitializer = {
  name: "TokenERC721",
  contractType: prebuiltContractTypes["nft-collection"],
  schema: TokenErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      _ref6[_key6] = arguments[_key6];
    }
    let [network, address, storage, options] = _ref6;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider2, storage), import("./nft-collection-083c9a68.browser.esm-UOYAJBKW.js"), provider2.getNetwork()]);
    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./TokenERC721-MQLH4ABU.js")).default;
  }
};
var NFTDropInitializer = {
  name: "DropERC721",
  contractType: prebuiltContractTypes["nft-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      _ref7[_key7] = arguments[_key7];
    }
    let [network, address, storage, options] = _ref7;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider2, storage), import("./nft-drop-4f7bc814.browser.esm-NEMEHT6C.js"), provider2.getNetwork()]);
    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 3 ? (await import("./DropERC721-EHU3EQ5L.js")).default : (await import("./DropERC721_V3-OU33X6TN.js")).default;
  }
};
var PackInitializer = {
  name: "Pack",
  contractType: prebuiltContractTypes["pack"],
  schema: PackContractSchema,
  roles: PACK_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      _ref8[_key8] = arguments[_key8];
    }
    let [network, address, storage, options] = _ref8;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider2, storage), import("./pack-91228b06.browser.esm-E4G4T6K2.js"), provider2.getNetwork()]);
    return new contract.Pack(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return AbiSchema.parse((await import("./Pack-ADC6UKG3.js")).default || []);
  }
};
var SignatureDropInitializer = {
  name: "SignatureDrop",
  contractType: prebuiltContractTypes["signature-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      _ref9[_key9] = arguments[_key9];
    }
    let [network, address, storage, options] = _ref9;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider2, storage), import("./signature-drop-fae5d268.browser.esm-5ANIUBDC.js"), provider2.getNetwork()]);
    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 4 ? (await import("./SignatureDrop-YFR5JVAB.js")).default : (await import("./SignatureDrop_V4-HOLGQF2J.js")).default;
  }
};
var SplitInitializer = {
  name: "Split",
  contractType: prebuiltContractTypes["split"],
  schema: SplitsContractSchema,
  roles: ADMIN_ROLE,
  initialize: async function() {
    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      _ref10[_key10] = arguments[_key10];
    }
    let [network, address, storage, options] = _ref10;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider2, storage), import("./split-662e0eb9.browser.esm-DQQOVCQ3.js"), provider2.getNetwork()]);
    return new contract.Split(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./Split-CNIZVQV2.js")).default;
  }
};
var TokenDropInitializer = {
  name: "DropERC20",
  contractType: prebuiltContractTypes["token-drop"],
  schema: DropErc20ContractSchema,
  roles: TOKEN_DROP_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      _ref11[_key11] = arguments[_key11];
    }
    let [network, address, storage, options] = _ref11;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider2, storage), import("./token-drop-60b3a7e1.browser.esm-BWCD5P5R.js"), provider2.getNetwork()]);
    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 2 ? (await import("./DropERC20-3XICS5E5.js")).default : (await import("./DropERC20_V2-WRBFC3WJ.js")).default;
  }
};
var TokenInitializer = {
  name: "TokenERC20",
  contractType: prebuiltContractTypes.token,
  schema: TokenErc20ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      _ref12[_key12] = arguments[_key12];
    }
    let [network, address, storage, options] = _ref12;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider2, storage), import("./token-f628c2eb.browser.esm-7BYP46YX.js"), provider2.getNetwork()]);
    return new contract.Token(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./TokenERC20-H6NX2KQD.js")).default;
  }
};
var VoteInitializer = {
  name: "VoteERC20",
  contractType: prebuiltContractTypes.vote,
  schema: VoteContractSchema,
  roles: [],
  initialize: async function() {
    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      _ref13[_key13] = arguments[_key13];
    }
    let [network, address, storage, options] = _ref13;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider2, storage), import("./vote-372766c9.browser.esm-6KAOS34C.js"), provider2.getNetwork()]);
    return new contract.Vote(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./VoteERC20-QD6JK7P2.js")).default;
  }
};
async function getContractInfo(address, provider2) {
  try {
    return await getPrebuiltInfo(address, provider2);
  } catch (e) {
    return void 0;
  }
}
var PREBUILT_CONTRACTS_MAP = {
  [prebuiltContractTypes["edition-drop"]]: EditionDropInitializer,
  [prebuiltContractTypes.edition]: EditionInitializer,
  [prebuiltContractTypes.marketplace]: MarketplaceInitializer,
  [prebuiltContractTypes["marketplace-v3"]]: MarketplaceV3Initializer,
  [prebuiltContractTypes.multiwrap]: MultiwrapInitializer,
  [prebuiltContractTypes["nft-collection"]]: NFTCollectionInitializer,
  [prebuiltContractTypes["nft-drop"]]: NFTDropInitializer,
  [prebuiltContractTypes.pack]: PackInitializer,
  [prebuiltContractTypes["signature-drop"]]: SignatureDropInitializer,
  [prebuiltContractTypes.split]: SplitInitializer,
  [prebuiltContractTypes["token-drop"]]: TokenDropInitializer,
  [prebuiltContractTypes.token]: TokenInitializer,
  [prebuiltContractTypes.vote]: VoteInitializer
};
var PREBUILT_CONTRACTS_APPURI_MAP = {
  [prebuiltContractTypes["edition-drop"]]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
  [prebuiltContractTypes.edition]: "",
  [prebuiltContractTypes.marketplace]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
  [prebuiltContractTypes["marketplace-v3"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
  [prebuiltContractTypes.multiwrap]: "",
  [prebuiltContractTypes["nft-collection"]]: "",
  [prebuiltContractTypes["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.pack]: "",
  [prebuiltContractTypes["signature-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.split]: "",
  [prebuiltContractTypes["token-drop"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
  [prebuiltContractTypes.token]: "",
  [prebuiltContractTypes.vote]: ""
};
var SmartContract = {
  name: "SmartContract",
  contractType: "custom",
  schema: {},
  roles: ALL_ROLES
};
var CONTRACTS_MAP = {
  ...PREBUILT_CONTRACTS_MAP,
  [SmartContract.contractType]: SmartContract
};
function getContractTypeForRemoteName(name) {
  var _a;
  return ((_a = Object.values(CONTRACTS_MAP).find((contract) => contract.name === name)) == null ? void 0 : _a.contractType) || "custom";
}
function getContractName(type) {
  var _a;
  return (_a = Object.values(CONTRACTS_MAP).find((contract) => contract.contractType === type)) == null ? void 0 : _a.name;
}

// node_modules/@thirdweb-dev/sdk/dist/transactions-de84ba20.browser.esm.js
init_lib();
async function getDefaultGasOverrides(provider2) {
  if (provider2.originalProvider) {
    provider2 = provider2.originalProvider;
  }
  const feeData = await getDynamicFeeData(provider2);
  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
    return {
      maxFeePerGas: feeData.maxFeePerGas,
      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
    };
  } else {
    return {
      gasPrice: await getGasPrice(provider2)
    };
  }
}
async function getDynamicFeeData(provider2) {
  let maxFeePerGas = null;
  let maxPriorityFeePerGas = null;
  const [{
    chainId
  }, block, eth_maxPriorityFeePerGas] = await Promise.all([provider2.getNetwork(), provider2.getBlock("latest"), provider2.send("eth_maxPriorityFeePerGas", []).catch(() => null)]);
  const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : utils_exports.parseUnits("100", "wei");
  if (chainId === c220.chainId || chainId === c1220.chainId) {
    return {
      maxFeePerGas: null,
      maxPriorityFeePerGas: null,
      baseFee: null
    };
  } else if (chainId === c80001.chainId || chainId === c137.chainId) {
    maxPriorityFeePerGas = await getPolygonGasPriorityFee(chainId);
  } else if (eth_maxPriorityFeePerGas) {
    maxPriorityFeePerGas = BigNumber.from(eth_maxPriorityFeePerGas);
  } else {
    const feeData = await provider2.getFeeData();
    maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
    if (!maxPriorityFeePerGas) {
      return {
        maxFeePerGas: null,
        maxPriorityFeePerGas: null,
        baseFee: null
      };
    }
  }
  maxPriorityFeePerGas = getPreferredPriorityFee(maxPriorityFeePerGas);
  maxFeePerGas = baseBlockFee.mul(2).add(maxPriorityFeePerGas);
  return {
    maxFeePerGas,
    maxPriorityFeePerGas,
    baseFee: baseBlockFee
  };
}
function getPreferredPriorityFee(defaultPriorityFeePerGas) {
  let percentMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  const extraTip = defaultPriorityFeePerGas.div(100).mul(percentMultiplier);
  const totalPriorityFee = defaultPriorityFeePerGas.add(extraTip);
  return totalPriorityFee;
}
async function getGasPrice(provider2) {
  const gasPrice = await provider2.getGasPrice();
  const maxGasPrice = utils_exports.parseUnits("300", "gwei");
  const extraTip = gasPrice.div(100).mul(10);
  const txGasPrice = gasPrice.add(extraTip);
  if (txGasPrice.gt(maxGasPrice)) {
    return maxGasPrice;
  }
  return txGasPrice;
}
function getGasStationUrl(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation.polygon.technology/v2";
    case ChainId.Mumbai:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
}
var MIN_POLYGON_GAS_PRICE = (() => utils_exports.parseUnits("31", "gwei"))();
var MIN_MUMBAI_GAS_PRICE = (() => utils_exports.parseUnits("1", "gwei"))();
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return MIN_POLYGON_GAS_PRICE;
    case ChainId.Mumbai:
      return MIN_MUMBAI_GAS_PRICE;
  }
}
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await fetch(gasStationUrl)).json();
    const priorityFee = data["fast"]["maxPriorityFee"];
    if (priorityFee > 0) {
      const fixedFee = parseFloat(priorityFee).toFixed(9);
      return utils_exports.parseUnits(fixedFee, "gwei");
    }
  } catch (e) {
    console.error("failed to fetch gas", e);
  }
  return getDefaultGasFee(chainId);
}
function buildDeployTransactionFunction(fn) {
  async function executeFn() {
    const tx = await fn(...arguments);
    return tx.execute();
  }
  executeFn.prepare = fn;
  return executeFn;
}
function buildTransactionFunction(fn) {
  async function executeFn() {
    const tx = await fn(...arguments);
    return tx.execute();
  }
  executeFn.prepare = fn;
  return executeFn;
}
var TransactionContext = class {
  constructor(options) {
    this.args = options.args;
    this.overrides = options.overrides || {};
    this.provider = options.provider;
    this.signer = options.signer;
    this.storage = options.storage;
    if (!this.signer.provider) {
      this.signer = this.signer.connect(this.provider);
    }
  }
  get getSigner() {
    return this.signer;
  }
  get getProvider() {
    return this.provider;
  }
  get getStorage() {
    return this.storage;
  }
  getArgs() {
    return this.args;
  }
  getOverrides() {
    return this.overrides;
  }
  getValue() {
    return this.overrides.value || 0;
  }
  setArgs(args) {
    this.args = args;
    return this;
  }
  setOverrides(overrides) {
    this.overrides = overrides;
    return this;
  }
  updateOverrides(overrides) {
    this.overrides = {
      ...this.overrides,
      ...overrides
    };
    return this;
  }
  setValue(value) {
    this.updateOverrides({
      value
    });
    return this;
  }
  setGasLimit(gasLimit) {
    this.updateOverrides({
      gasLimit
    });
    return this;
  }
  setGasPrice(gasPrice) {
    this.updateOverrides({
      gasPrice
    });
    return this;
  }
  setNonce(nonce) {
    this.updateOverrides({
      nonce
    });
    return this;
  }
  setMaxFeePerGas(maxFeePerGas) {
    this.updateOverrides({
      maxFeePerGas
    });
    return this;
  }
  setMaxPriorityFeePerGas(maxPriorityFeePerGas) {
    this.updateOverrides({
      maxPriorityFeePerGas
    });
    return this;
  }
  setType(type) {
    this.updateOverrides({
      type
    });
    return this;
  }
  setAccessList(accessList) {
    this.updateOverrides({
      accessList
    });
    return this;
  }
  setCustomData(customData) {
    this.updateOverrides({
      customData
    });
    return this;
  }
  setCcipReadEnabled(ccipReadEnabled) {
    this.updateOverrides({
      ccipReadEnabled
    });
    return this;
  }
  /**
   * Set a multiple to multiply the gas limit by
   *
   * @example
   * ```js
   * // Set the gas limit multiple to 1.2 (increase by 20%)
   * tx.setGasLimitMultiple(1.2)
   * ```
   */
  setGasLimitMultiple(factor) {
    if (BigNumber.isBigNumber(this.overrides.gasLimit)) {
      this.overrides.gasLimit = BigNumber.from(Math.floor(BigNumber.from(this.overrides.gasLimit).toNumber() * factor));
    } else {
      this.gasMultiple = factor;
    }
  }
  /**
   * Estimate the total gas cost of this transaction (in both ether and wei)
   */
  async estimateGasCost() {
    const [gasLimit, gasPrice] = await Promise.all([this.estimateGasLimit(), this.getGasPrice()]);
    const gasCost = gasLimit.mul(gasPrice);
    return {
      ether: utils_exports.formatEther(gasCost),
      wei: gasCost
    };
  }
  /**
   * Calculates the gas price for transactions (adding a 10% tip buffer)
   */
  async getGasPrice() {
    return getGasPrice(this.provider);
  }
  /**
   * Get the address of the transaction signer
   */
  async getSignerAddress() {
    return this.signer.getAddress();
  }
  /**
   * Get gas overrides for the transaction
   */
  async getGasOverrides() {
    if (isBrowser()) {
      return {};
    }
    return getDefaultGasOverrides(this.provider);
  }
};
var Transaction = class _Transaction extends TransactionContext {
  static fromContractWrapper(options) {
    const signer = options.contractWrapper.getSigner();
    if (!signer) {
      throw new Error("Cannot create a transaction without a signer. Please ensure that you have a connected signer.");
    }
    const optionsWithContract = {
      ...options,
      contract: options.contractWrapper.writeContract,
      provider: options.contractWrapper.getProvider(),
      signer,
      gasless: options.contractWrapper.options.gasless,
      storage: options.contractWrapper.storage
    };
    return new _Transaction(optionsWithContract);
  }
  static async fromContractInfo(options) {
    const storage = options.storage;
    let contractAbi = options.contractAbi;
    if (!contractAbi) {
      try {
        const metadata = await fetchContractMetadataFromAddress(options.contractAddress, options.provider, storage);
        contractAbi = metadata.abi;
      } catch {
        throw new Error(`Could resolve contract metadata for address ${options.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`);
      }
    }
    const contract = new Contract(options.contractAddress, contractAbi, options.provider);
    const optionsWithContract = {
      ...options,
      storage,
      contract
    };
    return new _Transaction(optionsWithContract);
  }
  constructor(options) {
    super({
      args: options.args,
      overrides: options.overrides,
      provider: options.provider,
      signer: options.signer,
      storage: options.storage
    });
    this.method = options.method;
    this.gaslessOptions = options.gasless;
    this.parse = options.parse;
    this.contract = options.contract.connect(this.signer);
    this.storage = options.storage;
  }
  getTarget() {
    return this.contract.address;
  }
  getMethod() {
    return this.method;
  }
  getGaslessOptions() {
    return this.gaslessOptions;
  }
  setGaslessOptions(options) {
    this.gaslessOptions = options;
    return this;
  }
  setParse(parse) {
    this.parse = parse;
    return this;
  }
  /**
   * Encode the function data for this transaction
   */
  encode() {
    return this.contract.interface.encodeFunctionData(this.method, this.args);
  }
  /**
   * Get the signed transaction
   */
  async sign() {
    const populatedTx = await this.populateTransaction();
    const signedTx = await this.contract.signer.signTransaction(populatedTx);
    return signedTx;
  }
  async populateTransaction() {
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    const tx = await this.contract.populateTransaction[this.method](...this.args, overrides);
    const populatedTx = await this.contract.signer.populateTransaction(tx);
    return populatedTx;
  }
  /**
   * Simulate the transaction on-chain without executing
   */
  async simulate() {
    if (!this.contract.callStatic[this.method]) {
      throw this.functionError();
    }
    try {
      return await this.contract.callStatic[this.method](...this.args, ...this.overrides.value ? [{
        value: this.overrides.value
      }] : []);
    } catch (err) {
      throw await this.transactionError(err);
    }
  }
  /**
   * Estimate the gas limit of this transaction
   */
  async estimateGasLimit() {
    if (!this.contract.estimateGas[this.method]) {
      throw this.functionError();
    }
    try {
      const gasEstimate = await this.contract.estimateGas[this.method](...this.args, this.overrides);
      if (this.gasMultiple) {
        return BigNumber.from(Math.floor(BigNumber.from(gasEstimate).toNumber() * this.gasMultiple));
      }
      return gasEstimate;
    } catch (err) {
      await this.simulate();
      throw await this.transactionError(err);
    }
  }
  /**
   * Send the transaction without waiting for it to be mined.
   */
  async send() {
    if (!this.contract.functions[this.method]) {
      throw this.functionError();
    }
    if (this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions || "engine" in this.gaslessOptions)) {
      return this.sendGasless();
    }
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    try {
      return await this.contract.functions[this.method](...this.args, overrides);
    } catch (err) {
      throw await this.transactionError(err);
    }
  }
  /**
   * Send the transaction and wait for it to be mined
   */
  async execute() {
    const tx = await this.send();
    let receipt;
    try {
      receipt = await tx.wait();
    } catch (err) {
      await this.simulate();
      throw await this.transactionError(err);
    }
    if (this.parse) {
      return this.parse(receipt);
    }
    return {
      receipt
    };
  }
  /**
   * Execute the transaction with gasless
   */
  async sendGasless() {
    const tx = await this.prepareGasless();
    const txHash = await defaultGaslessSendFunction(tx, this.signer, this.provider, this.storage, this.gaslessOptions);
    let sentTx;
    let iteration = 1;
    while (!sentTx) {
      try {
        sentTx = await this.provider.getTransaction(txHash);
      } catch (err) {
      }
      if (!sentTx) {
        await new Promise((resolve) => setTimeout(resolve, Math.min(iteration * 1e3, 1e4)));
        iteration++;
      }
      if (iteration > 20) {
        throw new Error(`Unable to retrieve transaction with hash ${txHash}`);
      }
    }
    return sentTx;
  }
  /**
   * @internal
   * @returns
   */
  async prepareGasless() {
    var _a;
    invariant(this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions || "engine" in this.gaslessOptions), "No gasless options set on this transaction!");
    const signerAddress = await this.getSignerAddress();
    const args = [...this.args];
    if (this.method === "multicall" && Array.isArray(this.args[0]) && args[0].length > 0) {
      args[0] = args[0].map((tx) => utils_exports.solidityPack(["bytes", "address"], [tx, signerAddress]));
    }
    invariant(this.signer, "Cannot execute gasless transaction without valid signer");
    const [{
      chainId
    }, from] = await Promise.all([this.provider.getNetwork(), this.overrides.from || signerAddress]);
    const to = this.contract.address;
    const value = ((_a = this.overrides) == null ? void 0 : _a.value) || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.contract.interface.encodeFunctionData(this.method, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.contract.estimateGas[this.method](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (this.overrides.gasLimit && BigNumber.from(this.overrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(this.overrides.gasLimit);
    }
    return {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: this.method,
      functionArgs: args,
      callOverrides: this.overrides
    };
  }
  functionError() {
    return new Error(`Contract "${this.contract.address}" does not have function "${this.method}"`);
  }
  /**
   * Create a nicely formatted error message with tx metadata and solidity stack trace
   */
  async transactionError(error) {
    var _a, _b, _c;
    const provider2 = this.provider;
    const [network, from] = await Promise.all([provider2.getNetwork(), this.overrides.from || this.getSignerAddress()]);
    const to = this.contract.address;
    const data = this.encode();
    const value = BigNumber.from(this.overrides.value || 0);
    const rpcUrl = (_a = provider2.connection) == null ? void 0 : _a.url;
    const functionSignature = this.contract.interface.getFunction(this.method);
    const methodArgs = this.args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash = error.transactionHash || ((_b = error.transaction) == null ? void 0 : _b.hash) || ((_c = error.receipt) == null ? void 0 : _c.transactionHash);
    const reason = parseRevertReason(error);
    let sources = void 0;
    let contractName = void 0;
    try {
      const chainId = (await provider2.getNetwork()).chainId;
      const metadata = getContractMetadataFromCache(this.contract.address, chainId);
      if (metadata == null ? void 0 : metadata.name) {
        contractName = metadata.name;
      }
      if (metadata == null ? void 0 : metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
    }
    return new TransactionError({
      reason,
      from,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash,
      contractName,
      sources
    }, error);
  }
};
var DeployTransaction = class extends TransactionContext {
  constructor(options) {
    super(options);
    this.factory = options.factory;
    this.events = options.events;
  }
  encode() {
    return utils_exports.hexlify(utils_exports.concat([this.factory.bytecode, this.factory.interface.encodeDeploy(this.args)]));
  }
  getTarget() {
    return lib_exports.AddressZero;
  }
  getMethod() {
    return "deploy";
  }
  async sign() {
    const populatedTx = await this.populateTransaction();
    return this.signer.signTransaction(populatedTx);
  }
  async simulate() {
    const populatedTx = await this.populateTransaction();
    return this.signer.call(populatedTx);
  }
  async estimateGasLimit() {
    try {
      const gasOverrides = await this.getGasOverrides();
      const overrides = {
        ...gasOverrides,
        ...this.overrides
      };
      const populatedTx = this.factory.getDeployTransaction(...this.args, overrides);
      return this.signer.estimateGas(populatedTx);
    } catch (err) {
      throw await this.deployError(err);
    }
  }
  async send() {
    try {
      const populatedTx = await this.populateTransaction();
      return await this.signer.sendTransaction(populatedTx);
    } catch (err) {
      throw await this.deployError(err);
    }
  }
  async execute() {
    const tx = await this.send();
    try {
      await tx.wait();
    } catch (err) {
      await this.simulate();
      throw await this.deployError(err);
    }
    const contractAddress = utils_exports.getContractAddress({
      from: tx.from,
      nonce: tx.nonce
    });
    if (this.events) {
      this.events.emit("contractDeployed", {
        status: "completed",
        contractAddress,
        transactionHash: tx.hash
      });
    }
    return contractAddress;
  }
  async populateTransaction() {
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    return this.factory.getDeployTransaction(...this.args, overrides);
  }
  /**
   * Create a nicely formatted error message with tx metadata and solidity stack trace
   */
  async deployError(error) {
    var _a, _b, _c;
    const provider2 = this.provider;
    const [network, from] = await Promise.all([provider2.getNetwork(), this.overrides.from || this.getSignerAddress()]);
    const data = this.encode();
    const value = BigNumber.from(this.overrides.value || 0);
    const rpcUrl = (_a = provider2.connection) == null ? void 0 : _a.url;
    const methodArgs = this.args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `deployContract(${joinedArgs})`;
    const hash = error.transactionHash || ((_b = error.transaction) == null ? void 0 : _b.hash) || ((_c = error.receipt) == null ? void 0 : _c.transactionHash);
    const reason = parseRevertReason(error);
    return new TransactionError({
      reason,
      from,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash
    }, error);
  }
};
async function defaultGaslessSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  if (gaslessOptions && "biconomy" in gaslessOptions) {
    return biconomySendFunction(transaction, signer, provider2, gaslessOptions);
  } else if (gaslessOptions && "openzeppelin" in gaslessOptions) {
    return defenderSendFunction(transaction, signer, provider2, storage, gaslessOptions);
  }
  return engineSendFunction(transaction, signer, provider2, storage, gaslessOptions);
}
async function engineSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  var _a;
  invariant(gaslessOptions && "engine" in gaslessOptions, "calling engine gasless transaction without engine config in the SDK options");
  const request = await enginePrepareRequest(transaction, signer, provider2, storage, gaslessOptions);
  const res = await fetch(gaslessOptions.engine.relayerUrl, {
    ...request,
    headers: {
      "Content-Type": "application/json"
    }
  });
  const data = await res.json();
  if (data.error) {
    throw new Error(((_a = data.error) == null ? void 0 : _a.message) || JSON.stringify(data.error));
  }
  const queueId = data.result.queueId;
  const engineUrl = gaslessOptions.engine.relayerUrl.split("/relayer/")[0];
  const startTime = Date.now();
  while (true) {
    const txRes = await fetch(`${engineUrl}/transaction/status/${queueId}`);
    const txData = await txRes.json();
    if (txData.result.transactionHash) {
      return txData.result.transactionHash;
    }
    if (Date.now() - startTime > 30 * 1e3) {
      throw new Error("timeout");
    }
    await new Promise((resolve) => setTimeout(resolve, 2e3));
  }
}
async function biconomySendFunction(transaction, signer, provider2, gaslessOptions) {
  const request = await biconomyPrepareRequest(transaction, signer, provider2, gaslessOptions);
  const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", request);
  if (response.ok) {
    const resp = await response.json();
    if (!resp.txHash) {
      throw new Error(`relay transaction failed: ${resp.log}`);
    }
    return resp.txHash;
  }
  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
}
async function defenderSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  invariant(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
  const request = await defenderPrepareRequest(transaction, signer, provider2, storage, gaslessOptions);
  const response = await fetch(gaslessOptions.openzeppelin.relayerUrl, request);
  if (response.ok) {
    const resp = await response.json();
    if (!resp.result) {
      throw new Error(`Relay transaction failed: ${resp.message}`);
    }
    const result = JSON.parse(resp.result);
    return result.txHash;
  }
  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
}
async function enginePrepareRequest(transaction, signer, provider2, storage, gaslessOptions) {
  var _a;
  invariant(gaslessOptions && "engine" in gaslessOptions, "calling engine gasless transaction without openzeppelin config in the SDK options");
  try {
    const metadata = await fetchContractMetadataFromAddress(transaction.to, provider2, storage);
    const chainId = (await provider2.getNetwork()).chainId;
    const abi = await getCompositeABI(transaction.to, metadata.abi, provider2, {}, storage);
    const contract = new ContractWrapper(signer, transaction.to, abi, {}, storage);
    if (abi.find((item) => item.name === "executeMetaTransaction")) {
      const name = await contract.call("name", []);
      const domain = {
        name,
        version: "1",
        salt: "0x" + chainId.toString(16).padStart(64, "0"),
        // Use 64 length hex chain id as salt
        verifyingContract: transaction.to
      };
      const types = {
        MetaTransaction: [{
          name: "nonce",
          type: "uint256"
        }, {
          name: "from",
          type: "address"
        }, {
          name: "functionSignature",
          type: "bytes"
        }]
      };
      const nonce = await contract.call("getNonce", [transaction.from]);
      const message = {
        nonce,
        from: transaction.from,
        functionSignature: transaction.data
      };
      const {
        signature
      } = await signTypedDataInternal(signer, domain, types, message);
      return {
        method: "POST",
        body: JSON.stringify({
          type: "execute-meta-transaction",
          request: {
            from: transaction.from,
            to: transaction.to,
            data: transaction.data
          },
          signature
        })
      };
    }
  } catch {
  }
  if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
    const spender = transaction.functionArgs[0];
    const amount = transaction.functionArgs[1];
    const {
      message: permit,
      signature: sig
    } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);
    const message = {
      to: transaction.to,
      owner: permit.owner,
      spender: permit.spender,
      value: BigNumber.from(permit.value).toString(),
      nonce: BigNumber.from(permit.nonce).toString(),
      deadline: BigNumber.from(permit.deadline).toString()
    };
    return {
      method: "POST",
      body: JSON.stringify({
        type: "permit",
        request: message,
        signature: sig
      })
    };
  } else {
    const forwarderAddress = gaslessOptions.engine.relayerForwarderAddress || ((_a = CONTRACT_ADDRESSES[transaction.chainId]) == null ? void 0 : _a.openzeppelinForwarder) || await computeForwarderAddress(provider2, storage);
    const ForwarderABI = (await import("./Forwarder-7RZQS6L7.js")).default;
    const forwarder = new Contract(forwarderAddress, ForwarderABI, provider2);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types;
    let message;
    if (gaslessOptions.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: gaslessOptions.engine.domainName,
        version: gaslessOptions.engine.domainVersion,
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    const signature = sig;
    return {
      method: "POST",
      body: JSON.stringify({
        type: "forward",
        request: message,
        signature,
        forwarderAddress
      })
    };
  }
}
async function defenderPrepareRequest(transaction, signer, provider2, storage, gaslessOptions) {
  var _a, _b;
  invariant(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
  invariant(signer, "provider is not set");
  invariant(provider2, "provider is not set");
  const forwarderAddress = gaslessOptions.openzeppelin.relayerForwarderAddress || (gaslessOptions.openzeppelin.useEOAForwarder ? ((_a = CONTRACT_ADDRESSES[transaction.chainId]) == null ? void 0 : _a.openzeppelinForwarderEOA) || await computeEOAForwarderAddress(provider2, storage) : ((_b = CONTRACT_ADDRESSES[transaction.chainId]) == null ? void 0 : _b.openzeppelinForwarder) || await computeForwarderAddress(provider2, storage));
  const ForwarderABI = (await import("./Forwarder-7RZQS6L7.js")).default;
  const forwarder = new Contract(forwarderAddress, ForwarderABI, provider2);
  const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
  let domain;
  let types;
  let message;
  if (gaslessOptions.experimentalChainlessSupport) {
    domain = {
      name: "GSNv2 Forwarder",
      version: "0.0.1",
      verifyingContract: forwarderAddress
    };
    types = {
      ForwardRequest: ChainAwareForwardRequest
    };
    message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data,
      chainid: BigNumber.from(transaction.chainId).toString()
    };
  } else {
    domain = {
      name: gaslessOptions.openzeppelin.domainName,
      version: gaslessOptions.openzeppelin.domainVersion,
      chainId: transaction.chainId,
      verifyingContract: forwarderAddress
    };
    types = {
      ForwardRequest
    };
    message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data
    };
  }
  let signature;
  if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
    const spender = transaction.functionArgs[0];
    const amount = transaction.functionArgs[1];
    const {
      message: permit,
      signature: sig
    } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);
    const {
      r,
      s,
      v
    } = utils_exports.splitSignature(sig);
    message = {
      to: transaction.to,
      owner: permit.owner,
      spender: permit.spender,
      value: BigNumber.from(permit.value).toString(),
      nonce: BigNumber.from(permit.nonce).toString(),
      deadline: BigNumber.from(permit.deadline).toString(),
      r,
      s,
      v
    };
    signature = sig;
  } else {
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    signature = sig;
  }
  let messageType = "forward";
  if (message == null ? void 0 : message.owner) {
    messageType = "permit";
  }
  return {
    method: "POST",
    body: JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    })
  };
}
async function prepareGaslessRequest(tx) {
  const gaslessTx = await tx.prepareGasless();
  const gaslessOptions = tx.getGaslessOptions();
  if (gaslessOptions && "biconomy" in gaslessOptions) {
    const request = await biconomyPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, gaslessOptions);
    return {
      url: "https://api.biconomy.io/api/v2/meta-tx/native",
      ...request
    };
  } else {
    invariant(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const request = await defenderPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, tx.getStorage, gaslessOptions);
    return {
      url: gaslessOptions.openzeppelin.relayerUrl,
      ...request
    };
  }
}
async function biconomyPrepareRequest(transaction, signer, provider2, gaslessOptions) {
  var _a;
  invariant(gaslessOptions && "biconomy" in gaslessOptions, "calling biconomySendFunction without biconomy");
  invariant(signer && provider2, "signer and provider must be set");
  const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider2);
  const batchId = 0;
  const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
  const request = {
    from: transaction.from,
    to: transaction.to,
    token: lib_exports.AddressZero,
    txGas: transaction.gasLimit.toNumber(),
    tokenGasPrice: "0",
    batchId,
    batchNonce: batchNonce.toNumber(),
    deadline: Math.floor(Date.now() / 1e3 + (gaslessOptions && "biconomy" in gaslessOptions && ((_a = gaslessOptions.biconomy) == null ? void 0 : _a.deadlineSeconds) || 3600)),
    data: transaction.data
  };
  const hashToSign = utils_exports.arrayify(utils_exports.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils_exports.keccak256(request.data)]));
  const signature = await signer.signMessage(hashToSign);
  return {
    method: "POST",
    body: JSON.stringify({
      from: transaction.from,
      apiId: gaslessOptions.biconomy.apiId,
      params: [request, signature],
      to: transaction.to,
      gasLimit: transaction.gasLimit.toHexString()
    }),
    headers: {
      "x-api-key": gaslessOptions.biconomy.apiKey,
      "Content-Type": "application/json;charset=utf-8"
    }
  };
}

export {
  invariant,
  z,
  aesDecryptCompat,
  aesEncrypt,
  IPackVRFDirect_default,
  isBrowser,
  isFileOrBuffer,
  replaceGatewayUrlWithScheme,
  ThirdwebStorage,
  getDefaultGasOverrides,
  getDynamicFeeData,
  getGasPrice,
  getPolygonGasPriorityFee,
  buildDeployTransactionFunction,
  buildTransactionFunction,
  Transaction,
  DeployTransaction,
  engineSendFunction,
  prepareGaslessRequest,
  getProcessEnv2 as getProcessEnv,
  getContractPublisherAddress,
  isSigner,
  isProvider,
  StaticJsonRpcBatchProvider,
  SDKOptionsSchema,
  getChainProvider,
  getChainIdFromNetwork,
  getChainIdOrName,
  isChainConfig,
  getProviderFromRpcUrl,
  getSignerAndProvider,
  resolveEns,
  AddressSchema,
  AddressOrEnsSchema,
  resolveAddress,
  FileOrBufferOrStringSchema,
  MAX_BPS,
  BytesLikeSchema,
  BigNumberTransformSchema$1,
  BasisPointsSchema,
  HexColor,
  AmountSchema,
  QuantitySchema,
  toSemver,
  isIncrementalVersion,
  isDowngradeVersion,
  BigNumberSchema,
  BigNumberishSchema,
  BigNumberTransformSchema,
  CommonContractSchema,
  CommonContractOutputSchema,
  CommonRoyaltySchema,
  CommonPrimarySaleSchema,
  CommonPlatformFeeSchema,
  CommonTrustedForwarderSchema,
  CommonSymbolSchema,
  MerkleSchema,
  SnapshotEntryInput,
  SnapshotInputSchema,
  SnapshotEntryWithProofSchema,
  SnapshotSchema,
  SnapshotInfoSchema,
  BYOCContractMetadataSchema,
  CustomContractInput,
  CustomContractOutput,
  CustomContractDeploy,
  CustomContractSchema,
  AbiTypeSchema,
  AbiObjectSchema,
  AbiSchema,
  PreDeployMetadata,
  ChainIdToAddressSchema,
  CustomFactoryInput,
  FactoryDeploymentSchema,
  DeployTypeInput,
  RouterTypeInput,
  DeploymentNetworkInput,
  ExtraPublishMetadataSchemaInput,
  ExtraPublishMetadataSchemaOutput,
  FullPublishMetadataSchemaInput,
  FullPublishMetadataSchemaOutput,
  ProfileSchemaInput,
  ProfileSchemaOutput,
  PublishedContractSchema,
  ContractInfoSchema,
  CompilerMetadataFetchedSchema,
  PreDeployMetadataFetchedSchema,
  fetchExtendedReleaseMetadata,
  fetchContractMetadata,
  formatCompilerMetadata,
  fetchRawPredeployMetadata,
  fetchPreDeployMetadata,
  isNode,
  createLruCache,
  fetchAndCacheDeployMetadata,
  setSupportedChains,
  getSupportedChains,
  THIRDWEB_DEPLOYER,
  fetchPublishedContractFromPolygon,
  getPrebuiltInfo,
  extractIPFSHashFromBytecode,
  extractMinimalProxyImplementationAddress,
  resolveContractUriFromAddress,
  resolveContractUriAndBytecode,
  resolveImplementation,
  getMultichainRegistryAddress,
  joinABIs,
  FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
  FEATURE_TOKEN_BURNABLE,
  FEATURE_TOKEN_SIGNATURE_MINTABLE,
  FEATURE_TOKEN_BATCH_MINTABLE,
  FEATURE_TOKEN_MINTABLE,
  FEATURE_TOKEN,
  FEATURE_NFT_BURNABLE,
  FEATURE_NFT_REVEALABLE,
  FEATURE_NFT_TIERED_DROP,
  FEATURE_NFT_CLAIM_CONDITIONS_V2,
  FEATURE_NFT_CLAIM_CUSTOM,
  FEATURE_NFT_CLAIM_ZORA,
  FEATURE_NFT_LAZY_MINTABLE,
  FEATURE_NFT_BATCH_MINTABLE,
  FEATURE_NFT_MINTABLE,
  FEATURE_NFT_SIGNATURE_MINTABLE_V2,
  FEATURE_NFT_ENUMERABLE,
  FEATURE_NFT_QUERYABLE,
  FEATURE_NFT_SUPPLY,
  FEATURE_NFT_SHARED_METADATA,
  FEATURE_NFT_LOYALTY_CARD,
  FEATURE_NFT_UPDATABLE_METADATA,
  FEATURE_NFT,
  FEATURE_EDITION_BURNABLE,
  FEATURE_EDITION_CLAIM_CONDITIONS_V2,
  FEATURE_EDITION_CLAIM_CUSTOM,
  FEATURE_EDITION_REVEALABLE,
  FEATURE_EDITION_LAZY_MINTABLE_V2,
  FEATURE_EDITION_SIGNATURE_MINTABLE,
  FEATURE_EDITION_BATCH_MINTABLE,
  FEATURE_EDITION_MINTABLE,
  FEATURE_EDITION_ENUMERABLE,
  FEATURE_EDITION_SUPPLY,
  FEATURE_EDITION,
  FEATURE_ROYALTY,
  FEATURE_PRIMARY_SALE,
  FEATURE_PLATFORM_FEE,
  FEATURE_PERMISSIONS,
  FEATURE_METADATA,
  FEATURE_APPURI,
  FEATURE_OWNER,
  FEATURE_PACK_VRF,
  FEATURE_DYNAMIC_CONTRACT,
  FEATURE_DIRECT_LISTINGS,
  FEATURE_ENGLISH_AUCTIONS,
  FEATURE_OFFERS,
  FEATURE_ACCOUNT_FACTORY,
  FEATURE_ACCOUNT_PERMISSIONS,
  FEATURE_ACCOUNT,
  FEATURE_AIRDROP_ERC20,
  FEATURE_AIRDROP_ERC721,
  FEATURE_AIRDROP_ERC1155,
  SUPPORTED_FEATURES,
  extractCommentFromMetadata,
  extractFunctionsFromAbi,
  hasMatchingAbi,
  matchesAbiFromBytecode,
  detectFeatures,
  detectFeaturesFromBytecode,
  extractFeatures,
  getAllDetectedFeatures,
  getAllDetectedExtensionsFromBytecode,
  constructAbiFromBytecode,
  getAllDetectedExtensions,
  getContractMetadataFromCache,
  fetchContractMetadataFromAddress,
  fetchContractMetadataFromBytecode,
  fetchAbiFromAddress,
  CUSTOM_GAS_FOR_CHAIN,
  CREATE2_FACTORY_BYTECODE,
  SIGNATURE,
  COMMON_FACTORY,
  GAS_LIMIT_FOR_DEPLOYER,
  DEPLOYER_BYTECODE,
  DEPLOYER_ABI,
  isContractDeployed,
  isEIP155Enforced,
  getKeylessTxn,
  getCreate2FactoryDeploymentInfo,
  getCreate2FactoryAddress,
  getSaltHash,
  getInitBytecodeWithSalt,
  computeDeploymentAddress,
  ChainId,
  NATIVE_TOKEN_ADDRESS,
  NATIVE_TOKENS,
  getNativeTokenByChainId,
  LINK_TOKEN_ADDRESS,
  extractConstructorParamsFromAbi,
  caches,
  AddressZero,
  computeDeploymentInfo,
  encodeConstructorParamsForImplementation,
  computeEOAForwarderAddress,
  computeForwarderAddress,
  NotFoundError,
  InvalidAddressError,
  MissingRoleError,
  AssetNotFoundError,
  UploadError,
  FileNameMissingError,
  DuplicateFileNameError,
  NotEnoughTokensError,
  MissingOwnerRoleError,
  QuantityAboveLimitError,
  FetchError,
  DuplicateLeafsError,
  AuctionAlreadyStartedError,
  FunctionDeprecatedError,
  ListingNotFoundError,
  WrongListingTypeError,
  RestrictedTransferError,
  AdminRoleMissingError,
  AuctionHasNotEndedError,
  ExtensionNotImplementedError,
  TransactionError,
  parseRevertReason,
  includesErrorMessage,
  fetchSourceFilesFromMetadata,
  signTypedDataInternal,
  OZ_DEFENDER_FORWARDER_ADDRESS,
  CONTRACT_ADDRESSES,
  getContractAddressByChainId,
  EventType,
  CallOverrideSchema,
  RPCConnectionHandler,
  ContractWrapper,
  isFeatureEnabled,
  isExtensionEnabled,
  getCompositeABI,
  ALL_ROLES,
  getRoleHash,
  DropErc1155ContractInput,
  DropErc1155ContractOutput,
  DropErc1155ContractDeploy,
  DropErc1155ContractSchema,
  DropErc20ContractSchema,
  DropErc721ContractInput,
  DropErc721ContractOutput,
  DropErc721ContractDeploy,
  DropErc721ContractSchema,
  MarketplaceContractInput,
  MarketplaceContractOutput,
  MarketplaceContractDeploy,
  MarketplaceContractSchema,
  MultiwrapContractSchema,
  PackContractInput,
  PackContractOutput,
  PackContractDeploy,
  PackContractSchema,
  SplitsContractInput,
  SplitsContractOutput,
  SplitsContractDeploy,
  SplitsContractSchema,
  TokenErc1155ContractInput,
  TokenErc1155ContractOutput,
  TokenErc1155ContractDeploy,
  TokenErc1155ContractSchema,
  TokenErc20ContractInput,
  TokenErc20ContractOutput,
  TokenErc20ContractDeploy,
  TokenErc20ContractSchema,
  TokenErc721ContractInput,
  TokenErc721ContractOutput,
  TokenErc721ContractDeploy,
  TokenErc721ContractSchema,
  VoteSettingsInputSchema,
  VoteSettingsOuputSchema,
  VoteContractInput,
  VoteContractOutput,
  VoteContractDeploy,
  VoteContractSchema,
  ProposalOutputSchema,
  ADMIN_ROLE,
  NFT_BASE_CONTRACT_ROLES,
  MARKETPLACE_CONTRACT_ROLES,
  PACK_CONTRACT_ROLES,
  TOKEN_DROP_CONTRACT_ROLES,
  MULTIWRAP_CONTRACT_ROLES,
  EditionDropInitializer,
  EditionInitializer,
  MarketplaceInitializer,
  MarketplaceV3Initializer,
  MultiwrapInitializer,
  NFTCollectionInitializer,
  NFTDropInitializer,
  PackInitializer,
  SignatureDropInitializer,
  SplitInitializer,
  TokenDropInitializer,
  TokenInitializer,
  VoteInitializer,
  PREBUILT_CONTRACTS_MAP,
  PREBUILT_CONTRACTS_APPURI_MAP,
  CONTRACTS_MAP,
  getContractTypeForRemoteName,
  getContractName
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.9.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2023
   * @license MIT
   *)

@thirdweb-dev/crypto/dist/thirdweb-dev-crypto.esm.js:
  (**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.8.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2023
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-DH5ORYRE.js.map
