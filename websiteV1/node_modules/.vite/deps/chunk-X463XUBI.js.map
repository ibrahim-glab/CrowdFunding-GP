{
  "version": 3,
  "sources": ["../../@web3auth/base-evm-adapter/src/baseEvmAdapter.ts"],
  "sourcesContent": ["import {\n  ADAPTER_STATUS,\n  BaseAdapter,\n  checkIfTokenIsExpired,\n  clearToken,\n  getSavedToken,\n  saveToken,\n  signChallenge,\n  UserAuthInfo,\n  verifySignedChallenge,\n  WalletLoginError,\n} from \"@web3auth/base\";\n\nexport abstract class BaseEvmAdapter<T> extends BaseAdapter<T> {\n  async authenticateUser(): Promise<UserAuthInfo> {\n    if (!this.provider || !this.chainConfig?.chainId) throw WalletLoginError.notConnectedError();\n\n    const { chainNamespace, chainId } = this.chainConfig;\n\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const accounts = await this.provider.request<string[]>({\n      method: \"eth_accounts\",\n    });\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0] as string, this.name);\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n        if (!isExpired) {\n          return { idToken: existingToken };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString(),\n      };\n\n      const challenge = await signChallenge(payload, chainNamespace);\n\n      const signedMessage = await this.provider.request<string>({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]],\n      });\n\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage as string, challenge, this.name, this.sessionTime);\n      saveToken(accounts[0] as string, this.name, idToken);\n      return {\n        idToken,\n      };\n    }\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    const accounts = await this.provider.request<string[]>({\n      method: \"eth_accounts\",\n    });\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;IAasBA;;;;AAAhB,IAAgBA,iBAAhB,cAA0CC,YAAc;MACtC,MAAhBC,mBAAgB;AAAA,YAAA;AACpB,YAAI,CAAC,KAAKC,YAAY,GAAA,oBAAC,KAAKC,iBAAN,QAAA,sBAAA,UAAC,kBAAkBC;AAAS,gBAAMC,iBAAiBC,kBAAjB;AAExD,cAAM;UAAEC;UAAgBH;QAAlB,IAA8B,KAAKD;AAEzC,YAAI,KAAKK,WAAWC,eAAeC;AAAW,gBAAML,iBAAiBC,kBAAkB,uDAAnC;AACpD,cAAMK,WAAW,MAAM,KAAKT,SAASU,QAAkB;UACrDC,QAAQ;QAD6C,CAAhC;AAGvB,YAAIF,YAAYA,SAASG,SAAS,GAAG;AACnC,gBAAMC,gBAAgBC,cAAcL,SAAS,CAAD,GAAe,KAAKM,IAA7B;AACnC,cAAIF,eAAe;AACjB,kBAAMG,YAAYC,sBAAsBJ,aAAD;AACvC,gBAAI,CAACG,WAAW;AACd,qBAAO;gBAAEE,SAASL;;YACnB;UACF;AAED,gBAAMM,UAAU;YACdC,QAAQC,OAAOC,SAASC;YACxBC,KAAKH,OAAOC,SAASG;YACrBC,SAASjB,SAAS,CAAD;YACjBP,SAASyB,SAASzB,SAAS,EAAV;YACjB0B,SAAS;YACTC,OAAOC,KAAKC,OAAL,EAAcC,SAAS,EAAvB,EAA2BC,MAAM,CAAjC;YACPC,WAAU,oBAAIC,KAAJ,GAAWC,YAAX;;AAGZ,gBAAMC,YAAY,MAAMC,cAAcnB,SAASd,cAAV;AAErC,gBAAMkC,gBAAgB,MAAM,KAAKvC,SAASU,QAAgB;YACxDC,QAAQ;YACR6B,QAAQ,CAACH,WAAW5B,SAAS,CAAD,CAApB;UAFgD,CAA9B;AAK5B,gBAAMS,UAAU,MAAMuB,sBAAsBpC,gBAAgBkC,eAAyBF,WAAW,KAAKtB,MAAM,KAAK2B,WAArE;AAC3CC,oBAAUlC,SAAS,CAAD,GAAe,KAAKM,MAAMG,OAAnC;AACT,iBAAO;YACLA;;QAEH;AACD,cAAMf,iBAAiBC,kBAAkB,uDAAnC;MACP;MAEe,MAAVwC,aAAU;AACd,YAAI,KAAKtC,WAAWC,eAAeC;AAAW,gBAAML,iBAAiB0C,mBAAmB,2BAApC;AACpD,cAAMpC,WAAW,MAAM,KAAKT,SAASU,QAAkB;UACrDC,QAAQ;QAD6C,CAAhC;AAGvB,YAAIF,YAAYA,SAASG,SAAS,GAAG;AACnCkC,qBAAWrC,SAAS,CAAD,GAAK,KAAKM,IAAnB;QACX;MACF;IArD2D;;;",
  "names": ["BaseEvmAdapter", "BaseAdapter", "authenticateUser", "provider", "chainConfig", "chainId", "WalletLoginError", "notConnectedError", "chainNamespace", "status", "ADAPTER_STATUS", "CONNECTED", "accounts", "request", "method", "length", "existingToken", "getSavedToken", "name", "isExpired", "checkIfTokenIsExpired", "idToken", "payload", "domain", "window", "location", "origin", "uri", "href", "address", "parseInt", "version", "nonce", "Math", "random", "toString", "slice", "issuedAt", "Date", "toISOString", "challenge", "signChallenge", "signedMessage", "params", "verifySignedChallenge", "sessionTime", "saveToken", "disconnect", "disconnectionError", "clearToken"]
}
