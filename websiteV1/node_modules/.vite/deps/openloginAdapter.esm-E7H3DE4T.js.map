{
  "version": 3,
  "sources": ["../../@web3auth/openlogin-adapter/src/config.ts", "../../@web3auth/openlogin-adapter/src/openloginAdapter.ts"],
  "sourcesContent": ["import { OPENLOGIN_NETWORK, UX_MODE } from \"@toruslabs/openlogin\";\nimport { ChainNamespaceType, getChainConfig } from \"@web3auth/base\";\n\nimport { OpenloginAdapterOptions } from \"./interface\";\n\nexport const getOpenloginDefaultOptions = (chainNamespace?: ChainNamespaceType, chainId?: number | string): OpenloginAdapterOptions => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP,\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : null,\n    loginSettings: {},\n  };\n};\n", "import OpenLogin, { getHashQueryParams, LoginParams, OPENLOGIN_NETWORK, OpenLoginOptions, SUPPORTED_KEY_CURVES, UX_MODE } from \"@toruslabs/openlogin\";\nimport {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  BaseAdapter,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  log,\n  SafeEventEmitterProvider,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n} from \"@web3auth/base\";\nimport { CommonPrivateKeyProvider, IBaseProvider } from \"@web3auth/base-provider\";\nimport merge from \"lodash.merge\";\n\nimport { getOpenloginDefaultOptions } from \"./config\";\nimport type { LoginSettings, OpenloginAdapterOptions } from \"./interface\";\n\nexport type OpenloginLoginParams = LoginParams & {\n  // to maintain backward compatibility\n  login_hint?: string;\n};\n\ntype PrivateKeyProvider = IBaseProvider<string>;\n\nexport class OpenloginAdapter extends BaseAdapter<OpenloginLoginParams> {\n  readonly name: string = WALLET_ADAPTERS.OPENLOGIN;\n\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.MULTICHAIN;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.IN_APP;\n\n  public openloginInstance: OpenLogin | null = null;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.EIP155;\n\n  private openloginOptions: OpenLoginOptions;\n\n  private loginSettings: LoginSettings = {};\n\n  private privKeyProvider: PrivateKeyProvider | null = null;\n\n  constructor(params: OpenloginAdapterOptions) {\n    super();\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions(params.chainConfig?.chainNamespace, params.chainConfig?.chainId);\n    this.openloginOptions = {\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET,\n      ...defaultOptions.adapterSettings,\n      ...(params.adapterSettings || {}),\n    };\n    this.loginSettings = { ...defaultOptions.loginSettings, ...params.loginSettings };\n    this.sessionTime = this.loginSettings.sessionTime || 86400;\n    // if no chainNamespace is passed then chain config should be set before calling init\n    if (params.chainConfig?.chainNamespace) {\n      this.currentChainNamespace = params.chainConfig?.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = { ...defaultChainIdConfig, ...params?.chainConfig };\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n      if (!this.chainConfig.rpcTarget && params.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n\n  get chainConfigProxy(): CustomChainConfig | null {\n    return this.chainConfig ? { ...this.chainConfig } : null;\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    return this.privKeyProvider?.provider || null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions): Promise<void> {\n    super.checkInitializationRequirements();\n    if (!this.openloginOptions?.clientId) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT) {\n      const redirectResult = getHashQueryParams();\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n    this.openloginOptions = {\n      ...this.openloginOptions,\n      replaceUrlOnRedirect: isRedirectResult,\n    };\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    log.debug(\"initializing openlogin adapter init\");\n\n    await this.openloginInstance.init();\n\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\");\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params?: OpenloginLoginParams): Promise<SafeEventEmitterProvider | null> {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, { ...params, adapter: WALLET_ADAPTERS.OPENLOGIN });\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error: unknown) {\n      log.error(\"Failed to connect with openlogin provider\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      if ((error as Error)?.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async authenticateUser(): Promise<{ idToken: string }> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken as string,\n    };\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  }\n\n  // should be called only before initialization.\n  setAdapterSettings(adapterSettings: OpenLoginOptions & { sessionTime: number }): void {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = { ...defaultOptions.adapterSettings, ...(this.openloginOptions || {}), ...adapterSettings };\n    if (adapterSettings.sessionTime) {\n      this.loginSettings = { ...this.loginSettings, sessionTime: adapterSettings.sessionTime };\n    }\n  }\n\n  // should be called only before initialization.\n  setChainConfig(customChainConfig: CustomChainConfig): void {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n\n  private async connectWithProvider(params?: OpenloginLoginParams): Promise<void> {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const { SolanaPrivateKeyProvider } = await import(\"@web3auth/solana-provider\");\n      this.privKeyProvider = new SolanaPrivateKeyProvider({ config: { chainConfig: this.chainConfig } });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const { EthereumPrivateKeyProvider } = await import(\"@web3auth/ethereum-provider\");\n      this.privKeyProvider = new EthereumPrivateKeyProvider({ config: { chainConfig: this.chainConfig } });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);\n    }\n    // if not logged in then login\n    if (!this.openloginInstance.privKey && params) {\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve =\n          this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n      await this.openloginInstance.login(\n        merge(\n          this.loginSettings,\n          { loginProvider: params.loginProvider },\n          { extraLoginOptions: { ...(params.extraLoginOptions || {}), login_hint: params.login_hint || params.extraLoginOptions?.login_hint } }\n        )\n      );\n    }\n    let finalPrivKey = this.openloginInstance.privKey;\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const { getED25519Key } = await import(\"@toruslabs/openlogin-ed25519\");\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.OPENLOGIN, reconnected: !params } as CONNECTED_EVENT_DATA);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["getOpenloginDefaultOptions", "OpenloginAdapter", "chainNamespace", "chainId", "adapterSettings", "network", "OPENLOGIN_NETWORK", "MAINNET", "clientId", "uxMode", "UX_MODE", "POPUP", "chainConfig", "getChainConfig", "loginSettings", "BaseAdapter", "constructor", "params", "WALLET_ADAPTERS", "OPENLOGIN", "ADAPTER_NAMESPACES", "MULTICHAIN", "ADAPTER_CATEGORY", "IN_APP", "ADAPTER_STATUS", "NOT_READY", "CHAIN_NAMESPACES", "EIP155", "log", "debug", "defaultOptions", "openloginOptions", "sessionTime", "currentChainNamespace", "defaultChainIdConfig", "rpcTarget", "OTHER", "WalletInitializationError", "invalidParams", "chainConfigProxy", "provider", "privKeyProvider", "_", "Error", "init", "options", "checkInitializationRequirements", "isRedirectResult", "REDIRECT", "redirectResult", "getHashQueryParams", "Object", "keys", "length", "_pid", "replaceUrlOnRedirect", "openloginInstance", "OpenLogin", "status", "READY", "emit", "ADAPTER_EVENTS", "privKey", "autoConnect", "connect", "error", "checkConnectionRequirements", "CONNECTING", "adapter", "connectWithProvider", "ERRORED", "message", "includes", "WalletLoginError", "popupClosed", "connectionError", "disconnect", "cleanup", "CONNECTED", "notConnectedError", "notReady", "logout", "DISCONNECTED", "authenticateUser", "userInfo", "getUserInfo", "idToken", "setAdapterSettings", "setChainConfig", "customChainConfig", "SOLANA", "SolanaPrivateKeyProvider", "config", "EthereumPrivateKeyProvider", "CommonPrivateKeyProvider", "curve", "SUPPORTED_KEY_CURVES", "ED25519", "SECP256K1", "login", "merge", "loginProvider", "extraLoginOptions", "login_hint", "finalPrivKey", "getED25519Key", "sk", "toString", "setupProvider", "reconnected"]
}
