{
  "version": 3,
  "sources": ["../../@thirdweb-dev/wallets/evm/connectors/wallet-connect/dist/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm.js"],
  "sourcesContent": ["import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\r\nimport { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\r\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-d7c057bf.browser.esm.js';\r\nimport { U as UserRejectedRequestError, S as SwitchChainError } from '../../../../dist/errors-9f6736cb.browser.esm.js';\r\nimport { utils, providers } from 'ethers';\r\nimport { w as walletIds } from '../../../../dist/walletIds-8e17ffe6.browser.esm.js';\r\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-a45219bd.browser.esm.js';\r\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\r\nimport '@thirdweb-dev/chains';\r\nimport 'eventemitter3';\r\n\r\nconst chainsToRequest = new Set([1, 137, 10, 42161, 56]);\r\nconst NAMESPACE = \"eip155\";\r\nconst REQUESTED_CHAINS_KEY = \"wagmi.requestedChains\";\r\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\r\nconst LAST_USED_CHAIN_ID = \"last-used-chain-id\";\r\nvar _provider = /*#__PURE__*/new WeakMap();\r\nvar _initProviderPromise = /*#__PURE__*/new WeakMap();\r\nvar _storage = /*#__PURE__*/new WeakMap();\r\nvar _createProvider = /*#__PURE__*/new WeakSet();\r\nvar _isChainsStale = /*#__PURE__*/new WeakSet();\r\nvar _removeListeners = /*#__PURE__*/new WeakSet();\r\nvar _setRequestedChainsIds = /*#__PURE__*/new WeakSet();\r\nvar _getRequestedChainsIds = /*#__PURE__*/new WeakSet();\r\nvar _getNamespaceChainsIds = /*#__PURE__*/new WeakSet();\r\nvar _getNamespaceMethods = /*#__PURE__*/new WeakSet();\r\nclass WalletConnectConnector extends WagmiConnector {\r\n  constructor(config) {\r\n    super({\r\n      ...config,\r\n      options: {\r\n        isNewChainsStale: true,\r\n        ...config.options\r\n      }\r\n    });\r\n    _classPrivateMethodInitSpec(this, _getNamespaceMethods);\r\n    _classPrivateMethodInitSpec(this, _getNamespaceChainsIds);\r\n    _classPrivateMethodInitSpec(this, _getRequestedChainsIds);\r\n    _classPrivateMethodInitSpec(this, _setRequestedChainsIds);\r\n    _classPrivateMethodInitSpec(this, _removeListeners);\r\n    /**\r\n     * Checks if the target chains match the chains that were\r\n     * initially requested by the connector for the WalletConnect session.\r\n     * If there is a mismatch, this means that the chains on the connector\r\n     * are considered stale, and need to be revalidated at a later point (via\r\n     * connection).\r\n     *\r\n     * There may be a scenario where a dapp adds a chain to the\r\n     * connector later on, however, this chain will not have been approved or rejected\r\n     * by the wallet. In this case, the chain is considered stale.\r\n     *\r\n     * There are exceptions however:\r\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\r\n     *    then the chain is not considered stale.\r\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\r\n     *    not considered stale.\r\n     *\r\n     * For the above cases, chain validation occurs dynamically when the user\r\n     * attempts to switch chain.\r\n     *\r\n     * Also check that dapp supports at least 1 chain from previously approved session.\r\n     */\r\n    _classPrivateMethodInitSpec(this, _isChainsStale);\r\n    _classPrivateMethodInitSpec(this, _createProvider);\r\n    _defineProperty(this, \"id\", walletIds.walletConnect);\r\n    _defineProperty(this, \"name\", \"WalletConnect\");\r\n    _defineProperty(this, \"ready\", true);\r\n    _classPrivateFieldInitSpec(this, _provider, {\r\n      writable: true,\r\n      value: void 0\r\n    });\r\n    _classPrivateFieldInitSpec(this, _initProviderPromise, {\r\n      writable: true,\r\n      value: void 0\r\n    });\r\n    _classPrivateFieldInitSpec(this, _storage, {\r\n      writable: true,\r\n      value: void 0\r\n    });\r\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\r\n      if (accounts.length === 0) {\r\n        this.emit(\"disconnect\");\r\n      } else {\r\n        if (accounts[0]) {\r\n          this.emit(\"change\", {\r\n            account: utils.getAddress(accounts[0])\r\n          });\r\n        }\r\n      }\r\n    });\r\n    _defineProperty(this, \"onChainChanged\", async chainId => {\r\n      const id = Number(chainId);\r\n      const unsupported = this.isChainUnsupported(id);\r\n      await _classPrivateFieldGet(this, _storage).setItem(LAST_USED_CHAIN_ID, String(chainId));\r\n      this.emit(\"change\", {\r\n        chain: {\r\n          id,\r\n          unsupported\r\n        }\r\n      });\r\n    });\r\n    _defineProperty(this, \"onDisconnect\", async () => {\r\n      await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\r\n      await _classPrivateFieldGet(this, _storage).removeItem(LAST_USED_CHAIN_ID);\r\n      this.emit(\"disconnect\");\r\n    });\r\n    _defineProperty(this, \"onDisplayUri\", uri => {\r\n      this.emit(\"message\", {\r\n        type: \"display_uri\",\r\n        data: uri\r\n      });\r\n    });\r\n    _defineProperty(this, \"onConnect\", () => {\r\n      this.emit(\"connect\", {\r\n        provider: _classPrivateFieldGet(this, _provider)\r\n      });\r\n    });\r\n    _classPrivateFieldSet(this, _storage, config.options.storage);\r\n    _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\r\n    this.filteredChains = this.chains.length > 50 ? this.chains.filter(c => {\r\n      return chainsToRequest.has(c.chainId);\r\n    }) : this.chains;\r\n    this.showWalletConnectModal = this.options.qrcode !== false;\r\n  }\r\n  async connect() {\r\n    let {\r\n      chainId: chainIdP,\r\n      pairingTopic\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    try {\r\n      let targetChainId = chainIdP;\r\n      if (!targetChainId) {\r\n        const lastUsedChainIdStr = await _classPrivateFieldGet(this, _storage).getItem(LAST_USED_CHAIN_ID);\r\n        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;\r\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {\r\n          targetChainId = lastUsedChainId;\r\n        } else {\r\n          targetChainId = this.filteredChains[0]?.chainId;\r\n        }\r\n      }\r\n      if (!targetChainId) {\r\n        throw new Error(\"No chains found on connector.\");\r\n      }\r\n      const provider = await this.getProvider();\r\n      this.setupListeners();\r\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this);\r\n\r\n      // If there is an active session with stale chains, disconnect the current session.\r\n      if (provider.session && isChainsStale) {\r\n        await provider.disconnect();\r\n      }\r\n\r\n      // If there no active session, or the chains are stale, connect.\r\n      if (!provider.session || isChainsStale) {\r\n        const optionalChains = this.filteredChains.filter(chain => chain.chainId !== targetChainId).map(optionalChain => optionalChain.chainId);\r\n        this.emit(\"message\", {\r\n          type: \"connecting\"\r\n        });\r\n        await provider.connect({\r\n          pairingTopic,\r\n          chains: [targetChainId],\r\n          optionalChains: optionalChains.length > 0 ? optionalChains : [targetChainId]\r\n        });\r\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, this.filteredChains.map(_ref => {\r\n          let {\r\n            chainId\r\n          } = _ref;\r\n          return chainId;\r\n        }));\r\n      }\r\n\r\n      // If session exists and chains are authorized, enable provider for required chain\r\n      const accounts = await provider.enable();\r\n      if (!accounts[0]) {\r\n        throw new Error(\"No accounts found on provider.\");\r\n      }\r\n      const account = utils.getAddress(accounts[0]);\r\n      const id = await this.getChainId();\r\n      const unsupported = this.isChainUnsupported(id);\r\n      return {\r\n        account,\r\n        chain: {\r\n          id,\r\n          unsupported\r\n        },\r\n        provider: new providers.Web3Provider(provider)\r\n      };\r\n    } catch (error) {\r\n      if (/user rejected/i.test(error?.message)) {\r\n        throw new UserRejectedRequestError(error);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n  async disconnect() {\r\n    const cleanup = () => {\r\n      if (typeof localStorage === \"undefined\") {\r\n        return;\r\n      }\r\n      for (const key in localStorage) {\r\n        if (key.startsWith(\"wc@2\")) {\r\n          localStorage.removeItem(key);\r\n        }\r\n      }\r\n    };\r\n    cleanup();\r\n    const provider = await this.getProvider();\r\n    const disconnectProvider = async () => {\r\n      try {\r\n        await provider.disconnect();\r\n      } catch (error) {\r\n        if (!/No matching key/i.test(error.message)) {\r\n          throw error;\r\n        }\r\n      } finally {\r\n        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\r\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\r\n        cleanup();\r\n      }\r\n    };\r\n    disconnectProvider();\r\n  }\r\n  async getAccount() {\r\n    const {\r\n      accounts\r\n    } = await this.getProvider();\r\n    if (!accounts[0]) {\r\n      throw new Error(\"No accounts found on provider.\");\r\n    }\r\n    return utils.getAddress(accounts[0]);\r\n  }\r\n  async getChainId() {\r\n    const {\r\n      chainId\r\n    } = await this.getProvider();\r\n    return chainId;\r\n  }\r\n  async getProvider() {\r\n    let {\r\n      chainId\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    if (!_classPrivateFieldGet(this, _provider)) {\r\n      await _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\r\n    }\r\n    if (chainId) {\r\n      await this.switchChain(chainId);\r\n    }\r\n    if (!_classPrivateFieldGet(this, _provider)) {\r\n      throw new Error(\"No provider found.\");\r\n    }\r\n    return _classPrivateFieldGet(this, _provider);\r\n  }\r\n  async getSigner() {\r\n    let {\r\n      chainId\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    const [provider, account] = await Promise.all([this.getProvider({\r\n      chainId\r\n    }), this.getAccount()]);\r\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\r\n  }\r\n  async isAuthorized() {\r\n    try {\r\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\r\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this);\r\n\r\n      // If an account does not exist on the session, then the connector is unauthorized.\r\n      if (!account) {\r\n        return false;\r\n      }\r\n\r\n      // If the chains are stale on the session, then the connector is unauthorized.\r\n      if (isChainsStale && provider.session) {\r\n        try {\r\n          await provider.disconnect();\r\n        } catch {} // eslint-disable-line no-empty\r\n        return false;\r\n      }\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n  async switchChain(chainId) {\r\n    const chain = this.chains.find(chain_ => chain_.chainId === chainId);\r\n    if (!chain) {\r\n      throw new SwitchChainError(`Chain with ID: ${chainId}, not found on connector.`);\r\n    }\r\n    try {\r\n      const provider = await this.getProvider();\r\n      const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\r\n      const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\r\n      const isChainApproved = namespaceChains.includes(chainId);\r\n      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\r\n        const firstExplorer = chain.explorers && chain.explorers[0];\r\n        const blockExplorerUrls = firstExplorer ? {\r\n          blockExplorerUrls: [firstExplorer.url]\r\n        } : {};\r\n        await provider.request({\r\n          method: ADD_ETH_CHAIN_METHOD,\r\n          params: [{\r\n            chainId: utils.hexValue(chain.chainId),\r\n            chainName: chain.name,\r\n            nativeCurrency: chain.nativeCurrency,\r\n            rpcUrls: getValidPublicRPCUrl(chain),\r\n            // no clientId on purpose\r\n            ...blockExplorerUrls\r\n          }]\r\n        });\r\n        const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\r\n        requestedChains.push(chainId);\r\n        await _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, requestedChains);\r\n      }\r\n      await provider.request({\r\n        method: \"wallet_switchEthereumChain\",\r\n        params: [{\r\n          chainId: utils.hexValue(chainId)\r\n        }]\r\n      });\r\n      return chain;\r\n    } catch (error) {\r\n      const message = typeof error === \"string\" ? error : error?.message;\r\n      if (/user rejected request/i.test(message)) {\r\n        throw new UserRejectedRequestError(error);\r\n      }\r\n      throw new SwitchChainError(error);\r\n    }\r\n  }\r\n  async initProvider() {\r\n    const {\r\n      default: EthereumProvider,\r\n      OPTIONAL_EVENTS,\r\n      OPTIONAL_METHODS\r\n    } = await import('@walletconnect/ethereum-provider');\r\n    const [defaultChain, ...optionalChains] = this.filteredChains.map(_ref2 => {\r\n      let {\r\n        chainId\r\n      } = _ref2;\r\n      return chainId;\r\n    });\r\n    if (defaultChain) {\r\n      // EthereumProvider populates & deduplicates required methods and events internally\r\n      _classPrivateFieldSet(this, _provider, await EthereumProvider.init({\r\n        showQrModal: this.showWalletConnectModal,\r\n        projectId: this.options.projectId,\r\n        optionalMethods: OPTIONAL_METHODS,\r\n        optionalEvents: OPTIONAL_EVENTS,\r\n        chains: [defaultChain],\r\n        optionalChains: optionalChains,\r\n        metadata: {\r\n          name: this.options.dappMetadata.name,\r\n          description: this.options.dappMetadata.description || \"\",\r\n          url: this.options.dappMetadata.url,\r\n          icons: [this.options.dappMetadata.logoUrl || \"\"]\r\n        },\r\n        rpcMap: Object.fromEntries(this.filteredChains.map(chain => [chain.chainId, chain.rpc[0] || \"\" // TODO: handle chain.rpc being empty array\r\n        ])),\r\n        qrModalOptions: this.options.qrModalOptions\r\n      }));\r\n    }\r\n  }\r\n  async setupListeners() {\r\n    if (!_classPrivateFieldGet(this, _provider)) {\r\n      return;\r\n    }\r\n    _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\r\n    _classPrivateFieldGet(this, _provider).on(\"accountsChanged\", this.onAccountsChanged);\r\n    _classPrivateFieldGet(this, _provider).on(\"chainChanged\", this.onChainChanged);\r\n    _classPrivateFieldGet(this, _provider).on(\"disconnect\", this.onDisconnect);\r\n    _classPrivateFieldGet(this, _provider).on(\"session_delete\", this.onDisconnect);\r\n    _classPrivateFieldGet(this, _provider).on(\"display_uri\", this.onDisplayUri);\r\n    _classPrivateFieldGet(this, _provider).on(\"connect\", this.onConnect);\r\n  }\r\n}\r\nasync function _createProvider2() {\r\n  if (!_classPrivateFieldGet(this, _initProviderPromise) && \"object\" !== \"undefined\") {\r\n    _classPrivateFieldSet(this, _initProviderPromise, this.initProvider());\r\n  }\r\n  return _classPrivateFieldGet(this, _initProviderPromise);\r\n}\r\nasync function _isChainsStale2() {\r\n  const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\r\n  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\r\n    return false;\r\n  }\r\n  if (!this.options.isNewChainsStale) {\r\n    return false;\r\n  }\r\n  const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\r\n  const connectorChains = this.filteredChains.map(_ref3 => {\r\n    let {\r\n      chainId\r\n    } = _ref3;\r\n    return chainId;\r\n  });\r\n  const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\r\n  if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) {\r\n    return false;\r\n  }\r\n  return !connectorChains.every(id => requestedChains.includes(id));\r\n}\r\nfunction _removeListeners2() {\r\n  if (!_classPrivateFieldGet(this, _provider)) {\r\n    return;\r\n  }\r\n  _classPrivateFieldGet(this, _provider).removeListener(\"accountsChanged\", this.onAccountsChanged);\r\n  _classPrivateFieldGet(this, _provider).removeListener(\"chainChanged\", this.onChainChanged);\r\n  _classPrivateFieldGet(this, _provider).removeListener(\"disconnect\", this.onDisconnect);\r\n  _classPrivateFieldGet(this, _provider).removeListener(\"session_delete\", this.onDisconnect);\r\n  _classPrivateFieldGet(this, _provider).removeListener(\"display_uri\", this.onDisplayUri);\r\n  _classPrivateFieldGet(this, _provider).removeListener(\"connect\", this.onConnect);\r\n}\r\nasync function _setRequestedChainsIds2(chains) {\r\n  await _classPrivateFieldGet(this, _storage).setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));\r\n}\r\nasync function _getRequestedChainsIds2() {\r\n  const data = await _classPrivateFieldGet(this, _storage).getItem(REQUESTED_CHAINS_KEY);\r\n  return data ? JSON.parse(data) : [];\r\n}\r\nfunction _getNamespaceChainsIds2() {\r\n  if (!_classPrivateFieldGet(this, _provider)) {\r\n    return [];\r\n  }\r\n  const chainIds = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\r\n  return chainIds ?? [];\r\n}\r\nfunction _getNamespaceMethods2() {\r\n  if (!_classPrivateFieldGet(this, _provider)) {\r\n    return [];\r\n  }\r\n  const methods = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.methods;\r\n  return methods ?? [];\r\n}\r\n\r\nexport { WalletConnectConnector };\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAOA,IAAM,kBAAkB,oBAAI,IAAI,CAAC,GAAG,KAAK,IAAI,OAAO,EAAE,CAAC;AACvD,IAAM,YAAY;AAClB,IAAM,uBAAuB;AAC7B,IAAM,uBAAuB;AAC7B,IAAM,qBAAqB;AAC3B,IAAI,YAAyB,oBAAI,QAAQ;AACzC,IAAI,uBAAoC,oBAAI,QAAQ;AACpD,IAAI,WAAwB,oBAAI,QAAQ;AACxC,IAAI,kBAA+B,oBAAI,QAAQ;AAC/C,IAAI,iBAA8B,oBAAI,QAAQ;AAC9C,IAAI,mBAAgC,oBAAI,QAAQ;AAChD,IAAI,yBAAsC,oBAAI,QAAQ;AACtD,IAAI,yBAAsC,oBAAI,QAAQ;AACtD,IAAI,yBAAsC,oBAAI,QAAQ;AACtD,IAAI,uBAAoC,oBAAI,QAAQ;AACpD,IAAM,yBAAN,cAAqC,eAAe;AAAA,EAClD,YAAY,QAAQ;AAClB,UAAM;AAAA,MACJ,GAAG;AAAA,MACH,SAAS;AAAA,QACP,kBAAkB;AAAA,QAClB,GAAG,OAAO;AAAA,MACZ;AAAA,IACF,CAAC;AACD,gCAA4B,MAAM,oBAAoB;AACtD,gCAA4B,MAAM,sBAAsB;AACxD,gCAA4B,MAAM,sBAAsB;AACxD,gCAA4B,MAAM,sBAAsB;AACxD,gCAA4B,MAAM,gBAAgB;AAuBlD,gCAA4B,MAAM,cAAc;AAChD,gCAA4B,MAAM,eAAe;AACjD,oBAAgB,MAAM,MAAM,UAAU,aAAa;AACnD,oBAAgB,MAAM,QAAQ,eAAe;AAC7C,oBAAgB,MAAM,SAAS,IAAI;AACnC,+BAA2B,MAAM,WAAW;AAAA,MAC1C,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,+BAA2B,MAAM,sBAAsB;AAAA,MACrD,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,+BAA2B,MAAM,UAAU;AAAA,MACzC,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,oBAAgB,MAAM,qBAAqB,cAAY;AACrD,UAAI,SAAS,WAAW,GAAG;AACzB,aAAK,KAAK,YAAY;AAAA,MACxB,OAAO;AACL,YAAI,SAAS,CAAC,GAAG;AACf,eAAK,KAAK,UAAU;AAAA,YAClB,SAAS,cAAM,WAAW,SAAS,CAAC,CAAC;AAAA,UACvC,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AACD,oBAAgB,MAAM,kBAAkB,OAAM,YAAW;AACvD,YAAM,KAAK,OAAO,OAAO;AACzB,YAAM,cAAc,KAAK,mBAAmB,EAAE;AAC9C,YAAM,sBAAsB,MAAM,QAAQ,EAAE,QAAQ,oBAAoB,OAAO,OAAO,CAAC;AACvF,WAAK,KAAK,UAAU;AAAA,QAClB,OAAO;AAAA,UACL;AAAA,UACA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AACD,oBAAgB,MAAM,gBAAgB,YAAY;AAChD,YAAM,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,MAAM,CAAC,CAAC;AACjG,YAAM,sBAAsB,MAAM,QAAQ,EAAE,WAAW,kBAAkB;AACzE,WAAK,KAAK,YAAY;AAAA,IACxB,CAAC;AACD,oBAAgB,MAAM,gBAAgB,SAAO;AAC3C,WAAK,KAAK,WAAW;AAAA,QACnB,MAAM;AAAA,QACN,MAAM;AAAA,MACR,CAAC;AAAA,IACH,CAAC;AACD,oBAAgB,MAAM,aAAa,MAAM;AACvC,WAAK,KAAK,WAAW;AAAA,QACnB,UAAU,sBAAsB,MAAM,SAAS;AAAA,MACjD,CAAC;AAAA,IACH,CAAC;AACD,0BAAsB,MAAM,UAAU,OAAO,QAAQ,OAAO;AAC5D,2BAAuB,MAAM,iBAAiB,gBAAgB,EAAE,KAAK,IAAI;AACzE,SAAK,iBAAiB,KAAK,OAAO,SAAS,KAAK,KAAK,OAAO,OAAO,OAAK;AACtE,aAAO,gBAAgB,IAAI,EAAE,OAAO;AAAA,IACtC,CAAC,IAAI,KAAK;AACV,SAAK,yBAAyB,KAAK,QAAQ,WAAW;AAAA,EACxD;AAAA,EACA,MAAM,UAAU;AA5HlB;AA6HI,QAAI;AAAA,MACF,SAAS;AAAA,MACT;AAAA,IACF,IAAI,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,CAAC;AACzE,QAAI;AACF,UAAI,gBAAgB;AACpB,UAAI,CAAC,eAAe;AAClB,cAAM,qBAAqB,MAAM,sBAAsB,MAAM,QAAQ,EAAE,QAAQ,kBAAkB;AACjG,cAAM,kBAAkB,qBAAqB,SAAS,kBAAkB,IAAI;AAC5E,YAAI,mBAAmB,CAAC,KAAK,mBAAmB,eAAe,GAAG;AAChE,0BAAgB;AAAA,QAClB,OAAO;AACL,2BAAgB,UAAK,eAAe,CAAC,MAArB,mBAAwB;AAAA,QAC1C;AAAA,MACF;AACA,UAAI,CAAC,eAAe;AAClB,cAAM,IAAI,MAAM,+BAA+B;AAAA,MACjD;AACA,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,WAAK,eAAe;AACpB,YAAM,gBAAgB,MAAM,uBAAuB,MAAM,gBAAgB,eAAe,EAAE,KAAK,IAAI;AAGnG,UAAI,SAAS,WAAW,eAAe;AACrC,cAAM,SAAS,WAAW;AAAA,MAC5B;AAGA,UAAI,CAAC,SAAS,WAAW,eAAe;AACtC,cAAM,iBAAiB,KAAK,eAAe,OAAO,WAAS,MAAM,YAAY,aAAa,EAAE,IAAI,mBAAiB,cAAc,OAAO;AACtI,aAAK,KAAK,WAAW;AAAA,UACnB,MAAM;AAAA,QACR,CAAC;AACD,cAAM,SAAS,QAAQ;AAAA,UACrB;AAAA,UACA,QAAQ,CAAC,aAAa;AAAA,UACtB,gBAAgB,eAAe,SAAS,IAAI,iBAAiB,CAAC,aAAa;AAAA,QAC7E,CAAC;AACD,cAAM,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,MAAM,KAAK,eAAe,IAAI,UAAQ;AAC7H,cAAI;AAAA,YACF;AAAA,UACF,IAAI;AACJ,iBAAO;AAAA,QACT,CAAC,CAAC;AAAA,MACJ;AAGA,YAAM,WAAW,MAAM,SAAS,OAAO;AACvC,UAAI,CAAC,SAAS,CAAC,GAAG;AAChB,cAAM,IAAI,MAAM,gCAAgC;AAAA,MAClD;AACA,YAAM,UAAU,cAAM,WAAW,SAAS,CAAC,CAAC;AAC5C,YAAM,KAAK,MAAM,KAAK,WAAW;AACjC,YAAM,cAAc,KAAK,mBAAmB,EAAE;AAC9C,aAAO;AAAA,QACL;AAAA,QACA,OAAO;AAAA,UACL;AAAA,UACA;AAAA,QACF;AAAA,QACA,UAAU,IAAI,YAAU,aAAa,QAAQ;AAAA,MAC/C;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,KAAK,+BAAO,OAAO,GAAG;AACzC,cAAM,IAAI,yBAAyB,KAAK;AAAA,MAC1C;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,MAAM,aAAa;AACjB,UAAM,UAAU,MAAM;AACpB,UAAI,OAAO,iBAAiB,aAAa;AACvC;AAAA,MACF;AACA,iBAAW,OAAO,cAAc;AAC9B,YAAI,IAAI,WAAW,MAAM,GAAG;AAC1B,uBAAa,WAAW,GAAG;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AACA,YAAQ;AACR,UAAM,WAAW,MAAM,KAAK,YAAY;AACxC,UAAM,qBAAqB,YAAY;AACrC,UAAI;AACF,cAAM,SAAS,WAAW;AAAA,MAC5B,SAAS,OAAO;AACd,YAAI,CAAC,mBAAmB,KAAK,MAAM,OAAO,GAAG;AAC3C,gBAAM;AAAA,QACR;AAAA,MACF,UAAE;AACA,+BAAuB,MAAM,kBAAkB,iBAAiB,EAAE,KAAK,IAAI;AAC3E,cAAM,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,MAAM,CAAC,CAAC;AACjG,gBAAQ;AAAA,MACV;AAAA,IACF;AACA,uBAAmB;AAAA,EACrB;AAAA,EACA,MAAM,aAAa;AACjB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,MAAM,KAAK,YAAY;AAC3B,QAAI,CAAC,SAAS,CAAC,GAAG;AAChB,YAAM,IAAI,MAAM,gCAAgC;AAAA,IAClD;AACA,WAAO,cAAM,WAAW,SAAS,CAAC,CAAC;AAAA,EACrC;AAAA,EACA,MAAM,aAAa;AACjB,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,MAAM,KAAK,YAAY;AAC3B,WAAO;AAAA,EACT;AAAA,EACA,MAAM,cAAc;AAClB,QAAI;AAAA,MACF;AAAA,IACF,IAAI,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,CAAC;AACzE,QAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C,YAAM,uBAAuB,MAAM,iBAAiB,gBAAgB,EAAE,KAAK,IAAI;AAAA,IACjF;AACA,QAAI,SAAS;AACX,YAAM,KAAK,YAAY,OAAO;AAAA,IAChC;AACA,QAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACtC;AACA,WAAO,sBAAsB,MAAM,SAAS;AAAA,EAC9C;AAAA,EACA,MAAM,YAAY;AAChB,QAAI;AAAA,MACF;AAAA,IACF,IAAI,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,CAAC;AACzE,UAAM,CAAC,UAAU,OAAO,IAAI,MAAM,QAAQ,IAAI,CAAC,KAAK,YAAY;AAAA,MAC9D;AAAA,IACF,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC;AACtB,WAAO,IAAI,YAAU,aAAa,UAAU,OAAO,EAAE,UAAU,OAAO;AAAA,EACxE;AAAA,EACA,MAAM,eAAe;AACnB,QAAI;AACF,YAAM,CAAC,SAAS,QAAQ,IAAI,MAAM,QAAQ,IAAI,CAAC,KAAK,WAAW,GAAG,KAAK,YAAY,CAAC,CAAC;AACrF,YAAM,gBAAgB,MAAM,uBAAuB,MAAM,gBAAgB,eAAe,EAAE,KAAK,IAAI;AAGnG,UAAI,CAAC,SAAS;AACZ,eAAO;AAAA,MACT;AAGA,UAAI,iBAAiB,SAAS,SAAS;AACrC,YAAI;AACF,gBAAM,SAAS,WAAW;AAAA,QAC5B,QAAQ;AAAA,QAAC;AACT,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,MAAM,YAAY,SAAS;AACzB,UAAM,QAAQ,KAAK,OAAO,KAAK,YAAU,OAAO,YAAY,OAAO;AACnE,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,iBAAiB,kBAAkB,OAAO,2BAA2B;AAAA,IACjF;AACA,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,YAAY;AACxC,YAAM,kBAAkB,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,IAAI;AAC/G,YAAM,mBAAmB,uBAAuB,MAAM,sBAAsB,qBAAqB,EAAE,KAAK,IAAI;AAC5G,YAAM,kBAAkB,gBAAgB,SAAS,OAAO;AACxD,UAAI,CAAC,mBAAmB,iBAAiB,SAAS,oBAAoB,GAAG;AACvE,cAAM,gBAAgB,MAAM,aAAa,MAAM,UAAU,CAAC;AAC1D,cAAM,oBAAoB,gBAAgB;AAAA,UACxC,mBAAmB,CAAC,cAAc,GAAG;AAAA,QACvC,IAAI,CAAC;AACL,cAAM,SAAS,QAAQ;AAAA,UACrB,QAAQ;AAAA,UACR,QAAQ,CAAC;AAAA,YACP,SAAS,cAAM,SAAS,MAAM,OAAO;AAAA,YACrC,WAAW,MAAM;AAAA,YACjB,gBAAgB,MAAM;AAAA,YACtB,SAAS,qBAAqB,KAAK;AAAA;AAAA,YAEnC,GAAG;AAAA,UACL,CAAC;AAAA,QACH,CAAC;AACD,cAAM,kBAAkB,MAAM,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,IAAI;AACrH,wBAAgB,KAAK,OAAO;AAC5B,cAAM,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,MAAM,eAAe;AAAA,MAChH;AACA,YAAM,SAAS,QAAQ;AAAA,QACrB,QAAQ;AAAA,QACR,QAAQ,CAAC;AAAA,UACP,SAAS,cAAM,SAAS,OAAO;AAAA,QACjC,CAAC;AAAA,MACH,CAAC;AACD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,UAAU,OAAO,UAAU,WAAW,QAAQ,+BAAO;AAC3D,UAAI,yBAAyB,KAAK,OAAO,GAAG;AAC1C,cAAM,IAAI,yBAAyB,KAAK;AAAA,MAC1C;AACA,YAAM,IAAI,iBAAiB,KAAK;AAAA,IAClC;AAAA,EACF;AAAA,EACA,MAAM,eAAe;AACnB,UAAM;AAAA,MACJ,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF,IAAI,MAAM,OAAO,wBAAkC;AACnD,UAAM,CAAC,cAAc,GAAG,cAAc,IAAI,KAAK,eAAe,IAAI,WAAS;AACzE,UAAI;AAAA,QACF;AAAA,MACF,IAAI;AACJ,aAAO;AAAA,IACT,CAAC;AACD,QAAI,cAAc;AAEhB,4BAAsB,MAAM,WAAW,MAAM,iBAAiB,KAAK;AAAA,QACjE,aAAa,KAAK;AAAA,QAClB,WAAW,KAAK,QAAQ;AAAA,QACxB,iBAAiB;AAAA,QACjB,gBAAgB;AAAA,QAChB,QAAQ,CAAC,YAAY;AAAA,QACrB;AAAA,QACA,UAAU;AAAA,UACR,MAAM,KAAK,QAAQ,aAAa;AAAA,UAChC,aAAa,KAAK,QAAQ,aAAa,eAAe;AAAA,UACtD,KAAK,KAAK,QAAQ,aAAa;AAAA,UAC/B,OAAO,CAAC,KAAK,QAAQ,aAAa,WAAW,EAAE;AAAA,QACjD;AAAA,QACA,QAAQ,OAAO,YAAY,KAAK,eAAe,IAAI,WAAS;AAAA,UAAC,MAAM;AAAA,UAAS,MAAM,IAAI,CAAC,KAAK;AAAA;AAAA,QAC5F,CAAC,CAAC;AAAA,QACF,gBAAgB,KAAK,QAAQ;AAAA,MAC/B,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EACA,MAAM,iBAAiB;AACrB,QAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C;AAAA,IACF;AACA,2BAAuB,MAAM,kBAAkB,iBAAiB,EAAE,KAAK,IAAI;AAC3E,0BAAsB,MAAM,SAAS,EAAE,GAAG,mBAAmB,KAAK,iBAAiB;AACnF,0BAAsB,MAAM,SAAS,EAAE,GAAG,gBAAgB,KAAK,cAAc;AAC7E,0BAAsB,MAAM,SAAS,EAAE,GAAG,cAAc,KAAK,YAAY;AACzE,0BAAsB,MAAM,SAAS,EAAE,GAAG,kBAAkB,KAAK,YAAY;AAC7E,0BAAsB,MAAM,SAAS,EAAE,GAAG,eAAe,KAAK,YAAY;AAC1E,0BAAsB,MAAM,SAAS,EAAE,GAAG,WAAW,KAAK,SAAS;AAAA,EACrE;AACF;AACA,eAAe,mBAAmB;AAChC,MAAI,CAAC,sBAAsB,MAAM,oBAAoB,KAAK,MAA0B;AAClF,0BAAsB,MAAM,sBAAsB,KAAK,aAAa,CAAC;AAAA,EACvE;AACA,SAAO,sBAAsB,MAAM,oBAAoB;AACzD;AACA,eAAe,kBAAkB;AAC/B,QAAM,mBAAmB,uBAAuB,MAAM,sBAAsB,qBAAqB,EAAE,KAAK,IAAI;AAC5G,MAAI,iBAAiB,SAAS,oBAAoB,GAAG;AACnD,WAAO;AAAA,EACT;AACA,MAAI,CAAC,KAAK,QAAQ,kBAAkB;AAClC,WAAO;AAAA,EACT;AACA,QAAM,kBAAkB,MAAM,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,IAAI;AACrH,QAAM,kBAAkB,KAAK,eAAe,IAAI,WAAS;AACvD,QAAI;AAAA,MACF;AAAA,IACF,IAAI;AACJ,WAAO;AAAA,EACT,CAAC;AACD,QAAM,kBAAkB,uBAAuB,MAAM,wBAAwB,uBAAuB,EAAE,KAAK,IAAI;AAC/G,MAAI,gBAAgB,UAAU,CAAC,gBAAgB,KAAK,QAAM,gBAAgB,SAAS,EAAE,CAAC,GAAG;AACvF,WAAO;AAAA,EACT;AACA,SAAO,CAAC,gBAAgB,MAAM,QAAM,gBAAgB,SAAS,EAAE,CAAC;AAClE;AACA,SAAS,oBAAoB;AAC3B,MAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C;AAAA,EACF;AACA,wBAAsB,MAAM,SAAS,EAAE,eAAe,mBAAmB,KAAK,iBAAiB;AAC/F,wBAAsB,MAAM,SAAS,EAAE,eAAe,gBAAgB,KAAK,cAAc;AACzF,wBAAsB,MAAM,SAAS,EAAE,eAAe,cAAc,KAAK,YAAY;AACrF,wBAAsB,MAAM,SAAS,EAAE,eAAe,kBAAkB,KAAK,YAAY;AACzF,wBAAsB,MAAM,SAAS,EAAE,eAAe,eAAe,KAAK,YAAY;AACtF,wBAAsB,MAAM,SAAS,EAAE,eAAe,WAAW,KAAK,SAAS;AACjF;AACA,eAAe,wBAAwB,QAAQ;AAC7C,QAAM,sBAAsB,MAAM,QAAQ,EAAE,QAAQ,sBAAsB,KAAK,UAAU,MAAM,CAAC;AAClG;AACA,eAAe,0BAA0B;AACvC,QAAM,OAAO,MAAM,sBAAsB,MAAM,QAAQ,EAAE,QAAQ,oBAAoB;AACrF,SAAO,OAAO,KAAK,MAAM,IAAI,IAAI,CAAC;AACpC;AACA,SAAS,0BAA0B;AAnanC;AAoaE,MAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C,WAAO,CAAC;AAAA,EACV;AACA,QAAM,YAAW,uCAAsB,MAAM,SAAS,EAAE,YAAvC,mBAAgD,WAAW,eAA3D,mBAAuE,WAAvE,mBAA+E,IAAI,WAAS,SAAS,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK,EAAE;AAC/I,SAAO,YAAY,CAAC;AACtB;AACA,SAAS,wBAAwB;AA1ajC;AA2aE,MAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AAC3C,WAAO,CAAC;AAAA,EACV;AACA,QAAM,WAAU,iCAAsB,MAAM,SAAS,EAAE,YAAvC,mBAAgD,WAAW,eAA3D,mBAAuE;AACvF,SAAO,WAAW,CAAC;AACrB;",
  "names": []
}
