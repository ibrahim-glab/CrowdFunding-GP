import {
  require_events
} from "./chunk-FSFHF7RN.js";
import {
  __commonJS
} from "./chunk-HY2WJTHE.js";

// node_modules/eth-provider/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/eth-provider/resolve/index.js"(exports, module) {
    var getProtocol = (location) => {
      if (location === "injected")
        return "injected";
      if (location.endsWith(".ipc"))
        return "ipc";
      if (location.startsWith("wss://") || location.startsWith("ws://"))
        return "ws";
      if (location.startsWith("https://") || location.startsWith("http://"))
        return "http";
      return "";
    };
    module.exports = (targets, presets) => {
      return [].concat(...[].concat(targets).map((provider) => {
        if (presets[provider]) {
          return presets[provider].map((location) => ({ type: provider, location, protocol: getProtocol(location) }));
        } else {
          return { type: "custom", location: provider, protocol: getProtocol(provider) };
        }
      })).filter((provider) => {
        if (provider.protocol || provider.type === "injected") {
          return true;
        } else {
          console.log('eth-provider | Invalid provider preset/location: "' + provider.location + '"');
          return false;
        }
      });
    };
  }
});

// node_modules/ethereum-provider/dist/payload.js
var require_payload = __commonJS({
  "node_modules/ethereum-provider/dist/payload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    function create(method, params = [], id, targetChain) {
      const payload = {
        id,
        method,
        params,
        jsonrpc: "2.0"
      };
      if (targetChain) {
        payload.chainId = targetChain;
      }
      if (payload.method === "eth_sendTransaction") {
        const mismatchedChain = isChainMismatch(payload);
        if (mismatchedChain) {
          throw new Error(`Payload chainId (${mismatchedChain}) inconsistent with specified target chainId: ${targetChain}`);
        }
        return updatePayloadChain(payload);
      }
      return payload;
    }
    exports.create = create;
    function isChainMismatch(payload) {
      if (payload.method !== "eth_sendTransaction")
        return false;
      const tx = payload.params[0] || {};
      const chainId = tx.chainId;
      return "chainId" in tx && parseInt(chainId) !== parseInt(payload.chainId || chainId);
    }
    function updatePayloadChain(payload) {
      const tx = payload.params[0] || {};
      return { ...payload, params: [{ ...tx, chainId: tx.chainId || payload.chainId }, ...payload.params.slice(1)] };
    }
  }
});

// node_modules/ethereum-provider/dist/index.js
var require_dist = __commonJS({
  "node_modules/ethereum-provider/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __importDefault(require_events());
    var payload_1 = require_payload();
    var Provider = class extends events_1.default {
      constructor(connection) {
        super();
        this.promises = {};
        this.attemptedSubscriptions = /* @__PURE__ */ new Set();
        this.subscriptions = [];
        this.checkConnectionRunning = false;
        this.nextId = 1;
        this.connected = false;
        this.accounts = [];
        this.selectedAddress = void 0;
        this.coinbase = void 0;
        this.enable = this.enable.bind(this);
        this.doSend = this.doSend.bind(this);
        this.send = this.send.bind(this);
        this.sendBatch = this.sendBatch.bind(this);
        this.subscribe = this.subscribe.bind(this);
        this.unsubscribe = this.unsubscribe.bind(this);
        this.resumeSubscriptions = this.resumeSubscriptions.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.sendAsyncBatch = this.sendAsyncBatch.bind(this);
        this.isConnected = this.isConnected.bind(this);
        this.close = this.close.bind(this);
        this.request = this.request.bind(this);
        this.connection = connection;
        this.on("connect", this.resumeSubscriptions);
        this.connection.on("connect", () => this.checkConnection(1e3));
        this.connection.on("close", () => {
          this.connected = false;
          this.attemptedSubscriptions.clear();
          this.emit("close");
          this.emit("disconnect");
        });
        this.connection.on("payload", (payload) => {
          const { id, method, error, result } = payload;
          if (typeof id !== "undefined") {
            if (this.promises[id]) {
              const requestMethod = this.promises[id].method;
              if (requestMethod && ["eth_accounts", "eth_requestAccounts"].includes(requestMethod)) {
                const accounts = result || [];
                this.accounts = accounts;
                this.selectedAddress = accounts[0];
                this.coinbase = accounts[0];
              }
              payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);
              delete this.promises[id];
            }
          } else if (method && method.indexOf("_subscription") > -1) {
            this.emit(payload.params.subscription, payload.params.result);
            this.emit(method, payload.params);
            this.emit("message", {
              type: payload.method,
              data: {
                subscription: payload.params.subscription,
                result: payload.params.result
              }
            });
            this.emit("data", payload);
          }
        });
        this.on("newListener", (event) => {
          if (Object.keys(this.eventHandlers).includes(event)) {
            if (!this.attemptedSubscription(event) && this.connected) {
              this.startSubscription(event);
              if (event === "networkChanged") {
                console.warn("The networkChanged event is being deprecated, use chainChanged instead");
              }
            }
          }
        });
        this.eventHandlers = {
          networkChanged: (netId) => {
            this.networkVersion = typeof netId === "string" ? parseInt(netId) : netId;
            this.emit("networkChanged", this.networkVersion);
          },
          chainChanged: (chainId) => {
            this.providerChainId = chainId;
            if (!this.manualChainId) {
              this.emit("chainChanged", chainId);
            }
          },
          chainsChanged: (chains) => {
            this.emit("chainsChanged", chains);
          },
          accountsChanged: (accounts) => {
            this.selectedAddress = accounts[0];
            this.emit("accountsChanged", accounts);
          },
          assetsChanged: (assets) => {
            this.emit("assetsChanged", assets);
          }
        };
      }
      get chainId() {
        return this.manualChainId || this.providerChainId;
      }
      async checkConnection(retryTimeout = 4e3) {
        if (this.checkConnectionRunning || this.connected)
          return;
        clearTimeout(this.checkConnectionTimer);
        this.checkConnectionTimer = void 0;
        this.checkConnectionRunning = true;
        try {
          this.networkVersion = await this.doSend("net_version", [], void 0, false);
          this.providerChainId = await this.doSend("eth_chainId", [], void 0, false);
          this.connected = true;
        } catch (e) {
          this.checkConnectionTimer = setTimeout(() => this.checkConnection(), retryTimeout);
          this.connected = false;
        } finally {
          this.checkConnectionRunning = false;
          if (this.connected) {
            this.emit("connect", { chainId: this.providerChainId });
          }
        }
      }
      attemptedSubscription(event) {
        return this.attemptedSubscriptions.has(event);
      }
      setSubscriptionAttempted(event) {
        this.attemptedSubscriptions.add(event);
      }
      async startSubscription(event) {
        console.debug(`starting subscription for ${event} events`);
        this.setSubscriptionAttempted(event);
        try {
          const eventId = await this.subscribe("eth_subscribe", event);
          this.on(eventId, this.eventHandlers[event]);
        } catch (e) {
          console.warn(`Unable to subscribe to ${event}`, e);
        }
      }
      resumeSubscriptions() {
        Object.keys(this.eventHandlers).forEach((event) => {
          if (this.listenerCount(event) && !this.attemptedSubscription(event))
            this.startSubscription(event);
        });
      }
      async enable() {
        const accounts = await this.doSend("eth_accounts");
        if (accounts.length > 0) {
          this.accounts = accounts;
          this.selectedAddress = accounts[0];
          this.coinbase = accounts[0];
          this.emit("enable");
          return accounts;
        } else {
          const err = new Error("User Denied Full Provider");
          err.code = "4001";
          throw err;
        }
      }
      doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {
        const sendFn = (resolve, reject) => {
          const method = typeof rawPayload === "object" ? rawPayload.method : rawPayload;
          const params = typeof rawPayload === "object" ? rawPayload.params : rawParams;
          const chainTarget = typeof rawPayload === "object" && rawPayload.chainId || targetChain;
          if (!method) {
            return reject(new Error("Method is not a valid string."));
          }
          try {
            const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);
            this.promises[payload.id] = {
              resolve: (result) => resolve(result),
              reject,
              method: payload.method
            };
            this.connection.send(payload);
          } catch (e) {
            reject(e);
          }
        };
        if (this.connected || !waitForConnection) {
          return new Promise(sendFn);
        }
        return new Promise((resolve, reject) => {
          const resolveSend = () => {
            clearTimeout(disconnectTimer);
            return resolve(new Promise(sendFn));
          };
          const disconnectTimer = setTimeout(() => {
            this.off("connect", resolveSend);
            reject(new Error("Not connected"));
          }, 5e3);
          this.once("connect", resolveSend);
        });
      }
      async send(methodOrPayload, callbackOrArgs) {
        if (typeof methodOrPayload === "string" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
          const params = callbackOrArgs;
          return this.doSend(methodOrPayload, params);
        }
        if (methodOrPayload && typeof methodOrPayload === "object" && typeof callbackOrArgs === "function") {
          const cb = callbackOrArgs;
          return this.sendAsync(methodOrPayload, cb);
        }
        return this.request(methodOrPayload);
      }
      sendBatch(requests) {
        return Promise.all(requests.map((payload) => {
          return this.doSend(payload.method, payload.params);
        }));
      }
      async subscribe(type, method, params = []) {
        const id = await this.doSend(type, [method, ...params]);
        this.subscriptions.push(id);
        return id;
      }
      async unsubscribe(type, id) {
        const success = await this.doSend(type, [id]);
        if (success) {
          this.subscriptions = this.subscriptions.filter((_id) => _id !== id);
          this.removeAllListeners(id);
          return success;
        }
      }
      async sendAsync(rawPayload, cb) {
        if (!cb || typeof cb !== "function")
          return new Error("Invalid or undefined callback provided to sendAsync");
        if (!rawPayload)
          return cb(new Error("Invalid Payload"));
        if (Array.isArray(rawPayload)) {
          const payloads = rawPayload.map((p) => ({ ...p, jsonrpc: "2.0" }));
          const callback = cb;
          return this.sendAsyncBatch(payloads, callback);
        } else {
          const payload = { ...rawPayload, jsonrpc: "2.0" };
          const callback = cb;
          try {
            const result = await this.doSend(payload.method, payload.params);
            callback(null, { id: payload.id, jsonrpc: payload.jsonrpc, result });
          } catch (e) {
            callback(e);
          }
        }
      }
      async sendAsyncBatch(payloads, cb) {
        try {
          const results = await this.sendBatch(payloads);
          const result = results.map((entry, index) => {
            return { id: payloads[index].id, jsonrpc: payloads[index].jsonrpc, result: entry };
          });
          cb(null, result);
        } catch (e) {
          cb(e);
        }
      }
      isConnected() {
        return this.connected;
      }
      close() {
        if (this.connection && this.connection.close)
          this.connection.close();
        this.off("connect", this.resumeSubscriptions);
        this.connected = false;
        const error = new Error("Provider closed, subscription lost, please subscribe again.");
        this.subscriptions.forEach((id) => this.emit(id, error));
        this.subscriptions = [];
        this.manualChainId = void 0;
        this.providerChainId = void 0;
        this.networkVersion = void 0;
        this.selectedAddress = void 0;
        this.coinbase = void 0;
      }
      async request(payload) {
        return this.doSend(payload.method, payload.params, payload.chainId);
      }
      setChain(chainId) {
        if (typeof chainId === "number")
          chainId = "0x" + chainId.toString(16);
        const chainChanged = chainId !== this.chainId;
        this.manualChainId = chainId;
        if (chainChanged) {
          this.emit("chainChanged", this.chainId);
        }
      }
    };
    exports.default = Provider;
  }
});

// node_modules/eth-provider/ConnectionManager/index.js
var require_ConnectionManager = __commonJS({
  "node_modules/eth-provider/ConnectionManager/index.js"(exports, module) {
    var EventEmitter = require_events();
    var dev = true;
    var ConnectionManager = class extends EventEmitter {
      constructor(connections, targets, options) {
        super();
        this.targets = targets;
        this.options = options;
        this.connections = connections;
        this.connected = false;
        this.status = "loading";
        this.interval = options.interval || 5e3;
        this.name = options.name || "default";
        this.inSetup = true;
        this.connect();
      }
      connect(index = 0) {
        if (dev && index === 0)
          console.log(`



A connection cycle started for provider with name: ${this.name}`);
        if (this.connection && this.connection.status === "connected" && index >= this.connection.index) {
          if (dev)
            console.log("Stopping connection cycle becasuse we're already connected to a higher priority provider");
        } else if (this.targets.length === 0) {
          if (dev)
            console.log("No valid targets supplied");
        } else {
          const { protocol, location } = this.targets[index];
          this.connection = this.connections[protocol](location, this.options);
          const connectionErrorHandler = (err) => this.connectionError(index, err);
          this.connection.once("error", connectionErrorHandler);
          this.connection.on("connect", () => {
            this.connection.off("error", connectionErrorHandler);
            this.connection.once("error", (err) => this.onError(err));
            this.connection.once("close", () => {
              this.connected = false;
              this.emitClose();
              if (!this.closing)
                this.refresh();
            });
            this.connection.target = this.targets[index];
            this.connection.index = index;
            this.targets[index].status = this.connection.status;
            this.connected = true;
            this.inSetup = false;
            if (dev)
              console.log("Successfully connected to: " + this.targets[index].location);
            this.emit("connect");
          });
          this.connection.on("data", (data) => this.emit("data", data));
          this.connection.on("payload", (payload) => this.emit("payload", payload));
        }
      }
      onError(err) {
        if (this.listenerCount("error"))
          return this.emit("error", err);
        console.warn("[eth-provider] Uncaught connection error: " + err.message);
      }
      refresh(interval = this.interval) {
        if (dev)
          console.log(`Reconnect queued for ${(interval / 1e3).toFixed(2)}s in the future`);
        clearTimeout(this.connectTimer);
        this.connectTimer = setTimeout(() => this.connect(), interval);
      }
      connectionError(index, err) {
        if (this.connection && this.connection.close)
          this.connection.close();
        this.targets[index].status = err;
        if (this.targets.length - 1 === index) {
          this.inSetup = false;
          if (dev)
            console.warn("eth-provider unable to connect to any targets, view connection cycle summary: ", this.targets);
          this.refresh();
        } else {
          this.connect(++index);
        }
      }
      emitClose() {
        this.emit("close");
      }
      close() {
        this.closing = true;
        if (this.connection && this.connection.close && !this.connection.closed) {
          this.connection.close();
        } else {
          this.emit("close");
        }
        clearTimeout(this.connectTimer);
        clearTimeout(this.setupTimer);
      }
      error(payload, message, code = -1) {
        this.emit("payload", { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } });
      }
      send(payload) {
        if (this.inSetup) {
          this.setupTimer = setTimeout(() => this.send(payload), 100);
        } else if (this.connection.closed) {
          this.error(payload, "Not connected", 4900);
        } else {
          this.connection.send(payload);
        }
      }
    };
    module.exports = ConnectionManager;
  }
});

// node_modules/eth-provider/provider/index.js
var require_provider = __commonJS({
  "node_modules/eth-provider/provider/index.js"(exports, module) {
    var EventEmitter = require_events();
    var EthereumProvider = require_dist().default;
    var ConnectionManager = require_ConnectionManager();
    var monitor = (provider) => {
      function update(status) {
        provider.status = status;
        if (provider instanceof EventEmitter)
          provider.emit("status", status);
      }
      async function checkSyncing() {
        try {
          if (await provider.send("eth_syncing")) {
            update("syncing");
          }
        } catch (e) {
        }
      }
      async function checkConnected() {
        if (provider.inSetup)
          return setTimeout(checkConnected, 1e3);
        try {
          await provider.send("eth_chainId");
          update("connected");
          setTimeout(checkSyncing, 500);
        } catch (e) {
          update("disconnected");
        }
      }
      update("loading");
      checkConnected();
      provider.on("connect", () => checkConnected());
      provider.on("close", () => update("disconnected"));
      return provider;
    };
    module.exports = (connections, targets, options) => {
      if (connections.injected.__isProvider && targets.map((t) => t.type).indexOf("injected") > -1) {
        delete connections.injected.__isProvider;
        return monitor(connections.injected);
      }
      const provider = new EthereumProvider(new ConnectionManager(connections, targets, options));
      provider.setMaxListeners(128);
      return monitor(provider);
    };
  }
});

// node_modules/eth-provider/presets/index.js
var require_presets = __commonJS({
  "node_modules/eth-provider/presets/index.js"(exports, module) {
    module.exports = (options = {}) => {
      return {
        injected: ["injected"],
        frame: ["ws://127.0.0.1:1248", "http://127.0.0.1:1248"],
        direct: ["ws://127.0.0.1:8546", "http://127.0.0.1:8545"],
        // IPC paths will be prepended in Node/Electron
        infura: [`wss://mainnet.infura.io/ws/v3/${options.infuraId}`, `https://mainnet.infura.io/v3/${options.infuraId}`],
        alchemy: [`wss://eth-mainnet.ws.alchemyapi.io/v2/${options.alchemyId}`, `https://eth-mainnet.alchemyapi.io/v2/${options.alchemyId}`],
        infuraGoerli: [`wss://goerli.infura.io/ws/v3/${options.infuraId}`, `https://goerli.infura.io/v3/${options.infuraId}`],
        alchemyGoerli: [`wss://eth-goerli.ws.alchemyapi.io/v2/${options.alchemyId}`, `https://eth-goerli.alchemyapi.io/v2/${options.alchemyId}`],
        infuraPolygon: [`https://polygon-mainnet.infura.io/v3/${options.infuraId}`],
        infuraArbitrum: [`https://arbitrum-mainnet.infura.io/v3/${options.infuraId}`],
        infuraOptimism: [`https://optimism-mainnet.infura.io/v3/${options.infuraId}`],
        infuraSepolia: [`wss://sepolia.infura.io/ws/v3/${options.infuraId}`, `https://sepolia.infura.io/v3/${options.infuraId}`],
        gnosis: ["https://rpc.gnosischain.com"],
        optimism: ["https://mainnet.optimism.io"]
      };
    };
  }
});

// node_modules/eth-provider/connections/injected.js
var require_injected = __commonJS({
  "node_modules/eth-provider/connections/injected.js"(exports, module) {
    var EventEmitter = require_events();
    var InjectedConnection = class extends EventEmitter {
      constructor(_injected, options) {
        super();
        if (_injected) {
          setTimeout(() => this.onError(new Error("Injected web3 provider is not currently supported")), 0);
        } else {
          setTimeout(() => this.onError(new Error("No injected provider found")), 0);
        }
      }
      onError(err) {
        if (this.listenerCount("error"))
          this.emit("error", err);
      }
    };
    module.exports = (injected) => (options) => new InjectedConnection(injected, options);
  }
});

// node_modules/eth-provider/connections/unavailable.js
var require_unavailable = __commonJS({
  "node_modules/eth-provider/connections/unavailable.js"(exports, module) {
    var EventEmitter = require_events();
    var UnavailableConnection = class extends EventEmitter {
      constructor(message) {
        super();
        setTimeout(() => this.onError(new Error(message)), 0);
      }
      onError(err) {
        if (this.listenerCount("error"))
          this.emit("error", err);
      }
    };
    module.exports = (message) => () => new UnavailableConnection(message);
  }
});

// node_modules/eth-provider/parse/index.js
var require_parse = __commonJS({
  "node_modules/eth-provider/parse/index.js"(exports, module) {
    var last;
    var timeout;
    module.exports = (res, cb) => {
      const values = [];
      res.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach((data) => {
        if (last)
          data = last + data;
        let result;
        try {
          result = JSON.parse(data);
        } catch (e) {
          last = data;
          clearTimeout(timeout);
          timeout = setTimeout(() => cb(new Error("Parse response timeout")), 15 * 1e3);
          return;
        }
        clearTimeout(timeout);
        last = null;
        if (result)
          values.push(result);
      });
      cb(null, values);
    };
  }
});

// node_modules/eth-provider/connections/ws.js
var require_ws = __commonJS({
  "node_modules/eth-provider/connections/ws.js"(exports, module) {
    var EventEmitter = require_events();
    var parse = require_parse();
    var dev = true;
    var WebSocket;
    var WebSocketConnection = class extends EventEmitter {
      constructor(_WebSocket, url, options) {
        super();
        this.socketListeners = [];
        WebSocket = _WebSocket;
        setTimeout(() => this.create(url, options), 0);
      }
      create(url, options) {
        if (!WebSocket)
          return this.onError(new Error("No WebSocket transport available"));
        try {
          this.socket = new WebSocket(url, [], { origin: options.origin });
        } catch (e) {
          return this.onError(e);
        }
        this.addSocketListener("error", this.onError.bind(this));
        this.addSocketListener("open", this.onOpen.bind(this));
        this.addSocketListener("close", this.onClose.bind(this));
      }
      addSocketListener(event, handler) {
        this.socket.addEventListener(event, handler);
        this.socketListeners.push({ event, handler });
      }
      removeAllSocketListeners() {
        this.socketListeners.forEach(({ event, handler }) => {
          this.socket.removeEventListener(event, handler);
        });
        this.socketListeners = [];
      }
      onOpen() {
        this.emit("connect");
        this.addSocketListener("message", this.onMessage.bind(this));
      }
      onMessage(message) {
        const data = typeof message.data === "string" ? message.data : "";
        parse(data, (err, payloads) => {
          if (err)
            return;
          payloads.forEach((load) => {
            if (Array.isArray(load)) {
              load.forEach((payload) => this.emit("payload", payload));
            } else {
              this.emit("payload", load);
            }
          });
        });
      }
      onError(err) {
        if (this.listenerCount("error"))
          this.emit("error", err);
      }
      onClose(e) {
        const err = {
          reason: e ? e.reason : "unknown",
          code: e ? e.code : "unknown"
        };
        if (this.socket) {
          this.removeAllSocketListeners();
          this.socket = null;
        }
        this.closed = true;
        if (dev)
          console.log(`Closing WebSocket connection, reason: ${err.reason} (code ${err.code})`);
        this.emit("close");
        this.removeAllListeners();
      }
      close() {
        if (this.socket && WebSocket && this.socket.readyState !== WebSocket.CLOSED) {
          this.removeAllSocketListeners();
          this.addSocketListener("error", () => {
          });
          this.addSocketListener("close", this.onClose.bind(this));
          if (this.socket.terminate) {
            this.socket.terminate();
          } else {
            this.socket.close();
          }
        } else {
          this.onClose();
        }
      }
      error(payload, message, code = -1) {
        this.emit("payload", { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } });
      }
      send(payload) {
        try {
          if (this.socket && this.socket.readyState === this.socket.CONNECTING) {
            setTimeout((_) => this.send(payload), 10);
          } else if (!this.socket || this.socket.readyState > 1) {
            this.connected = false;
            this.error(payload, "Not connected");
          } else {
            this.socket.send(JSON.stringify(payload));
          }
        } catch (e) {
          if (dev)
            console.error("Error sending Websocket request", e);
          this.error(payload, e.message);
        }
      }
    };
    module.exports = (WebSocket2) => (url, cb) => new WebSocketConnection(WebSocket2, url, cb);
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse2 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.URL = exports.DNS = void 0;
    exports.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL;
    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/version.js
var require_version = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version;
    exports.default = _default;
  }
});

// node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/eth-provider/connections/http.js
var require_http = __commonJS({
  "node_modules/eth-provider/connections/http.js"(exports, module) {
    var EventEmitter = require_events();
    var { v4: uuid } = require_commonjs_browser();
    var dev = true;
    var XHR;
    var HTTPConnection = class extends EventEmitter {
      constructor(_XHR, url, options) {
        super();
        XHR = _XHR;
        this.options = options;
        this.connected = false;
        this.subscriptions = false;
        this.status = "loading";
        this.url = url;
        this.pollId = uuid();
        setTimeout(() => this.create(), 0);
        this._emit = (...args) => !this.closed ? this.emit(...args) : null;
      }
      onError(err) {
        if (!this.closed && this.listenerCount("error"))
          this.emit("error", err);
      }
      create() {
        if (!XHR)
          return this.onError(new Error("No HTTP transport available"));
        this.on("error", () => {
          if (this.connected)
            this.close();
        });
        this.init();
      }
      init() {
        this.send({ jsonrpc: "2.0", method: "net_version", params: [], id: 1 }, (err, response) => {
          if (err)
            return this.onError(err);
          this.connected = true;
          this._emit("connect");
          this.send({ jsonrpc: "2.0", id: 1, method: "eth_pollSubscriptions", params: [this.pollId, "immediate"] }, (err2, response2) => {
            if (!err2) {
              this.subscriptions = true;
              this.pollSubscriptions();
            }
          });
        });
      }
      pollSubscriptions() {
        this.send({ jsonrpc: "2.0", id: 1, method: "eth_pollSubscriptions", params: [this.pollId] }, (err, result) => {
          if (err) {
            this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 1e4);
            return this.onError(err);
          } else {
            if (!this.closed)
              this.subscriptionTimeout = this.pollSubscriptions();
            if (result) {
              result.map((p) => {
                let parse;
                try {
                  parse = JSON.parse(p);
                } catch (e) {
                  parse = false;
                }
                return parse;
              }).filter((n) => n).forEach((p) => this._emit("payload", p));
            }
          }
        });
      }
      close() {
        if (dev)
          console.log("Closing HTTP connection");
        clearTimeout(this.subscriptionTimeout);
        this._emit("close");
        this.closed = true;
        this.removeAllListeners();
      }
      filterStatus(res) {
        if (res.status >= 200 && res.status < 300)
          return res;
        const error = new Error(res.statusText);
        error.res = res;
        throw error.message;
      }
      error(payload, message, code = -1) {
        this._emit("payload", { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } });
      }
      send(payload, internal) {
        if (this.closed)
          return this.error(payload, "Not connected");
        if (payload.method === "eth_subscribe") {
          if (this.subscriptions) {
            payload.pollId = this.pollId;
          } else {
            return this.error(payload, "Subscriptions are not supported by this HTTP endpoint");
          }
        }
        const xhr = new XHR();
        let responded = false;
        const res = (err, result) => {
          if (!responded) {
            xhr.abort();
            responded = true;
            if (internal) {
              internal(err, result);
            } else {
              const { id, jsonrpc } = payload;
              const load = err ? { id, jsonrpc, error: { message: err.message, code: err.code } } : { id, jsonrpc, result };
              this._emit("payload", load);
            }
          }
        };
        try {
          xhr.open("POST", this.url, true);
          xhr.setRequestHeader("Content-Type", "application/json");
          xhr.timeout = 60 * 1e3;
          xhr.onerror = res;
          xhr.ontimeout = res;
          xhr.onreadystatechange = () => {
            if (xhr.readyState === 4) {
              try {
                const response = JSON.parse(xhr.responseText);
                res(response.error, response.result);
              } catch (e) {
                res(e);
              }
            }
          };
          xhr.send(JSON.stringify(payload));
        } catch (e) {
          if (dev)
            console.error("Error sending HTTP request", e);
          res({ message: e.message, code: -1 });
        }
      }
    };
    module.exports = (XHR2) => (url, options) => new HTTPConnection(XHR2, url, options);
  }
});

// node_modules/eth-provider/browser.js
var require_browser = __commonJS({
  "node_modules/eth-provider/browser.js"(exports, module) {
    var resolve = require_resolve();
    var provider = require_provider();
    var presets = require_presets();
    var injected = {
      ethereum: typeof window !== "undefined" && typeof window.ethereum !== "undefined" ? window.ethereum : null,
      web3: typeof window !== "undefined" && typeof window.web3 !== "undefined" ? window.web3.currentProvider : null
    };
    var ws = typeof window !== "undefined" && typeof window.WebSocket !== "undefined" ? window.WebSocket : null;
    var XHR = typeof window !== "undefined" && typeof window.XMLHttpRequest !== "undefined" ? window.XMLHttpRequest : null;
    if (injected.ethereum)
      injected.ethereum.__isProvider = true;
    var connections = {
      injected: injected.ethereum || require_injected()(injected.web3),
      ipc: require_unavailable()("IPC connections are unavliable in the browser"),
      ws: require_ws()(ws),
      http: require_http()(XHR)
    };
    module.exports = (targets, options) => {
      if (targets && !Array.isArray(targets) && typeof targets === "object" && !options) {
        options = targets;
        targets = void 0;
      }
      if (!targets)
        targets = ["injected", "frame"];
      if (!options)
        options = {};
      targets = [].concat(targets);
      targets.forEach((t) => {
        if (t.startsWith("alchemy") && !options.alchemyId)
          throw new Error("Alchemy was included as a connection target but no Alchemy project ID was passed in options e.g. { alchemyId: '123abc' }");
        if (t.startsWith("infura") && !options.infuraId)
          throw new Error("Infura was included as a connection target but no Infura project ID was passed in options e.g. { infuraId: '123abc' }");
      });
      const sets = presets(options);
      return provider(connections, resolve(targets, sets), options);
    };
  }
});
export default require_browser();
//# sourceMappingURL=browser-UOXYJN5G.js.map
