import {
  ContractPublisher
} from "./chunk-4X5MHEIS.js";
import {
  createTransactionBatches,
  deployContractDeterministic,
  deployWithThrowawayDeployer,
  getDeploymentInfo
} from "./chunk-ZTXDEAPM.js";
import {
  TWMultichainRegistryLogic_default
} from "./chunk-YKWEALR3.js";
import {
  require_fast_deep_equal
} from "./chunk-RBNKNJXH.js";
import {
  CommonNFTInput,
  CommonNFTOutput,
  NFTInputOrUriSchema,
  normalizePriceValue
} from "./chunk-KC5M5N6O.js";
import {
  ContractEncoder,
  fetchCurrencyValue,
  isNativeToken
} from "./chunk-OPQDTNHM.js";
import {
  AbiSchema,
  AddressOrEnsSchema,
  AddressZero,
  AmountSchema,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  COMMON_FACTORY,
  CONTRACT_ADDRESSES,
  CUSTOM_GAS_FOR_CHAIN,
  ChainId,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  ContractWrapper,
  DeployTransaction,
  DropErc721ContractSchema,
  EditionDropInitializer,
  EditionInitializer,
  EventType,
  MarketplaceInitializer,
  MarketplaceV3Initializer,
  MultiwrapInitializer,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  RPCConnectionHandler,
  SignatureDropInitializer,
  SplitInitializer,
  THIRDWEB_DEPLOYER,
  ThirdwebStorage,
  TokenDropInitializer,
  TokenInitializer,
  Transaction,
  VoteInitializer,
  buildDeployTransactionFunction,
  buildTransactionFunction,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeForwarderAddress,
  createLruCache,
  detectFeatures,
  encodeConstructorParamsForImplementation,
  extractConstructorParamsFromAbi,
  extractFeatures,
  fetchAndCacheDeployMetadata,
  fetchContractMetadataFromAddress,
  fetchExtendedReleaseMetadata,
  fetchPublishedContractFromPolygon,
  fetchSourceFilesFromMetadata,
  getChainProvider,
  getCompositeABI,
  getContractAddressByChainId,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getCreate2FactoryDeploymentInfo,
  getDefaultGasOverrides,
  getInitBytecodeWithSalt,
  getMultichainRegistryAddress,
  getProcessEnv,
  getSignerAndProvider,
  hasMatchingAbi,
  invariant,
  isBrowser,
  isChainConfig,
  isContractDeployed,
  isEIP155Enforced,
  require_bs58,
  resolveAddress,
  resolveContractUriFromAddress,
  resolveImplementation,
  setSupportedChains,
  signTypedDataInternal,
  z
} from "./chunk-RH5X6O6Y.js";
import {
  defaultChains
} from "./chunk-OSKR2P2Q.js";
import {
  eventemitter3_default
} from "./chunk-LYEG5PGG.js";
import {
  Contract,
  ContractFactory,
  init_lib,
  utils_exports
} from "./chunk-I3BLH5LU.js";
import {
  require_utils
} from "./chunk-VZ6GM6HX.js";
import {
  Wallet
} from "./chunk-QDKWUOME.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-3JDV7GMI.js";
import {
  require_bn
} from "./chunk-JVFNGTH2.js";
import {
  __publicField,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryRouter.json
var TWMultichainRegistryRouter_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_pluginMap",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "_trustedForwarders",
        type: "address[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "string",
        name: "functionSignature",
        type: "string"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldPluginAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newPluginAddress",
        type: "address"
      }
    ],
    name: "PluginUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    stateMutability: "payable",
    type: "fallback"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "_getPluginForFunction",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin",
        name: "_plugin",
        type: "tuple"
      }
    ],
    name: "addPlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_pluginAddress",
        type: "address"
      }
    ],
    name: "getAllFunctionsOfPlugin",
    outputs: [
      {
        internalType: "bytes4[]",
        name: "registered",
        type: "bytes4[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllPlugins",
    outputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin[]",
        name: "registered",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "getPluginForFunction",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRoleWithSwitch",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginMap",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "removePlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin",
        name: "_plugin",
        type: "tuple"
      }
    ],
    name: "updatePlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-4ef5aea9.browser.esm.js
init_lib();

// node_modules/@thirdweb-dev/generated-abis/dist/thirdweb-dev-generated-abis.esm.js
var GENERATED_ABI = {};

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json
var TWFactory_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "address",
        name: "_registry",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "contractType",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "version",
        type: "uint256"
      }
    ],
    name: "ImplementationAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      }
    ],
    name: "ImplementationApproved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "proxy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      }
    ],
    name: "ProxyDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FACTORY_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "addImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "approval",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "currentVersion",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "deployProxy",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyByImplementation",
    outputs: [
      {
        internalType: "address",
        name: "deployedProxy",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyDeterministic",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deployer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_version",
        type: "uint256"
      }
    ],
    name: "getImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      }
    ],
    name: "getLatestImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "registry",
    outputs: [
      {
        internalType: "contract TWRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-4ef5aea9.browser.esm.js
var alreadyChecked = false;
function checkClientIdOrSecretKey(message, clientId, secretKey) {
  if (alreadyChecked) {
    return;
  }
  alreadyChecked = true;
  if (clientId || secretKey) {
    return;
  }
  console.warn(message);
}
async function getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage) {
  var _a;
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  let constructorParamMap = arguments.length > 6 ? arguments[6] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, contractVersion, storage, clientId, secretKey);
  const publishUri = publishedContract.metadataUri;
  const metadata = await fetchAndCacheDeployMetadata(publishUri, storage);
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishUri, storage);
  let encodedArgs;
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" || (extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic") {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);
    encodedArgs = (_a = deploymentInfo.find((contract) => contract.type === "implementation")) == null ? void 0 : _a.encodedArgs;
  } else {
    encodedArgs = await encodeConstructorParamsForImplementation(metadata.compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey);
  }
  return encodedArgs;
}
async function predictThirdwebContractAddress(contractName, chainId, storage) {
  var _a;
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, contractVersion, storage, clientId, secretKey);
  const publishUri = publishedContract.metadataUri;
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishUri, storage);
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" || (extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic") {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);
    const implementation2 = (_a = deploymentInfo.find((contract) => contract.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
    invariant(implementation2, "Error computing address for plugin router");
    return implementation2;
  }
  const implementation = await computeDeploymentInfo("implementation", provider, storage, create2Factory, {
    contractName
  }, clientId, secretKey);
  return implementation.transaction.predictedAddress;
}
async function getThirdwebContractAddress(contractName, chainId, storage) {
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const contractAddress = await predictThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);
  const isDeployed = await isContractDeployed(contractAddress, provider);
  invariant(isDeployed, "Contract not deployed yet");
  return contractAddress;
}
var VerificationStatus = {
  FAILED: "Fail - Unable to verify",
  SUCCESS: "Pass - Verified",
  PENDING: "Pending in queue",
  ALREADY_VERIFIED: "Contract source code already verified",
  AUTOMATICALLY_VERIFIED: "Already Verified"
};
var RequestStatus = {
  OK: "1",
  NOTOK: "0"
};
async function verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, storage) {
  let contractVersion = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "latest";
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let constructorArgs = arguments.length > 8 ? arguments[8] : void 0;
  const contractAddress = await getThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);
  const encodedArgs = await getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, contractVersion, clientId, secretKey, constructorArgs);
  console.info(`Verifying ${contractName} at address ${contractAddress}`);
  const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedArgs == null ? void 0 : encodedArgs.toString().replace("0x", ""));
  return guid;
}
async function verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedConstructorArgs) {
  try {
    const provider = getChainProvider(chainId, {});
    contractAddress = (await resolveImplementation(contractAddress, provider)).address;
    const compilerMetadata = await fetchContractMetadataFromAddress(contractAddress, provider, storage);
    const compilerVersion = compilerMetadata.metadata.compiler.version;
    const sources = await fetchSourceFilesFromMetadata(compilerMetadata, storage);
    const sourcesWithUrl = compilerMetadata.metadata.sources;
    const sourcesWithContents = {};
    for (const path of Object.keys(sourcesWithUrl)) {
      const sourceCode = sources.find((source) => path === source.filename);
      if (!sourceCode) {
        throw new Error(`Could not find source file for ${path}`);
      }
      sourcesWithContents[path] = {
        content: sourceCode.source
      };
    }
    const compilerInput = {
      language: "Solidity",
      sources: sourcesWithContents,
      settings: {
        optimizer: compilerMetadata.metadata.settings.optimizer,
        evmVersion: compilerMetadata.metadata.settings.evmVersion,
        remappings: compilerMetadata.metadata.settings.remappings,
        outputSelection: {
          "*": {
            "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
            "": ["ast"]
          }
        }
      }
    };
    const compilationTarget = compilerMetadata.metadata.settings.compilationTarget;
    const targets = Object.keys(compilationTarget);
    const contractPath = targets[0];
    const encodedArgs = encodedConstructorArgs ? encodedConstructorArgs : await fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, compilerMetadata.abi, provider, storage);
    const requestBody = {
      apikey: explorerAPIKey,
      module: "contract",
      action: "verifysourcecode",
      contractaddress: contractAddress,
      sourceCode: JSON.stringify(compilerInput),
      codeformat: "solidity-standard-json-input",
      contractname: `${contractPath}:${compilerMetadata.name}`,
      compilerversion: `v${compilerVersion}`,
      constructorArguements: encodedArgs
    };
    const parameters = new URLSearchParams({
      ...requestBody
    });
    const result = await fetch(explorerAPIUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: parameters.toString()
    });
    const data = await result.json();
    if (data.status === RequestStatus.OK) {
      return data.result;
    } else {
      throw new Error(`${data.result}`);
    }
  } catch (e) {
    throw new Error(e.toString());
  }
}
async function checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid) {
  const endpoint = `${explorerAPIUrl}?module=contract&action=checkverifystatus&guid=${guid}&apikey=${explorerAPIKey}"`;
  return new Promise((resolve, reject) => {
    const intervalId = setInterval(async () => {
      try {
        const result = await fetch(endpoint, {
          method: "GET"
        });
        const data = await result.json();
        if ((data == null ? void 0 : data.result) !== VerificationStatus.PENDING) {
          clearInterval(intervalId);
          resolve(data);
        }
      } catch (e) {
        clearInterval(intervalId);
        reject(e);
      }
    }, 3e3);
  });
}
async function isVerifiedOnEtherscan(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, clientId) {
  const provider = getChainProvider(chainId, {
    clientId
  });
  invariant(await isContractDeployed(contractAddress, provider), "Contract not deployed yet.");
  const endpoint = `${explorerAPIUrl}?module=contract&action=getsourcecode&address=${contractAddress}&apikey=${explorerAPIKey}"`;
  try {
    const result = await fetch(endpoint, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json;charset=UTF-8"
      }
    });
    const data = await result.json();
    const etherscanResult = data.result[0];
    if (etherscanResult.ABI === "Contract source code not verified") {
      return false;
    }
    return true;
  } catch (e) {
    throw new Error(`Error checking verification for contract ${contractAddress}: ${e}`);
  }
}
async function fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, abi, provider, storage) {
  const constructorParamTypes = extractConstructorParamsFromAbi(abi);
  if (constructorParamTypes.length === 0) {
    return "";
  }
  const result = await fetch(`${explorerAPIUrl}?module=contract&action=getcontractcreation&contractaddresses=${contractAddress}&apikey=${explorerAPIKey}`);
  const data = await result.json();
  if (data && data.status === RequestStatus.OK && data.result[0] !== void 0) {
    const contract = new utils_exports.Interface(abi);
    const txHash = data.result[0].txHash;
    let constructorArgs = "";
    if (contract.deploy.inputs.length === 0) {
      return "";
    }
    const tx = await provider.getTransaction(txHash);
    const txDeployBytecode = tx.data;
    try {
      const bytecode = await fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage);
      if (bytecode) {
        const bytecodeHex = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
        let create2FactoryAddress;
        try {
          create2FactoryAddress = await getCreate2FactoryAddress(provider);
        } catch (error) {
        }
        const create2SaltLength = tx.to === create2FactoryAddress ? 64 : 0;
        constructorArgs = txDeployBytecode.substring(bytecodeHex.length + create2SaltLength);
      }
    } catch (e) {
    }
    if (!constructorArgs) {
      const matches = [...txDeployBytecode.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      if (matches.length > 0) {
        constructorArgs = matches[0][2];
      }
    }
    if (!constructorArgs) {
      const constructorParamByteLength = constructorParamTypes.length * 64;
      constructorArgs = txDeployBytecode.substring(txDeployBytecode.length - constructorParamByteLength);
    }
    try {
      utils_exports.defaultAbiCoder.decode(contract.deploy.inputs, `0x${constructorArgs}`);
    } catch (e) {
      throw new Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.");
    }
    return constructorArgs;
  } else {
    return "";
  }
}
async function fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage) {
  const compilerMetaUri = await resolveContractUriFromAddress(contractAddress, provider);
  if (compilerMetaUri) {
    const ContractPublisherAbi = (await import("./ContractPublisher-QJTOP77Y.js")).default;
    const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider("polygon", {}));
    const publishedMetadataUri = await contract.getPublishedUriFromCompilerUri(compilerMetaUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);
    }
    const pubmeta = await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => fetchExtendedReleaseMetadata(uri, storage)));
    return pubmeta.length > 0 ? await (await storage.download(pubmeta[0].bytecodeUri)).text() : void 0;
  }
  return void 0;
}
var ContractVerifier = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    this.storage = storage;
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
  }
  /**
   * Verifies a Thirdweb contract
   *
   * @example
   * ```javascript
   *
   * // Note: If verifying on a network different from the SDK instance's network,
   * //       update the verifier's chain/network as below:
   * //
   * //       sdk.verifier.updateSignerOrProvider(chainId);
   *
   * const explorerAPIUrl = "" // e.g. https://api.etherscan.io/api
   * const explorerAPIKey = "" // Generate API key on the explorer
   *
   * await sdk.verifier.verifyThirdwebContract(
   *   "DropERC721",
   *   explorerAPIUrl,
   *   explorerAPIKey,
   * );
   * ```
   * @param contractName - Name of the contract to verify
   * @param explorerAPIUrl - Explorer API URL
   * @param explorerAPIKey - Explorer API key
   */
  async verifyThirdwebContract(contractName, explorerAPIUrl, explorerAPIKey) {
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let constructorArgs = arguments.length > 4 ? arguments[4] : void 0;
    const chainId = (await this.getProvider().getNetwork()).chainId;
    const guid = await verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, this.storage, contractVersion, this.options.clientId, this.options.secretKey, constructorArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
  /**
   * Verifies any contract
   *
   * @example
   * ```javascript
   *
   * // Note: If verifying on a network different from the SDK instance's network,
   * //       update the verifier's chain/network as below:
   * //
   * //       sdk.verifier.updateSignerOrProvider(chainId);
   *
   * const contractAddress = ""
   * const explorerAPIUrl = "" // e.g. https://api.etherscan.io/api
   * const explorerAPIKey = "" // Generate API key on the explorer
   *
   * await sdk.verifier.verifyContract(
   *   contractAddress,
   *   explorerAPIUrl,
   *   explorerAPIKey,
   * );
   * ```
   * @param contractAddress - Address of the contract to verify
   * @param explorerAPIUrl - Explorer API URL
   * @param explorerAPIKey - Explorer API key
   */
  async verifyContract(contractAddress, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    let encodedArgs;
    if (constructorArgs) {
      const paramTypes = Object.values(constructorArgs).map((arg) => {
        invariant(arg.type, "Param type is required");
        return arg.type;
      });
      const paramValues = Object.values(constructorArgs).map((arg) => {
        return arg.value;
      });
      encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypes, paramValues);
    }
    const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, this.storage, encodedArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
};
var LOCAL_NODE_PKEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
var UserWallet = class _UserWallet {
  constructor(network, options, storage) {
    __publicField(this, "events", new eventemitter3_default());
    this.connection = new RPCConnectionHandler(network, options);
    this.options = options;
    this.events = new eventemitter3_default();
    this.storage = storage;
  }
  // TODO disconnect()
  // TODO switchChain()
  // TODO tokens()
  // TODO NFTs()
  // TODO this will become the source of truth of the signer and have every contract read from it
  // TODO separate signer and provider logics
  connect(network) {
    this.connection.updateSignerOrProvider(network);
    this.events.emit("signerChanged", this.connection.getSigner());
  }
  /**
   * Transfer native or ERC20 tokens from this wallet to another wallet
   * @example
   * ```javascript
   *  // transfer 0.8 ETH
   * await sdk.wallet.transfer("0x...", 0.8);
   *  // transfer 0.8 tokens of `tokenContractAddress`
   * await sdk.wallet.transfer("0x...", 0.8, tokenContractAddress);
   * ```
   * @param to - the account to send funds to
   * @param amount - the amount in tokens
   * @param currencyAddress - Optional - ERC20 contract address of the token to transfer
   */
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const [resolvedTo, resolvedCurrency, amountInWei] = await Promise.all([resolveAddress(to), resolveAddress(currencyAddress), normalizePriceValue(this.connection.getProvider(), amount, currencyAddress)]);
    const signer = this.requireWallet();
    if (isNativeToken(resolvedCurrency)) {
      const from = await signer.getAddress();
      const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());
      const tx = await signer.sendTransaction({
        from,
        to: resolvedTo,
        value: amountInWei,
        ...gasOverrides
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const ERC20Abi = (await import("./IERC20-6KVZSVJS.js")).default;
      return {
        receipt: await this.createErc20(resolvedCurrency, ERC20Abi).sendTransaction("transfer", [resolvedTo, amountInWei])
      };
    }
  }
  /**
   * Fetch the native or ERC20 token balance of this wallet
   * @example
   * ```javascript
   * // native currency balance
   * const balance = await sdk.wallet.balance();
   * // ERC20 token balance
   * const erc20balance = await sdk.wallet.balance(tokenContractAddress);
   *
   * ```
   */
  async balance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    this.requireWallet();
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const provider = this.connection.getProvider();
    let balance;
    if (isNativeToken(resolvedCurrency)) {
      balance = await provider.getBalance(await this.getAddress());
    } else {
      const ERC20Abi = (await import("./IERC20-6KVZSVJS.js")).default;
      balance = await this.createErc20(resolvedCurrency, ERC20Abi).read("balanceOf", [await this.getAddress()]);
    }
    return await fetchCurrencyValue(provider, resolvedCurrency, balance);
  }
  /**
   * Get the currently connected address
   * @example
   * ```javascript
   * const address = await sdk.wallet.getAddress();
   * ```
   */
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  /**
   * Get the currently connected wallet's chainId
   * @internal
   */
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  /**
   * Get the number of transactions sent from this address.
   * @param blockTag - Optional - the block tag to read the nonce from
   */
  async getNonce(blockTag) {
    const txCount = await this.connection.getProvider().getTransactionCount(await this.getAddress(), blockTag);
    return txCount;
  }
  /**
   * Checks whether there's a signer connected with the SDK
   * @internal
   */
  isConnected() {
    try {
      this.requireWallet();
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Sign any message with the connected wallet private key
   * @param message - the message to sign
   * @returns The signed message
   *
   * @example
   * ```javascript
   * // This is the message to be signed
   * const message = "Sign this message...";
   *
   * // Now we can sign the message with the connected wallet
   * const signature = await sdk.wallet.sign(message);
   * ```
   */
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  /**
   * Sign a typed data structure (EIP712) with the connected wallet private key
   * @param domain - the domain as EIP712 standard
   * @param types - the structure and data types as defined by the EIP712 standard
   * @param message - the data to sign
   * @returns The payload and its associated signature
   *
   * @example
   * ```javascript
   * // This is the message to be signed
   * // Now we can sign the message with the connected wallet
   * const { payload, signature } = await sdk.wallet.signTypedData(
   *   {
          name: "MyEIP721Domain",
          version: "1",
          chainId: 1,
          verifyingContract: "0x...",
        },
        { MyStruct: [ { name: "to", type: "address" }, { name: "quantity", type: "uint256" } ] },
        { to: "0x...", quantity: 1 },
   * );
   * ```
   */
  async signTypedData(domain, types, message) {
    return await signTypedDataInternal(this.requireWallet(), domain, types, message);
  }
  /**
   * Recover the signing address from a signed message
   * @param message - the original message that was signed
   * @param signature - the signature to recover the address from
   * @returns The address that signed the message
   *
   * @example
   * ```javascript
   * const message = "Sign this message...";
   * const signature = await sdk.wallet.sign(message);
   *
   * // Now we can recover the signing address
   * const address = sdk.wallet.recoverAddress(message, signature);
   * ```
   */
  recoverAddress(message, signature) {
    const messageHash = utils_exports.hashMessage(message);
    const messageHashBytes = utils_exports.arrayify(messageHash);
    return utils_exports.recoverAddress(messageHashBytes, signature);
  }
  /**
   * Send a raw transaction to the blockchain from the connected wallet
   * @param transactionRequest - raw transaction data to send to the blockchain
   */
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());
    transactionRequest = {
      ...gasOverrides,
      ...transactionRequest
    };
    return signer.sendTransaction(transactionRequest);
  }
  /**
   * Execute a raw transaction to the blockchain from the connected wallet and wait for it to be mined
   * @param transactionRequest - raw transaction data to send to the blockchain
   */
  async executeRawTransaction(transactionRequest) {
    const tx = await this.sendRawTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  /**
   * Request funds from a running local node to the currently connected wallet
   * @param amount - the amount in native currency (in ETH) to request
   */
  async requestFunds(amount) {
    const chainId = await this.getChainId();
    if (chainId === ChainId.Localhost || chainId === ChainId.Hardhat) {
      const localWallet = new _UserWallet(new Wallet(LOCAL_NODE_PKEY, getChainProvider(chainId, this.options)), this.options, this.storage);
      return localWallet.transfer(await this.getAddress(), amount);
    } else {
      throw new Error(`Requesting funds is not supported on chain: '${chainId}'.`);
    }
  }
  /** ***********************
   * PRIVATE FUNCTIONS
   * ***********************/
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress, ERC20Abi) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, ERC20Abi, this.options, this.storage);
  }
};
function getAllDetectedFeatureNames(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features.map((f) => f.name);
}
function getAllDetectedExtensionNames(abi) {
  return getAllDetectedFeatureNames(abi);
}
function createStorage(storage, options) {
  if (storage) {
    return storage;
  } else if (options == null ? void 0 : options.gatewayUrls) {
    return new ThirdwebStorage({
      gatewayUrls: options.gatewayUrls,
      clientId: options.clientId,
      secretKey: options.secretKey
    });
  } else {
    return new ThirdwebStorage({
      clientId: options == null ? void 0 : options.clientId,
      secretKey: options == null ? void 0 : options.secretKey
    });
  }
}
var MultichainRegistry = class {
  constructor(network, storage) {
    __publicField(this, "addContract", buildTransactionFunction(async (contract) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryLogic,
        method: "add",
        args: [deployerAddress, contract.address, contract.chainId, contract.metadataURI || ""]
      });
    }));
    __publicField(this, "addContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = [];
      const contractEncoder = new ContractEncoder(this.registryLogic);
      contracts.forEach((contact) => {
        encoded.push(contractEncoder.encode("add", [deployerAddress, contact.address, contact.chainId, contact.metadataURI || ""]));
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "removeContract", buildTransactionFunction(async (contract) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryLogic,
        method: "remove",
        args: [deployerAddress, await resolveAddress(contract.address), contract.chainId]
      });
    }));
    __publicField(this, "removeContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const contractEncoder = new ContractEncoder(this.registryLogic);
      const encoded = await Promise.all(contracts.map(async (contract) => contractEncoder.encode("remove", [deployerAddress, await resolveAddress(contract.address), contract.chainId])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.storage = storage;
    this.registryLogic = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryLogic_default, options, storage);
    this.registryRouter = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryRouter_default, options, storage);
  }
  async updateSigner(signer) {
    this.registryLogic.updateSignerOrProvider(signer);
    this.registryRouter.updateSignerOrProvider(signer);
  }
  async getContractMetadataURI(chainId, address) {
    return await this.registryLogic.read("getMetadataUri", [chainId, await resolveAddress(address)]);
  }
  async getContractMetadata(chainId, address) {
    const uri = await this.getContractMetadataURI(chainId, address);
    if (!uri) {
      throw new Error(`No metadata URI found for contract ${address} on chain ${chainId}`);
    }
    return await this.storage.downloadJSON(uri);
  }
  async getContractAddresses(walletAddress) {
    return (await this.registryLogic.read("getAll", [await resolveAddress(walletAddress)])).filter((result) => utils_exports.isAddress(result.deploymentAddress) && result.deploymentAddress.toLowerCase() !== lib_exports.AddressZero).map((result) => ({
      address: result.deploymentAddress,
      chainId: result.chainId.toNumber()
    }));
  }
};
function extractFunctionParamsFromAbi(abi, functionName) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs || [];
    }
  }
  return [];
}
async function computeCloneFactoryAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "TWCloneFactory"
  }, clientId, secretKey)).transaction.predictedAddress;
}
function convertParamValues(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((p, index) => {
    if (p === "tuple" || p.endsWith("[]")) {
      if (typeof constructorParamValues[index] === "string") {
        return JSON.parse(constructorParamValues[index]);
      } else {
        return constructorParamValues[index];
      }
    }
    if (p === "bytes32") {
      invariant(utils_exports.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return utils_exports.hexZeroPad(constructorParamValues[index], 32);
    }
    if (p.startsWith("bytes")) {
      invariant(utils_exports.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return constructorParamValues[index];
    }
    if (p.startsWith("uint") || p.startsWith("int")) {
      return BigNumber.from(constructorParamValues[index].toString());
    }
    return constructorParamValues[index];
  });
}
async function deployCreate2Factory(signer, options) {
  var _a, _b, _c, _d;
  invariant(signer.provider, "No provider");
  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, signer.provider);
  if (commonFactoryExists) {
    return COMMON_FACTORY;
  }
  const enforceEip155 = await isEIP155Enforced(signer.provider);
  const networkId = (await signer.provider.getNetwork()).chainId;
  const chainId = enforceEip155 ? networkId : 0;
  console.debug(`ChainId ${networkId} enforces EIP155: ${enforceEip155}`);
  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, {
    gasPrice: CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice,
    gasLimit: CUSTOM_GAS_FOR_CHAIN[networkId].gasLimit
  }) : getCreate2FactoryDeploymentInfo(chainId, {});
  const factoryExists = await isContractDeployed(deploymentInfo.deployment, signer.provider);
  if (!factoryExists) {
    const gasPrice = ((_a = CUSTOM_GAS_FOR_CHAIN[networkId]) == null ? void 0 : _a.gasPrice) ? CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice : 100 * 10 ** 9;
    const gasLimit = ((_b = CUSTOM_GAS_FOR_CHAIN[networkId]) == null ? void 0 : _b.gasLimit) ? CUSTOM_GAS_FOR_CHAIN[networkId].gasLimit : 1e5;
    invariant(gasLimit, "gasLimit undefined for create2 factory deploy");
    invariant(gasPrice, "gasPrice undefined for create2 factory deploy");
    const valueToSend = BigNumber.from(gasPrice).mul(gasLimit);
    if ((await signer.provider.getBalance(deploymentInfo.signer)).lt(valueToSend)) {
      await (await signer.sendTransaction({
        to: deploymentInfo.signer,
        value: valueToSend
      })).wait();
    }
    try {
      console.debug(`deploying CREATE2 factory at: ${deploymentInfo.deployment}`);
      (_c = options == null ? void 0 : options.notifier) == null ? void 0 : _c.call(options, "deploying", "create2Factory");
      await (await signer.provider.sendTransaction(deploymentInfo.transaction)).wait();
      (_d = options == null ? void 0 : options.notifier) == null ? void 0 : _d.call(options, "deployed", "create2Factory");
    } catch (err) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(err)}`);
    }
  }
  return deploymentInfo.deployment;
}
var SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet, ChainId.Hardhat, ChainId.Localhost];
function getDefaultTrustedForwarders(chainId) {
  var _a, _b;
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const biconomyForwarder = chainEnum ? (_a = CONTRACT_ADDRESSES[chainEnum]) == null ? void 0 : _a.biconomyForwarder : AddressZero;
  const openzeppelinForwarder = chainEnum ? (_b = CONTRACT_ADDRESSES[chainEnum]) == null ? void 0 : _b.openzeppelinForwarder : AddressZero;
  return [openzeppelinForwarder, biconomyForwarder].filter((a) => a !== AddressZero);
}
function overrideRecipientAddress(signerAddress, recipient) {
  if (recipient === lib_exports.AddressZero) {
    return signerAddress;
  }
  return recipient;
}
async function getDeployArguments(contractType, metadata, contractURI, signer, storage) {
  const signerAddress = await signer.getAddress();
  const trustedForwarders = [];
  if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
    trustedForwarders.push(...metadata.trusted_forwarders);
  }
  switch (contractType) {
    case NFTDropInitializer.contractType:
    case NFTCollectionInitializer.contractType:
      const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];
    case SignatureDropInitializer.contractType:
      const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];
    case MultiwrapInitializer.contractType:
      const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
    case EditionDropInitializer.contractType:
    case EditionInitializer.contractType:
      const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];
    case TokenDropInitializer.contractType:
    case TokenInitializer.contractType:
      const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];
    case VoteInitializer.contractType:
      const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
      return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
    case SplitInitializer.contractType:
      const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
    case MarketplaceInitializer.contractType:
    case MarketplaceV3Initializer.contractType:
      const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];
    case PackInitializer.contractType:
      const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
    default:
      return [];
  }
}
async function getTrustedForwarders(provider, storage, contractName) {
  const chainId = (await provider.getNetwork()).chainId;
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const trustedForwarders = contractName && contractName === PackInitializer.name ? [] : chainEnum ? getDefaultTrustedForwarders(chainId) : [await computeForwarderAddress(provider, storage)];
  return trustedForwarders;
}
var APPROVED_IMPLEMENTATIONS = {
  [ChainId.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
  },
  [ChainId.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
  },
  [ChainId.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
  },
  [ChainId.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
  },
  [ChainId.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
  },
  [ChainId.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
  },
  [ChainId.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
  },
  [ChainId.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
  },
  [ChainId.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  },
  [ChainId.Hardhat]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  },
  [ChainId.Localhost]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  }
};
function getApprovedImplementation(chainId, contractType) {
  if (chainId in APPROVED_IMPLEMENTATIONS) {
    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];
    if (contractType in approvedImpls) {
      return approvedImpls[contractType];
    }
  }
  return null;
}
var ContractFactory2 = class extends ContractWrapper {
  constructor(factoryAddr, network, storage, options) {
    super(network, factoryAddr, TWFactory_default, options, storage);
    // Map from contract type to version to deploy specific versions by default
    __publicField(this, "DEFAULT_VERSION_MAP", {
      [NFTDropInitializer.contractType]: 3,
      [NFTCollectionInitializer.contractType]: 1,
      [SignatureDropInitializer.contractType]: 4,
      [MultiwrapInitializer.contractType]: 1,
      [EditionDropInitializer.contractType]: 2,
      [EditionInitializer.contractType]: 1,
      [TokenDropInitializer.contractType]: 2,
      [TokenInitializer.contractType]: 1,
      [VoteInitializer.contractType]: 1,
      [SplitInitializer.contractType]: 1,
      [MarketplaceInitializer.contractType]: 2,
      [MarketplaceV3Initializer.contractType]: 3,
      [PackInitializer.contractType]: 2
    });
    __publicField(this, "deploy", buildTransactionFunction(async (contractType, contractMetadata, eventEmitter, version, options, onExecute) => {
      const contract = PREBUILT_CONTRACTS_MAP[contractType];
      const metadata = await contract.schema.deploy.parseAsync(contractMetadata);
      const contractURI = await this.storage.upload(metadata);
      const implementationAddress = await this.getImplementation(contract, version) || void 0;
      if (!implementationAddress || implementationAddress === lib_exports.AddressZero) {
        throw new Error(`No implementation found for ${contractType}`);
      }
      const ABI = await contract.getAbi(implementationAddress, this.getProvider(), this.storage);
      const signer = this.getSigner();
      invariant(signer, "A signer is required to deploy contracts");
      const args = await getDeployArguments(contractType, metadata, contractURI, signer, this.storage);
      const encodedFunc = Contract.getInterface(ABI).encodeFunctionData("initialize", args);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = (options == null ? void 0 : options.saltForProxyDeploy) ? utils_exports.id(options.saltForProxyDeploy) : utils_exports.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    // TODO once IContractFactory is implemented, this can be probably be moved to its own class
    __publicField(this, "deployProxyByImplementation", buildTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs, eventEmitter, saltForProxyDeploy, onExecute) => {
      const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = saltForProxyDeploy ? utils_exports.id(saltForProxyDeploy) : utils_exports.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    this.storage = storage;
  }
  /**
   *
   * @param contractType - the contract type to deploy
   * @param metadata - the metadata for the contract
   * @param contractURI - the contract URI
   * @returns
   * @internal
   */
  async getDeployArguments(contractType, metadata, contractURI) {
    let trustedForwarders = [];
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    const signerAddress = await this.getSignerAddress();
    switch (contractType) {
      case NFTDropInitializer.contractType:
      case NFTCollectionInitializer.contractType:
        const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];
      case SignatureDropInitializer.contractType:
        const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];
      case MultiwrapInitializer.contractType:
        const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
      case EditionDropInitializer.contractType:
      case EditionInitializer.contractType:
        const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];
      case TokenDropInitializer.contractType:
      case TokenInitializer.contractType:
        const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];
      case VoteInitializer.contractType:
        const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
      case SplitInitializer.contractType:
        const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
      case MarketplaceInitializer.contractType:
        const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];
      case MarketplaceV3Initializer.contractType:
        const marketplaceV3Metadata = await MarketplaceV3Initializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceV3Metadata.platform_fee_recipient), marketplaceV3Metadata.platform_fee_basis_points];
      case PackInitializer.contractType:
        const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
      default:
        return [];
    }
  }
  async getImplementation(contract, version) {
    const encodedType = utils_exports.formatBytes32String(contract.name);
    const chainId = await this.getChainID();
    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);
    if (approvedImplementation && approvedImplementation.length > 0 && version === void 0) {
      return approvedImplementation;
    }
    return this.read("getImplementation", [encodedType, version !== void 0 ? version : this.DEFAULT_VERSION_MAP[contract.contractType]]);
  }
  async getLatestVersion(contractType) {
    const name = getContractName(contractType);
    if (!name) {
      throw new Error(`Invalid contract type ${contractType}`);
    }
    const encodedType = utils_exports.formatBytes32String(name);
    return this.read("currentVersion", [encodedType]);
  }
};
var ContractRegistry = class extends ContractWrapper {
  constructor(registryAddress, network, storage, TWRegistryABI, options) {
    super(network, registryAddress, TWRegistryABI, options, storage);
    __publicField(this, "addContract", buildTransactionFunction(async (contractAddress) => {
      return await this.addContracts.prepare([contractAddress]);
    }));
    __publicField(this, "addContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const contractEncoder = new ContractEncoder(this);
      const encoded = (await Promise.all(contractAddresses.map((addr) => resolveAddress(addr)))).map((address) => contractEncoder.encode("add", [deployerAddress, address]));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "removeContract", buildTransactionFunction(async (contractAddress) => {
      return await this.removeContracts.prepare([contractAddress]);
    }));
    __publicField(this, "removeContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const contractEncoder = new ContractEncoder(this);
      const encoded = (await Promise.all(contractAddresses.map((addr) => resolveAddress(addr)))).map((address) => contractEncoder.encode("remove", [deployerAddress, address]));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
  }
  async getContractAddresses(walletAddress) {
    return (await this.read("getAll", [await resolveAddress(walletAddress)])).filter((adr) => utils_exports.isAddress(adr) && adr.toLowerCase() !== lib_exports.AddressZero);
  }
};
var LoyaltyCardContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var LoyaltyCardContractDeploy = (() => LoyaltyCardContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var AirdropContractInput = (() => CommonContractSchema.merge(CommonSymbolSchema))();
var AirdropContractDeploy = (() => AirdropContractInput.merge(CommonTrustedForwarderSchema))();
async function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  invariant(signer.provider, "Provider is required");
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await deployCreate2Factory(signer);
  const constructorParams = extractConstructorParamsFromAbi(abi);
  const constructorParamTypes = constructorParams.map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const paramTypesForEncoder = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  const contractDeployed = await isContractDeployed(address, signer.provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${address}`);
    initBytecodeWithSalt = getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);
    const tx = {
      to: create2Factory,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  } else {
    throw new Error(`Contract already deployed at ${address}`);
  }
  return address;
}
async function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function directDeployDeterministicPublished(contractName, publisherAddress) {
  let contractVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let constructorArgs = arguments.length > 3 ? arguments[3] : void 0;
  let signer = arguments.length > 4 ? arguments[4] : void 0;
  let storage = arguments.length > 5 ? arguments[5] : void 0;
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let saltForCreate2 = arguments.length > 8 ? arguments[8] : void 0;
  let gasLimit = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 7e6;
  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await getCreate2FactoryAddress(provider);
  const constructorParams = extractConstructorParamsFromAbi(abi);
  const constructorParamTypes = constructorParams.map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const paramTypesForEncoder = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  return address;
}
async function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
async function predictAddressDeterministicPublished(contractName, publisherAddress) {
  let contractVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let constructorArgs = arguments.length > 3 ? arguments[3] : void 0;
  let provider = arguments.length > 4 ? arguments[4] : void 0;
  let storage = arguments.length > 5 ? arguments[5] : void 0;
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let saltForCreate2 = arguments.length > 8 ? arguments[8] : void 0;
  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
var ThirdwebSDK = class _ThirdwebSDK extends RPCConnectionHandler {
  /**
   * @internal
   * should never be accessed directly, use {@link ThirdwebSDK.getPublisher} instead
   */
  /**
   * Internal handler for uploading and downloading files
   */
  /**
   * New contract deployer
   */
  /**
   * Contract verifier
   */
  /**
   * The registry of deployed contracts
   */
  /**
   * Interact with the connected wallet
   */
  /**
   * Upload and download files from IPFS or from your own storage service
   */
  constructor(network) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let storage = arguments.length > 2 ? arguments[2] : void 0;
    const apiKeyType = "clientId";
    let warnMessage = `No API key. Please provide a ${apiKeyType}. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key`;
    checkClientIdOrSecretKey(warnMessage, options.clientId, options.secretKey);
    options = addChainToSupportedChains(network, options);
    super(network, options);
    /**
     * @internal
     * the cache of contracts that we have already seen
     */
    __publicField(this, "contractCache", /* @__PURE__ */ new Map());
    setSupportedChains(options == null ? void 0 : options.supportedChains);
    const configuredStorage = createStorage(storage, options);
    this.storage = configuredStorage;
    this.storageHandler = configuredStorage;
    this.wallet = new UserWallet(network, options, configuredStorage);
    this.deployer = new ContractDeployer(network, options, configuredStorage);
    this.verifier = new ContractVerifier(network, options, configuredStorage);
    this.multiChainRegistry = new MultichainRegistry(network, this.storageHandler, this.options);
    this._publisher = new ContractPublisher(network, this.options, this.storageHandler);
  }
  /**
   * Get an instance of the thirdweb SDK based on an AbstractWallet
   *
   * @example
   * ```javascript
   * import { ThirdwebSDK } from "@thirdweb-dev/sdk"
   *
   * const wallet = new AbstractWalletImplementation();
   * const sdk = await ThirdwebSDK.fromWallet(wallet, "mainnet");
   * ```
   *
   * @param wallet - the implementation of the AbstractWallet class to use for signing
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns An instance of the SDK
   *
   * @beta
   */
  static async fromWallet(wallet, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const signer = await wallet.getSigner();
    return _ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  /**
   * Get an instance of the thirdweb SDK based on an existing ethers signer
   *
   * @example
   * ```javascript
   * // get a signer from somewhere (createRandom is being used purely for example purposes)
   * const signer = Wallet.createRandom();
   *
   * // get an instance of the SDK with the signer already setup
   * const sdk = ThirdwebSDK.fromSigner(signer, "mainnet");
   * ```
   *
   * @param signer - a ethers Signer to be used for transactions
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns An instance of the SDK
   *
   * @beta
   */
  static fromSigner(signer, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    let signerWithProvider = signer;
    if (network) {
      try {
        const provider = getChainProvider(network, options);
        signerWithProvider = signer.connect(provider);
      } catch {
      }
    }
    const sdk = new _ThirdwebSDK(network || signerWithProvider, network ? addChainToSupportedChains(network, options) : options, storage);
    sdk.updateSignerOrProvider(signerWithProvider);
    return sdk;
  }
  /**
   * Get an instance of the thirdweb SDK based on a private key.
   *
   * @remarks
   * This should only be used for backend services or scripts, with the private key stored in a secure way.
   * **NEVER** expose your private key to the public in any way.
   *
   * @example
   * ```javascript
   * const sdk = ThirdwebSDK.fromPrivateKey("SecretPrivateKey", "mainnet");
   * ```
   *
   * @param privateKey - the private key - **DO NOT EXPOSE THIS TO THE PUBLIC**
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns An instance of the SDK
   *
   * @public
   */
  static fromPrivateKey(privateKey, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const provider = getChainProvider(network, options);
    const signer = new Wallet(privateKey, provider);
    return new _ThirdwebSDK(signer, addChainToSupportedChains(network, options), storage);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/wallets/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  /**
   * Get an instance of a NFT Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const dropContract = await sdk.getDropContract("0x1234...");
   * + const dropContract = await sdk.getContract("0x1234...", "nft-drop");
   * ```
   */
  async getNFTDrop(contractAddress) {
    return await this.getContract(contractAddress, "nft-drop");
  }
  /**
   * Get an instance of a Signature Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const signatureDrop = await sdk.getSignatureDrop("0x1234...");
   * + const signatureDrop = await sdk.getContract("0x1234...", "signature-drop");
   * ```
   */
  async getSignatureDrop(contractAddress) {
    return await this.getContract(contractAddress, "signature-drop");
  }
  /**
   * Get an instance of a NFT Collection Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const signatureDrop = await sdk.getNFTCollection("0x1234...");
   * + const signatureDrop = await sdk.getContract("0x1234...", "nft-collection");
   * ```
   */
  async getNFTCollection(contractAddress) {
    return await this.getContract(contractAddress, "nft-collection");
  }
  /**
   * Get an instance of a Edition Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const editionDrop = await sdk.getEditionDrop("0x1234...");
   * + const editionDrop = await sdk.getContract("0x1234...", "edition-drop");
   * ```
   */
  async getEditionDrop(contractAddress) {
    return await this.getContract(contractAddress, "edition-drop");
  }
  /**
   * Get an instance of a Edition contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const edition = await sdk.getEdition("0x1234...");
   * + const edition = await sdk.getContract("0x1234...", "edition");
   * ```
   */
  async getEdition(contractAddress) {
    return await this.getContract(contractAddress, "edition");
  }
  /**
   * Get an instance of a Token Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const tokenDrop = await sdk.getTokenDrop("0x1234...");
   * + const tokenDrop = await sdk.getContract("0x1234...", "token-drop");
   * ```
   */
  async getTokenDrop(contractAddress) {
    return await this.getContract(contractAddress, "token-drop");
  }
  /**
   * Get an instance of a Token contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const token = await sdk.getToken("0x1234...");
   * + const token = await sdk.getContract("0x1234...", "token");
   * ```
   */
  async getToken(contractAddress) {
    return await this.getContract(contractAddress, "token");
  }
  /**
   * Get an instance of a Vote contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const vote = await sdk.getVote("0x1234...");
   * + const vote = await sdk.getContract("0x1234...", "vote");
   * ```
   */
  async getVote(contractAddress) {
    return await this.getContract(contractAddress, "vote");
  }
  /**
   * Get an instance of a Split contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const split = await sdk.getSplit("0x1234...");
   * + const split = await sdk.getContract("0x1234...", "split");
   * ```
   */
  async getSplit(contractAddress) {
    return await this.getContract(contractAddress, "split");
  }
  /**
   * Get an instance of a Marketplace contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const marketplace = await sdk.getMarketplace("0x1234...");
   * + const marketplace = await sdk.getContract("0x1234...", "marketplace");
   * ```
   */
  async getMarketplace(contractAddress) {
    return await this.getContract(contractAddress, "marketplace");
  }
  /**
   * Get an instance of a Marketplace contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const marketplace = await sdk.getMarketplaceV3("0x1234...");
   * + const marketplace = await sdk.getContract("0x1234...", "marketplace-v3");
   * ```
   */
  async getMarketplaceV3(contractAddress) {
    return await this.getContract(contractAddress, "marketplace-v3");
  }
  /**
   * Get an instance of a Pack contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const pack = await sdk.getPack("0x1234...");
   * + const pack = await sdk.getContract("0x1234...", "pack");
   * ```
   */
  async getPack(contractAddress) {
    return await this.getContract(contractAddress, "pack");
  }
  /**
   * Get an instance of a Pack contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const multiWrap = await sdk.getMultiwrap("0x1234...");
   * + const multiWrap = await sdk.getContract("0x1234...", "multiwrap");
   * ```
   */
  async getMultiwrap(contractAddress) {
    return await this.getContract(contractAddress, "multiwrap");
  }
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @returns The contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}");
   * ```
   */
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @param contractType - the {@link ContractType} of the contract to load
   * @returns The contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}", "nft-drop");
   * ```
   */
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @param abi - the ABI ({@link ContractInterface}) of the contract to load
   * @returns The contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}", ABI);
   * ```
   */
  async getContract(address, contractTypeOrABI) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    if (resolvedAddress in GENERATED_ABI) {
      return await this.getContractFromAbi(resolvedAddress, GENERATED_ABI[resolvedAddress]);
    }
    let newContract;
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      try {
        const metadata = await this.getPublisher().fetchCompilerMetadataFromAddress(resolvedAddress);
        newContract = await this.getContractFromAbi(resolvedAddress, metadata.abi);
      } catch (e) {
        const resolvedContractType = await this.resolveContractType(resolvedAddress);
        if (resolvedContractType && resolvedContractType !== "custom") {
          const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(resolvedAddress, this.getProvider(), this.storage);
          newContract = await this.getContractFromAbi(resolvedAddress, contractAbi);
        } else {
          throw e;
        }
      }
    } else if (typeof contractTypeOrABI === "string" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {
      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), resolvedAddress, this.storage, this.options);
    } else {
      newContract = await this.getContractFromAbi(resolvedAddress, contractTypeOrABI);
    }
    this.contractCache.set(resolvedAddress, newContract);
    return newContract;
  }
  /**
   * @internal
   * @deprecated use {@link getContract} directly instead
   */
  async getBuiltInContract(address, contractType) {
    return await this.getContract(address, contractType);
  }
  /**
   * @param contractAddress - the address of the contract to attempt to resolve the contract type for
   * @returns The {@link ContractType} for the given contract address
   *
   */
  async resolveContractType(contractAddress) {
    try {
      const IThirdwebContractABI = (await import("./IThirdwebContract-HEO5V7TM.js")).default;
      const contract = new Contract(
        await resolveAddress(contractAddress),
        IThirdwebContractABI,
        // !provider only! - signer can break things here!
        this.getProvider()
      );
      const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
      return getContractTypeForRemoteName(remoteContractType);
    } catch (err) {
      return "custom";
    }
  }
  /**
   * Return all the contracts deployed by the specified address
   * @param walletAddress - the deployed address
   * @example
   * ```javascript
   * const contracts = sdk.getContractList("{{wallet_address}}");
   * ```
   */
  async getContractList(walletAddress) {
    var _a;
    const addresses = await ((_a = await this.deployer.getRegistry()) == null ? void 0 : _a.getContractAddresses(await resolveAddress(walletAddress))) || [];
    const chainId = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(addresses.map(async (address) => {
      return {
        address,
        chainId,
        contractType: () => this.resolveContractType(address),
        metadata: async () => (await this.getContract(address)).metadata.get(),
        extensions: async () => getAllDetectedExtensionNames((await this.getContract(address)).abi)
      };
    }));
  }
  async getMultichainContractList(walletAddress) {
    let chains = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultChains;
    const contracts = await this.multiChainRegistry.getContractAddresses(walletAddress);
    const chainMap = chains.reduce((acc, chain) => {
      acc[chain.chainId] = chain;
      return acc;
    }, {});
    const sdkMap = {};
    return contracts.map((_ref) => {
      let {
        address,
        chainId
      } = _ref;
      if (!chainMap[chainId]) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({
            name: ""
          }),
          extensions: async () => []
        };
      }
      try {
        let chainSDK = sdkMap[chainId];
        if (!chainSDK) {
          chainSDK = new _ThirdwebSDK(chainId, {
            ...this.options,
            // need to disable readonly settings for this to work
            readonlySettings: void 0,
            // @ts-expect-error - zod doesn't like this
            supportedChains: chains
          }, this.storage);
          sdkMap[chainId] = chainSDK;
        }
        return {
          address,
          chainId,
          contractType: () => chainSDK.resolveContractType(address),
          metadata: async () => (await chainSDK.getContract(address)).metadata.get(),
          extensions: async () => getAllDetectedExtensionNames((await chainSDK.getContract(address)).abi)
        };
      } catch (e) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({
            name: ""
          }),
          extensions: async () => []
        };
      }
    });
  }
  /**
   * Update the active signer or provider for all contracts
   * @param network - the new signer or provider
   */
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    this.multiChainRegistry.updateSigner(this.getSignerOrProvider());
    this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  /**
   * Get an instance of a Custom contract from a json ABI
   * @param address - the address of the deployed contract
   * @param abi - the JSON abi
   * @returns The contract
   * @beta
   * @example
   * ```javascript
   * // Import your ABI from a JSON file
   * import myABI from "./path/to/myABI.json";
   *
   * const contract = sdk.getContractFromAbi(
   *   "{{contract_address}}",
   *   // Pass in the "abi" field from the JSON file
   *   myABI.abi
   * );
   * ```
   */
  async getContractFromAbi(address, abi) {
    const [resolvedAddress, {
      SmartContract
    }] = await Promise.all([resolveAddress(address), import("./smart-contract-f3e34912.browser.esm-3BG5VYRR.js")]);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);
    const parsedABI = typeof abi === "string" ? JSON.parse(abi) : abi;
    const contract = new SmartContract(this.getSignerOrProvider(), resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(parsedABI), provider, this.options, this.storage), this.storageHandler, this.options, (await provider.getNetwork()).chainId);
    this.contractCache.set(resolvedAddress, contract);
    return contract;
  }
  /**
   * Get the native balance of a given address (wallet or contract)
   * @example
   * ```javascript
   * const balance = await sdk.getBalance("0x...");
   * console.log(balance.displayValue);
   * ```
   * @param address - the address to check the balance for
   */
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(await resolveAddress(address)));
  }
  /**
   * @internal
   */
  getPublisher() {
    return this._publisher;
  }
};
function addChainToSupportedChains(network, options) {
  if (isChainConfig(network)) {
    options = {
      ...options,
      // @ts-expect-error - we know that the network is assignable despite the readonly mismatch
      supportedChains: [network, ...(options == null ? void 0 : options.supportedChains) || []]
    };
  }
  return options;
}
var THIRDWEB_DEPLOYER2 = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
var ContractDeployer = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    /**
     * @internal
     * should never be accessed directly, use {@link ContractDeployer.getFactory} instead
     */
    /**
     * @internal
     * should never be accessed directly, use {@link ContractDeployer.getRegistry} instead
     */
    __publicField(this, "transactionListener", (event) => {
      if (event.status === "submitted") {
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: event.transactionHash
        });
      }
    });
    /**
     * Deploys an NFT Collection contract
     *
     * @remarks Deploys an NFT Collection contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployNFTCollection({
     *   name: "My Collection",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployNFTCollection", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTCollectionInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new NFTDrop contract
     *
     * @remarks Deploys an NFT Drop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployNFTDrop({
     *   name: "My Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployNFTDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new LoyaltyCard contract
     *
     * @remarks Deploys a LoyaltyCard contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployLoyaltyCard({
     *   name: "My Loyalty Program",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployLoyaltyCard", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await LoyaltyCardContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points, parsedMetadata.platform_fee_basis_points, parsedMetadata.platform_fee_recipient];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "LoyaltyCard", deployArgs, "latest", options);
    }));
    /**
     * Deploys a new OpenEditionERC721 contract
     *
     * @remarks Deploys a OpenEdition contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployOpenEdition({
     *   name: "My Open Edition",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployOpenEdition", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await DropErc721ContractSchema.deploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points];
      return await this.deployPublishedContract.prepare(THIRDWEB_DEPLOYER2, "OpenEditionERC721", deployArgs, "latest", options);
    }));
    /**
     * Deploys a new SignatureDrop contract
     *
     * @remarks Deploys a SignatureDrop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deploySignatureDrop({
     *   name: "My Signature Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deploySignatureDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SignatureDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Multiwrap contract
     *
     * @remarks Deploys a Multiwrap contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployMultiwrap({
     *   name: "My Multiwrap",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     * @beta
     */
    __publicField(this, "deployMultiwrap", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MultiwrapInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Edition contract
     *
     * @remarks Deploys an Edition contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployEdition({
     *   name: "My Edition",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployEdition", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new EditionDrop contract
     *
     * @remarks Deploys an Edition Drop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployEditionDrop({
     *   name: "My Edition Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployEditionDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Token contract
     *
     * @remarks Deploys a Token contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployToken({
     *   name: "My Token",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployToken", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Token Drop contract
     *
     * @remarks Deploys a Token Drop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployTokenDrop({
     *   name: "My Token Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployTokenDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Marketplace contract
     *
     * @remarks Deploys a Marketplace contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployMarketplace({
     *   name: "My Marketplace",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployMarketplace", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Marketplace-V3 contract
     *
     * @remarks Deploys a Marketplace-V3 contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployMarketplaceV3({
     *   name: "My Marketplace",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployMarketplaceV3", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceV3Initializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Pack contract
     *
     * @remarks Deploys a Pack contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployPack({
     *   name: "My Pack",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployPack", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(PackInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Split contract
     *
     * @remarks Deploys a Split contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deploySplit({
     *   name: "My Split",
     *   primary_sale_recipient: "your-address",
     *   recipients: [
     *    {
     *      address: "your-address",
     *      sharesBps: 80 * 100, // 80%
     *    },
     *    {
     *      address: "another-address",
     *      sharesBps: 20 * 100, // 20%
     *    },
     *   ],
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deploySplit", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SplitInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Vote contract
     *
     * @remarks Deploys an Vote contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployVote({
     *   name: "My Vote",
     *   primary_sale_recipient: "your-address",
     *   voting_token_address: "your-token-contract-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployVote", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(VoteInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployAirdropERC20", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC20", deployArgs, "latest", options);
    }));
    __publicField(this, "deployAirdropERC721", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC721", deployArgs, "latest", options);
    }));
    __publicField(this, "deployAirdropERC1155", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC1155", deployArgs, "latest", options);
    }));
    /**
     * Deploys a new prebuilt contract
     *
     * @public
     * @param contractType - the type of contract to deploy
     * @param contractMetadata - the metadata to deploy the contract with
     * @param version - the version of the contract to deploy
     * @returns A promise of the address of the newly deployed contract
     */
    __publicField(this, "deployBuiltInContract", buildDeployTransactionFunction(/* @__PURE__ */ (() => {
      var _this = this;
      return async function(contractType, contractMetadata) {
        let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
        let options = arguments.length > 3 ? arguments[3] : void 0;
        const signer = _this.getSigner();
        invariant(signer, "A signer is required to deploy contracts");
        const parsedMetadata = {
          app_uri: PREBUILT_CONTRACTS_APPURI_MAP[contractType],
          ...await PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parseAsync(contractMetadata)
        };
        if (_this.hasLocalFactory()) {
          let parsedVersion = void 0;
          try {
            parsedVersion = parseInt(version);
            if (isNaN(parsedVersion)) {
              parsedVersion = void 0;
            }
          } catch (e) {
            parsedVersion = void 0;
          }
          const factory = await _this.getFactory();
          if (!factory) {
            throw new Error("Factory not found");
          }
          factory.on(EventType.Transaction, _this.transactionListener);
          return factory.deploy.prepare(contractType, parsedMetadata, _this.events, parsedVersion, options, () => {
            factory.off(EventType.Transaction, _this.transactionListener);
          });
        }
        const contractName = getContractName(contractType);
        invariant(contractName, "Contract name not found");
        const contractURI = await _this.storage.upload(parsedMetadata);
        const constructorParams = await getDeployArguments(contractType, parsedMetadata, contractURI, signer, _this.storage);
        const publishedContract = await _this.fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER2, contractName, version);
        return _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
      };
    })()));
    /**
     * Deploy any published contract by its name
     * @param publisherAddress - the address of the publisher
     * @param contractName - the name of the contract to deploy
     * @param constructorParams - the constructor params to pass to the contract
     *
     * @deprecated use deployPublishedContract instead
     * @internal
     */
    __publicField(this, "deployReleasedContract", buildDeployTransactionFunction(/* @__PURE__ */ (() => {
      var _this2 = this;
      return async function(publisherAddress, contractName, constructorParams) {
        let version = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
        let options = arguments.length > 4 ? arguments[4] : void 0;
        const publishedContract = await _this2.fetchPublishedContractFromPolygon(publisherAddress, contractName, version);
        return await _this2.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
      };
    })()));
    /**
     * Deploy any published contract by its name
     * @param publisherAddress - the address of the publisher
     * @param contractName - the name of the contract to deploy
     * @param constructorParams - the constructor params to pass to the contract
     * @param version - Optional: the version of the contract to deploy or "latest"
     * @param options - Optional: the deploy options
     */
    __publicField(this, "deployPublishedContract", this.deployReleasedContract);
    /**
     * Deploy a proxy contract of a given implementation via the given factory
     * @param factoryAddress - the address of the factory
     * @param implementationAddress - the address of the implementation
     * @param implementationAbi - the abi of the implementation
     * @param initializerFunction - the initializer function to call
     * @param initializerArgs - the initializer args to pass to the initializer function
     */
    __publicField(this, "deployViaFactory", buildTransactionFunction(async (factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs, saltForProxyDeploy) => {
      const resolvedFactoryAddress = await resolveAddress(factoryAddress);
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const signer = this.getSigner();
      invariant(signer, "signer is required");
      const proxyFactory = new ContractFactory2(resolvedFactoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      proxyFactory.on(EventType.Transaction, this.transactionListener);
      return await proxyFactory.deployProxyByImplementation.prepare(resolvedImplementationAddress, implementationAbi, initializerFunction, initializerArgs, this.events, saltForProxyDeploy, () => {
        proxyFactory.off(EventType.Transaction, this.transactionListener);
      });
    }));
    /**
     * Deploy a proxy contract of a given implementation directly
     * @param implementationAddress - the address of the implementation
     * @param implementationAbi - the abi of the implementation
     * @param initializerFunction - the initializer function to call
     * @param initializerArgs - the initializer args to pass to the initializer function
     */
    __publicField(this, "deployProxy", buildDeployTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {
      const resolvedAddress = await resolveAddress(implementationAddress);
      const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const {
        TWProxy__factory
      } = await import("./thirdweb-dev-contracts-js-factories-TWProxy__factory.browser.esm-GQV47KZM.js");
      return this.deployContractWithAbi.prepare(TWProxy__factory.abi, TWProxy__factory.bytecode, [resolvedAddress, encodedInitializer]);
    }));
    /**
     * Deploy a proxy contract of a given implementation via thirdweb's Clone factory
     * @param publishMetadataUri - the uri of the publish metadata
     * @param constructorParamValues - the constructor param values
     * @param deployMetadata - the deploy metadata
     * @param signer - the signer to use
     * @param options - the deploy options
     * @internal
     */
    __publicField(this, "deployViaAutoFactory", buildDeployTransactionFunction(async (publishMetadataUri, deployMetadata, signer, initializerFunction, paramValues, options) => {
      var _a, _b, _c;
      const create2Factory = await deployCreate2Factory(signer, options);
      const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2Factory, this.options.clientId, this.options.secretKey);
      const implementationAddress = (_a = deploymentInfo.find((i) => i.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
      const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
      const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
        return i.type !== "infra";
      }).map((i) => i.transaction);
      const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
        return i.type === "infra";
      }).map((i) => i.transaction);
      await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, options);
      for (const tx of transactionsforDirectDeploy) {
        try {
          await deployContractDeterministic(signer, tx, options);
        } catch (e) {
          console.debug(`Error deploying contract at ${tx.predictedAddress}`, e == null ? void 0 : e.message);
          throw e;
        }
      }
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const cloneFactory = await computeCloneFactoryAddress(this.getProvider(), this.storage, create2Factory, this.options.clientId, this.options.secretKey);
      (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deploying", "proxy");
      const proxyDeployTransaction = await this.deployViaFactory.prepare(cloneFactory, resolvedImplementationAddress, deployMetadata.compilerMetadata.abi, initializerFunction, paramValues, options == null ? void 0 : options.saltForProxyDeploy);
      (_c = options == null ? void 0 : options.notifier) == null ? void 0 : _c.call(options, "deployed", "proxy");
      return proxyDeployTransaction;
    }));
    /**
     * Deploy a proxy contract of a given implementation via a custom factory
     * @param constructorParamValues - the constructor param values
     * @param deployMetadata - the deploy metadata
     * @param signer - the signer to use
     * @param chainId - the chain id to deploy to
     * @internal
     */
    __publicField(this, "deployViaCustomFactory", buildDeployTransactionFunction(async (constructorParamValues, deployMetadata, signer, chainId) => {
      var _a, _b, _c, _d, _e, _f;
      const customFactoryAddress = (_c = (_b = (_a = deployMetadata.extendedMetadata) == null ? void 0 : _a.factoryDeploymentData) == null ? void 0 : _b.customFactoryInput) == null ? void 0 : _c.customFactoryAddresses[chainId];
      const resolvedCustomFactoryAddress = await resolveAddress(customFactoryAddress);
      invariant(resolvedCustomFactoryAddress, `customFactoryAddress not found for chainId '${chainId}'`);
      invariant((_f = (_e = (_d = deployMetadata.extendedMetadata) == null ? void 0 : _d.factoryDeploymentData) == null ? void 0 : _e.customFactoryInput) == null ? void 0 : _f.factoryFunction, `customFactoryFunction not set'`);
      const customFactoryMetadata = await fetchContractMetadataFromAddress(resolvedCustomFactoryAddress, this.getProvider(), this.storage, this.options);
      const factoryFunctionParamTypes = extractFunctionParamsFromAbi(customFactoryMetadata.abi, deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map((p) => p.type);
      const factoryFunctionparamValues = convertParamValues(factoryFunctionParamTypes, constructorParamValues);
      let deployedImplementationAddress;
      const deployTransaction = await Transaction.fromContractInfo({
        contractAddress: resolvedCustomFactoryAddress,
        contractAbi: customFactoryMetadata.abi,
        provider: this.getProvider(),
        signer,
        method: deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,
        args: factoryFunctionparamValues,
        parse: () => {
          return deployedImplementationAddress;
        },
        storage: this.storage
      });
      deployedImplementationAddress = await deployTransaction.simulate();
      return deployTransaction;
    }));
    /**
     * @internal
     * @param publishMetadataUri - the uri of the publish metadata
     * @param constructorParamValues - the constructor param values
     * @param options - the deploy options
     */
    __publicField(this, "deployContractFromUri", buildDeployTransactionFunction(async (publishMetadataUri, constructorParamValues, options) => {
      var _a, _b;
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const {
        compilerMetadata,
        extendedMetadata
      } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
      const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const isNetworkEnabled = ((_a = extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) == null ? void 0 : _a.networksEnabled.includes(chainId)) || ((_b = extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) == null ? void 0 : _b.allNetworks);
      if ((extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) && !isNetworkEnabled && compilerMetadata.name !== "AccountFactory") {
        throw new Error(`Deployments disabled on this network, with chainId: ${chainId}`);
      }
      if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType && extendedMetadata.deployType !== "standard") && !forceDirectDeploy) {
        if (extendedMetadata.deployType === "customFactory") {
          return await this.deployViaCustomFactory.prepare(constructorParamValues, {
            compilerMetadata,
            extendedMetadata
          }, signer, chainId);
        } else {
          invariant(extendedMetadata.factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
          const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction).map((p) => p.type);
          const paramValues2 = convertParamValues(initializerParamTypes, constructorParamValues);
          const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
          if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
            return await this.deployViaAutoFactory.prepare(publishMetadataUri, {
              compilerMetadata,
              extendedMetadata
            }, signer, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options);
          }
          const resolvedImplementationAddress = await resolveAddress(implementationAddress);
          invariant(resolvedImplementationAddress, `implementationAddress not found for chainId '${chainId}'`);
          if (extendedMetadata.isDeployableViaFactory) {
            invariant(extendedMetadata.factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
            const factoryAddress = extendedMetadata.factoryDeploymentData.factoryAddresses[chainId];
            invariant(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);
            const resolvedFactoryAddress = await resolveAddress(factoryAddress);
            return await this.deployViaFactory.prepare(resolvedFactoryAddress, resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options == null ? void 0 : options.saltForProxyDeploy);
          } else if (extendedMetadata.isDeployableViaProxy) {
            return await this.deployProxy.prepare(resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2);
          }
        }
      }
      const bytecode = compilerMetadata.bytecode.startsWith("0x") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;
      if (!utils_exports.isHexString(bytecode)) {
        throw new Error(`Contract bytecode is invalid.

${bytecode}`);
      }
      const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map((p) => p.type);
      const paramValues = convertParamValues(constructorParamTypes, constructorParamValues);
      return this.deployContractWithAbi.prepare(compilerMetadata.abi, bytecode, paramValues);
    }));
    /**
     * @public
     * @param abi - the abi of the contract
     * @param bytecode - the bytecode of the contract
     * @param constructorParams - the constructor params to pass to the contract
     */
    __publicField(this, "deployContractWithAbi", buildDeployTransactionFunction(async (abi, bytecode, constructorParams) => {
      const signer = this.getSigner();
      const provider = this.getProvider();
      invariant(signer, "Signer is required to deploy contracts");
      const factory = new ContractFactory(abi, bytecode).connect(signer);
      return new DeployTransaction({
        args: constructorParams,
        provider,
        signer,
        factory,
        storage: this.storage,
        events: this.events
      });
    }));
    this.storage = storage;
    this.events = new eventemitter3_default();
    this.getFactory();
    this.getRegistry();
  }
  /**
   * @internal
   * @param contractType - the type of contract to deploy
   */
  async getLatestBuiltInContractVersion(contractType) {
    const factory = await this.getFactory();
    if (!factory) {
      throw new Error("Factory not found");
    }
    return await factory.getLatestVersion(contractType);
  }
  /**
   * Deploy any published contract by its name
   * @param contractName - the name of the contract to deploy
   * @param constructorParams - the constructor params to pass to the contract
   * @param publisherAddress - the address of the publisher
   * @param version - Optional: the version of the contract to deploy or "latest"
   * @param saltForCreate2 - Optional: salt for create2 deployment, will determine deployment address
   */
  async deployPublishedContractDeterministic(contractName, constructorParams) {
    let publisherAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : THIRDWEB_DEPLOYER2;
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let saltForCreate2 = arguments.length > 4 ? arguments[4] : void 0;
    const signer = this.getSigner();
    invariant(signer, "Signer is required");
    return directDeployDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, signer, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);
  }
  /**
   * Predict Create2 address of a contract
   * @param contractName - the name of the contract
   * @param constructorParams - the constructor params to pass to the contract
   * @param publisherAddres -s the address of the publisher
   * @param version - Optional: the version of the contract to deploy or "latest"
   * @param saltForCreate2 - Optional: salt for create2 deployment, will determine deployment address
   */
  async predictAddressDeterministic(contractName, constructorParams) {
    let publisherAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : THIRDWEB_DEPLOYER2;
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let saltForCreate2 = arguments.length > 4 ? arguments[4] : void 0;
    const provider = this.getProvider();
    invariant(provider, "Provider is required");
    return predictAddressDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, provider, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);
  }
  /**
   * @internal
   */
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async (_ref2) => {
      let {
        chainId
      } = _ref2;
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      if (!registryAddress) {
        return void 0;
      }
      const TWRegistryABI = (await import("./TWRegistry-6HOL52CR.js")).default;
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.storage, TWRegistryABI, this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async (_ref3) => {
      let {
        chainId
      } = _ref3;
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      if (!factoryAddress) {
        return void 0;
      }
      const factory = new ContractFactory2(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      return factory;
    });
  }
  /**
   * @internal
   */
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var _a, _b;
    (_a = this._factory) == null ? void 0 : _a.then((factory) => {
      factory == null ? void 0 : factory.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
    (_b = this._registry) == null ? void 0 : _b.then((registry) => {
      registry == null ? void 0 : registry.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
  }
  /**
   * @public
   * @param publishMetadataUri - the uri of the publish metadata
   * @param options - the deploy options
   */
  async getTransactionsForDeploy(publishMetadataUri, options) {
    let transactions = [];
    const provider = this.getProvider();
    invariant(provider, "A provider is required");
    const {
      extendedMetadata
    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
    const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType === "autoFactory") && !forceDirectDeploy) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
      if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
        const create2FactoryAddress = await getCreate2FactoryAddress(this.getProvider());
        transactions.push({
          contractType: "create2Factory",
          addresses: [create2FactoryAddress]
        });
        const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2FactoryAddress, this.options.clientId, this.options.secretKey);
        const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
        const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
          return i.type !== "infra";
        }).map((i) => i.transaction);
        transactionsforDirectDeploy.forEach((tx) => {
          transactions.push({
            contractType: "preset",
            addresses: [tx.predictedAddress]
          });
        });
        const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
          return i.type === "infra";
        }).map((i) => i.transaction);
        const transactionBatches = createTransactionBatches(transactionsForThrowawayDeployer);
        transactionBatches.forEach((batch) => {
          const addresses = batch.map((tx) => tx.predictedAddress);
          transactions.push({
            contractType: "infra",
            addresses
          });
        });
      }
      transactions = (await Promise.all(transactions.map(async (tx) => {
        const addresses = (await Promise.all(tx.addresses.map(async (address) => {
          const isDeployed = await isContractDeployed(address, provider);
          return isDeployed ? null : address;
        }))).filter(Boolean);
        return addresses.length > 0 ? tx : null;
      }))).filter(Boolean);
      transactions.push({
        contractType: "proxy",
        addresses: []
      });
    } else {
      transactions.push({
        contractType: "custom",
        addresses: []
      });
    }
    return transactions;
  }
  /**
   * Listen to all deploy transactions from this deployer
   * @param listener - the listener to add
   */
  addDeployListener(listener) {
    this.events.on("contractDeployed", listener);
  }
  /**
   * Remove a deploy listener
   * @param listener - the listener to remove
   */
  removeDeployListener(listener) {
    this.events.off("contractDeployed", listener);
  }
  /**
   * Remove all deploy listeners
   */
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  // PRIVATE METHODS
  async fetchPublishedContractFromPolygon(publisherAddress, contractName, version) {
    const address = await resolveAddress(publisherAddress);
    const publishedContract = await new ThirdwebSDK("polygon", {
      clientId: this.options.clientId,
      secretKey: this.options.secretKey
    }, this.storage).getPublisher().getVersion(address, contractName, version);
    if (!publishedContract) {
      throw new Error(`No published contract found for '${contractName}' at version '${version}' by '${address}'`);
    }
    return publishedContract;
  }
  hasLocalFactory() {
    return !!getProcessEnv("factoryAddress");
  }
};

// node_modules/@thirdweb-dev/sdk/dist/token-a47df0f1.browser.esm.js
init_lib();
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}
function toEther(amount) {
  return utils_exports.formatEther(amount);
}
function toUnits(amount, decimals) {
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toDisplayValue(amount, decimals) {
  return utils_exports.formatUnits(amount, decimals);
}
async function computeNativeTokenAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  }, clientId, secretKey)).transaction.predictedAddress;
}
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    const tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return void 0;
}
var ProposalState = function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
  return ProposalState2;
}({});
var PropertiesInput = (() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();
var OptionalPropertiesInput = (() => z.union([z.array(PropertiesInput), PropertiesInput]).optional())();
var EditionMetadataOutputSchema = (() => z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
}))();
var EditionMetadataWithOwnerOutputSchema = (() => EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
}))();
var EditionMetadataInputSchema = (() => z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
}))();
var EditionMetadataInputOrUriSchema = (() => z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
}))();
var TokenMintInputSchema = (() => z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
}))();

// node_modules/@thirdweb-dev/sdk/dist/watchTransactions-e6ad162b.browser.esm.js
init_lib();
var STORAGE_CACHE = new ThirdwebStorage();
var CONTRACT_CACHE = createLruCache(10);
function getContractCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function inContractCache(address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.has(cacheKey);
}
function getCachedContract(address, chainId) {
  if (!inContractCache(address, chainId)) {
    throw new Error(`Contract ${address} was not found in cache`);
  }
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.get(cacheKey);
}
function cacheContract(contract, address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  CONTRACT_CACHE.put(cacheKey, contract);
}
function getCachedStorage(storage) {
  return storage || STORAGE_CACHE;
}
async function getContractFromAbi(params) {
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const [resolvedAddress, {
    chainId
  }, {
    SmartContract
  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork(), import("./smart-contract-f3e34912.browser.esm-3BG5VYRR.js")]);
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  const parsedAbi = typeof params.abi === "string" ? JSON.parse(params.abi) : params.abi;
  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);
  cacheContract(contract, resolvedAddress, chainId);
  return contract;
}
async function resolveContractType(params) {
  try {
    const IThirdwebContractABI = (await import("./IThirdwebContract-HEO5V7TM.js")).default;
    const contract = new Contract(params.address, IThirdwebContractABI, params.provider);
    const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
    return getContractTypeForRemoteName(remoteContractType);
  } catch (err) {
    return "custom";
  }
}
async function getContract(params) {
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const [resolvedAddress, {
    chainId
  }, {
    ContractPublisher: ContractPublisher2
  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork(), import("./contract-publisher-ba394bd6.browser.esm-BT46XJAT.js").then(function(n) {
    return n.c;
  })]);
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === "custom") {
    const contractType = await resolveContractType({
      address: resolvedAddress,
      provider
    });
    if (contractType === "custom") {
      const publisher = new ContractPublisher2(params.network, params.sdkOptions, getCachedStorage(params.storage));
      try {
        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);
        return getContractFromAbi({
          ...params,
          address: resolvedAddress,
          abi: metadata.abi
        });
      } catch {
        throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
      }
    } else {
      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));
      return getContractFromAbi({
        ...params,
        address: resolvedAddress,
        abi
      });
    }
  } else if (typeof params.contractTypeOrAbi === "string" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {
    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);
    cacheContract(contract, resolvedAddress, chainId);
    return contract;
  } else {
    return getContractFromAbi({
      ...params,
      address: resolvedAddress,
      abi: params.contractTypeOrAbi
    });
  }
}
var CHAIN_ID_CACHE = /* @__PURE__ */ new WeakMap();
async function getChainId(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  let chainIdPromise;
  if (CHAIN_ID_CACHE.has(provider)) {
    chainIdPromise = CHAIN_ID_CACHE.get(provider);
  } else {
    chainIdPromise = provider.getNetwork().then((network) => network.chainId).catch((err) => {
      CHAIN_ID_CACHE.delete(provider);
      throw err;
    });
    CHAIN_ID_CACHE.set(provider, chainIdPromise);
  }
  return await chainIdPromise;
}
async function getBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  return provider.getBlockNumber();
}
var BLOCK_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlock(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlock(blockTag).catch((err) => {
      BLOCK_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
var BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlockWithTransactions(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlockWithTransactions(blockTag).catch((err) => {
      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
function watchBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  provider.on("block", params.onBlockNumber);
  return () => {
    provider.off("block", params.onBlockNumber);
  };
}
function watchBlock(_ref) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlock({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchBlockWithTransactions(_ref2) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref2;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlockWithTransactions({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchTransactions(_ref) {
  let {
    address,
    onTransactions,
    ...sharedBlockParams
  } = _ref;
  const lcAddress = address.toLowerCase();
  function onBlock(block) {
    const transactions = block.transactions.filter((tx) => {
      var _a;
      if (tx.from.toLowerCase() === lcAddress) {
        return true;
      }
      return ((_a = tx.to) == null ? void 0 : _a.toLowerCase()) === lcAddress;
    });
    if (transactions.length > 0) {
      onTransactions(transactions);
    }
  }
  return watchBlockWithTransactions({
    ...sharedBlockParams,
    onBlock
  });
}

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_utils = __toESM(require_utils());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
function getRpcUrl(network, clientId) {
  return `https://${network}.rpc.thirdweb.com/${clientId || ""}`;
}
globalThis.global = globalThis;

export {
  checkClientIdOrSecretKey,
  getEncodedConstructorParamsForThirdwebContract,
  predictThirdwebContractAddress,
  getThirdwebContractAddress,
  verifyThirdwebPrebuiltImplementation,
  verify,
  checkVerificationStatus,
  isVerifiedOnEtherscan,
  ContractVerifier,
  LOCAL_NODE_PKEY,
  UserWallet,
  getAllDetectedFeatureNames,
  getAllDetectedExtensionNames,
  extractFunctionParamsFromAbi,
  computeCloneFactoryAddress,
  convertParamValues,
  deployCreate2Factory,
  SUPPORTED_CHAIN_IDS,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getTrustedForwarders,
  APPROVED_IMPLEMENTATIONS,
  getApprovedImplementation,
  directDeployDeterministic,
  directDeployDeterministicWithUri,
  directDeployDeterministicPublished,
  predictAddressDeterministic,
  predictAddressDeterministicWithUri,
  predictAddressDeterministicPublished,
  ThirdwebSDK,
  ContractDeployer,
  matchesPrebuiltAbi,
  toEther,
  toUnits,
  toDisplayValue,
  computeNativeTokenAddress,
  deployContractDeterministicRaw,
  getCachedAbiForContract,
  ProposalState,
  OptionalPropertiesInput,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EditionMetadataInputSchema,
  EditionMetadataInputOrUriSchema,
  TokenMintInputSchema,
  getContractFromAbi,
  getContract,
  getChainId,
  getBlockNumber,
  getBlock,
  getBlockWithTransactions,
  watchBlockNumber,
  watchBlock,
  watchBlockWithTransactions,
  watchTransactions,
  getRpcUrl
};
//# sourceMappingURL=chunk-XBJODW7Z.js.map
