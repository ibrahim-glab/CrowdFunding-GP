import {
  getValidPublicRPCUrl
} from "./chunk-OZHK2Y2Y.js";
import {
  index_browser_esm_exports,
  init_index_browser_esm
} from "./chunk-I5L2Q44A.js";
import "./chunk-UKR7QG24.js";
import "./chunk-AQ6RT5SW.js";
import "./chunk-P3UYPI43.js";
import {
  normalizeChainId
} from "./chunk-FG2CDSPQ.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-FHB7QQX6.js";
import {
  walletIds
} from "./chunk-7WSDJM3S.js";
import {
  ConnectorNotFoundError,
  SwitchChainError,
  UserRejectedRequestError
} from "./chunk-W53H6NW3.js";
import {
  WagmiConnector
} from "./chunk-QRS3G5NJ.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-I5FN74TN.js";
import {
  _defineProperty
} from "./chunk-YUOLCEGR.js";
import "./chunk-LYEG5PGG.js";
import "./chunk-YN6UTFQV.js";
import "./chunk-TVZY4654.js";
import "./chunk-XZ6OD6N5.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-WYHBVST3.js";
import {
  lib_exports19 as lib_exports
} from "./chunk-SPBWBR4K.js";
import "./chunk-6OCL4JXY.js";
import "./chunk-OP3MHZRI.js";
import "./chunk-TZBESOIF.js";
import "./chunk-7GHALKSO.js";
import "./chunk-JVHSL6P6.js";
import "./chunk-XRYAEC2L.js";
import "./chunk-3JC5L5ZG.js";
import "./chunk-UFR7PFM3.js";
import {
  __toCommonJS
} from "./chunk-HY2WJTHE.js";

// node_modules/@blocto/sdk/dist/blocto-sdk.module.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function invariant(condition, format) {
  if (!condition) {
    throw new Error(format);
  }
}
var KEY_SESSION;
(function(KEY_SESSION2) {
  KEY_SESSION2["prod"] = "BLOCTO_SDK";
  KEY_SESSION2["dev"] = "BLOCTO_SDK_DEV";
  KEY_SESSION2["staging"] = "BLOCTO_SDK_STAGING";
})(KEY_SESSION || (KEY_SESSION = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["ETHEREUM"] = "ethereum";
  CHAIN2["SOLANA"] = "solana";
  CHAIN2["APTOS"] = "aptos";
})(CHAIN || (CHAIN = {}));
var MemoryStorage = class {
  constructor() {
    this.storage = {};
  }
  getItem(key) {
    return this[key] || null;
  }
  setItem(key, value) {
    this.storage[key] = value;
  }
  removeItem(key) {
    delete this.storage[key];
  }
};
var memoryStorage = typeof window !== "undefined" ? window.memoryStorage : new MemoryStorage();
var isSupported = () => {
  if (typeof window === "undefined") {
    return false;
  }
  try {
    window.sessionStorage.setItem("local_storage_supported", "1");
    const result = window.sessionStorage.getItem("local_storage_supported");
    window.sessionStorage.removeItem("local_storage_supported");
    return result === "1";
  } catch (error) {
    return false;
  }
};
var storage = isSupported() ? window.sessionStorage : memoryStorage;
var getItem = (key, defaultValue = null) => {
  const value = storage.getItem(key);
  try {
    return value && JSON.parse(value) || defaultValue;
  } catch (SyntaxError) {
    return value || defaultValue;
  }
};
var setItem = (key, value) => storage.setItem(key, typeof value === "string" ? value : JSON.stringify(value));
var removeItem = (key) => {
  setItem(key, "");
  storage.removeItem(key);
};
var getAccountStorage = (key) => {
  const rawAccountStorage = getItem(key, null);
  if (!rawAccountStorage)
    return null;
  if ((/* @__PURE__ */ new Date()).getTime() > rawAccountStorage.expiry || rawAccountStorage.v !== SDK_VERSION) {
    removeItem(key);
    return null;
  }
  return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;
};
var setAccountStorage = (key, data, expiry) => {
  var _a, _b, _c;
  const rawAccountStorage = getItem(key);
  const newAccountStorage = {
    data: {
      code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),
      connected: !!((data === null || data === void 0 ? void 0 : data.code) || ((_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.code)),
      accounts: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.accounts), data === null || data === void 0 ? void 0 : data.accounts)
    },
    expiry: expiry || (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) || (/* @__PURE__ */ new Date()).getTime() + LOGIN_PERSISTING_TIME,
    v: SDK_VERSION
  };
  setItem(key, newAccountStorage);
  return;
};
var getChainAddress = (key, chain) => {
  var _a, _b;
  if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {
    removeItem(key);
    return null;
  }
  return ((_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts[chain]) || null;
};
var setChainAddress = (key, chain, account) => {
  setAccountStorage(key, { accounts: { [chain]: account } });
  return;
};
var removeChainAddress = (key, chain) => {
  setAccountStorage(key, { accounts: { [chain]: void 0 } });
  return;
};
var ETH_RPC_LIST = {
  // This is the list of public RPC endpoints that we known to be working
  // Used to help developers did not set up their own RPC endpoints
  // BSC mainnet
  56: "https://bsc-dataseed1.binance.org",
  // BSC testnet
  97: "https://data-seed-prebsc-1-s1.binance.org:8545",
  // Polygon Mainnet
  137: "https://rpc-mainnet.maticvigil.com/",
  // Polygon Testnet
  80001: "https://rpc-mumbai.matic.today/",
  // Avalanche Mainnet
  43114: "https://api.avax.network/ext/bc/C/rpc",
  // Avalanche Fuji Testnet
  43113: "https://api.avax-test.network/ext/bc/C/rpc",
  // Arbitrum Mainnet
  42161: "https://arb1.arbitrum.io/rpc",
  // Arbitrum Testnet
  421613: "https://endpoints.omniatech.io/v1/arbitrum/goerli/public",
  // Optimism Mainnet
  10: "https://mainnet.optimism.io",
  // Optimism Goerli Testnet
  420: "https://goerli.optimism.io"
};
var ETH_ENV_WALLET_SERVER_MAPPING = {
  prod: "https://wallet-v2.blocto.app",
  staging: "https://wallet-v2-staging.blocto.app",
  dev: "https://wallet-v2-dev.blocto.app"
};
var ETH_SESSION_KEY_MAPPING = {
  prod: KEY_SESSION.prod,
  staging: KEY_SESSION.staging,
  dev: KEY_SESSION.dev
};
var SOL_NET = {
  MainnetBeta: "mainnet-beta",
  Testnet: "testnet",
  Devnet: "devnet"
};
var SOL_NET_SERVER_MAPPING = {
  [SOL_NET.MainnetBeta]: "https://wallet-v2.blocto.app",
  [SOL_NET.Devnet]: "https://wallet-v2-dev.blocto.app",
  [SOL_NET.Testnet]: "https://wallet-v2-dev.blocto.app"
};
var SOL_SESSION_KEY_MAPPING = {
  [SOL_NET.MainnetBeta]: KEY_SESSION.prod,
  [SOL_NET.Devnet]: KEY_SESSION.dev,
  [SOL_NET.Testnet]: KEY_SESSION.dev
};
var APT_SESSION_KEY_MAPPING = {
  1: KEY_SESSION.prod,
  2: KEY_SESSION.dev,
  3: KEY_SESSION.dev,
  4: KEY_SESSION.dev,
  5: KEY_SESSION.staging
};
var APT_CHAIN_ID_SERVER_MAPPING = {
  // MAINNET
  1: "https://wallet-v2.blocto.app",
  // TESTNET
  2: "https://wallet-v2-dev.blocto.app",
  // DEVNET
  3: "https://wallet-v2-dev.blocto.app",
  // TESTING
  4: "https://wallet-v2-dev.blocto.app",
  // PREMAINNET
  5: "https://wallet-v2-staging.blocto.app"
};
var WalletAdapterNetwork;
(function(WalletAdapterNetwork2) {
  WalletAdapterNetwork2["Mainnet"] = "mainnet";
  WalletAdapterNetwork2["Testnet"] = "testnet";
  WalletAdapterNetwork2["Devnet"] = "devnet";
  WalletAdapterNetwork2["Testing"] = "testing";
  WalletAdapterNetwork2["Premainnet"] = "premainnet";
})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));
var APT_CHAIN_ID_NAME_MAPPING = {
  1: WalletAdapterNetwork.Mainnet,
  2: WalletAdapterNetwork.Testnet,
  3: WalletAdapterNetwork.Devnet,
  4: WalletAdapterNetwork.Testing,
  5: WalletAdapterNetwork.Premainnet
};
var APT_CHAIN_ID_RPC_MAPPING = {
  1: "https://fullnode.mainnet.aptoslabs.com/v1",
  2: "https://fullnode.testnet.aptoslabs.com/v1",
  3: "https://fullnode.devnet.aptoslabs.com/v1",
  4: "",
  5: "https://premainnet.aptosdev.com/v1"
};
var EIP1193_EVENTS = [
  "connect",
  "disconnect",
  "message",
  "chainChanged",
  "accountsChanged"
];
var LOGIN_PERSISTING_TIME = 86400 * 1e3;
var DEFAULT_APP_ID = "00000000-0000-0000-0000-000000000000";
var SDK_VERSION = "0.5.5";
var BloctoProvider = class {
  constructor() {
    this.isBlocto = true;
    this.isConnecting = false;
    this.eventListeners = {};
    this.off = this.removeListener;
    EIP1193_EVENTS.forEach((event) => {
      this.eventListeners[event] = [];
    });
    this.appId = DEFAULT_APP_ID;
  }
  // implement by children
  // eslint-disable-next-line
  request(payload) {
    return __awaiter(this, void 0, void 0, function* () {
    });
  }
  on(event, listener) {
    if (!EIP1193_EVENTS.includes(event))
      return;
    this.eventListeners[event].push(listener);
  }
  // @todo: implement it
  // eslint-disable-next-line
  once() {
  }
  removeListener(event, listener) {
    const listeners = this.eventListeners[event];
    const index = listeners.findIndex((item) => item === listener);
    if (index !== -1) {
      this.eventListeners[event].splice(index, 1);
    }
  }
};
var IFRAME_STYLE = "width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;";
function createFrame(url) {
  const frame = document.createElement("iframe");
  frame.setAttribute("src", url);
  frame.setAttribute("style", IFRAME_STYLE);
  return frame;
}
function attachFrame(frame) {
  document.body.appendChild(frame);
}
function detatchFrame(frame) {
  const parentNode = frame && frame.parentNode;
  if (parentNode && parentNode.removeChild instanceof Function) {
    parentNode.removeChild(frame);
  }
}
var addSelfRemovableHandler = (eventType, handler, target = window) => {
  function listener(e) {
    const removeEventListener = () => target.removeEventListener(eventType, listener);
    handler(e, removeEventListener);
  }
  target.addEventListener(eventType, listener);
};
function responseSessionGuard(response, key, disconnectHandler) {
  return __awaiter(this, void 0, void 0, function* () {
    if (response.status === 403 || response.status === 401) {
      if (disconnectHandler) {
        disconnectHandler();
      }
      removeItem(key);
    }
    if (!response.ok) {
      const data = yield response.json();
      const e = new Error((data === null || data === void 0 ? void 0 : data.message) || "unknown error");
      e.error_code = data === null || data === void 0 ? void 0 : data.error_code;
      throw e;
    }
    return response.json();
  });
}
var isEmail = (value) => /\S+@\S+\.\S+/.test(value);
var isValidTransaction = (transaction) => typeof transaction === "object" && transaction !== null && "from" in transaction;
var isValidTransactions = (transactions) => Array.isArray(transactions) && transactions.every((tx) => isValidTransaction(tx));
function getEvmSupport() {
  return __awaiter(this, void 0, void 0, function* () {
    const { networks } = yield fetch("https://api.blocto.app/networks/evm").then((response) => response.json());
    const evmSupportMap = networks.reduce((a, v) => Object.assign(Object.assign({}, a), { [v.chain_id]: v }), {});
    return evmSupportMap;
  });
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var dist = {};
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var classes = {};
var fastSafeStringify = stringify;
stringify["default"] = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr = [];
var replacerStack = [];
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  decirc(obj, "", 0, [], void 0, 0, options);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, {
        value: replace
      });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (_typeof(val) === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function compareFunction(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (_typeof(val) === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_) {
      return;
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, i, stack, val, depth, options);
        tmp[key] = val[key];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(classes, "__esModule", {
  value: true
});
classes.EthereumProviderError = classes.EthereumRpcError = void 0;
var fast_safe_stringify_1 = fastSafeStringify;
var EthereumRpcError = function(_Error) {
  _inherits(EthereumRpcError2, _Error);
  var _super = _createSuper(EthereumRpcError2);
  function EthereumRpcError2(code, message, data) {
    var _this;
    _classCallCheck(this, EthereumRpcError2);
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    _this = _super.call(this, message);
    _this.code = code;
    if (data !== void 0) {
      _this.data = data;
    }
    return _this;
  }
  _createClass(EthereumRpcError2, [{
    key: "serialize",
    value: function serialize() {
      var serialized = {
        code: this.code,
        message: this.message
      };
      if (this.data !== void 0) {
        serialized.data = this.data;
      }
      if (this.stack) {
        serialized.stack = this.stack;
      }
      return serialized;
    }
    /**
     * Return a string representation of the serialized error, omitting
     * any circular references.
     */
  }, {
    key: "toString",
    value: function toString3() {
      return fast_safe_stringify_1["default"](this.serialize(), stringifyReplacer, 2);
    }
  }]);
  return EthereumRpcError2;
}(_wrapNativeSuper(Error));
classes.EthereumRpcError = EthereumRpcError;
var EthereumProviderError = function(_EthereumRpcError) {
  _inherits(EthereumProviderError2, _EthereumRpcError);
  var _super2 = _createSuper(EthereumProviderError2);
  function EthereumProviderError2(code, message, data) {
    _classCallCheck(this, EthereumProviderError2);
    if (!isValidEthProviderCode(code)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    return _super2.call(this, code, message, data);
  }
  return _createClass(EthereumProviderError2);
}(EthereumRpcError);
classes.EthereumProviderError = EthereumProviderError;
function isValidEthProviderCode(code) {
  return Number.isInteger(code) && code >= 1e3 && code <= 4999;
}
function stringifyReplacer(_, value) {
  if (value === "[Circular]") {
    return void 0;
  }
  return value;
}
var utils = {};
var errorConstants = {};
Object.defineProperty(errorConstants, "__esModule", {
  value: true
});
errorConstants.errorValues = errorConstants.errorCodes = void 0;
errorConstants.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
errorConstants.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  var error_constants_12 = errorConstants;
  var classes_12 = classes;
  var FALLBACK_ERROR_CODE = error_constants_12.errorCodes.rpc.internal;
  var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
  var FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
  };
  exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function getMessageFromCode(code) {
    var fallbackMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : FALLBACK_MESSAGE;
    if (Number.isInteger(code)) {
      var codeString = code.toString();
      if (hasKey(error_constants_12.errorValues, codeString)) {
        return error_constants_12.errorValues[codeString].message;
      }
      if (isJsonRpcServerError(code)) {
        return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
    }
    return fallbackMessage;
  }
  exports.getMessageFromCode = getMessageFromCode;
  function isValidCode(code) {
    if (!Number.isInteger(code)) {
      return false;
    }
    var codeString = code.toString();
    if (error_constants_12.errorValues[codeString]) {
      return true;
    }
    if (isJsonRpcServerError(code)) {
      return true;
    }
    return false;
  }
  exports.isValidCode = isValidCode;
  function serializeError(error) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$fallbackError = _ref.fallbackError, fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError, _ref$shouldIncludeSta = _ref.shouldIncludeStack, shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;
    var _a, _b;
    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
      throw new Error("Must provide fallback error with integer number code and string message.");
    }
    if (error instanceof classes_12.EthereumRpcError) {
      return error.serialize();
    }
    var serialized = {};
    if (error && _typeof(error) === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
      var _error = error;
      serialized.code = _error.code;
      if (_error.message && typeof _error.message === "string") {
        serialized.message = _error.message;
        if (hasKey(_error, "data")) {
          serialized.data = _error.data;
        }
      } else {
        serialized.message = getMessageFromCode(serialized.code);
        serialized.data = {
          originalError: assignOriginalError(error)
        };
      }
    } else {
      serialized.code = fallbackError.code;
      var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
      serialized.message = message && typeof message === "string" ? message : fallbackError.message;
      serialized.data = {
        originalError: assignOriginalError(error)
      };
    }
    var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
    if (shouldIncludeStack && error && stack && typeof stack === "string") {
      serialized.stack = stack;
    }
    return serialized;
  }
  exports.serializeError = serializeError;
  function isJsonRpcServerError(code) {
    return code >= -32099 && code <= -32e3;
  }
  function assignOriginalError(error) {
    if (error && _typeof(error) === "object" && !Array.isArray(error)) {
      return Object.assign({}, error);
    }
    return error;
  }
  function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
})(utils);
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArrayLimit(arr2, i) {
  var _i = null == arr2 ? null : "undefined" != typeof Symbol && arr2[Symbol.iterator] || arr2["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr2)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayLikeToArray(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr2, i) {
  return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i) || _unsupportedIterableToArray(arr2, i) || _nonIterableRest();
}
var errors = {};
Object.defineProperty(errors, "__esModule", {
  value: true
});
errors.ethErrors = void 0;
var classes_1 = classes;
var utils_1 = utils;
var error_constants_1 = errorConstants;
errors.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: function parse(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);
    },
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: function invalidRequest(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);
    },
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: function invalidParams(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);
    },
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: function methodNotFound(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);
    },
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: function internal(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);
    },
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: function server(opts) {
      if (!opts || _typeof(opts) !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      var code = opts.code;
      if (!Number.isInteger(code) || code > -32005 || code < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code, opts);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: function invalidInput(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);
    },
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: function resourceNotFound(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);
    },
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: function resourceUnavailable(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);
    },
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: function transactionRejected(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);
    },
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: function methodNotSupported(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);
    },
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: function limitExceeded(arg) {
      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);
    }
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: function userRejectedRequest(arg) {
      return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
    },
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: function unauthorized(arg) {
      return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
    },
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: function unsupportedMethod(arg) {
      return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
    },
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: function disconnected(arg) {
      return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
    },
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: function chainDisconnected(arg) {
      return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
    },
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: function custom(opts) {
      if (!opts || _typeof(opts) !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      var code = opts.code, message = opts.message, data = opts.data;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new classes_1.EthereumProviderError(code, message, data);
    }
  }
};
function getEthJsonRpcError(code, arg) {
  var _parseOpts = parseOpts(arg), _parseOpts2 = _slicedToArray(_parseOpts, 2), message = _parseOpts2[0], data = _parseOpts2[1];
  return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
}
function getEthProviderError(code, arg) {
  var _parseOpts3 = parseOpts(arg), _parseOpts4 = _slicedToArray(_parseOpts3, 2), message = _parseOpts4[0], data = _parseOpts4[1];
  return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (_typeof(arg) === "object" && !Array.isArray(arg)) {
      var message = arg.message, data = arg.data;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
  var classes_12 = classes;
  Object.defineProperty(exports, "EthereumRpcError", {
    enumerable: true,
    get: function get() {
      return classes_12.EthereumRpcError;
    }
  });
  Object.defineProperty(exports, "EthereumProviderError", {
    enumerable: true,
    get: function get() {
      return classes_12.EthereumProviderError;
    }
  });
  var utils_12 = utils;
  Object.defineProperty(exports, "serializeError", {
    enumerable: true,
    get: function get() {
      return utils_12.serializeError;
    }
  });
  Object.defineProperty(exports, "getMessageFromCode", {
    enumerable: true,
    get: function get() {
      return utils_12.getMessageFromCode;
    }
  });
  var errors_1 = errors;
  Object.defineProperty(exports, "ethErrors", {
    enumerable: true,
    get: function get() {
      return errors_1.ethErrors;
    }
  });
  var error_constants_12 = errorConstants;
  Object.defineProperty(exports, "errorCodes", {
    enumerable: true,
    get: function get() {
      return error_constants_12.errorCodes;
    }
  });
})(dist);
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr2;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr2 = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr2[L++] = tmp >> 16 & 255;
    arr2[L++] = tmp >> 8 & 255;
    arr2[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr2[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr2[L++] = tmp >> 8 & 255;
    arr2[L++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
var toString = {}.toString;
var isArray = Array.isArray || function(arr2) {
  return toString.call(arr2) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
kMaxLength();
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
Buffer._augment = function(arr2) {
  arr2.__proto__ = Buffer.prototype;
  return arr2;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
Buffer.from = function(value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer)
    ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
Buffer.alloc = function(size, fill2, encoding) {
  return alloc(null, size, fill2, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer.isBuffer = isBuffer;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a === b)
    return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === void 0) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString2() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = "";
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
    if (this.length > max)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr2.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr2.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr2, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr2, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
        return asciiWrite(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i = byteLength2;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (!Buffer.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }
  return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src2, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src2.length)
      break;
    dst[i + offset] = src2[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var isHexString = (hex) => typeof hex === "string" && /^0x[0-9A-Fa-f]*$/.test(hex);
var utf8ToHex = (str) => {
  return Buffer.from(str, "utf8").toString("hex");
};
var _EthereumProvider_instances;
var _EthereumProvider_getBloctoProperties;
var _EthereumProvider_addToSwitchable;
var _EthereumProvider_checkNetworkMatched;
function parseChainId(chainId) {
  if (!chainId) {
    return 1;
  }
  if (typeof chainId === "number") {
    return chainId;
  } else if (chainId.startsWith("0x")) {
    return parseInt(chainId, 16);
  }
  return parseInt(chainId, 10);
}
var EthereumProvider = class extends BloctoProvider {
  constructor({ chainId, rpc, walletServer, appId }) {
    super();
    _EthereumProvider_instances.add(this);
    this.networkVersion = "1";
    invariant(chainId, "'chainId' is required");
    this.networkVersion = `${parseChainId(chainId)}`;
    this.chainId = `0x${parseChainId(chainId).toString(16)}`;
    this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];
    invariant(this.rpc, "'rpc' is required");
    this.injectedWalletServer = walletServer;
    this._blocto = {
      sessionKey: KEY_SESSION.prod,
      walletServer: this.injectedWalletServer || "",
      blockchainName: "",
      networkType: "",
      supportNetworkList: {},
      switchableNetwork: {}
    };
    this.appId = appId || DEFAULT_APP_ID;
  }
  // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated
  send(methodOrPayload, paramsOrCallback) {
    return __awaiter(this, void 0, void 0, function* () {
      switch (true) {
        case paramsOrCallback instanceof Function:
          return this.sendAsync(methodOrPayload, paramsOrCallback);
        case (typeof methodOrPayload === "string" && Array.isArray(paramsOrCallback)):
          return this.sendAsync({
            jsonrpc: "2.0",
            method: methodOrPayload,
            params: paramsOrCallback
          });
        default:
          return this.sendAsync(methodOrPayload);
      }
    });
  }
  // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation
  // web3 v1.x BatchRequest still depends on it so we need to implement anyway \_()_/
  sendAsync(payload, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const handleRequest = new Promise((resolve) => {
        if (Array.isArray(payload)) {
          const transactions = payload.filter((request) => request.method === "eth_sendTransaction").map((request) => {
            var _a;
            return (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];
          });
          const idBase = Math.floor(Math.random() * 1e4);
          const batchedRequestPayload = {
            method: "blocto_sendBatchTransaction",
            params: transactions
          };
          const batchResponsePromise = this.request(batchedRequestPayload);
          const requests = payload.map(({ method, params }, index) => method === "eth_sendTransaction" ? batchResponsePromise : this.request({
            id: idBase + index + 1,
            jsonrpc: "2.0",
            method,
            params
          }));
          Promise.allSettled(requests).then((responses) => resolve(responses.map((response, index) => {
            return {
              id: String(idBase + index + 1),
              jsonrpc: "2.0",
              method: payload[index].method,
              result: response.status === "fulfilled" ? response.value : void 0,
              error: response.status !== "fulfilled" ? response.reason : void 0
            };
          }))).catch((error) => {
            throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);
          });
        } else {
          this.request(Object.assign(Object.assign({}, payload), { id: Number(payload.id) })).then(resolve);
        }
      });
      if (callback) {
        handleRequest.then((data) => callback(null, data)).catch((error) => callback(error));
      } else {
        return handleRequest;
      }
    });
  }
  /**
   * Sending userOperation using Blocto SDK.
   * @param {IUserOperation} userOp - userOperation object
   * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.
   * These parameters will be ignored.
   * @returns {Promise<string>} - userOperation hash
   */
  sendUserOperation(userOp) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request({
        method: "eth_sendUserOperation",
        params: [userOp]
      });
    });
  }
  request(payload) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return __awaiter(this, void 0, void 0, function* () {
      if (!(payload === null || payload === void 0 ? void 0 : payload.method))
        throw dist.ethErrors.rpc.invalidRequest();
      const existedSDK = window.ethereum;
      if (existedSDK && existedSDK.isBlocto) {
        if (payload.method === "wallet_switchEthereumChain") {
          if (!((_b = (_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chainId)) {
            throw dist.ethErrors.rpc.invalidParams();
          }
          return existedSDK.request(payload).then(() => {
            var _a2, _b2, _c2;
            this.networkVersion = `${parseChainId((_a2 = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a2 === void 0 ? void 0 : _a2[0].chainId)}`;
            this.chainId = `0x${parseChainId((_b2 = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b2 === void 0 ? void 0 : _b2[0].chainId).toString(16)}`;
            this.rpc = (_c2 = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c2 === void 0 ? void 0 : _c2.rpc_url;
            return null;
          });
        }
        return existedSDK.request(payload);
      }
      const { blockchainName, switchableNetwork, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      switch (payload.method) {
        case "eth_chainId": {
          return this.chainId;
        }
        case "net_version": {
          return this.networkVersion;
        }
        case "wallet_addEthereumChain": {
          return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);
        }
        case "eth_call": {
          const response = yield this.handleReadRequests(payload);
          if (!response || response && !response.result && response.error) {
            const errorMessage = ((_c = response === null || response === void 0 ? void 0 : response.error) === null || _c === void 0 ? void 0 : _c.message) ? response.error.message : "Request failed";
            throw dist.ethErrors.rpc.internal(errorMessage);
          }
          return response.result;
        }
        case "wallet_switchEthereumChain": {
          if (!((_e = (_d = payload === null || payload === void 0 ? void 0 : payload.params) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.chainId))
            throw dist.ethErrors.rpc.invalidParams();
          const newChainId = payload.params[0].chainId;
          if (!getChainAddress(sessionKey, blockchainName)) {
            const phasedChainId = parseChainId(newChainId);
            if (!switchableNetwork[phasedChainId]) {
              throw dist.ethErrors.provider.custom({
                code: 4902,
                message: `Unrecognized chain ID "${newChainId}". Try adding the chain using wallet_addEthereumChain first.`
              });
            }
            this.networkVersion = `${phasedChainId}`;
            this.chainId = `0x${phasedChainId.toString(16)}`;
            this.rpc = switchableNetwork[phasedChainId].rpc_url;
            this.eventListeners.chainChanged.forEach((listener) => listener(this.chainId));
            return null;
          }
          break;
        }
      }
      if (!getChainAddress(sessionKey, blockchainName)) {
        const email = (_f = payload === null || payload === void 0 ? void 0 : payload.params) === null || _f === void 0 ? void 0 : _f[0];
        if (payload.method === "eth_requestAccounts" && isEmail(email)) {
          yield this.enable(email);
        } else {
          yield this.enable();
        }
      }
      try {
        let response = null;
        let result = null;
        switch (payload.method) {
          case "eth_requestAccounts":
            yield this.fetchAccounts();
          case "eth_accounts":
            result = getChainAddress(sessionKey, blockchainName);
            break;
          case "eth_coinbase": {
            result = (_g = getChainAddress(sessionKey, blockchainName)) === null || _g === void 0 ? void 0 : _g[0];
            break;
          }
          case "eth_signTypedData_v3":
          case "eth_signTypedData":
          case "eth_signTypedData_v4":
          case "personal_sign":
          case "eth_sign": {
            result = yield this.handleSign(payload);
            break;
          }
          case "wallet_disconnect": {
            this.handleDisconnect();
            result = null;
            break;
          }
          case "eth_sendTransaction":
            result = yield this.handleSendTransaction(payload);
            break;
          case "blocto_sendBatchTransaction":
            result = yield this.handleSendBatchTransaction(payload);
            break;
          case "eth_signTransaction":
          case "eth_sendRawTransaction": {
            throw dist.ethErrors.rpc.methodNotSupported("Method Not Supported: " + payload.method);
          }
          case "eth_sendUserOperation":
            result = yield this.handleSendUserOperation(payload);
            break;
          case "wallet_switchEthereumChain": {
            if (!((_j = (_h = payload === null || payload === void 0 ? void 0 : payload.params) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.chainId)) {
              throw dist.ethErrors.rpc.invalidParams();
            }
            const oldAccount = (_k = getChainAddress(sessionKey, blockchainName)) === null || _k === void 0 ? void 0 : _k[0];
            const oldChainId = this.chainId;
            const newChainId = payload.params[0].chainId;
            if (!switchableNetwork[parseChainId(newChainId)]) {
              throw dist.ethErrors.provider.custom({
                code: 4902,
                message: `Unrecognized chain ID "${parseChainId(payload.params[0].chainId)}". Try adding the chain using wallet_addEthereumChain first.`
              });
            }
            this.networkVersion = `${parseChainId(newChainId)}`;
            this.chainId = `0x${parseChainId(newChainId).toString(16)}`;
            this.rpc = switchableNetwork[this.networkVersion].rpc_url;
            yield this.enable().then(([newAccount]) => {
              var _a2;
              if (newAccount !== oldAccount) {
                (_a2 = this.eventListeners) === null || _a2 === void 0 ? void 0 : _a2.accountsChanged.forEach((listener) => listener([newAccount]));
              }
              this.eventListeners.chainChanged.forEach((listener) => listener(this.chainId));
              result = null;
            }).catch((error) => {
              this.networkVersion = `${parseChainId(oldChainId)}`;
              this.chainId = `0x${parseChainId(oldChainId).toString(16)}`;
              this.rpc = switchableNetwork[this.networkVersion].rpc_url;
              throw error;
            });
            break;
          }
          case "eth_estimateUserOperationGas":
          case "eth_getUserOperationByHash":
          case "eth_getUserOperationReceipt":
          case "eth_supportedEntryPoints":
            result = yield this.handleBundler(payload);
            break;
          default:
            response = yield this.handleReadRequests(payload);
        }
        if (response && !response.result && response.error) {
          const errorMessage = response.error.message ? response.error.message : "Request failed";
          throw dist.ethErrors.rpc.internal(errorMessage);
        }
        if (response)
          return response.result;
        return result;
      } catch (error) {
        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);
      }
    });
  }
  bloctoApi(url, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      const sessionId = ((_a = getAccountStorage(sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || "";
      if (!sessionId) {
        throw dist.ethErrors.provider.unauthorized();
      }
      return fetch(`${walletServer}/api/${blockchainName}${url}`, Object.assign({ headers: {
        "Content-Type": "application/json",
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        "Blocto-Application-Identifier": this.appId,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        "Blocto-Session-Identifier": sessionId
      } }, options)).then((response) => responseSessionGuard(response, sessionKey, () => {
        var _a2;
        (_a2 = this.eventListeners) === null || _a2 === void 0 ? void 0 : _a2.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));
      })).catch((e) => {
        if ((e === null || e === void 0 ? void 0 : e.error_code) === "unsupported_method") {
          throw dist.ethErrors.rpc.methodNotSupported("Method Not Supported: " + e.message);
        } else {
          throw dist.ethErrors.rpc.server({
            code: -32005,
            message: `Blocto server error: ${e.message}`
          });
        }
      });
    });
  }
  responseListener(frame, objectKey) {
    return __awaiter(this, void 0, void 0, function* () {
      const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      return new Promise((resolve, reject) => addSelfRemovableHandler("message", (event, removeEventListener) => {
        const e = event;
        if (e.origin === walletServer && e.data.type === "ETH:FRAME:RESPONSE") {
          if (e.data.status === "APPROVED") {
            removeEventListener();
            detatchFrame(frame);
            resolve(e.data[objectKey]);
          }
          if (e.data.status === "DECLINED") {
            removeEventListener();
            detatchFrame(frame);
            if (e.data.errorCode === "incorrect_session_id") {
              this.handleDisconnect();
            }
            reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));
          }
        }
        if (e.data.type === "ETH:FRAME:CLOSE") {
          removeEventListener();
          detatchFrame(frame);
          reject(dist.ethErrors.provider.userRejectedRequest("User declined the request"));
        }
      }));
    });
  }
  setIframe(url) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof window === "undefined") {
        throw dist.ethErrors.provider.custom({
          code: 1001,
          message: "Blocto SDK only works in browser environment"
        });
      }
      const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      const frame = createFrame(`${walletServer}/${this.appId}/${blockchainName}${url}`);
      attachFrame(frame);
      return frame;
    });
  }
  // eip-1102 alias
  // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md
  enable(email) {
    return __awaiter(this, void 0, void 0, function* () {
      const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      const existedSDK = window.ethereum;
      if (existedSDK && existedSDK.isBlocto) {
        if (existedSDK.chainId !== this.chainId) {
          yield existedSDK.request({
            method: "wallet_addEthereumChain",
            params: [{ chainId: this.chainId }]
          });
          yield existedSDK.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: this.chainId }]
          });
          setChainAddress(sessionKey, blockchainName, [existedSDK.address]);
        }
        return new Promise((resolve, reject) => (
          // add a small delay to make sure the network has been switched
          setTimeout(() => existedSDK.enable().then(resolve).catch(reject), 10)
        ));
      }
      const address = getChainAddress(sessionKey, blockchainName);
      if (address) {
        return new Promise((resolve) => {
          resolve(address);
        });
      }
      const params = new URLSearchParams();
      params.set("l6n", window.location.origin);
      params.set("v", SDK_VERSION);
      const emailParam = email && isEmail(email) ? `/${email}` : "";
      const loginFrame = yield this.setIframe(`/authn${emailParam}?${params.toString()}`);
      return new Promise((resolve, reject) => {
        addSelfRemovableHandler("message", (event, removeListener) => {
          var _a;
          const e = event;
          if (e.origin === walletServer) {
            if (e.data.type === "ETH:FRAME:RESPONSE") {
              removeListener();
              detatchFrame(loginFrame);
              (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener) => listener({ chainId: this.chainId }));
              setAccountStorage(sessionKey, {
                code: e.data.code,
                connected: true,
                accounts: {
                  [blockchainName]: [e.data.addr]
                }
              }, e.data.exp);
              resolve([e.data.addr]);
            }
            if (e.data.type === "ETH:FRAME:CLOSE") {
              removeListener();
              detatchFrame(loginFrame);
              reject(dist.ethErrors.provider.userRejectedRequest());
            }
          }
        });
      });
    });
  }
  fetchAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      const { blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      const { accounts } = yield this.bloctoApi(`/accounts`);
      setChainAddress(sessionKey, blockchainName, accounts);
      return accounts;
    });
  }
  handleReadRequests(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      return fetch(this.rpc, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(Object.assign({ id: 1, jsonrpc: "2.0" }, payload))
      }).then((response) => response.json()).catch((e) => {
        throw dist.ethErrors.rpc.internal(e);
      });
    });
  }
  handleSign({ method, params }) {
    return __awaiter(this, void 0, void 0, function* () {
      let message = "";
      if (Array.isArray(params)) {
        if (method === "eth_sign") {
          message = isHexString(params[1]) ? params[1].slice(2) : utf8ToHex(params[1]);
        } else if (method === "personal_sign") {
          message = isHexString(params[0]) ? params[0].slice(2) : utf8ToHex(params[0]);
        } else if ([
          "eth_signTypedData",
          "eth_signTypedData_v3",
          "eth_signTypedData_v4"
        ].includes(method)) {
          message = params[1];
          const { domain } = JSON.parse(message);
          if (isHexString(domain.chainId)) {
            throw dist.ethErrors.rpc.invalidParams(`Provided chainId "${domain.chainId}" must be a number`);
          }
          if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {
            throw dist.ethErrors.rpc.invalidParams(`Provided chainId "${domain.chainId}" must match the active chainId "${parseChainId(this.chainId)}"`);
          }
        }
      }
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      const { signatureId } = yield this.bloctoApi(`/user-signature`, { method: "POST", body: JSON.stringify({ method, message }) });
      const signFrame = yield this.setIframe(`/user-signature/${signatureId}`);
      return this.responseListener(signFrame, "signature");
    });
  }
  handleSendTransaction(payload) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      if (!isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0])) {
        throw dist.ethErrors.rpc.invalidParams();
      }
      const { authorizationId } = yield this.bloctoApi(`/authz`, { method: "POST", body: JSON.stringify(payload.params) });
      const authzFrame = yield this.setIframe(`/authz/${authorizationId}`);
      return this.responseListener(authzFrame, "txHash");
    });
  }
  handleSendBatchTransaction(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      const extractParams = (params) => params.map((param) => "params" in param ? param.params[0] : param);
      const formatParams = extractParams(payload.params);
      const copyPayload = Object.assign(Object.assign({}, payload), { params: formatParams });
      if (!isValidTransactions(copyPayload.params)) {
        throw dist.ethErrors.rpc.invalidParams();
      }
      return this.handleSendTransaction(copyPayload);
    });
  }
  handleSendUserOperation(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      const { authorizationId } = yield this.bloctoApi(`/user-operation`, {
        method: "POST",
        body: JSON.stringify(payload.params)
      });
      const userOPFrame = yield this.setIframe(`/user-operation/${authorizationId}`);
      return this.responseListener(userOPFrame, "userOpHash");
    });
  }
  handleBundler(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_checkNetworkMatched).call(this);
      return this.bloctoApi(`/rpc/bundler`, {
        method: "POST",
        body: JSON.stringify(Object.assign({ id: 1, jsonrpc: "2.0" }, payload))
      });
    });
  }
  handleDisconnect() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.ethereum;
      if (existedSDK && existedSDK.isBlocto) {
        return existedSDK.disconnect();
      }
      const { sessionKey, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
      removeChainAddress(sessionKey, blockchainName);
      (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));
    });
  }
  loadSwitchableNetwork(networkList) {
    return __awaiter(this, void 0, void 0, function* () {
      if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {
        const listToAdd = networkList.map(({ chainId, rpcUrls }) => {
          if (!chainId)
            throw dist.ethErrors.rpc.invalidParams("Empty chainId");
          if (!(rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls.length))
            throw dist.ethErrors.rpc.invalidParams("Empty rpcUrls");
          return __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_addToSwitchable).call(this, {
            chainId: `${parseChainId(chainId)}`,
            rpcUrls
          });
        });
        return Promise.all(listToAdd).then(() => null);
      } else {
        throw dist.ethErrors.rpc.invalidParams("Empty networkList");
      }
    });
  }
};
_EthereumProvider_instances = /* @__PURE__ */ new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties2() {
  return __awaiter(this, void 0, void 0, function* () {
    if (!Object.keys(this._blocto.supportNetworkList).length) {
      yield getEvmSupport().then((result) => this._blocto.supportNetworkList = result).catch((e) => {
        throw dist.ethErrors.provider.custom({
          code: 1001,
          message: `Get blocto server failed: ${e.message}`
        });
      });
    }
    const { chain_id, name, network_type, blocto_service_environment, display_name } = this._blocto.supportNetworkList[this.networkVersion];
    if (!chain_id)
      throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${this.networkVersion} might not be supported yet.`);
    this._blocto = Object.assign(Object.assign({}, this._blocto), { sessionKey: ETH_SESSION_KEY_MAPPING[blocto_service_environment], walletServer: this.injectedWalletServer || ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment], blockchainName: name, networkType: network_type, switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), { [chain_id]: {
      name,
      display_name,
      network_type,
      wallet_web_url: this._blocto.walletServer,
      rpc_url: this.rpc
    } }) });
    return this._blocto;
  });
}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable2({ chainId, rpcUrls }) {
  return __awaiter(this, void 0, void 0, function* () {
    const { supportNetworkList } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, "m", _EthereumProvider_getBloctoProperties).call(this);
    const { chain_id, name, display_name, network_type, blocto_service_environment } = supportNetworkList[chainId];
    const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];
    this._blocto.switchableNetwork[chain_id] = {
      name,
      display_name,
      network_type,
      wallet_web_url,
      rpc_url: rpcUrls[0]
    };
  });
}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched2() {
  const existedSDK = window.ethereum;
  if (existedSDK && existedSDK.isBlocto && parseChainId(existedSDK.chainId) !== parseChainId(this.chainId)) {
    throw dist.ethErrors.provider.chainDisconnected();
  }
};
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var src = base;
var basex = src;
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET);
var bs58$1 = getDefaultExportFromCjs(bs58);
var Solana;
try {
  Solana = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
} catch (_a) {
}
var SolanaProvider = class extends BloctoProvider {
  constructor({ net = "mainnet-beta", server: server2, appId, rpc }) {
    super();
    invariant(net, "'net' is required");
    invariant(Object.values(SOL_NET).includes(net), "unsupported net");
    this.net = net;
    this.rpc = rpc || (net === "mainnet-beta" ? "https://free.rpcpool.com" : `https://api.${net}.solana.com`);
    this.server = server2 || SOL_NET_SERVER_MAPPING[this.net] || "";
    this.appId = appId || DEFAULT_APP_ID;
    this.sessionKey = SOL_SESSION_KEY_MAPPING[this.net];
    if (!Solana) {
      throw new Error("No @solana/web3.js installed. Please install it to interact with Solana.");
    }
  }
  request(payload) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.solana;
      if (existedSDK && existedSDK.isBlocto) {
        return existedSDK.request(payload);
      }
      if (!getChainAddress(this.sessionKey, CHAIN.SOLANA)) {
        yield this.connect();
      }
      try {
        let response = null;
        let result = null;
        switch (payload.method) {
          case "connect":
            result = yield this.fetchAccounts();
            break;
          case "disconnect":
            this.disconnect();
            break;
          case "getAccounts":
            result = ((_a = getChainAddress(this.sessionKey, CHAIN.SOLANA)) === null || _a === void 0 ? void 0 : _a.length) ? getChainAddress(this.sessionKey, CHAIN.SOLANA) : yield this.fetchAccounts();
            break;
          case "getAccountInfo": {
            const accountInfo = yield this.handleReadRequests(payload);
            const [bufferData, encoding] = accountInfo.result.value.data;
            result = Object.assign(Object.assign({}, accountInfo.result.value), { data: Buffer.from(bufferData, encoding), owner: new Solana.PublicKey(accountInfo.result.value.owner) });
            break;
          }
          case "convertToProgramWalletTransaction":
            result = yield this.handleConvertTransaction(payload);
            break;
          case "signAndSendTransaction":
            result = yield this.handleSignAndSendTransaction(payload);
            break;
          case "signTransaction":
          case "signAllTransactions":
            throw new Error(`Blocto is program wallet, which doesn't support ${payload.method}. Use signAndSendTransaction instead.`);
          default:
            response = yield this.handleReadRequests(payload);
        }
        if (response && !response.result && response.error) {
          const errorMessage = response.error.message ? response.error.message : "Request failed";
          throw new Error(errorMessage);
        }
        if (response)
          return response.result;
        return result;
      } catch (error) {
        console.error(error);
        throw error;
      }
    });
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.solana;
      if (existedSDK && existedSDK.isBlocto) {
        return new Promise((resolve) => {
          existedSDK.on("connect", () => {
            setChainAddress(this.sessionKey, CHAIN.SOLANA, [
              existedSDK.publicKey.toBase58()
            ]);
            resolve();
          });
          existedSDK.connect();
        });
      }
      return new Promise((resolve, reject) => {
        if (typeof window === "undefined") {
          return reject("Currently only supported in browser");
        }
        if (getChainAddress(this.sessionKey, CHAIN.SOLANA)) {
          return resolve();
        }
        const location = encodeURIComponent(window.location.origin);
        const loginFrame = createFrame(`${this.server}/${this.appId}/solana/authn?l6n=${location}&v=${SDK_VERSION}`);
        attachFrame(loginFrame);
        addSelfRemovableHandler("message", (event, removeListener) => {
          const e = event;
          if (e.origin === this.server) {
            if (e.data.type === "SOL:FRAME:RESPONSE") {
              removeListener();
              detatchFrame(loginFrame);
              this.eventListeners.connect.forEach((listener) => listener(this.net));
              setAccountStorage(this.sessionKey, {
                code: e.data.code,
                connected: true,
                accounts: {
                  [CHAIN.SOLANA]: [e.data.addr]
                }
              }, e.data.exp);
              resolve();
            }
            if (e.data.type === "SOL:FRAME:CLOSE") {
              removeListener();
              detatchFrame(loginFrame);
              reject(new Error("User declined the login request"));
            }
          }
        });
      });
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.solana;
      if (existedSDK && existedSDK.isBlocto) {
        yield existedSDK.disconnect();
        return;
      }
      this.eventListeners.disconnect.forEach((listener) => listener(null));
      removeChainAddress(this.sessionKey, CHAIN.SOLANA);
    });
  }
  fetchAccounts() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || "";
      const { accounts } = yield fetch(`${this.server}/api/solana/accounts`, {
        headers: {
          // We already check the existence in the constructor
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          "Blocto-Application-Identifier": this.appId,
          "Blocto-Session-Identifier": sessionId
        }
      }).then((response) => responseSessionGuard(response, this.sessionKey));
      setChainAddress(this.sessionKey, CHAIN.SOLANA, accounts);
      return accounts;
    });
  }
  handleReadRequests(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return fetch(this.rpc, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(Object.assign({ id: 1, jsonrpc: "2.0" }, payload))
      }).then((response) => response.json());
    });
  }
  // solana web3 utility
  convertToProgramWalletTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.solana;
      if (existedSDK && existedSDK.isBlocto) {
        return existedSDK.convertToProgramWalletTransaction(transaction);
      }
      const message = yield this.request({
        method: "convertToProgramWalletTransaction",
        params: {
          message: transaction.serializeMessage().toString("hex")
        }
      });
      return this.toTransaction(message, []);
    });
  }
  // solana web3 utility
  signAndSendTransaction(transaction, connection) {
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.solana;
      if (existedSDK && existedSDK.isBlocto) {
        return existedSDK.signAndSendTransaction(transaction);
      }
      const extra = {};
      if (connection) {
        if (connection.commitment)
          extra.commitment = connection.commitment;
        const rpc = connection ? connection._rpcEndpoint : null;
        if (rpc && rpc !== this.rpc) {
          this.rpc = rpc;
          this.disconnect();
          yield this.connect();
        }
      }
      return this.request({
        method: "signAndSendTransaction",
        params: Object.assign({ signatures: yield this.collectSignatures(transaction), message: transaction.serializeMessage().toString("hex") }, extra)
      });
    });
  }
  // solana web3 utility
  // eslint-disable-next-line class-methods-use-this
  toTransaction(raw, signatures) {
    return __awaiter(this, void 0, void 0, function* () {
      const message = Solana.Message.from(Buffer.from(raw, "hex"));
      const transaction = new Solana.Transaction();
      transaction.recentBlockhash = message.recentBlockhash;
      if (message.header.numRequiredSignatures > 0) {
        transaction.feePayer = message.accountKeys[0];
      }
      signatures.forEach((signature, index) => {
        const sigPubkeyPair = {
          signature: signature === Solana.PublicKey.default.toBase58() ? null : bs58$1.decode(signature),
          publicKey: message.accountKeys[index]
        };
        transaction.signatures.push(sigPubkeyPair);
      });
      message.instructions.forEach((instruction) => {
        const keys = instruction.accounts.map((account) => {
          const pubkey = message.accountKeys[account];
          return {
            pubkey,
            isSigner: account < message.header.numRequiredSignatures,
            isWritable: message.isAccountWritable(account)
          };
        });
        transaction.instructions.push(new Solana.TransactionInstruction({
          keys,
          programId: message.accountKeys[instruction.programIdIndex],
          data: bs58$1.decode(instruction.data)
        }));
      });
      return transaction;
    });
  }
  // solana web3 utility
  // eslint-disable-next-line class-methods-use-this
  collectSignatures(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      return transaction.signatures.reduce((acc, cur) => {
        if (cur.signature) {
          acc[cur.publicKey.toBase58()] = cur.signature.toString("hex");
        }
        return acc;
      }, {});
    });
  }
  handleConvertTransaction(payload) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || "";
      return fetch(`${this.server}/api/solana/convertToWalletTx`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // We already check the existence in the constructor
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          "Blocto-Application-Identifier": this.appId,
          "Blocto-Session-Identifier": sessionId
        },
        body: JSON.stringify(payload.params)
      }).then((response) => responseSessionGuard(response, this.sessionKey));
    });
  }
  handleSignAndSendTransaction(payload) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || "";
      const { authorizationId } = yield fetch(`${this.server}/api/solana/authz`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // We already check the existence in the constructor
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          "Blocto-Application-Identifier": this.appId,
          "Blocto-Session-Identifier": sessionId
        },
        body: JSON.stringify(payload.params)
      }).then((response) => responseSessionGuard(response, this.sessionKey));
      if (typeof window === "undefined") {
        throw new Error("Currently only supported in browser");
      }
      const authzFrame = createFrame(`${this.server}/${this.appId}/solana/authz/${authorizationId}`);
      attachFrame(authzFrame);
      return new Promise((resolve, reject) => addSelfRemovableHandler("message", (event, removeEventListener) => {
        const e = event;
        if (e.origin === this.server && e.data.type === "SOL:FRAME:RESPONSE") {
          if (e.data.status === "APPROVED") {
            removeEventListener();
            detatchFrame(authzFrame);
            resolve(e.data.txHash);
          }
          if (e.data.status === "DECLINED") {
            removeEventListener();
            detatchFrame(authzFrame);
            if (e.data.errorCode === "incorrect_session_id") {
              this.disconnect();
            }
            reject(new Error(e.data.errorMessage));
          }
        }
      }));
    });
  }
};
var checkMessagePayloadFormat = (payload) => {
  var _a, _b;
  const formattedPayload = Object.assign({}, payload);
  const { message, nonce, address, application, chainId } = payload;
  if (typeof message !== "string") {
    formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : "";
  }
  if (typeof nonce !== "string") {
    formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : "";
  }
  if (address && typeof address !== "boolean") {
    formattedPayload.address = !!address;
  }
  if (application && typeof application !== "boolean") {
    formattedPayload.application = !!application;
  }
  if (chainId && typeof chainId !== "boolean") {
    formattedPayload.chainId = !!chainId;
  }
  return formattedPayload;
};
var AptosProvider = class extends BloctoProvider {
  constructor({ chainId, server: server2, appId }) {
    super();
    this.publicKey = [];
    this.authKey = "";
    invariant(chainId, "'chainId' is required");
    invariant(appId, "It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.");
    this.chainId = chainId;
    this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];
    this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];
    this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];
    const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];
    this.appId = appId || DEFAULT_APP_ID;
    this.server = server2 || defaultServer || "";
  }
  get publicAccount() {
    var _a;
    return {
      address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,
      publicKey: this.publicKey.length ? this.publicKey : null,
      // @todo: provide authkey
      authKey: null,
      minKeysRequired: 2
    };
  }
  network() {
    return __awaiter(this, void 0, void 0, function* () {
      return {
        name: this.networkName,
        api: this.api,
        chainId: this.chainId.toString()
      };
    });
  }
  isConnected() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      return !!((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code);
    });
  }
  signTransaction(transaction) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.bloctoAptos;
      if (existedSDK) {
        return existedSDK.signTransaction(transaction);
      }
      const hasConnected = yield this.isConnected();
      if (!hasConnected) {
        yield this.connect();
      }
      if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {
        throw new Error("Fail to get account");
      }
      throw new Error("signTransaction method not supported.");
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.bloctoAptos;
      if (existedSDK) {
        yield existedSDK.disconnect();
        return;
      }
      removeChainAddress(this.sessionKey, CHAIN.APTOS);
    });
  }
  signAndSubmitTransaction(transaction, txOptions = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.bloctoAptos;
      if (existedSDK) {
        return existedSDK.signAndSubmitTransaction(transaction, txOptions);
      }
      const hasConnected = yield this.isConnected();
      if (!hasConnected) {
        yield this.connect();
      }
      if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {
        throw new Error("Fail to get account");
      }
      const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || "";
      const { authorizationId } = yield fetch(`${this.server}/api/aptos/authz`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // We already check the existence in the constructor
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          "Blocto-Application-Identifier": this.appId,
          "Blocto-Session-Identifier": sessionId
        },
        body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions))
      }).then((response) => responseSessionGuard(response, this.sessionKey));
      if (typeof window === "undefined") {
        throw new Error("Currently only supported in browser");
      }
      const authzFrame = createFrame(`${this.server}/${this.appId}/aptos/authz/${authorizationId}`);
      attachFrame(authzFrame);
      return new Promise((resolve, reject) => addSelfRemovableHandler("message", (event, removeEventListener) => {
        const e = event;
        if (e.origin === this.server && e.data.type === "APTOS:FRAME:RESPONSE") {
          if (e.data.status === "APPROVED") {
            removeEventListener();
            detatchFrame(authzFrame);
            resolve({ hash: e.data.txHash });
          }
          if (e.data.status === "DECLINED") {
            removeEventListener();
            detatchFrame(authzFrame);
            if (e.data.errorCode === "incorrect_session_id") {
              this.disconnect();
            }
            reject(new Error(e.data.errorMessage));
          }
        }
      }));
    });
  }
  signMessage(payload) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.bloctoAptos;
      const formattedPayload = checkMessagePayloadFormat(payload);
      if (existedSDK) {
        return existedSDK.signMessage(formattedPayload);
      }
      const hasConnected = yield this.isConnected();
      if (!hasConnected) {
        yield this.connect();
      }
      if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {
        throw new Error("Fail to get account");
      }
      if (typeof window === "undefined") {
        throw new Error("Currently only supported in browser");
      }
      const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || "";
      const { signatureId } = yield fetch(`${this.server}/api/aptos/user-signature`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // We already check the existence in the constructor
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          "Blocto-Application-Identifier": this.appId,
          "Blocto-Session-Identifier": sessionId
        },
        body: JSON.stringify(formattedPayload)
      }).then((response) => responseSessionGuard(response, this.sessionKey));
      const url = `${this.server}/${this.appId}/aptos/user-signature/${signatureId}`;
      const signFrame = createFrame(url);
      attachFrame(signFrame);
      return new Promise((resolve, reject) => addSelfRemovableHandler("message", (event, removeEventListener) => {
        const e = event;
        if (e.origin === this.server && e.data.type === "APTOS:FRAME:RESPONSE") {
          if (e.data.status === "APPROVED") {
            removeEventListener();
            detatchFrame(signFrame);
            resolve(e.data);
          }
          if (e.data.status === "DECLINED") {
            removeEventListener();
            detatchFrame(signFrame);
            if (e.data.errorCode === "incorrect_session_id") {
              this.disconnect();
            }
            reject(new Error(e.data.errorMessage));
          }
        }
      }));
    });
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      const existedSDK = window.bloctoAptos;
      if (existedSDK) {
        return new Promise((resolve, reject) => (
          // add a small delay to make sure the network has been switched
          setTimeout(() => existedSDK.connect().then(resolve).catch(reject), 10)
        ));
      }
      return new Promise((resolve, reject) => {
        var _a, _b;
        if (typeof window === "undefined") {
          return reject("Currently only supported in browser");
        }
        if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {
          return resolve({
            address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,
            publicKey: this.publicKey,
            authKey: null,
            minKeysRequired: 2
          });
        }
        const location = encodeURIComponent(window.location.origin);
        const loginFrame = createFrame(`${this.server}/${this.appId}/aptos/authn?l6n=${location}&v=${SDK_VERSION}}`);
        attachFrame(loginFrame);
        addSelfRemovableHandler("message", (event, removeListener) => __awaiter(this, void 0, void 0, function* () {
          var _c, _d, _e;
          const e = event;
          if (e.origin === this.server) {
            if (e.data.type === "APTOS:FRAME:RESPONSE") {
              removeListener();
              detatchFrame(loginFrame);
              setAccountStorage(this.sessionKey, {
                code: e.data.code,
                connected: true,
                accounts: {
                  [CHAIN.APTOS]: [e.data.addr]
                }
              }, e.data.exp);
              if ((_c = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _c === void 0 ? void 0 : _c.length) {
                try {
                  const { public_keys: publicKeys } = yield fetch(`${this.server}/blocto/aptos/accounts/${(_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d[0]}`).then((response) => response.json());
                  this.publicKey = publicKeys || [];
                  resolve({
                    address: ((_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]) || "",
                    publicKey: this.publicKey,
                    authKey: null,
                    minKeysRequired: 2
                  });
                } catch (err) {
                  return reject(e);
                }
              } else {
                return reject();
              }
            }
            if (e.data.type === "APTOS:FRAME:CLOSE") {
              removeListener();
              detatchFrame(loginFrame);
              reject(new Error("User declined the login request"));
            }
          }
        }));
      });
    });
  }
  fetchAddress() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || "";
      const { accounts } = yield fetch(`${this.server}/api/aptos/accounts`, {
        headers: {
          // We already check the existence in the constructor
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          "Blocto-Application-Identifier": this.appId,
          "Blocto-Session-Identifier": sessionId
        }
      }).then((response) => responseSessionGuard(response, this.sessionKey));
      setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);
      return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || "";
    });
  }
};
var BloctoSDK = class {
  constructor({ appId, ethereum, solana, aptos }) {
    if (ethereum) {
      this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), { appId }));
    }
    if (solana) {
      this.solana = new SolanaProvider(Object.assign(Object.assign({}, solana), { appId }));
    }
    if (aptos) {
      this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), { appId }));
    }
  }
};

// node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js
init_lib();
var _provider = /* @__PURE__ */ new WeakMap();
var _onAccountsChangedBind = /* @__PURE__ */ new WeakMap();
var _onChainChangedBind = /* @__PURE__ */ new WeakMap();
var _onDisconnectBind = /* @__PURE__ */ new WeakMap();
var _isUserRejectedRequestError = /* @__PURE__ */ new WeakSet();
var _handleConnectReset = /* @__PURE__ */ new WeakSet();
var BloctoConnector = class extends WagmiConnector {
  constructor(_ref) {
    let {
      chains,
      options = {}
    } = _ref;
    super({
      chains,
      options
    });
    _classPrivateMethodInitSpec(this, _handleConnectReset);
    _classPrivateMethodInitSpec(this, _isUserRejectedRequestError);
    _defineProperty(this, "id", walletIds.blocto);
    _defineProperty(this, "name", "Blocto");
    _defineProperty(this, "ready", true);
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onAccountsChangedBind, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onChainChangedBind, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onDisconnectBind, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _onAccountsChangedBind, this.onAccountsChanged.bind(this));
    _classPrivateFieldSet(this, _onChainChangedBind, this.onChainChanged.bind(this));
    _classPrivateFieldSet(this, _onDisconnectBind, this.onDisconnect.bind(this));
  }
  async connect(config) {
    try {
      const provider = await this.getProvider(config);
      this.setupListeners();
      this.emit("message", {
        type: "connecting"
      });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = utils_exports.getAddress(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      _classPrivateMethodGet(this, _handleConnectReset, _handleConnectReset2).call(this);
      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.request({
      method: "wallet_disconnect"
    });
    this.removeListeners();
    _classPrivateMethodGet(this, _handleConnectReset, _handleConnectReset2).call(this);
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    const [address] = accounts || [];
    if (!address) {
      throw new Error("No accounts found");
    }
    return address;
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = await provider.request({
      method: "eth_chainId"
    });
    return normalizeChainId(chainId);
  }
  getProvider() {
    var _a, _b, _c;
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_classPrivateFieldGet(this, _provider)) {
      const _chainId = chainId ?? this.options.chainId ?? ((_a = this.chains[0]) == null ? void 0 : _a.chainId) ?? 1;
      const _rpc = (_b = this.chains.find((x) => x.chainId === _chainId)) == null ? void 0 : _b.rpc[0];
      _classPrivateFieldSet(this, _provider, (_c = new BloctoSDK({
        ethereum: {
          chainId: _chainId,
          rpc: _rpc
        },
        appId: this.options.appId
      })) == null ? void 0 : _c.ethereum);
    }
    if (!_classPrivateFieldGet(this, _provider)) {
      throw new ConnectorNotFoundError();
    }
    return Promise.resolve(_classPrivateFieldGet(this, _provider));
  }
  async getSigner() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new lib_exports.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    var _a, _b;
    return !!((_b = (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a._blocto) == null ? void 0 : _b.sessionKey);
  }
  async switchChain(chainId) {
    const provider = await this.getProvider();
    const id = utils_exports.hexValue(chainId);
    const chain = this.chains.find((x) => x.chainId === chainId);
    if (!chain) {
      throw new SwitchChainError(new Error("chain not found on connector."));
    }
    const isBloctoSupportChain = provider._blocto.supportNetworkList[`${chainId}`];
    if (!isBloctoSupportChain) {
      throw new SwitchChainError(new Error(`Blocto unsupported chain: ${id}`));
    }
    try {
      await provider.request({
        method: "wallet_addEthereumChain",
        params: [{
          chainId: id,
          rpcUrls: getValidPublicRPCUrl(chain)
          // no client id on purpose here
        }]
      });
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      return chain;
    } catch (error) {
      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) {
        throw new UserRejectedRequestError(error);
      }
      throw new SwitchChainError(error);
    }
  }
  onAccountsChanged() {
  }
  async onChainChanged(chain) {
    const id = normalizeChainId(chain);
    const unsupported = this.isChainUnsupported(id);
    const account = await this.getAccount();
    this.emit("change", {
      chain: {
        id,
        unsupported
      },
      account
    });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  async setupListeners() {
    const provider = await this.getProvider();
    provider.on("accountsChanged", _classPrivateFieldGet(this, _onAccountsChangedBind));
    provider.on("chainChanged", _classPrivateFieldGet(this, _onChainChangedBind));
    provider.on("disconnect", _classPrivateFieldGet(this, _onDisconnectBind));
  }
  async removeListeners() {
    const provider = await this.getProvider();
    provider.off("accountsChanged", _classPrivateFieldGet(this, _onAccountsChangedBind));
    provider.off("chainChanged", _classPrivateFieldGet(this, _onChainChangedBind));
    provider.off("disconnect", _classPrivateFieldGet(this, _onDisconnectBind));
  }
};
function _isUserRejectedRequestError2(error) {
  return /(user rejected)/i.test(error.message);
}
function _handleConnectReset2() {
  _classPrivateFieldSet(this, _provider, void 0);
}
export {
  BloctoConnector
};
/*! Bundled license information:

@blocto/sdk/dist/blocto-sdk.module.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-H6OP6XCP.js.map
