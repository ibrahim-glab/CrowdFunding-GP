import {
  require_browser
} from "./chunk-C6ILTZLL.js";
import {
  require_fast_safe_stringify
} from "./chunk-E54CA2HM.js";
import {
  require_js,
  require_readable_browser
} from "./chunk-N7L26NZZ.js";
import {
  require_regenerator
} from "./chunk-LKLMWNJK.js";
import {
  require_events
} from "./chunk-FSFHF7RN.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-HY2WJTHE.js";

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
    o3.__proto__ = p2;
    return o3;
  };
  return _setPrototypeOf(o2, p);
}
var init_setPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
var init_superPropBase = __esm({
  "node_modules/@babel/runtime/helpers/esm/superPropBase.js"() {
    init_getPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var init_get = __esm({
  "node_modules/@babel/runtime/helpers/esm/get.js"() {
    init_superPropBase();
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e2) {
    return typeof fn === "function";
  }
}
var init_isNativeFunction = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct4() {
    return !!t2;
  })();
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t2, e2, r2) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o2 = [null];
  o2.push.apply(o2, e2);
  var p = new (t2.bind.apply(t2, o2))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}
var init_construct = __esm({
  "node_modules/@babel/runtime/helpers/esm/construct.js"() {
    init_setPrototypeOf();
    init_isNativeReflectConstruct();
  }
});

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var init_wrapNativeSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js"() {
    init_getPrototypeOf();
    init_setPrototypeOf();
    init_isNativeFunction();
    init_construct();
  }
});

// node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/base64url/dist/pad-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
        buffer.write("=", position++);
      }
      return buffer.toString();
    }
    exports.default = padString;
  }
});

// node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/base64url/dist/base64url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode(base64url3, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url3), "base64").toString(encoding);
    }
    function toBase64(base64url3) {
      base64url3 = base64url3.toString();
      return pad_string_1.default(base64url3).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url3) {
      return Buffer.from(toBase64(base64url3), "base64");
    }
    var base64url2 = encode;
    base64url2.encode = encode;
    base64url2.decode = decode;
    base64url2.toBase64 = toBase64;
    base64url2.fromBase64 = fromBase64;
    base64url2.toBuffer = toBuffer;
    exports.default = base64url2;
  }
});

// node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/base64url/index.js"(exports, module) {
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function safeatob(str) {
  return base64url.decode(str);
}
function jsonToBase64(json) {
  return base64url.encode(JSON.stringify(json));
}
var import_randombytes, import_base64url, import_keccak, randomId, URLWithHashParams, base64url, keccak;
var init_openloginUtils_esm = __esm({
  "node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js"() {
    import_randombytes = __toESM(require_browser());
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_wrapNativeSuper();
    init_defineProperty();
    import_base64url = __toESM(require_base64url2());
    import_keccak = __toESM(require_js());
    randomId = function randomId2() {
      return (0, import_randombytes.default)(32).toString("hex");
    };
    URLWithHashParams = function(_URL) {
      _inherits(URLWithHashParams2, _URL);
      var _super = _createSuper(URLWithHashParams2);
      function URLWithHashParams2() {
        var _this;
        _classCallCheck(this, URLWithHashParams2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "hashParams", new URLSearchParams());
        return _this;
      }
      _createClass(URLWithHashParams2, [{
        key: "toString",
        value: function toString() {
          this.hash = this.hashParams.toString();
          return _get(_getPrototypeOf(URLWithHashParams2.prototype), "toString", this).call(this);
        }
      }]);
      return URLWithHashParams2;
    }(_wrapNativeSuper(URL));
    base64url = import_base64url.default;
    keccak = import_keccak.default;
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r2, l) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u, a = [], f = true, o2 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l); f = true)
          ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError2(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError2;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/@toruslabs/openlogin-jrpc/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once2);
    module.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    var once2 = require_once();
    var noop2 = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos2 = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos2(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once2(callback || noop2);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos2;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module) {
    var once2 = require_once();
    var eos2 = require_end_of_stream();
    var fs = require_fs();
    var noop2 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop2) || stream instanceof (fs.WriteStream || noop2)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once2(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos2(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop2);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump2 = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop2) && streams.pop() || noop2;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module.exports = pump2;
  }
});

// node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function noop() {
  return void 0;
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(function() {
      throw err;
    });
  }
}
function arrayClone(arr) {
  var n2 = arr.length;
  var copy = new Array(n2);
  for (var i = 0; i < n2; i += 1) {
    copy[i] = arr[i];
  }
  return copy;
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function createStreamMiddleware() {
  var idMap = {};
  function readNoop() {
    return false;
  }
  var events = new SafeEventEmitter();
  function processResponse(res) {
    var context = idMap[res.id];
    if (!context) {
      throw new Error('StreamMiddleware - Unknown response id "'.concat(res.id, '"'));
    }
    delete idMap[res.id];
    Object.assign(context.res, res);
    setTimeout(context.end);
  }
  function processNotification(res) {
    events.emit("notification", res);
  }
  function processMessage(res, _encoding, cb) {
    var err;
    try {
      var isNotification = !res.id;
      if (isNotification) {
        processNotification(res);
      } else {
        processResponse(res);
      }
    } catch (_err) {
      err = _err;
    }
    cb(err);
  }
  var stream = new import_readable_stream.Duplex({
    objectMode: true,
    read: readNoop,
    write: processMessage
  });
  var middleware = function middleware2(req, res, next, end) {
    stream.push(req);
    idMap[req.id] = {
      req,
      res,
      next,
      end
    };
  };
  return {
    events,
    middleware,
    stream
  };
}
function createScaffoldMiddleware(handlers) {
  return function(req, res, next, end) {
    var handler = handlers[req.method];
    if (handler === void 0) {
      return next();
    }
    if (typeof handler === "function") {
      return handler(req, res, next, end);
    }
    res.result = handler;
    return end();
  };
}
function createIdRemapMiddleware() {
  return function(req, res, next, _end) {
    var originalId = req.id;
    var newId = randomId();
    req.id = newId;
    res.id = newId;
    next(function(done) {
      req.id = originalId;
      res.id = originalId;
      done();
    });
  };
}
function createAsyncMiddleware(asyncMiddleware) {
  return function() {
    var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res, next, end) {
      var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              nextPromise = new Promise(function(resolve) {
                resolveNextPromise = resolve;
              });
              returnHandlerCallback = null;
              nextWasCalled = false;
              asyncNext = function() {
                var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
                  return import_regenerator.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          nextWasCalled = true;
                          next(function(runReturnHandlersCallback) {
                            returnHandlerCallback = runReturnHandlersCallback;
                            resolveNextPromise();
                          });
                          _context.next = 4;
                          return nextPromise;
                        case 4:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));
                return function asyncNext2() {
                  return _ref2.apply(this, arguments);
                };
              }();
              _context2.prev = 4;
              _context2.next = 7;
              return asyncMiddleware(req, res, asyncNext);
            case 7:
              if (!nextWasCalled) {
                _context2.next = 13;
                break;
              }
              _context2.next = 10;
              return nextPromise;
            case 10:
              returnHandlerCallback(null);
              _context2.next = 14;
              break;
            case 13:
              end(null);
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](4);
              if (returnHandlerCallback) {
                returnHandlerCallback(_context2.t0);
              } else {
                end(_context2.t0);
              }
            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[4, 16]]);
    }));
    return function(_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i >= o2.length)
          return { done: true };
        return { done: false, value: o2[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o2);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function mergeMiddleware(middlewareStack) {
  var engine = new JRPCEngine();
  middlewareStack.forEach(function(middleware) {
    return engine.push(middleware);
  });
  return engine.asMiddleware();
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function anyStreamEnd(stream, _cb) {
  var cb = (0, import_once.default)(_cb);
  (0, import_end_of_stream.default)(stream, {
    readable: false
  }, cb);
  (0, import_end_of_stream.default)(stream, {
    writable: false
  }, cb);
}
function setupMultiplex(stream) {
  var mux = new ObjectMultiplex();
  mux.getStream = function streamHelper(name) {
    if (this._substreams[name]) {
      return this._substreams[name];
    }
    return this.createStream(name);
  };
  (0, import_pump.default)(stream, mux, stream, function(err) {
    if (err)
      window.console.error(err);
  });
  return mux;
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var import_readable_stream, import_regenerator, import_events, import_fast_safe_stringify, import_eth_rpc_errors, import_end_of_stream, import_once, import_pump, SYN, ACK, BRK, BasePostMessageStream, SafeEventEmitter, SerializableError, getRpcPromiseCallback, JRPCEngine, Substream, IGNORE_SUBSTREAM, ObjectMultiplex, PostMessageStream;
var init_openloginJrpc_esm = __esm({
  "node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js"() {
    init_typeof();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_readable_stream = __toESM(require_readable_browser());
    init_asyncToGenerator();
    import_regenerator = __toESM(require_regenerator());
    init_openloginUtils_esm();
    import_events = __toESM(require_events());
    init_wrapNativeSuper();
    import_fast_safe_stringify = __toESM(require_fast_safe_stringify());
    init_slicedToArray();
    import_eth_rpc_errors = __toESM(require_dist());
    import_end_of_stream = __toESM(require_end_of_stream());
    import_once = __toESM(require_once());
    import_pump = __toESM(require_pump());
    SYN = "SYN";
    ACK = "ACK";
    BRK = "BRK";
    BasePostMessageStream = function(_Duplex) {
      _inherits(BasePostMessageStream2, _Duplex);
      var _super = _createSuper$6(BasePostMessageStream2);
      function BasePostMessageStream2(_ref) {
        var _this;
        var name = _ref.name, target = _ref.target, _ref$targetWindow = _ref.targetWindow, targetWindow = _ref$targetWindow === void 0 ? window : _ref$targetWindow, _ref$targetOrigin = _ref.targetOrigin, targetOrigin = _ref$targetOrigin === void 0 ? "*" : _ref$targetOrigin;
        _classCallCheck(this, BasePostMessageStream2);
        _this = _super.call(this, {
          objectMode: true
        });
        _defineProperty(_assertThisInitialized(_this), "_init", void 0);
        _defineProperty(_assertThisInitialized(_this), "_haveSyn", void 0);
        _defineProperty(_assertThisInitialized(_this), "_name", void 0);
        _defineProperty(_assertThisInitialized(_this), "_target", void 0);
        _defineProperty(_assertThisInitialized(_this), "_targetWindow", void 0);
        _defineProperty(_assertThisInitialized(_this), "_targetOrigin", void 0);
        _defineProperty(_assertThisInitialized(_this), "_onMessage", void 0);
        _defineProperty(_assertThisInitialized(_this), "_synIntervalId", void 0);
        if (!name || !target) {
          throw new Error("Invalid input.");
        }
        _this._init = false;
        _this._haveSyn = false;
        _this._name = name;
        _this._target = target;
        _this._targetWindow = targetWindow;
        _this._targetOrigin = targetOrigin;
        _this._onMessage = _this.onMessage.bind(_assertThisInitialized(_this));
        _this._synIntervalId = null;
        window.addEventListener("message", _this._onMessage, false);
        _this._handShake();
        return _this;
      }
      _createClass(BasePostMessageStream2, [{
        key: "_break",
        value: function _break() {
          this.cork();
          this._write(BRK, null, noop);
          this._haveSyn = false;
          this._init = false;
        }
      }, {
        key: "_handShake",
        value: function _handShake() {
          this._write(SYN, null, noop);
          this.cork();
        }
      }, {
        key: "_onData",
        value: function _onData(data) {
          if (!this._init) {
            if (data === SYN) {
              this._haveSyn = true;
              this._write(ACK, null, noop);
            } else if (data === ACK) {
              this._init = true;
              if (!this._haveSyn) {
                this._write(ACK, null, noop);
              }
              this.uncork();
            }
          } else if (data === BRK) {
            this._break();
          } else {
            try {
              this.push(data);
            } catch (err) {
              this.emit("error", err);
            }
          }
        }
      }, {
        key: "_postMessage",
        value: function _postMessage(data) {
          var originConstraint = this._targetOrigin;
          this._targetWindow.postMessage({
            target: this._target,
            data
          }, originConstraint);
        }
      }, {
        key: "onMessage",
        value: function onMessage(event) {
          var message = event.data;
          if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || _typeof(message) !== "object" || message.target !== this._name || !message.data) {
            return;
          }
          this._onData(message.data);
        }
      }, {
        key: "_read",
        value: function _read() {
          return void 0;
        }
      }, {
        key: "_write",
        value: function _write(data, _, cb) {
          this._postMessage(data);
          cb();
        }
      }, {
        key: "_destroy",
        value: function _destroy() {
          window.removeEventListener("message", this._onMessage, false);
        }
      }]);
      return BasePostMessageStream2;
    }(import_readable_stream.Duplex);
    SafeEventEmitter = function(_EventEmitter) {
      _inherits(SafeEventEmitter2, _EventEmitter);
      var _super = _createSuper$5(SafeEventEmitter2);
      function SafeEventEmitter2() {
        _classCallCheck(this, SafeEventEmitter2);
        return _super.apply(this, arguments);
      }
      _createClass(SafeEventEmitter2, [{
        key: "emit",
        value: function emit(type) {
          var doError = type === "error";
          var events = this._events;
          if (events !== void 0) {
            doError = doError && events.error === void 0;
          } else if (!doError) {
            return false;
          }
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (doError) {
            var er;
            if (args.length > 0) {
              er = args[0];
            }
            if (er instanceof Error) {
              throw er;
            }
            var err = new Error("Unhandled error.".concat(er ? " (".concat(er.message, ")") : ""));
            err.context = er;
            throw err;
          }
          var handler = events[type];
          if (handler === void 0) {
            return false;
          }
          if (typeof handler === "function") {
            safeApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler);
            for (var i = 0; i < len; i += 1) {
              safeApply(listeners[i], this, args);
            }
          }
          return true;
        }
      }]);
      return SafeEventEmitter2;
    }(import_events.EventEmitter);
    SerializableError = function(_Error) {
      _inherits(SerializableError2, _Error);
      var _super = _createSuper$4(SerializableError2);
      function SerializableError2(_ref) {
        var _this;
        var code = _ref.code, message = _ref.message, data = _ref.data;
        _classCallCheck(this, SerializableError2);
        if (!Number.isInteger(code)) {
          throw new Error("code must be an integer");
        }
        if (!message || typeof message !== "string") {
          throw new Error("message must be string");
        }
        _this = _super.call(this, message);
        _defineProperty(_assertThisInitialized(_this), "code", void 0);
        _defineProperty(_assertThisInitialized(_this), "data", void 0);
        _this.code = code;
        if (data !== void 0) {
          _this.data = data;
        }
        return _this;
      }
      _createClass(SerializableError2, [{
        key: "toString",
        value: function toString() {
          return (0, import_fast_safe_stringify.default)({
            code: this.code,
            message: this.message,
            data: this.data,
            stack: this.stack
          });
        }
      }]);
      return SerializableError2;
    }(_wrapNativeSuper(Error));
    getRpcPromiseCallback = function getRpcPromiseCallback2(resolve, reject) {
      var unwrapResult = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return function(error, response) {
        if (error || response.error) {
          reject(error || response.error);
        } else if (!unwrapResult || Array.isArray(response)) {
          resolve(response);
        } else {
          resolve(response.result);
        }
      };
    };
    JRPCEngine = function(_SafeEventEmitter) {
      _inherits(JRPCEngine2, _SafeEventEmitter);
      var _super = _createSuper$3(JRPCEngine2);
      function JRPCEngine2() {
        var _this;
        _classCallCheck(this, JRPCEngine2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "_middleware", void 0);
        _this._middleware = [];
        return _this;
      }
      _createClass(JRPCEngine2, [{
        key: "push",
        value: (
          /**
           * Add a middleware function to the engine's middleware stack.
           *
           * @param middleware - The middleware function to add.
           */
          function push(middleware) {
            this._middleware.push(middleware);
          }
        )
      }, {
        key: "handle",
        value: function handle(req, cb) {
          if (cb && typeof cb !== "function") {
            throw new Error('"callback" must be a function if provided.');
          }
          if (Array.isArray(req)) {
            if (cb) {
              return this._handleBatch(req, cb);
            }
            return this._handleBatch(req);
          }
          if (cb) {
            return this._handle(req, cb);
          }
          return this._promiseHandle(req);
        }
        /**
         * Returns this engine as a middleware function that can be pushed to other
         * engines.
         *
         * @returns This engine as a middleware function.
         */
      }, {
        key: "asMiddleware",
        value: function asMiddleware() {
          var _this2 = this;
          return function() {
            var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res, next, end) {
              var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;
              return import_regenerator.default.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.prev = 0;
                      _context2.next = 3;
                      return JRPCEngine2._runAllMiddleware(req, res, _this2._middleware);
                    case 3:
                      _yield$JRPCEngine$_ru = _context2.sent;
                      _yield$JRPCEngine$_ru2 = _slicedToArray(_yield$JRPCEngine$_ru, 3);
                      middlewareError = _yield$JRPCEngine$_ru2[0];
                      isComplete = _yield$JRPCEngine$_ru2[1];
                      returnHandlers = _yield$JRPCEngine$_ru2[2];
                      if (!isComplete) {
                        _context2.next = 12;
                        break;
                      }
                      _context2.next = 11;
                      return JRPCEngine2._runReturnHandlers(returnHandlers);
                    case 11:
                      return _context2.abrupt("return", end(middlewareError));
                    case 12:
                      return _context2.abrupt("return", next(function() {
                        var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee(handlerCallback) {
                          return import_regenerator.default.wrap(function _callee$(_context) {
                            while (1) {
                              switch (_context.prev = _context.next) {
                                case 0:
                                  _context.prev = 0;
                                  _context.next = 3;
                                  return JRPCEngine2._runReturnHandlers(returnHandlers);
                                case 3:
                                  _context.next = 8;
                                  break;
                                case 5:
                                  _context.prev = 5;
                                  _context.t0 = _context["catch"](0);
                                  return _context.abrupt("return", handlerCallback(_context.t0));
                                case 8:
                                  return _context.abrupt("return", handlerCallback());
                                case 9:
                                case "end":
                                  return _context.stop();
                              }
                            }
                          }, _callee, null, [[0, 5]]);
                        }));
                        return function(_x5) {
                          return _ref2.apply(this, arguments);
                        };
                      }()));
                    case 15:
                      _context2.prev = 15;
                      _context2.t0 = _context2["catch"](0);
                      return _context2.abrupt("return", end(_context2.t0));
                    case 18:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[0, 15]]);
            }));
            return function(_x, _x2, _x3, _x4) {
              return _ref.apply(this, arguments);
            };
          }();
        }
      }, {
        key: "_handleBatch",
        value: function() {
          var _handleBatch2 = _asyncToGenerator(import_regenerator.default.mark(function _callee3(reqs, cb) {
            var responses;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.prev = 0;
                    _context3.next = 3;
                    return Promise.all(
                      // 1. Begin executing each request in the order received
                      reqs.map(this._promiseHandle.bind(this))
                    );
                  case 3:
                    responses = _context3.sent;
                    if (!cb) {
                      _context3.next = 6;
                      break;
                    }
                    return _context3.abrupt("return", cb(null, responses));
                  case 6:
                    return _context3.abrupt("return", responses);
                  case 9:
                    _context3.prev = 9;
                    _context3.t0 = _context3["catch"](0);
                    if (!cb) {
                      _context3.next = 13;
                      break;
                    }
                    return _context3.abrupt("return", cb(_context3.t0));
                  case 13:
                    throw _context3.t0;
                  case 14:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[0, 9]]);
          }));
          function _handleBatch(_x6, _x7) {
            return _handleBatch2.apply(this, arguments);
          }
          return _handleBatch;
        }()
        /**
         * A promise-wrapped _handle.
         */
      }, {
        key: "_promiseHandle",
        value: function _promiseHandle(req) {
          var _this3 = this;
          return new Promise(function(resolve) {
            _this3._handle(req, function(_err, res) {
              resolve(res);
            });
          });
        }
        /**
         * Ensures that the request object is valid, processes it, and passes any
         * error and the response object to the given callback.
         *
         * Does not reject.
         */
      }, {
        key: "_handle",
        value: function() {
          var _handle2 = _asyncToGenerator(import_regenerator.default.mark(function _callee4(callerReq, cb) {
            var _error2, _error3, req, res, error;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(!callerReq || Array.isArray(callerReq) || _typeof(callerReq) !== "object")) {
                      _context4.next = 3;
                      break;
                    }
                    _error2 = new SerializableError({
                      code: -32603,
                      message: "request must be plain object"
                    });
                    return _context4.abrupt("return", cb(_error2, {
                      id: void 0,
                      jsonrpc: "2.0",
                      error: _error2
                    }));
                  case 3:
                    if (!(typeof callerReq.method !== "string")) {
                      _context4.next = 6;
                      break;
                    }
                    _error3 = new SerializableError({
                      code: -32603,
                      message: "method must be string"
                    });
                    return _context4.abrupt("return", cb(_error3, {
                      id: callerReq.id,
                      jsonrpc: "2.0",
                      error: _error3
                    }));
                  case 6:
                    req = _objectSpread$1({}, callerReq);
                    res = {
                      id: req.id,
                      jsonrpc: req.jsonrpc
                    };
                    error = null;
                    _context4.prev = 9;
                    _context4.next = 12;
                    return this._processRequest(req, res);
                  case 12:
                    _context4.next = 17;
                    break;
                  case 14:
                    _context4.prev = 14;
                    _context4.t0 = _context4["catch"](9);
                    error = _context4.t0;
                  case 17:
                    if (error) {
                      delete res.result;
                      if (!res.error) {
                        res.error = (0, import_eth_rpc_errors.serializeError)(error);
                      }
                    }
                    return _context4.abrupt("return", cb(error, res));
                  case 19:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[9, 14]]);
          }));
          function _handle(_x8, _x9) {
            return _handle2.apply(this, arguments);
          }
          return _handle;
        }()
        /**
         * For the given request and response, runs all middleware and their return
         * handlers, if any, and ensures that internal request processing semantics
         * are satisfied.
         */
      }, {
        key: "_processRequest",
        value: function() {
          var _processRequest2 = _asyncToGenerator(import_regenerator.default.mark(function _callee5(req, res) {
            var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return JRPCEngine2._runAllMiddleware(req, res, this._middleware);
                  case 2:
                    _yield$JRPCEngine$_ru3 = _context5.sent;
                    _yield$JRPCEngine$_ru4 = _slicedToArray(_yield$JRPCEngine$_ru3, 3);
                    error = _yield$JRPCEngine$_ru4[0];
                    isComplete = _yield$JRPCEngine$_ru4[1];
                    returnHandlers = _yield$JRPCEngine$_ru4[2];
                    JRPCEngine2._checkForCompletion(req, res, isComplete);
                    _context5.next = 10;
                    return JRPCEngine2._runReturnHandlers(returnHandlers);
                  case 10:
                    if (!error) {
                      _context5.next = 12;
                      break;
                    }
                    throw error;
                  case 12:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function _processRequest(_x10, _x11) {
            return _processRequest2.apply(this, arguments);
          }
          return _processRequest;
        }()
      }], [{
        key: "_runAllMiddleware",
        value: function() {
          var _runAllMiddleware2 = _asyncToGenerator(import_regenerator.default.mark(function _callee6(req, res, middlewareStack) {
            var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    returnHandlers = [];
                    error = null;
                    isComplete = false;
                    _iterator = _createForOfIteratorHelper(middlewareStack);
                    _context6.prev = 4;
                    _iterator.s();
                  case 6:
                    if ((_step = _iterator.n()).done) {
                      _context6.next = 18;
                      break;
                    }
                    middleware = _step.value;
                    _context6.next = 10;
                    return JRPCEngine2._runMiddleware(req, res, middleware, returnHandlers);
                  case 10:
                    _yield$JRPCEngine$_ru5 = _context6.sent;
                    _yield$JRPCEngine$_ru6 = _slicedToArray(_yield$JRPCEngine$_ru5, 2);
                    error = _yield$JRPCEngine$_ru6[0];
                    isComplete = _yield$JRPCEngine$_ru6[1];
                    if (!isComplete) {
                      _context6.next = 16;
                      break;
                    }
                    return _context6.abrupt("break", 18);
                  case 16:
                    _context6.next = 6;
                    break;
                  case 18:
                    _context6.next = 23;
                    break;
                  case 20:
                    _context6.prev = 20;
                    _context6.t0 = _context6["catch"](4);
                    _iterator.e(_context6.t0);
                  case 23:
                    _context6.prev = 23;
                    _iterator.f();
                    return _context6.finish(23);
                  case 26:
                    return _context6.abrupt("return", [error, isComplete, returnHandlers.reverse()]);
                  case 27:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, null, [[4, 20, 23, 26]]);
          }));
          function _runAllMiddleware(_x12, _x13, _x14) {
            return _runAllMiddleware2.apply(this, arguments);
          }
          return _runAllMiddleware;
        }()
        /**
         * Runs an individual middleware.
         *
         * @returns An array of any error encountered during middleware exection,
         * and a boolean indicating whether the request should end.
         */
      }, {
        key: "_runMiddleware",
        value: function _runMiddleware(req, res, middleware, returnHandlers) {
          return new Promise(function(resolve) {
            var end = function end2(err) {
              var error = err || res.error;
              if (error) {
                res.error = (0, import_eth_rpc_errors.serializeError)(error);
              }
              resolve([error, true]);
            };
            var next = function next2(returnHandler) {
              if (res.error) {
                end(res.error);
              } else {
                if (returnHandler) {
                  if (typeof returnHandler !== "function") {
                    end(new SerializableError({
                      code: -32603,
                      message: "JRPCEngine: 'next' return handlers must be functions"
                    }));
                  }
                  returnHandlers.push(returnHandler);
                }
                resolve([null, false]);
              }
            };
            try {
              middleware(req, res, next, end);
            } catch (error) {
              end(error);
            }
          });
        }
        /**
         * Serially executes array of return handlers. The request and response are
         * assumed to be in their scope.
         */
      }, {
        key: "_runReturnHandlers",
        value: function() {
          var _runReturnHandlers2 = _asyncToGenerator(import_regenerator.default.mark(function _callee7(handlers) {
            var _iterator2, _step2, _loop;
            return import_regenerator.default.wrap(function _callee7$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _iterator2 = _createForOfIteratorHelper(handlers);
                    _context8.prev = 1;
                    _loop = import_regenerator.default.mark(function _loop2() {
                      var handler;
                      return import_regenerator.default.wrap(function _loop$(_context7) {
                        while (1) {
                          switch (_context7.prev = _context7.next) {
                            case 0:
                              handler = _step2.value;
                              _context7.next = 3;
                              return new Promise(function(resolve, reject) {
                                handler(function(err) {
                                  return err ? reject(err) : resolve();
                                });
                              });
                            case 3:
                            case "end":
                              return _context7.stop();
                          }
                        }
                      }, _loop2);
                    });
                    _iterator2.s();
                  case 4:
                    if ((_step2 = _iterator2.n()).done) {
                      _context8.next = 8;
                      break;
                    }
                    return _context8.delegateYield(_loop(), "t0", 6);
                  case 6:
                    _context8.next = 4;
                    break;
                  case 8:
                    _context8.next = 13;
                    break;
                  case 10:
                    _context8.prev = 10;
                    _context8.t1 = _context8["catch"](1);
                    _iterator2.e(_context8.t1);
                  case 13:
                    _context8.prev = 13;
                    _iterator2.f();
                    return _context8.finish(13);
                  case 16:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee7, null, [[1, 10, 13, 16]]);
          }));
          function _runReturnHandlers(_x15) {
            return _runReturnHandlers2.apply(this, arguments);
          }
          return _runReturnHandlers;
        }()
        /**
         * Throws an error if the response has neither a result nor an error, or if
         * the "isComplete" flag is falsy.
         */
      }, {
        key: "_checkForCompletion",
        value: function _checkForCompletion(req, res, isComplete) {
          if (!("result" in res) && !("error" in res)) {
            throw new SerializableError({
              code: -32603,
              message: "Response has no error or result for request"
            });
          }
          if (!isComplete) {
            throw new SerializableError({
              code: -32603,
              message: "Nothing ended request"
            });
          }
        }
      }]);
      return JRPCEngine2;
    }(SafeEventEmitter);
    Substream = function(_Duplex) {
      _inherits(Substream2, _Duplex);
      var _super = _createSuper$2(Substream2);
      function Substream2(_ref) {
        var _this;
        var parent = _ref.parent, name = _ref.name;
        _classCallCheck(this, Substream2);
        _this = _super.call(this, {
          objectMode: true
        });
        _defineProperty(_assertThisInitialized(_this), "_parent", void 0);
        _defineProperty(_assertThisInitialized(_this), "_name", void 0);
        _this._parent = parent;
        _this._name = name;
        return _this;
      }
      _createClass(Substream2, [{
        key: "_read",
        value: function _read() {
          return void 0;
        }
        /**
         * Called when data should be written to this writable stream.
         *
         * @param chunk - Arbitrary object to write
         * @param encoding - Encoding to use when writing payload
         * @param callback - Called when writing is complete or an error occurs
         */
      }, {
        key: "_write",
        value: function _write(chunk, _encoding, callback) {
          this._parent.push({
            name: this._name,
            data: chunk
          });
          callback();
        }
      }]);
      return Substream2;
    }(import_readable_stream.Duplex);
    IGNORE_SUBSTREAM = Symbol("IGNORE_SUBSTREAM");
    ObjectMultiplex = function(_Duplex) {
      _inherits(ObjectMultiplex2, _Duplex);
      var _super = _createSuper$1(ObjectMultiplex2);
      function ObjectMultiplex2() {
        var _this;
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, ObjectMultiplex2);
        _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {
          objectMode: true
        }));
        _defineProperty(_assertThisInitialized(_this), "_substreams", void 0);
        _defineProperty(_assertThisInitialized(_this), "getStream", void 0);
        _this._substreams = {};
        return _this;
      }
      _createClass(ObjectMultiplex2, [{
        key: "createStream",
        value: function createStream(name) {
          if (!name) {
            throw new Error("ObjectMultiplex - name must not be empty");
          }
          if (this._substreams[name]) {
            throw new Error('ObjectMultiplex - Substream for name "'.concat(name, '" already exists'));
          }
          var substream = new Substream({
            parent: this,
            name
          });
          this._substreams[name] = substream;
          anyStreamEnd(this, function(_error) {
            return substream.destroy(_error || void 0);
          });
          return substream;
        }
        // ignore streams (dont display orphaned data warning)
      }, {
        key: "ignoreStream",
        value: function ignoreStream(name) {
          if (!name) {
            throw new Error("ObjectMultiplex - name must not be empty");
          }
          if (this._substreams[name]) {
            throw new Error('ObjectMultiplex - Substream for name "'.concat(name, '" already exists'));
          }
          this._substreams[name] = IGNORE_SUBSTREAM;
        }
      }, {
        key: "_read",
        value: function _read() {
          return void 0;
        }
      }, {
        key: "_write",
        value: function _write(chunk, _encoding, callback) {
          var name = chunk.name, data = chunk.data;
          if (!name) {
            window.console.warn('ObjectMultiplex - malformed chunk without name "'.concat(chunk, '"'));
            return callback();
          }
          var substream = this._substreams[name];
          if (!substream) {
            window.console.warn('ObjectMultiplex - orphaned data for stream "'.concat(name, '"'));
            return callback();
          }
          if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
          }
          return callback();
        }
      }]);
      return ObjectMultiplex2;
    }(import_readable_stream.Duplex);
    PostMessageStream = function(_BasePostMessageStrea) {
      _inherits(PostMessageStream2, _BasePostMessageStrea);
      var _super = _createSuper2(PostMessageStream2);
      function PostMessageStream2() {
        _classCallCheck(this, PostMessageStream2);
        return _super.apply(this, arguments);
      }
      _createClass(PostMessageStream2, [{
        key: "_postMessage",
        value: function _postMessage(data) {
          var originConstraint = this._targetOrigin;
          if (_typeof(data) === "object") {
            var dataObj = data;
            if (_typeof(dataObj.data) === "object") {
              var dataObjData = dataObj.data;
              if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {
                var dataObjDataParam = dataObjData.params[0];
                if (dataObjDataParam._origin) {
                  originConstraint = dataObjDataParam._origin;
                }
                dataObjDataParam._origin = window.location.origin;
              }
            }
          }
          this._targetWindow.postMessage({
            target: this._target,
            data
          }, originConstraint);
        }
      }]);
      return PostMessageStream2;
    }(BasePostMessageStream);
  }
});

// node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge2;
  }
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports, module) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module === "object" && module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports, function() {
      "use strict";
      var noop2 = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e2) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop2;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop2 : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function setAPIKey(apiKey_) {
  apiKey = apiKey_;
}
async function fetchAndTrace(url, init) {
  let _url = null;
  try {
    _url = new URL(url);
  } catch (error) {
  }
  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {
    const transaction = sentry.startTransaction({
      name: url
    });
    const span = transaction.startChild({
      op: "http"
    });
    const response = await fetch(url, init);
    span.finish();
    transaction.finish();
    return response;
  }
  return fetch(url, init);
}
function getApiKeyHeaders() {
  const headers = {};
  if (apiKey)
    headers[gatewayAuthHeader] = apiKey;
  if (embedHost)
    headers[gatewayEmbedHostHeader] = embedHost;
  return headers;
}
function debugLogResponse(response) {
  log.info(`Response: ${response.status} ${response.statusText}`);
  log.info(`Url: ${response.url}`);
}
function logTracingHeader(response) {
  log.info(`Request tracing with traceID=${response.headers.get("x-web3-correlation-id")}`);
}
var import_lodash, import_loglevel, log, apiKey, embedHost, gatewayAuthHeader, gatewayEmbedHostHeader, sentry, tracingOrigins, tracingPaths, promiseTimeout, get, post;
var init_httpHelpers_esm = __esm({
  "node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"() {
    init_defineProperty();
    import_lodash = __toESM(require_lodash());
    import_loglevel = __toESM(require_loglevel());
    log = import_loglevel.default.getLogger("http-helpers");
    log.setLevel(import_loglevel.levels.INFO);
    apiKey = "torus-default";
    embedHost = "";
    gatewayAuthHeader = "x-api-key";
    gatewayEmbedHostHeader = "x-embed-host";
    sentry = null;
    tracingOrigins = [];
    tracingPaths = [];
    promiseTimeout = (ms, promise) => {
      const timeout = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
          clearTimeout(id);
          reject(new Error(`Timed out in ${ms}ms`));
        }, ms);
      });
      return Promise.race([promise, timeout]);
    };
    get = async function(url) {
      let options_ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let customOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const defaultOptions = {
        mode: "cors",
        headers: {}
      };
      if (customOptions.useAPIKey) {
        defaultOptions.headers = _objectSpread2(_objectSpread2({}, defaultOptions.headers), getApiKeyHeaders());
      }
      const options = (0, import_lodash.default)(defaultOptions, options_, {
        method: "GET"
      });
      const response = await fetchAndTrace(url, options);
      if (response.ok) {
        return response.json();
      }
      debugLogResponse(response);
      throw response;
    };
    post = function(url) {
      let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let options_ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let customOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const defaultOptions = {
        mode: "cors",
        headers: {
          "Content-Type": "application/json; charset=utf-8"
        }
      };
      if (customOptions.useAPIKey) {
        defaultOptions.headers = _objectSpread2(_objectSpread2({}, defaultOptions.headers), getApiKeyHeaders());
      }
      const options = (0, import_lodash.default)(defaultOptions, options_, {
        method: "POST"
      });
      if (customOptions.isUrlEncodedData) {
        options.body = data;
        if (options.headers["Content-Type"] === "application/json; charset=utf-8")
          delete options.headers["Content-Type"];
      } else {
        options.body = JSON.stringify(data);
      }
      return promiseTimeout(customOptions.timeout || 6e4, fetchAndTrace(url, options).then((response) => {
        if (customOptions.logTracingHeader) {
          logTracingHeader(response);
        }
        if (response.ok) {
          return response.json();
        }
        debugLogResponse(response);
        throw response;
      }));
    };
  }
});

// node_modules/ts-custom-error/dist/custom-error.mjs
function fixProto(target, prototype) {
  var setPrototypeOf = Object.setPrototypeOf;
  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
}
function fixStack(target, fn) {
  if (fn === void 0) {
    fn = target.constructor;
  }
  var captureStackTrace = Error.captureStackTrace;
  captureStackTrace && captureStackTrace(target, fn);
}
var __extends, CustomError;
var init_custom_error = __esm({
  "node_modules/ts-custom-error/dist/custom-error.mjs"() {
    __extends = /* @__PURE__ */ function() {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    CustomError = function(_super) {
      __extends(CustomError2, _super);
      function CustomError2(message, options) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message, options) || this;
        Object.defineProperty(_this, "name", {
          value: _newTarget.name,
          enumerable: false,
          configurable: true
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
      }
      return CustomError2;
    }(Error);
  }
});

// node_modules/jwt-decode/build/jwt-decode.esm.js
function e(e2) {
  this.message = e2;
}
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
var r, jwt_decode_esm_default;
var init_jwt_decode_esm = __esm({
  "node_modules/jwt-decode/build/jwt-decode.esm.js"() {
    e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
    r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
      var t2 = String(r2).replace(/=+$/, "");
      if (t2.length % 4 == 1)
        throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
      for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
        o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
      return c;
    };
    n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
    jwt_decode_esm_default = o;
  }
});

// node_modules/@web3auth/base/dist/base.esm.js
function ownKeys$12(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$12(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$12(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function storageAvailable(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    const _error = error;
    return !!(_error && // everything except Firefox
    (_error.code === 22 || // Firefox
    _error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    _error.name === "QuotaExceededError" || // Firefox
    _error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0);
  }
}
var import_loglevel2, CHAIN_NAMESPACES, ADAPTER_NAMESPACES, DEFAULT_INFURA_ID, getDefaultNetworkId, getEvmChainConfig, getSolanaChainConfig, getChainConfig, Web3AuthError, WalletInitializationError, WalletLoginError, MULTI_CHAIN_ADAPTERS, SOLANA_ADAPTERS, EVM_ADAPTERS, WALLET_ADAPTERS, ADAPTER_CATEGORY, ADAPTER_STATUS, ADAPTER_EVENTS, BaseAdapter, authServer, log2, isHexStrict, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, getSavedToken, saveToken, clearToken;
var init_base_esm = __esm({
  "node_modules/@web3auth/base/dist/base.esm.js"() {
    init_defineProperty();
    init_openloginJrpc_esm();
    init_custom_error();
    init_httpHelpers_esm();
    init_jwt_decode_esm();
    import_loglevel2 = __toESM(require_loglevel());
    CHAIN_NAMESPACES = {
      EIP155: "eip155",
      SOLANA: "solana",
      OTHER: "other"
    };
    ADAPTER_NAMESPACES = {
      EIP155: "eip155",
      SOLANA: "solana",
      MULTICHAIN: "multichain"
    };
    DEFAULT_INFURA_ID = "776218ac4734478c90191dde8cae483c";
    getDefaultNetworkId = (chainNamespace) => {
      if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
        return 1;
      } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
        return 1;
      }
      throw new Error("Chain namespace ".concat(chainNamespace, " is not supported"));
    };
    getEvmChainConfig = (chainId) => {
      const chainNamespace = CHAIN_NAMESPACES.EIP155;
      if (chainId === 1) {
        return {
          chainNamespace,
          chainId: "0x1",
          rpcTarget: "https://mainnet.infura.io/v3/".concat(DEFAULT_INFURA_ID),
          displayName: "Ethereum Mainnet",
          blockExplorer: "https://etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      } else if (chainId === 3) {
        return {
          chainNamespace,
          chainId: "0x3",
          rpcTarget: "https://ropsten.infura.io/v3/".concat(DEFAULT_INFURA_ID),
          displayName: "ropsten",
          blockExplorer: "https://ropsten.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      } else if (chainId === 4) {
        return {
          chainNamespace,
          chainId: "0x4",
          rpcTarget: "https://rinkeby.infura.io/v3/".concat(DEFAULT_INFURA_ID),
          displayName: "rinkeby",
          blockExplorer: "https://rinkeby.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      } else if (chainId === 5) {
        return {
          chainNamespace,
          chainId: "0x5",
          rpcTarget: "https://goerli.infura.io/v3/".concat(DEFAULT_INFURA_ID),
          displayName: "goerli",
          blockExplorer: "https://goerli.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      } else if (chainId === 42) {
        return {
          chainNamespace,
          chainId: "0x2a",
          rpcTarget: "https://kovan.infura.io/v3/".concat(DEFAULT_INFURA_ID),
          displayName: "kovan",
          blockExplorer: "https://kovan.etherscan.io/",
          ticker: "ETH",
          tickerName: "Ethereum"
        };
      } else if (chainId === 137) {
        return {
          chainNamespace,
          rpcTarget: "https://polygon-rpc.com",
          blockExplorer: "https://polygonscan.com",
          chainId: "0x89",
          displayName: "Polygon Mainnet",
          ticker: "matic",
          tickerName: "matic"
        };
      } else if (chainId === 80001) {
        return {
          chainNamespace,
          rpcTarget: "https://rpc-mumbai.maticvigil.com",
          blockExplorer: "https://mumbai-explorer.matic.today",
          chainId: "0x13881",
          displayName: "Polygon Mumbai Testnet",
          ticker: "matic",
          tickerName: "matic"
        };
      } else if (chainId === 56) {
        return {
          chainNamespace,
          rpcTarget: "https://bsc-dataseed.binance.org",
          blockExplorer: "https://bscscan.com",
          chainId: "0x38",
          displayName: "Binance SmartChain Mainnet",
          ticker: "BNB",
          tickerName: "BNB"
        };
      } else if (chainId === 97) {
        return {
          chainNamespace,
          rpcTarget: "https://data-seed-prebsc-2-s3.binance.org:8545",
          blockExplorer: "https://testnet.bscscan.com",
          chainId: "0x61",
          displayName: "Binance SmartChain Testnet",
          ticker: "BNB",
          tickerName: "BNB"
        };
      }
      return null;
    };
    getSolanaChainConfig = (chainId) => {
      const chainNamespace = CHAIN_NAMESPACES.SOLANA;
      if (chainId === 1) {
        return {
          chainNamespace,
          blockExplorer: "https://explorer.solana.com",
          chainId: "0x1",
          displayName: "Solana Mainnet",
          rpcTarget: "https://api.mainnet-beta.solana.com",
          ticker: "SOL",
          tickerName: "Solana Token"
        };
      } else if (chainId === 2) {
        return {
          rpcTarget: "https://api.testnet.solana.com",
          blockExplorer: "https://explorer.solana.com?cluster=testnet",
          chainId: "0x2",
          chainNamespace,
          displayName: "testnet",
          ticker: "SOL",
          tickerName: "solana"
        };
      } else if (chainId === 3) {
        return {
          rpcTarget: "https://api.devnet.solana.com",
          blockExplorer: "https://explorer.solana.com?cluster=devnet",
          chainId: "0x3",
          chainNamespace,
          displayName: "devnet",
          ticker: "SOL",
          tickerName: "solana"
        };
      }
      return null;
    };
    getChainConfig = (chainNamespace, chainId) => {
      if (chainNamespace === CHAIN_NAMESPACES.OTHER)
        return null;
      const finalChainId = chainId ? typeof chainId === "number" ? chainId : parseInt(chainId, 16) : getDefaultNetworkId(chainNamespace);
      if (chainNamespace === CHAIN_NAMESPACES.EIP155) {
        return getEvmChainConfig(finalChainId);
      } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {
        return getSolanaChainConfig(finalChainId);
      }
      return null;
    };
    Web3AuthError = class extends CustomError {
      constructor(code, message) {
        super(message);
        _defineProperty(this, "code", void 0);
        _defineProperty(this, "message", void 0);
        this.code = code;
        this.message = message || "";
        Object.defineProperty(this, "name", {
          value: "Web3AuthError"
        });
      }
      toJSON() {
        return {
          name: this.name,
          code: this.code,
          message: this.message
        };
      }
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    WalletInitializationError = class _WalletInitializationError extends Web3AuthError {
      constructor(code, message) {
        super(code, message);
        Object.defineProperty(this, "name", {
          value: "WalletInitializationError"
        });
      }
      static fromCode(code) {
        let extraMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        return new _WalletInitializationError(code, "".concat(_WalletInitializationError.messages[code], ", ").concat(extraMessage));
      }
      // Custom methods
      static notFound() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5001, extraMessage);
      }
      static notInstalled() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5002, extraMessage);
      }
      static notReady() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5003, extraMessage);
      }
      static windowBlocked() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5004, extraMessage);
      }
      static windowClosed() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5005, extraMessage);
      }
      static incompatibleChainNameSpace() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5006, extraMessage);
      }
      static duplicateAdapterError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5007, extraMessage);
      }
      static invalidProviderConfigError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5008, extraMessage);
      }
      static providerNotReadyError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5009, extraMessage);
      }
      static rpcConnectionError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5010, extraMessage);
      }
      static invalidParams() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5011, extraMessage);
      }
      static invalidNetwork() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletInitializationError.fromCode(5013, extraMessage);
      }
    };
    _defineProperty(WalletInitializationError, "messages", {
      5e3: "Custom",
      5001: "Wallet is not found",
      5002: "Wallet is not installed",
      5003: "Wallet is not ready yet",
      5004: "Wallet window is blocked",
      5005: "Wallet window has been closed by the user",
      5006: "Incompatible chain namespace provided",
      5007: "Adapter has already been included",
      5008: "Invalid provider Config",
      5009: "Provider is not ready yet",
      5010: "Failed to connect with rpc url",
      5011: "Invalid params passed in",
      5013: "Invalid network provided"
    });
    WalletLoginError = class _WalletLoginError extends Web3AuthError {
      constructor(code, message) {
        super(code, message);
        Object.defineProperty(this, "name", {
          value: "WalletLoginError"
        });
      }
      static fromCode(code) {
        let extraMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        return new _WalletLoginError(code, "".concat(_WalletLoginError.messages[code]).concat(extraMessage));
      }
      static connectionError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletLoginError.fromCode(5111, extraMessage);
      }
      static disconnectionError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletLoginError.fromCode(5112, extraMessage);
      }
      static notConnectedError() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletLoginError.fromCode(5113, extraMessage);
      }
      static popupClosed() {
        let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return _WalletLoginError.fromCode(5114, extraMessage);
      }
    };
    _defineProperty(WalletLoginError, "messages", {
      5e3: "Custom",
      5111: "Failed to connect with wallet",
      5112: "Failed to disconnect from wallet",
      5113: "Wallet is not connected",
      5114: "Wallet popup has been closed by the user"
    });
    MULTI_CHAIN_ADAPTERS = {
      OPENLOGIN: "openlogin",
      WALLET_CONNECT_V1: "wallet-connect-v1",
      WALLET_CONNECT_V2: "wallet-connect-v2"
    };
    SOLANA_ADAPTERS = _objectSpread$12({
      TORUS_SOLANA: "torus-solana",
      PHANTOM: "phantom",
      SOLLET: "sollet",
      SOLLET_EXTENSION: "sollet-extension",
      SOLFLARE: "solflare",
      SLOPE: "slope"
    }, MULTI_CHAIN_ADAPTERS);
    EVM_ADAPTERS = _objectSpread$12({
      TORUS_EVM: "torus-evm",
      METAMASK: "metamask",
      COINBASE: "coinbase"
    }, MULTI_CHAIN_ADAPTERS);
    WALLET_ADAPTERS = _objectSpread$12(_objectSpread$12({}, EVM_ADAPTERS), SOLANA_ADAPTERS);
    ADAPTER_CATEGORY = {
      EXTERNAL: "external",
      IN_APP: "in_app"
    };
    ADAPTER_STATUS = {
      NOT_READY: "not_ready",
      READY: "ready",
      CONNECTING: "connecting",
      CONNECTED: "connected",
      DISCONNECTED: "disconnected",
      ERRORED: "errored"
    };
    ADAPTER_EVENTS = _objectSpread3(_objectSpread3({}, ADAPTER_STATUS), {}, {
      ADAPTER_DATA_UPDATED: "adapter_data_updated"
    });
    BaseAdapter = class extends SafeEventEmitter {
      constructor() {
        super(...arguments);
        _defineProperty(this, "adapterData", {});
        _defineProperty(this, "sessionTime", 86400);
        _defineProperty(this, "chainConfig", null);
      }
      get chainConfigProxy() {
        return this.chainConfig ? _objectSpread3({}, this.chainConfig) : null;
      }
      setChainConfig(customChainConfig) {
        if (this.status === ADAPTER_STATUS.READY)
          return;
        if (!customChainConfig.chainNamespace)
          throw WalletInitializationError.notReady("ChainNamespace is required while setting chainConfig");
        const defaultChainConfig = getChainConfig(customChainConfig.chainNamespace, customChainConfig.chainId);
        this.chainConfig = _objectSpread3(_objectSpread3({}, defaultChainConfig), customChainConfig);
      }
      setAdapterSettings(_) {
      }
      checkConnectionRequirements() {
        if (this.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.status === ADAPTER_STATUS.CONNECTING)
          return;
        else if (this.status === ADAPTER_STATUS.CONNECTING)
          throw WalletInitializationError.notReady("Already connecting");
        if (this.status === ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.connectionError("Already connected");
        if (this.status !== ADAPTER_STATUS.READY)
          throw WalletLoginError.connectionError("Wallet adapter is not ready yet");
      }
      checkInitializationRequirements() {
        if (this.status === ADAPTER_STATUS.NOT_READY)
          return;
        if (this.status === ADAPTER_STATUS.CONNECTED)
          throw WalletInitializationError.notReady("Already connected");
        if (this.status === ADAPTER_STATUS.READY)
          throw WalletInitializationError.notReady("Adapter is already initialized");
      }
      updateAdapterData(data) {
        this.adapterData = data;
        this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, {
          adapterName: this.name,
          data
        });
      }
    };
    authServer = "https://auth-js-backend.tor.us";
    log2 = import_loglevel2.default.getLogger("web3auth-logger");
    isHexStrict = (hex) => {
      return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
    };
    checkIfTokenIsExpired = (token) => {
      const decoded = jwt_decode_esm_default(token);
      if (!decoded.exp) {
        return true;
      }
      if (decoded.exp < Math.floor(Date.now() / 1e3)) {
        return true;
      }
      return false;
    };
    signChallenge = async (payload, chainNamespace) => {
      const t2 = chainNamespace === "solana" ? "sip99" : "eip191";
      const header = {
        t: t2
      };
      const network = chainNamespace === "solana" ? "solana" : "ethereum";
      const data = {
        payload,
        header,
        network
      };
      const res = await post("".concat(authServer, "/siww/get"), data);
      if (!res.success) {
        throw new Error("Failed to authenticate user, Please reach out to Web3Auth Support team");
      }
      return res.challenge;
    };
    verifySignedChallenge = async (chainNamespace, signedMessage, challenge, issuer, sessionTime) => {
      const t2 = chainNamespace === "solana" ? "sip99" : "eip191";
      const sigData = {
        signature: {
          s: signedMessage,
          t: t2
        },
        message: challenge,
        issuer,
        audience: window.location.hostname,
        timeout: sessionTime
      };
      const idTokenRes = await post("".concat(authServer, "/siww/verify"), sigData);
      if (!idTokenRes.success) {
        log2.error("Failed to authenticate user, ,message verification failed", idTokenRes.error);
        throw new Error("Failed to authenticate user, ,message verification failed");
      }
      return idTokenRes.token;
    };
    getSavedToken = (userAddress, issuer) => {
      if (storageAvailable("localStorage")) {
        return localStorage.getItem("".concat(userAddress.toLowerCase(), "_").concat(issuer));
      }
      return null;
    };
    saveToken = (userAddress, issuer, token) => {
      if (storageAvailable("localStorage")) {
        return localStorage.setItem("".concat(userAddress.toLowerCase(), "_").concat(issuer), token);
      }
      return null;
    };
    clearToken = (userAddress, issuer) => {
      if (storageAvailable("localStorage")) {
        return localStorage.removeItem("".concat(userAddress.toLowerCase(), "_").concat(issuer));
      }
      return null;
    };
  }
});

export {
  _typeof,
  init_typeof,
  _defineProperty,
  init_defineProperty,
  _classCallCheck,
  init_classCallCheck,
  _createClass,
  init_createClass,
  _assertThisInitialized,
  init_assertThisInitialized,
  _inherits,
  init_inherits,
  _possibleConstructorReturn,
  init_possibleConstructorReturn,
  _getPrototypeOf,
  init_getPrototypeOf,
  _asyncToGenerator,
  init_asyncToGenerator,
  require_base64url2 as require_base64url,
  randomId,
  base64url,
  safeatob,
  keccak,
  jsonToBase64,
  init_openloginUtils_esm,
  _slicedToArray,
  init_slicedToArray,
  require_once,
  require_end_of_stream,
  require_pump,
  BasePostMessageStream,
  SafeEventEmitter,
  getRpcPromiseCallback,
  createStreamMiddleware,
  createScaffoldMiddleware,
  createIdRemapMiddleware,
  createAsyncMiddleware,
  JRPCEngine,
  mergeMiddleware,
  ObjectMultiplex,
  setupMultiplex,
  PostMessageStream,
  init_openloginJrpc_esm,
  require_lodash,
  require_loglevel,
  setAPIKey,
  get,
  init_httpHelpers_esm,
  CHAIN_NAMESPACES,
  ADAPTER_NAMESPACES,
  getChainConfig,
  Web3AuthError,
  WalletInitializationError,
  WalletLoginError,
  SOLANA_ADAPTERS,
  EVM_ADAPTERS,
  WALLET_ADAPTERS,
  ADAPTER_CATEGORY,
  ADAPTER_STATUS,
  ADAPTER_EVENTS,
  BaseAdapter,
  log2 as log,
  storageAvailable,
  isHexStrict,
  checkIfTokenIsExpired,
  signChallenge,
  verifySignedChallenge,
  getSavedToken,
  saveToken,
  clearToken,
  init_base_esm
};
//# sourceMappingURL=chunk-FJCF2OTK.js.map
